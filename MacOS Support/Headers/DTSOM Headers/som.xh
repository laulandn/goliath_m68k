/************************************************************Created: Friday, March 24, 1995 at 3:12:00 PM    som.xh	    System Object Model	Macintosh Version        © International Business Machines Corp. 1992-1994        © Apple Computer, Inc.					1994-1996        All rights reserved************************************************************/#ifndef		__SOM__#define		__SOM__#ifndef		__STDARG__#include	<stdarg.h>#endif#ifndef		__STDDEF__#include	<stddef.h>#endif#ifndef		__STRING__#include	<string.h>  /* needed for memset, used in somcorba.h */#endif#if !_WINDOWS && !defined __CONDITIONALMACROS__#include	<ConditionalMacros.h>#endif#ifndef	SOMEXTERN #ifdef	__cplusplus  #define SOMEXTERN extern "C" #else  #define SOMEXTERN extern #endif#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif#if PRAGMA_ALIGN_SUPPORTED#  pragma options align=power#endif#if _WINDOWS#ifndef	SOMLINK#define SOMLINK		__stdcall#endif#ifndef	SOMDLINK#define SOMDLINK	__declspec ( dllimport )#endif#ifndef	SOMDXLINK#define SOMDXLINK	__declspec ( dllexport )#endif#else#ifndef	SOMLINK#define SOMLINK#endif#ifndef	SOMDLINK#define SOMDLINK#endif#ifndef	SOMDXLINK#define SOMDXLINK#endif#endif#ifndef	__SOMDTS__#include <somdts.h>#endiftypedef void *somToken;					/* Uninterpreted value   */typedef void *somOpaque;#if !__SOM_ENABLED__#ifdef	__cplusplusextern "C" {#endiftypedef void* SOMLINK somMethodProc (void *somSelf);typedef somMethodProc *somMethodPtr;typedef void SOMLINK somTP_somClassInitFunc (void *somSelf);typedef void SOMLINK somTP_somClassUninitFunc (void *somSelf);#ifdef	__cplusplus}#endif#if !defined OLDIBMSOMAPISUPPORT && __IBM_TO_MAC__#define OLDIBMSOMAPISUPPORT 1#endiftypedef unsigned char boolean;typedef char **somId;#if OLDIBMSOMAPISUPPORT typedef somId somKernelId;				/* a kernel somId		 */#else typedef long somKernelId;				/* a kernel somId		 */#endif/* for declaring statically created Id's */typedef struct {	long private1;	char *str;	long private2;	long private3;} somStaticStr;#endif	/* __SOM_ENABLED__ */#ifdef	__cplusplusclass SOMObject;class SOMClass;class SOMClassMgr;#elsetypedef struct somMethodTabStruct *somMethodTabPtr;typedef struct {    somMethodTabPtr mtab;    // long			body[1];} SOMAny;#define SOMObject	SOMAny#define SOMClass	SOMAny#define SOMClassMgr SOMAny#endif	/* __cplusplus */#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#if PRAGMA_ALIGN_SUPPORTED#  pragma options align=reset#endif#ifndef		__SOMDTS__#include	<somdts.h>  /* needed for Environment */#endif#if PRAGMA_ALIGN_SUPPORTED#  pragma options align=power#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif/* #include <somcorba.h> */#ifndef		__SOMCORBA__#define		__SOMCORBA__#ifdef CORBA_FUNCTION_NAMES#define CORBAObject Object#endif/* in SOM, a CORBA object is a SOM object */typedef SOMObject CORBAObject;/* CORBA 5.7, p.89 */typedef unsigned char octet;typedef char *corbastring;/* CORBA 7.5.1, p. 129 */typedef corbastring Identifier;enum {YES, NO, MAYBE};typedef long completion_status;typedef struct {    unsigned long minor;    completion_status completed;} StExcep;/* CORBA 7.6.1, p.139 plus 5.7, p.89 enum Data Type Mapping */typedef unsigned long TCKind;   #define TypeCode_tk_null		1   #define TypeCode_tk_void		2  #define TypeCode_tk_short		3   #define TypeCode_tk_long		4   #define TypeCode_tk_ushort	5   #define TypeCode_tk_ulong		6  #define TypeCode_tk_float		7   #define TypeCode_tk_double	8   #define TypeCode_tk_boolean	9   #define TypeCode_tk_char		10  #define TypeCode_tk_octet		11   #define TypeCode_tk_any		12   #define TypeCode_tk_TypeCode	13   #define TypeCode_tk_Principal	14   #define TypeCode_tk_objref	15  #define TypeCode_tk_struct	16   #define TypeCode_tk_union		17   #define TypeCode_tk_enum		18   #define TypeCode_tk_string	19  #define TypeCode_tk_sequence	20   #define TypeCode_tk_array		21  #define TypeCode_tk_pointer	101 /* SOM extension */  #define TypeCode_tk_self		102 /* SOM extension */  #define TypeCode_tk_foreign	103 /* SOM extension *//* Short forms of tk_<x> enumerators */  #define tk_null		TypeCode_tk_null   #define tk_void		TypeCode_tk_void  #define tk_short		TypeCode_tk_short   #define tk_long		TypeCode_tk_long   #define tk_ushort		TypeCode_tk_ushort   #define tk_ulong		TypeCode_tk_ulong  #define tk_float		TypeCode_tk_float   #define tk_double		TypeCode_tk_double   #define tk_boolean	TypeCode_tk_boolean   #define tk_char		TypeCode_tk_char  #define tk_octet		TypeCode_tk_octet   #define tk_any		TypeCode_tk_any   #define tk_TypeCode	TypeCode_tk_TypeCode   #define tk_Principal	TypeCode_tk_Principal   #define tk_objref		TypeCode_tk_objref  #define tk_struct		TypeCode_tk_struct   #define tk_union		TypeCode_tk_union   #define tk_enum		TypeCode_tk_enum   #define tk_string		TypeCode_tk_string  #define tk_sequence	TypeCode_tk_sequence   #define tk_array		TypeCode_tk_array  #define tk_pointer	TypeCode_tk_pointer  #define tk_self		TypeCode_tk_self  #define tk_foreign	TypeCode_tk_foreign #ifndef SOM_TYPECODE  #define SOM_TYPECODE  typedef void *TypeCode;#endif /* SOM_TYPECODE *//* CORBA 5.7, p.89 */typedef struct {	TypeCode	_type;	void		*_value;} any;/* Convenience macros for sequences */#define sequence(type) _IDL_SEQUENCE_ ## type#define SOM_SEQUENCE_NAME(name,type)\    struct name {\	unsigned long _maximum;\	unsigned long _length;\	type	 *    _buffer;\    }#define SOM_SEQUENCE(type)\    struct {\	unsigned long _maximum;\	unsigned long _length;\	type	 *    _buffer;\    }#define SOM_SEQUENCE_TYPEDEF(type) typedef SOM_SEQUENCE(type) sequence(type)#define SOM_SEQUENCE_TYPEDEF_NAME(type, name) typedef SOM_SEQUENCE(type) name/* per CORBA 5.10, p.91 */#ifndef _IDL_SEQUENCE_void_defined#define _IDL_SEQUENCE_void_definedSOM_SEQUENCE_TYPEDEF (void);#endif /* _IDL_SEQUENCE_void_defined *//* SOM extensions for sequence manipulation */#define GENERIC_SEQUENCE	sequence(void)/* 	Normally the sequenceNew macro assumes that a TypeCode constant	of the form TC_xxx exists for any type xxx used as an argument	and invokes the kernel function tcSequenceNew to allocate	#define sequenceNew(type,max)	(*(sequence(type) *)tcSequenceNew(TC_##type,max))	Currently, SOM's Type Code facility, Interface Repository	and distribution facility (DSOM) are not supported on the 	Macintosh platform, so sequenceNew is not defined.*/#define sequenceElement(s,elem) (s._buffer[elem])#define sequenceLength(s)	(s._length)#define sequenceMaximum(s)	(s._maximum)SOMEXTERN char * SOMLINK somExceptionId    (Environment *ev);SOMEXTERN void * SOMLINK somExceptionValue (Environment *ev);#if !__SOM_ENABLED__SOMEXTERN void	 SOMLINK somExceptionFree  (Environment *ev);#endifSOMEXTERN void	 SOMLINK somSetException   (Environment *ev,    exception_type major, char *exception_name, void *params);SOMEXTERN Environment * SOMLINK somGetGlobalEnvironment (void);/* Exception function names per CORBA 5.19, p.99 */#define exception_id	somExceptionId#define exception_value somExceptionValue#define exception_free	somExceptionFree#ifndef    TRUE#define    TRUE 1#endif	/* TRUE */#ifndef    FALSE#define    FALSE 0#endif	/* FALSE */#if OLDIBMSOMAPISUPPORT/* can no longer treat shared objects as globals without	keeping track of reference counts.  get a reference to the	class manager object and access its interface repository	instead*/#define SOM_InterfaceRepository\    (__get_somInterfaceRepository(SOMClassMgrObject))#endif/*  Convenience macros for manipulating environment structures in C ONLY * *  SOM_CreateLocalEnvironment returns a pointer to an Environment. *  The other 3 macros all expect a single argument that is also *  a pointer to an Environment.  Use the create/destroy forms for *  a dynamic local environment and the init/uninit forms for a stack-based *  local environment. * *  For example  * *      Environment *ev; *      ev = SOM_CreateLocalEnvironment (); *      ... Use ev in methods  *      SOM_DestroyLocalEnvironment (ev); * *  or * *      Environment ev; *      SOM_InitEnvironment (&ev); *      ... Use &ev in methods *      SOM_UninitEnvironment (&ev); * *  NOTE: in C++ you should use an AutoInitEnvironment as a local: * *		AutoInitEnvironment ev; * *		... Use &ev in methods... * *		This class has a default constructor and destructor that *		do the right thing.  For reference is defined in somdts.h, *		though you must include som.[x]h and not somdts.h directly. * */#ifndef	__cplusplus#define SOM_CreateLocalEnvironment()\    ((Environment *) SOMCalloc (1, sizeof (Environment)))	#define SOM_DestroyLocalEnvironment(ev)\    (somExceptionFree ((ev)), SOMFree ((ev)))#define SOM_InitEnvironment(ev)\    (memset (((char *)((ev))), 0, sizeof (Environment)))#define SOM_UninitEnvironment(ev)\    (somExceptionFree ((ev)))#endif#endif	/* __SOMCORBA__ *//* #include <somcdev.h> */#ifndef		__SOMCDEV__#define		__SOMCDEV__/* *  Method and Data Resolution macros *//* *  Method Resolution. Methods are invoked on an object o of some *  object class oc, where oc has immediate ancestor classes *  called parent classes. Macro arguments include method names *  (e.g., mn), object class and parent class names (e.g., ocn, pcn) *  and parent class positions (e.g., pcp), expressed in terms of the *  left-to-right ordering (beginning with 1, for the first parent) *  used when declaring oc's parents. The choice of resolution *  macro determines the method table from which methods are selected. * *  Macros are available to select a method from ... *//* * Default definition of somresolve_ to call the procedure, somResolve. * This may be be changed by emitters on systems for which method * tokens are thunks. */#define somresolve_(obj,mToken) (somResolve(obj,mToken))/* from oc's mtbl, with verification of o */#define SOM_Resolve(o, ocn, mn) \    (( somTD_ ## ocn ## _ ## mn ) \     somresolve_(SOM_TestCls_TT(o, ocn ## ClassData), \                ocn ## ClassData.mn ))/* from oc's mtbl, without verification of o */#define SOM_ResolveNoCheck(o, ocn, mn) \    (( somTD_ ## ocn ## _ ## mn ) \     somresolve_(o, \                ocn ## ClassData.mn ))/* from the pcp'th element of oc's ClassData.parentMtab list */#define SOM_ParentNumResolveCC(pcn, pcp, ocn, mn) \    (( somTD_ ## pcn ## _ ## mn ) \     somParentNumResolve( (somClassDataStructure*) & ocn ## ClassData, pcp, \                         pcn ## ClassData.mn ))/* from an argument class's method table */#define SOM_ClassResolve(cn, class, mn) \    (( somTD_ ## cn ## _ ## mn ) \     somClassResolve(class, \                     cn ## ClassData.mn ))/* support reintroduction of methods *//* tdc == typedef class name; cdc == classdata class name */#define SOM_ResolveD(o, tdc, cdc, mn) \	(( somTD_ ## tdc ## _ ## mn ) \	  somresolve_(SOM_TestCls_TT(o, cdc ## ClassData),\	             cdc ## ClassData.mn))/* * Data resolution macro */#define SOM_DataResolve(obj, dataId) \  (somDataResolve(obj, dataId))#if !defined(__SOMDLL__)  /*   * Main programs should register for SOM cleanup at exit   */   #define SOM_MainProgram()\    (atexit(somEnvironmentEnd), somMainProgram())  /*   * somEnvironmentEnd may not have the right   * linkage to be called by atexit. Allow a user to   * create a routine that can be called by atexit   * and which will call somEnvironmentEnd.   */   #define SOM_MainProgramWithUserExit( userExitFcn ) \    (atexit( userExitFcn ), somMainProgram())#endif /* __SOMDLL__ *//* * Platform provided automatic class library initialization rtns * should use this macro to inform the SOM Class Manager that * they have been loaded.  */#define SOM_ClassLibrary(name)\    (somRegisterClassLibrary(name,\        (somMethodProc *) &SOMInitModule))/* *   Development support macros and globals */#if defined (SOM_STRICT_IDL) && !__SOM_ENABLED__#define SOMSTAR#else#define SOMSTAR *#endif/* * This macro is used throughout the generated source * to prevent compiler warnings for unreferenced variables */#ifndef SOM_IgnoreWarning    #ifdef __xlC__	#define SOM_IgnoreWarning(v)	    #else	#define SOM_IgnoreWarning(v)	(void) v    #endif#endif /* SOM_IgnoreWarning *//* Check the validity of method resolution using the specified target  *//* object.  Note: this macro makes programs bigger and slower.  After  *//* you are confident that your program is running correctly you should *//* turn off this macro by defining SOM_NoTest, or adding -DSOM_NoTest  *//* to your makefile.                                                   */#if !defined(SOM_NoTest) && defined(SOM_TestOn)  #define SOM_TestCls(obj, class) (somTestCls(((SOMObject SOMSTAR)\    ((void *)obj)), ((SOMClass SOMSTAR)((void *)class)), __FILE__, __LINE__))  #define SOM_Measure#else  #define SOM_TestCls(obj, class) ((SOMObject SOMSTAR)((void *)obj))#endif#if !defined(SOM_NoTest) && defined(SOM_TestOn)  #define SOM_TestCls_TT(obj, tt) (somTestClsTT(((SOMObject SOMSTAR)\    ((void *)obj)),  (somClassDataStructure*)&(tt), __FILE__, __LINE__))  #define SOM_Measure#else  #define SOM_TestCls_TT(obj, tt) ((SOMObject SOMSTAR)((void *)obj))#endif/* Control the printing of method and procedure entry messages, *//* 0-none, 1-user, 2-core&user */SOMEXTERN int SOMDLINK SOM_TraceLevel;/* Control the printing of warning messages, 0-none, 1-all */SOMEXTERN int SOMDLINK SOM_WarnLevel;/* Control the printing of successful assertions, 0-none, 1-user, *//* 2-core&user */SOMEXTERN int SOMDLINK SOM_AssertLevel;/* *  Scans argv looking for flags -somt, -somtc, -soma -somac -somw setting *  SOM_TraceLevel, SOM_AssertLevel and SOM_WarnLevel as appropriate. *  argv is not modified */SOMEXTERN void SOMLINK somCheckArgs(int argc, char *argv[]);#define SOM_Error(c) ((*SOMError) (c,__FILE__, __LINE__))#define SOM_NoTrace(c,m)#ifdef _RETAIL  #define SOM_Trace(c,m)  #define SOM_TraceCore(c,m)#else  #define SOM_Trace(c,m) if (SOM_TraceLevel > 0) \      somPrintf("\"%s\": %d:\tIn %s:%s \n", \          __FILE__, __LINE__, c, m)  #define SOM_TraceCore(c,m) if (SOM_TraceLevel > 1) \      somPrintf("\"%s\": %d:\tIn %s:%s \n", \          __FILE__, __LINE__, c, m)#endifSOMEXTERN void SOMLINK somTest(int condition, int severity,	corbastring fileName, int lineNum, corbastring msg);#define SOM_Assert(condition,ecode) \  (somAssert(condition, ecode, __FILE__, __LINE__, # condition))#define SOM_AssertCore(condition,ecode) \  (somAssertCore(condition, ecode, __FILE__, __LINE__, # condition))#define SOM_Expect(condition) \      somTest(condition, SOM_Warn, __FILE__, __LINE__, # condition)#define SOM_WarnMsg(msg) \  if (SOM_WarnLevel > 0) \      somPrintf("\"%s\": %d:\tWarning: %s\n", __FILE__, __LINE__, msg)#define SOM_Test(boolexp) \    somTest(boolexp, SOM_Fatal, __FILE__, __LINE__, # boolexp)#define SOM_TestC(boolexp) \    somTest(boolexp, SOM_Warn, __FILE__, __LINE__, # boolexp)/* *   Default method debug macro, can be overridden */#ifndef SOMMethodDebug#define SOMMethodDebug(c,m) SOM_Trace(c,m)#endif#ifndef SOMProcedureDebug#define SOMProcedureDebug(c,m) SOM_Trace(c,m)#endif/* *  Error severity codes, these are added to the base error number to *  produce the full error code */#define SOM_Ok        0x0#define SOM_Warn      0x1#define SOM_Ignore    0x2 /* don't do anything */#define SOM_Fatal     0x9 /* terminate the program */#define SOM_Template  0x5 /* use to identify msg templates */#define SOM_EB 20000#define SOM_FatalCode(code) (SOM_EB + (code)*10 + SOM_Fatal)#define SOM_WarnCode(code) (SOM_EB + (code)*10 + SOM_Warn)#define SOM_IgnoreCode(code) (SOM_EB + (code)*10 + SOM_Ignore)#define SOM_OkCode(code) (SOM_EB + (code)*10 + SOM_Ok)#define SOM_TemplateCode(code) (SOM_EB + (code)*10 + SOM_Template)#define SOM_MsgCode(ecode) (((ecode)-SOM_EB)/10)#define SOMERROR_MustOverride SOM_FatalCode(18)#endif	/* __SOMCDEV__ *//*  SOM Version Numbers  */SOMEXTERN long SOMDLINK SOM_MajorVersion;SOMEXTERN long SOMDLINK SOM_MinorVersion;/*  SOM Thread Support  */SOMEXTERN long SOMDLINK SOM_MaxThreads;/*---------------------------------------------------------------------- *  Typedefs for pointers to functions */#ifdef	__cplusplusextern "C" {#endiftypedef void SOMLINK somTD_classInitRoutine (SOMClass SOMSTAR, SOMClass SOMSTAR);typedef int	SOMLINK somTD_SOMOutCharRoutine (char);typedef int	SOMLINK somTD_SOMLoadModule (IN corbastring	/* className */,										 IN corbastring	/* fileName */,										 IN corbastring	/* functionName */,										 IN long	/* majorVersion */,										 IN long	/* minorVersion */,										 OUT somToken* /* modHandle */);typedef int	SOMLINK somTD_SOMDeleteModule (IN somToken /* modHandle */);typedef corbastring SOMLINK somTD_SOMClassInitFuncName (void);typedef somToken SOMLINK somTD_SOMMalloc (IN size_t /* nbytes */);typedef somToken SOMLINK somTD_SOMCalloc (IN size_t /* element_count */,										  IN size_t /* element_size */);typedef somToken SOMLINK somTD_SOMRealloc (IN somToken	/* memory */,										   IN size_t	/* nbytes */);typedef void SOMLINK somTD_SOMFree (IN somToken	/* memory */);typedef void SOMLINK somTD_SOMError (IN int		/* code */,									 IN corbastring	/* fileName */,									 IN int		/* lineNum */);typedef unsigned long SOMLINK somTD_SOMCreateMutexSem (OUT somToken *sem);typedef unsigned long SOMLINK somTD_SOMRequestMutexSem (IN somToken sem);typedef unsigned long SOMLINK somTD_SOMReleaseMutexSem (IN somToken sem);typedef unsigned long SOMLINK somTD_SOMDestroyMutexSem (IN somToken sem);typedef unsigned long SOMLINK somTD_SOMGetThreadId (void);#ifdef __cplusplus}#endif/*---------------------------------------------------------------------- *  Windows extra procedures: */SOMEXTERN void SOMLINK somSetOutChar (somTD_SOMOutCharRoutine *outch);SOMEXTERN void SOMLINK somEnvironmentEnd (void);/* ------- Start User Assignable Variables ---------- *//* *  Replaceable character output handler. *  Points to the character output routine to be used in development *  support.  Initialized to <somOutChar>, but may be reset at anytime. *  Should return 0 (false) if an error occurs and 1 (true) otherwise. */ SOMEXTERN SOMDLINK somTD_SOMOutCharRoutine * SOMOutCharRoutine;/*---------------------------------------------------------------------- * Pointers to routines used to do dynamic code loading and deleting */SOMEXTERN SOMDLINK somTD_SOMLoadModule	  * SOMLoadModule;SOMEXTERN SOMDLINK somTD_SOMDeleteModule   * SOMDeleteModule;SOMEXTERN SOMDLINK somTD_SOMClassInitFuncName * SOMClassInitFuncName;/*---------------------------------------------------------------------- *  Replaceable SOM Memory Management Interface * *  External procedure variables SOMCalloc, SOMFree, SOMMalloc, SOMRealloc *  have the same interface as their standard C-library analogs. */SOMEXTERN SOMDLINK somTD_SOMCalloc  * SOMCalloc;SOMEXTERN SOMDLINK somTD_SOMFree    * SOMFree;SOMEXTERN SOMDLINK somTD_SOMMalloc  * SOMMalloc;SOMEXTERN SOMDLINK somTD_SOMRealloc * SOMRealloc;/*---------------------------------------------------------------------- *  Replaceable SOM Error handler */SOMEXTERN SOMDLINK somTD_SOMError * SOMError;/* ------- End User Assignable Variables ---------- *//* * Uses <SOMOutCharRoutine> to output its arguments under control of the ANSI C * style format.  Returns the number of characters output. */SOMEXTERN int SOMLINK somPrintf (const char * fmt, ...);/* * vprint form of somPrintf */SOMEXTERN int SOMLINK somVprintf (const char * fmt, va_list ap);/* * Outputs (via somPrintf) blanks to prefix a line at the indicated level */SOMEXTERN void SOMLINK somPrefixLevel (long level);/* * Combines somPrefixLevel and somPrintf */SOMEXTERN int SOMLINK somLPrintf (int level, const char * fmt, ...);/* -- Method/Data Tokens -- For locating methods and data members. */#if !__SOM_ENABLED__typedef somToken somMToken;typedef somToken somDToken;#endiftypedef struct somStaticClassInfo somStaticClassInfo, *somStaticClassInfoPtr;typedef struct {	long					zero;	somStaticClassInfo		*sci;	somDToken				instanceDataToken;	long					reserved [3];	somMToken				tokens[1];} somClassDataStructure, *somClassDataStructurePtr;/* Token Table Slot Entry Kinds: */enum {	mtVirtualMethod = 0,	mtProcedure = 1,	mtNonStatic = 2,	mtEmpty = 3,	mtDToken = 4};/* Stuff for automatic stub generation: *//* Parameter Description Nibble Codes: */enum {			/* Scalar Integer Group */	pdUByte = 0,	/* unsigned char (1 byte) */	pdSByte = 1,	/* signed char (1 byte) */	pdUHalf = 2,	/* unsigned half (2 byte) */	pdSHalf = 3,	/* signed half (2 byte) */	pdULong = 4,	/* unsigned long (4 byte) */	pdSLong = 5,	/* signed long (4 byte) */	pdVLong = 6,	/* long long (8 byte) */	pdVoid  = 7,	/* void */			/* Floating Point Group */	pdSFlt	= 8,	/* float (4 byte) */	pdDFlt	= 9,	/* double (8 byte) */	pdLFlt	= 10,	/* long double (12 or 16 byte) */	pdVSAgg	= 11,	/* very small aggregate (2 byte) */			/* Pointer Group */	pdNPtr  = 12,	/* 4 byte pointer */	pdLPtr  = 13,	/* 8 byte pointer */				/* Aggregate Group */	pdSAgg	= 14,	/* small aggregate (4 byte) */	pdLAgg	= 15	/* large aggregate */};/* Flags Nibble Bit Positions */enum {	fgShortOrChars	= 1,	fgShortFloats	= 2,	fgAnyFloats		= 4,	fgAnyNon4Bytes	= 8};/* Flags for special procs */enum {	cfSharedStrings 	= 1,	cfTempClass 		= 2,	cfProxyClass		= 4,		cfClassAllocate 	= 256*1,	cfClassDeallocate	= 256*2,	cfClassInit 		= 256*4,	cfClassUninit 		= 256*8};typedef struct {    unsigned long			majorVersion;    unsigned long			minorVersion;	unsigned long			flags;					/* low bit = shared strings */	unsigned short			dataAlignment;	unsigned short			classTokenCount;	/* bounds of token array */	unsigned short			numDirectParents;	unsigned short			numMetaClasses;	unsigned short			numOverriddenAncestors;	unsigned short			numMigratedMethods;	unsigned short			numSelectInherited;	unsigned short			numUnused;	unsigned short			dummy2a [4];} somStaticClassCounts, *somStaticClassCountsPtr;typedef unsigned char somSlotUsage;typedef unsigned char somSignatureInfo;typedef unsigned short somOverrideData;typedef unsigned short somMigratedMethods;typedef unsigned short somSelectedInherited;typedef unsigned long somParentVersions;typedef struct somRuntimeClassInfo somRuntimeClassInfo;typedef struct {	const char					*className;	unsigned long				instanceDataSize;	const somParentVersions		*parentVersions;	const somSlotUsage			*ttSlotUsage;	const somSignatureInfo		*signatureInfo;	const char					*methodNames;	const somOverrideData		*overrideData;	const somMigratedMethods	*migratedMethods;	const somSelectedInherited	*selectedInherited;	const void 					*unused;	const void					*dummy4b [4];} somStaticClassDescription, *somStaticClassDescriptionPtr;#define SOM_Layout_Version 70struct somStaticClassInfo {	unsigned long				layoutVersion;	somClassDataStructure		*tokenTable;	somMethodPtr				*overrideMethods;	somClassDataStructure		**specifiedAncestry;	somOpaque					DLLDesignator;	somMethodPtr				*specialProcs;	somRuntimeClassInfo			*runtimeClassInfo;	long						interesting;	somClassDataStructure		**actualAncestry;	void 						*extra [4];	const somStaticClassCounts	*classCounts;	somStaticClassDescription	classDescription;};/*  *	When using CFM or SOM API calls to load and unload classes, *	the following routines do not need to be called directly. *	If loading code other than through CFM or SOM, these functions, *	somNewClass and somKillClass may be used to inform the SOM kernel *	of the presence and	impending demise, respectively, of additional *	classes.  Note: somNewClass returns zero on success, non-zero *	otherwise.  somKillClass has void return. * *	In addition, if you want to obtain a dynamic (by name) reference *	to a class that (is in your own DLL and) is not already loaded via  *	some other means (instance object creation, etc..) and it does *	not have a 'cfrg' or a CFM level export of the xxxClassData *	function (such that it cannot be found using the regular CFM *	search mechanism) then you can call somNewClass  *	(a good place is from within the DLL/app's init routine)  *	to let SOM know of the presence of the (local/private) class,  *	and thereafter (until the class is released or "killed") *	somGetDynamicReference to work. */#define somNewClass(cls) \	somNewClassByTT ( (somClassDataStructure*) & cls ## ClassData )#define somKillClass(cls) \	somKillClassByTT ( (somClassDataStructure*) & cls ## ClassData )	/*  *	kernel functions to implement somNewClass and somKillClass *	please use the macros "somNewClass" and "somKillClass", *	respectively, instead of these functions... */SOMEXTERN long SOMLINK somNewClassByTT  ( somClassDataStructure *ttRef );SOMEXTERN void SOMLINK somKillClassByTT ( somClassDataStructure *ttRef );/* * Object Allocation: * a newly allocated object will retain a reference to its class object * which is released when the object is uninitialized. see below for * more information on the release of class objects. */ /*  * The recommended way to allocate an object: *  	SOMObject *obj = somNewObject ( SOMObject ); *			... *      somReleaseObjectReference ( obj ); */#define somNewObject( cls ) \ 	( ( cls SOMSTAR ) somNewObjectInstance ((somClassDataStructure*) \		& cls ## ClassData, cls ## _MajorVersion, cls ## _MinorVersion ) )/*  * The recommended way to allocate an object of a versioned class: *  	SOMObject *obj = somNewVersionedObject ( SOMObject, 70, 1 ); *			... *      somReleaseObjectReference ( obj ); */#define somNewVersionedObject( cls, majorVersion, minorVersion ) \ 	( ( cls SOMSTAR ) somNewObjectInstance ( (somClassDataStructure*) \		& cls ## ClassData, majorVersion, minorVersion ) ) 	/*  * the kernel function for allocating new object instances. * please use the macros "somNewObject" or "somNewVersionedObject" instead of invoking directly. */#if !__SOM_ENABLED__SOMEXTERN void *SOMLINK somNewObjectInstance ( somClassDataStructure *tokenTable,	long majorVersion, long minorVersion );#endif/* * when casting the return from these functions to your actual object * type in C++, some compilers may complain of ambiguities requiring * you to first cast the return to (void*) and then to the desired type */SOMEXTERN SOMObject SOMSTAR SOMLINK somNewObjectByName ( corbastring className, 	long majorVersion, long minorVersion );SOMEXTERN SOMObject SOMSTAR SOMLINK somNewObjectById ( somId classId,	long majorVersion, long minorVersion );#if !__SOM_ENABLED__SOMEXTERN SOMObject SOMSTAR SOMLINK somReleaseObjectReference ( SOMObject SOMSTAR obj );#endif/*--------------------------------------------------------------------- *  Offset-based method resolution. *//* obtaining method pointers for direct method invocation */SOMEXTERN somMethodPtr SOMLINK somResolve ( SOMObject SOMSTAR obj, somMToken mToken );/* obtaining method pointer of a direct parent for calling through */#if !__SOM_ENABLED__SOMEXTERN somMethodPtr SOMLINK somParentNumResolve ( somClassDataStructure *ref,	int parentNum, somMToken mToken );#endif/* method resolution via metaclass object */SOMEXTERN somMethodPtr SOMLINK somClassResolve ( SOMClass SOMSTAR classObj, somMToken mToken );/*------------------------------------------------------------------------------ * Name/Id-based data resolution *//* method resolution by name */SOMEXTERN somMethodPtr SOMLINK somResolveByName ( SOMObject SOMSTAR obj, char *methodName );/* method resolution by id */SOMEXTERN somMethodPtr SOMLINK somResolveById ( SOMObject SOMSTAR obj, somId methodId );/*------------------------------------------------------------------------------ * Offset-based data resolution */SOMEXTERN somToken SOMLINK somDataResolve ( SOMObject SOMSTAR obj, somDToken dataId );SOMEXTERN somToken SOMLINK somDataResolveChk ( SOMObject SOMSTAR obj, somDToken dataId );/*------------------------------------------------------------------------------ * Obtaining a new reference to the meta-class object: *//*  * The recommended way to obtain a static class object reference: *  	SOMClass *classObject = somNewClassReference ( SOMObject ); *			... *      somReleaseClassReference ( classObject ); */#define somNewClassReference(cls) \	( ( cls ## MetaClass SOMSTAR ) somGetStaticClassReference ( (somClassDataStructure*) \		& cls ## ClassData, cls ## _MajorVersion, cls ## _MinorVersion ) )/*  * The recommended way to obtain a static class object reference with *		specific version numbers: *  	SOMClass *classObject = somNewVersionedClassReference ( SOMObject, 70, 1 ); *			... *      somReleaseClassReference ( classObject ); */#define somNewVersionedClassReference(cls,majorVersion,minorVersion)			\	( ( cls ## MetaClass SOMSTAR ) somGetStaticClassReference ( (somClassDataStructure*) \		& cls ## ClassData, majorVersion, minorVersion ) ) /* * obtains a new reference to a statically linked class object * which must be released when you finish with the object * please use the macros "somNewClassReference" or "somNewVersionedClassReference" * instead of invoking this functions directly. */SOMEXTERN void *SOMLINK somGetStaticClassReference	( somClassDataStructure *tokenTable, long majorVersion, long minorVersion );/* * looks up a class object by id and version. * if "file" is not NULL, will look for the class in "file" * which on the Macintosh is a code fragment name */SOMEXTERN SOMClass SOMSTAR SOMLINK somGetDynamicClassReference ( somId classId,	long majorVersion, long minorVersion, corbastring file /* optionally NULL */ );/* * releases the reference obtained by "somGetStaticClassReference" or * "somGetDynamicClassReference".  if the class reference was obtained * dynamically, this may cause unloading of the class' DLLSOMEXTERN SOMClass SOMSTAR SOMLINK somReleaseClassReference ( SOMClass SOMSTAR classObj ); */#define somReleaseClassReference(classObj) \	(( SOMClass SOMSTAR ) somReleaseObjectReference ( classObj ))/* * automatic object convenience calls: *	    "somGetInstanceSizeAndStaticClassReference" returns the runtime *			size of the object in bytes and a reference to its class *			object for use in "somInitInstanceAndFreeClassReference" * *		"somInitInstanceAndFreeClassReference" takes an arbitrary *			block of memory of the size returned by *			"somGetInstanceSizeAndStaticClassReference", initializes *			it and releases the reference to its class object. * *		"somDestructAutoObject" takes a reference to the object *			initialized via "somInitInstanceAndFreeClassReference" *			and tears it down without disposing of the object itself. * */#define somGetInstanceSizeAndStaticClassReference(cls,majorVersion,minorVersion,classObj) \	somGetInstSizeAndStaticClassRef ( (somClassDataStructure*) \		& cls ## ClassData, majorVersion, minorVersion, classObj )SOMEXTERN long SOMLINK somGetInstSizeAndStaticClassRef	( somClassDataStructure *tokenTable, long majorVersion, long minorVersion, SOMClass SOMSTAR *classObject );SOMEXTERN void SOMLINK somInitInstanceAndFreeClassReference	( SOMClass SOMSTAR classObject, void *addr );SOMEXTERN void SOMLINK somDestructAutoObject ( SOMObject SOMSTAR obj ); /*---------------------------------------------------------------------- *  Class Manager: SOMClassMgr, stem <somcm> *//* * obtains a new reference to the global class manager object * which must be released when you finish with it. */SOMEXTERN SOMClassMgr * SOMLINK somGetClassManagerReference ( void );/* * obtains a new reference to the global class manager object * which must be released when you finish with it.SOMEXTERN SOMClassMgr * SOMLINK somReleaseClassManagerReference	( SOMClassMgr *classMgrObj ); */#define somReleaseClassManagerReference(classMgrObj) \	(( SOMClassMgr SOMSTAR ) somReleaseObjectReference ( classMgrObj ))/* * The somRegisterClassLibrary function is provided for use * in SOM class libraries on platforms that have loader-invoked * entry points associated with shared libraries (DLLs). * Not generally used on the Macintosh. */SOMEXTERN void SOMLINK somRegisterClassLibrary (corbastring libraryName,    somMethodProc *libraryInitRtn);/*---------------------------------------------------------------------- *  Misc. procedures: *//* *  Create and initialize the SOM environment * *  Can be called repeatedly * *  Will be called automatically when first object (including a class *  object) is created, if it has not already been done. * *  Used to return the global class mgr object which wasn't use counted *	See "somGetClassManagerReference" for information on accessing the *	class manager object. */SOMEXTERN void SOMLINK somEnvironmentNew (void);/* * Test whether <obj> is a valid SOM object.  This test attempts to verify * that <obj> refers to a valid method table.  If so, then methods can be * invoked on <obj>. */SOMEXTERN boolean SOMLINK somIsObj ( somToken obj );/*---------------------------------------------------------------------- *  String Manager: stem <somsm> *//* * given a somKernelId returned by kernel API functions, create a * user somId which must be freed by user via SOMFree.  the * somKernelId passed in is freed by the kernel. */#if !__SOM_ENABLED__SOMEXTERN somId SOMLINK somConvertAndFreeKernelId (somKernelId id);#endif/* * any somKernelId's not freed by somConvertAndFreeKernelId * must be freed with this function */#if !__SOM_ENABLED__SOMEXTERN void SOMLINK somFreeKernelId (somKernelId id);#endif/* * makes sure that the id is registered and in normal form, * returns the id */SOMEXTERN somId SOMLINK somCheckId (somId id);/* * Same as somCheckId except returns 1 (true) if this is the first * time the string associated with this id has been registered, * returns 0 (false) otherwise * * This function has very bad memory charactaristics *		!! avoid use if possible !! */SOMEXTERN int SOMLINK somRegisterId(somId id);/* * allocates storage that the user needs to free */#if !__SOM_ENABLED__SOMEXTERN somId SOMLINK somIdFromString (corbastring aString);#endif/* * This function has very bad memory charactaristics *		!! avoid use if possible !! * Use somMakeStringFromId instead. */SOMEXTERN corbastring SOMLINK somStringFromId (somId id);/* * Memory returned belongs to user. Free with SOMFree, * just like the return value from somIdFromString need's to be free'd */#if !__SOM_ENABLED__SOMEXTERN corbastring SOMLINK somMakeStringFromId (somId id);#endif/* * returns true (1) if the two ids are equal, else false (0) */#if !__SOM_ENABLED__SOMEXTERN int SOMLINK somCompareIds(somId id1, somId id2);#endif/* * Returns the total number of ids that have been registered so far, * you can use this to advise the SOM runtime concerning expected * number of ids in later executions of your program, via a call to * somSetExpectedIds defined below */SOMEXTERN unsigned long SOMLINK somTotalRegIds(void);/* * Tells the SOM runtime how many unique ids you expect to use during * the execution of your program, this can improve space and time * utilization slightly, this routine must be called before the SOM * environment is created to have any effect */SOMEXTERN void SOMLINK somSetExpectedIds(unsigned long numIds);/* * Returns the unique key for this id, this key will be the same as the * key in another id if and only if the other id refers to the same * name as this one * * This function has very bad memory charactaristics *		!! avoid use if possible !! */SOMEXTERN unsigned long SOMLINK somUniqueKey(somId id);/* * Tells the id manager that strings for any new ids that are * registered will never be freed or otherwise modified. This allows * the id manager to just use a pointer to the string in the * unregistered id as the master copy of the ids string. Thus saving * space * Under normal use (where ids are static varibles) the string * associated with an id would only be freed if the code module in * which it occured was unloaded */SOMEXTERN void SOMLINK somBeginPersistentIds(void);/* * Tells the id manager that strings for any new ids that are * registered may be freed or otherwise modified.  Therefore the id * manager must copy the strings inorder to remember the name of an id. */SOMEXTERN void SOMLINK somEndPersistentIds(void);/*---------------------------------------------------------------------- * -- somApply -- * * This routine replaces direct use of applyStubs in SOMr1. The reason * for the replacement is that the SOMr1 style of applyStub is not * generally available in SOMr2, which uses a fixed set of applyStubs, * according to method information in the somMethodData. In particular, * neither the redispatch stub nor the apply stub found in the method * data structure are necessarily useful as such. The method somGetRdStub * is the way to get a redispatch stub, and the above function is the * way to call an apply stub. If an appropriate apply stub for the * method indicated by md is available, then this is invoked and TRUE is * returned; otherwise FALSE is returned. * * The va_list passed to somApply *must* include the target object, * somSelf, as its first entry, and any single precision floating point * arguments being passed to the the method procedure must be * represented on the va_list using double precision values. retVal cannot * be NULL. */#if !__SOM_ENABLED__typedef struct somMethodData somMethodData, *somMethodDataPtr;struct somMethodData {	somOpaque stuff [6];};#endifSOMEXTERN boolean SOMLINK somApply ( SOMObject SOMSTAR somSelf,	somToken *retVal, somMethodDataPtr mdPtr, va_list ap );/*  *	handle somDispatch and somClassDisptach separately so *	that we don't wind up with static functions in base *	header files (some systems may not dead strip well)... */   #define SOMGD_somDispatch 1#define _somDispatch va_SOMObject_somDispatch#define va_somDispatch va_SOMObject_somDispatchSOMEXTERN boolean  SOMLINK va_SOMObject_somDispatch(SOMObject SOMSTAR somSelf,	somToken* retValue, somId methodId, ...);#define SOMGD_somClassDispatch 1#define _somClassDispatch va_SOMObject_somClassDispatch#define va_somClassDispatch va_SOMObject_somClassDispatchSOMEXTERN boolean  SOMLINK va_SOMObject_somClassDispatch(SOMObject SOMSTAR somSelf,	SOMClass SOMSTAR clsObj, somToken* retValue, somId methodId, ...);SOMEXTERN SOMObject SOMSTAR SOMLINK somTestCls	(SOMObject SOMSTAR obj, SOMClass SOMSTAR classObj, corbastring fileName, int lineNumber);SOMEXTERN SOMObject SOMSTAR SOMLINK somTestClsTT	(SOMObject SOMSTAR obj, somClassDataStructure *tt, corbastring fileName, int lineNumber);#if __TESTING_THE_KERNEL__SOMEXTERN somMethodPtr _somGetRdStub ( SOMClass SOMSTAR classObject, somId methodId );/* This procedure is used to test SOM internals. *//* It is not officially supported.               */#endiftypedef struct somRuntimeClassInfo	somClassInfo, *somClassInfoPtr;typedef struct somMethodTabStruct somMethodTab;typedef unsigned long *somBooleanVector;#if OLDIBMSOMAPISUPPORT#include <somcmpat.h>#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#if PRAGMA_ALIGN_SUPPORTED#  pragma options align=reset#endif#ifndef __cplusplus#ifdef SOM_STRICT_IDL	#undef SOMObject	#undef SOMClass	#undef SOMClassMgr		typedef SOMAny *SOMAnyStrict;		#define SOMObject SOMAnyStrict	#define SOMClass SOMAnyStrict	#define SOMClassMgr SOMAnyStrict#endif#ifndef SOM_NO_OBJECTS	#define SOMObject_VA_EXTERN	#include <somobj.h>	#include <somcls.h>	#include <somcm.h>#endif#endif#endif	/* __SOM__ */