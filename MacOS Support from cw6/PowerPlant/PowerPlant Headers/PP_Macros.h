// ===========================================================================//	PP_Macros.h					PowerPlant 2.1		©1993-2000 Metrowerks Inc.// ===========================================================================////	Macro definitions for controlling conditional compilation options////	The basic format of most of the options is:////		#ifndef Option_Name//			#define Option_Name		Default_Value//		#endif////		#if Option_Name//			// Define symbols for the option being ON//		#else//			// Define symbols for the option being OFF//		#endif////	If you wish to set the option yourself, you should place the appropriate//	#define of the Option_Name in a header file that gets #include'd before//	this one, normally your project prefix file or precompiled header.#ifndef _H_PP_Macros#define _H_PP_Macros#pragma once// ---------------------------------------------------------------------------//	PowerPlant version number#define		__PowerPlant__	0x02108000	// Version 2.1// ---------------------------------------------------------------------------//	Target OS#ifndef PP_Target_Carbon				// Default is Classic	#define PP_Target_Classic		1	#define PP_Target_Carbon		0#endif#ifndef __dest_os						// For MSL	#define __dest_os  __mac_os#endif// ---------------------------------------------------------------------------//	PowerPlant Namespace#ifndef PP_Uses_PowerPlant_Namespace	#define PP_Uses_PowerPlant_Namespace	0		// Default to OFF#endif#if PP_Uses_PowerPlant_Namespace	#define PP_Begin_Namespace_PowerPlant	namespace PowerPlant {	#define PP_End_Namespace_PowerPlant		}	#define PP_Using_Namespace_PowerPlant	using namespace PowerPlant;	#define PP_PowerPlant					PowerPlant#else	#define PP_Begin_Namespace_PowerPlant	#define PP_End_Namespace_PowerPlant	#define PP_Using_Namespace_PowerPlant	#define PP_PowerPlant#endif// ---------------------------------------------------------------------------//	std Namespace	// Macro for controlling use of "std" namespace for the C++	// standard libraries. Within CodeWarrior, this setting should	// be ON if _MSL_USING_NAMESPACE is #define'd.	//	// Set to OFF only if you have explicitly disabled namespace support	// in the MSL or are using another implementation of the C++	// standard libraries that does not support namespaces.#ifndef PP_Uses_Std_Namespace	#define	PP_Uses_Std_Namespace			1		// Default to ON#endif#if PP_Uses_Std_Namespace	#define PP_Using_Namespace_Std			using namespace std;	#define PP_STD							std#else	#define PP_Using_Namespace_Std	#define PP_STD#endif// ---------------------------------------------------------------------------//	String Literals	// Mac OS uses Pascal-style strings (length byte followed by characters)	// for most Toolbox calls. Prefixing string literals with \p (which	// the compiler replaces with a length byte) is a non-standard extension	// to C supported by Mac OS compilers.	//	// If you use literal strings in your code and want to build with	// multiple compilers that may or may not support Pascal strings, you	// must be able to handle both C and Pascal strings. One way to do	// this is to only use string literals as arguments to functions,	// and to overload such functions so that there is a version that	// accepts C strings (char *) and one that accepts Pascal strings	// (unsigned char *).#ifndef PP_Supports_Pascal_Strings	#define PP_Supports_Pascal_Strings		1		// Default is true#endif#if PP_Supports_Pascal_Strings	#define StringLiteral_(str)		("\p" str)		// Pascal string#else	#define StringLiteral_(str)		(str)			// C string#endif// ---------------------------------------------------------------------------//	Option for implementation of standard dialogs	// Navigation Services provides standard dialogs for confirming	// document saves and for choosing and specifying files. However,	// Nav Services is not present in all Systems. It is available as	// a separate SDK for System 8.1 and ships with System 8.5 and later.	// For compatibility, PP offers three implementations of the dialogs.	//	//		1) Classic Only - Uses Alert and Standard File, which is	//							available in System 7 or later	//	//		2) Nav Services Only - You are responsible for checking for	//								Nav Services before using the dialogs.	//								You may want to check at launch and	//								refuse to run or disable features.	//	//		3) Conditional - Checks at runtime. Uses Nav Services if	//							available, otherwise Classic	//	//	Note: For Carbon targets, you must use Nav Services Only.#define	PP_StdDialogs_ClassicOnly			1		// Always use Classic#define	PP_StdDialogs_NavServicesOnly		2		// Always use Nav Services#define PP_StdDialogs_Conditional			3		// Check at runtime#ifndef	PP_StdDialogs_Option	#if PP_Target_Carbon			// Under Carbon, NavServices is									//   the only option		#define PP_StdDialogs_Option	PP_StdDialogs_NavServicesOnly	#else							// Default to Classic otherwise		#define PP_StdDialogs_Option	PP_StdDialogs_ClassicOnly	#endif#endif#if PP_Target_Carbon && (PP_StdDialogs_Option != PP_StdDialogs_NavServicesOnly)	#error Must use NavServices for Carbon targets#endif// ---------------------------------------------------------------------------//	Option for including PP implementation of RepositionWindow()		// Although CarbonLib implements most of the important functions of		// Window Manager 2.0, it does not implement RepositionWindow().		// Window Mgr 2.0 has support for floating windows and it was		// introduced with Mac OS 8.5.		//		// This presents a problem for systems using CarbonLib 1.0.x on		// Mac OS 8.1. PP's floating window code isn't Carbonized (it		// uses too many non-Carbon routines). So, to support floating		// windows on this configuration, PP has its own implementation		// of RepositionWindow() in UWindows, which is called by		// UWMgr20-Desktop.cp when the Toolbox implementation isn't present.		//		// UWindows::RepositionWindow() brings in a lot of code, all of		// which is unnecessary on Mac OS 8.5 or later. So, this flag		// let's you turn on or off this code.		//		// Define the flag to 1 if all the following conditions are true:		//		- Target is Carbon 1.0.x		//		- Program needs to support Mac OS 8.1		//		- Program uses UWMgr20Desktop.cp instead of UDesktop.cp		//			in order to support floating windows		#ifndef PP_Implement_RepositionWindow			// Default to ON for Carbon												//   and OFF for Classic	#define PP_Implement_RepositionWindow	PP_Target_Carbon#endif// ---------------------------------------------------------------------------//	Option for defining PP integer types		// PP_Types.h has typedef's for signed and unsigned types		// of char, short, and long. Apple's MacTypes.h also has		// typedef's for those items but with slightly different names.		//		// You should use the Apple typedef's. The PP typedef's are		// deprecated.#ifndef PP_Uses_Old_Integer_Types	#define	PP_Uses_Old_Integer_Types		0		// Default to OFF#endif// ---------------------------------------------------------------------------//	Option for forcing a compiler error if using the obsolete//	LCommander::AllowTargetSwitch() function.		// If you override AllowTargetSwitch() to perform data entry		// validation, you must rename that function to AllowBeTarget().		// You may also want to update your code to take advantage of the		// greater flexibility of the AllowBeTarget/AllowDontBeTarget calls.#ifndef PP_Obsolete_AllowTargetSwitch	#define PP_Obsolete_AllowTargetSwitch	0		// Default to OFF#endif// ---------------------------------------------------------------------------//	Option for throwing exceptions		// PP now throws LException objects. To switch back to the		// old behavior of throwing ExceptionCodes (long integers),		// set the symbol to 1 (true).#ifndef PP_Obsolete_ThrowExceptionCode	#define PP_Obsolete_ThrowExceptionCode	0#endif// ---------------------------------------------------------------------------//	Option for warning if using obsolete classes		// Whether or not to issue a compile-time warning if a project		// uses a class that will be obsolete.#ifndef PP_Warn_Obsolete_Classes	#define PP_Warn_Obsolete_Classes		1		// Default is ON#endif// ---------------------------------------------------------------------------//	Option for explaining name changes		// Symbol names can change due to bug fixes, enhancements, or		// changes in Apple's Universal Interfaces. You will need to change		// existing code that uses the old names.		//		// With this option on, PP will #define the old name to a message		// that explains what to do. The explanatory message will be		// invalid code, so the message will appear as a compilation error.		//		// Once you have updated your code, you may want to turn off this		// option to remove unnecessary #define's.#ifndef PP_Explain_Name_Changes	#define PP_Explain_Name_Changes			1		// Default is ON#endif// ---------------------------------------------------------------------------//	Import option for CFM68K#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#define PP_Uses_Pragma_Import	1#else	#define PP_Uses_Pragma_Import	0#endif// ---------------------------------------------------------------------------//	Preprocessor symbols for Apple Universal Headers options#undef SystemSevenOrLater				// PowerPlant requires System 7#define SystemSevenOrLater	1#undef OLDROUTINENAMES					// PP uses only new names#define OLDROUTINENAMES		0#undef OLDROUTINELOCATIONS				// PP uses only new header locations#define OLDROUTINELOCATIONS	0#endif