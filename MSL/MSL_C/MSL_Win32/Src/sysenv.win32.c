/*  Metrowerks Standard Library  *//*  $Date: 2000/06/12 17:54:30 $  *  $Revision: 1.5.12.8 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. */ /* *	sysenv.win32.c *	 *	Routines *	-------- *		getenv *		system * */#include <crtl.h>   			/* for _Environ */#include <cstdlib>				/* for getenv */#include <extras.h>				/* cc 000512 */#define WIN32_LEAN_AND_MEAN#include <windows.h>#include <cerrno>  				/* for errno */#include <string.h>  /*#include <stdarg.h>  *//*#include <wchar.h>   */ /* This routine takes the name of an environment variable and returns * its corresponding value.	*/#if ( __dest_os==__wince_os)char * getenv(const char * /*inVarName*/){return 0;}#elsechar * getenv(const char * inVarName){	/* begin mm 990115 */	char * CurEnvString;	int theVarNameLength = strlen(inVarName);	int StrInx = 0;	 	while((CurEnvString = _Environ[StrInx++]) != NULL)		/* mm 990125 */	{		if ((CurEnvString[theVarNameLength] == '=') &&		    (_strnicmp(CurEnvString, inVarName, theVarNameLength) == 0)) 			/* The string matches. Return a pointer to the value			 * after the '=' sign.	*/			return (CurEnvString + theVarNameLength + 1);	}	/* end mm 990115 */		return 0;}#endif /* implementation of Microsoft runtime function to put a new value or * update an existing value in the runtime libraries environment variable * space. */ int _putenv(const char * inVarName){	/* scan the incoming string for the variable name and its value */	const char *equal_sign = strchr(inVarName, '=');	if (equal_sign)	{		/* isolate variable and argument */		int var_length = equal_sign - inVarName;		const char *arg = equal_sign + 1;		int existing;		/* scan for existing variable with specified name */		for (existing = 0; _Environ[existing] != NULL; existing++)		{			if (_Environ[existing][var_length + 1] == '=' &&				_strnicmp(_Environ[existing], inVarName, var_length) == 0)			{				break;			}		}		if (_Environ[existing] != NULL)		{			/* found existing element so free its allocation */			free(_Environ[existing]);		}		else if (arg)		{			/* append new environment string onto end if value provided */			_Environ = realloc(_Environ, sizeof(char *) * (existing + 1));			_Environ[existing + 1] = NULL;		}		/* allocate space for new string and place in list if there is		 * a new value for it */		if (arg)		{			_Environ[existing] = _strdup(inVarName);		}	}	else	{		/* error: malformed argument */		return -1;		}	return 0;	/* success */}int system(const char * cmdLine){	int result = 0;	unsigned short bResult = 0;		if(cmdLine)	{		PROCESS_INFORMATION piProcInfo; 		STARTUPINFO			siStartInfo;		char *				env_block; 		char * 				env_current;		size_t				env_size /*real_cmdLine_size*/;  /* 000609 */		int					i;		char *				real_cmdLine; 					/* 000609 */	   	OSVERSIONINFOEX 	osvi;  							/* 000609 */   		BOOL 				bOsVersionInfoEx;				/* 000609 */				/* setup the real command line -- its based on getting the name		 * of the current shell, then executing it with these parameters */		 		real_cmdLine = getenv("COMSPEC");  /* 000609 */				/* fall back if comspec is not set */  /* 000609 */		if (real_cmdLine == 0)		{		   ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));		   osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);				   if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )		   {		      // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.				      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);		      if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 		         return FALSE;		   }			   switch (osvi.dwPlatformId)		   {		      case VER_PLATFORM_WIN32_NT:				           if (( osvi.dwMajorVersion <= 4 ) || (osvi.dwMajorVersion == 5))		            real_cmdLine = "cmd.exe";	          break;			      case VER_PLATFORM_WIN32_WINDOWS:				         if (osvi.dwMajorVersion > 4) 		            real_cmdLine = "command.com";		         break;				    }	    } /* 000609 */				strcat(real_cmdLine," /c");  	/* 000609 */		strcat(real_cmdLine,"  ");		/* 000609 */		strcat(real_cmdLine,cmdLine);	/* 000609 */		/* find the size of the new environment block */		env_size = 0;		for (i = 0; _Environ[i] != NULL; i++)		{			env_size += strlen(_Environ[i]) + 1;		}		++env_size; /* account for final null terminator */		/* create the new environment block */		env_block = malloc(env_size);		if (!env_block)		{			/* no memory available -- return failure */			errno = ENOMEM;			return -1;		}				env_current = env_block;		for (i = 0; _Environ[i] != NULL; i++)		{			strcpy(env_current, _Environ[i]);			env_current += strlen(_Environ[i] + 1);		}		*env_current = 0; /* set final null terminator */		/* Create the child process. */         memset(&siStartInfo,0,sizeof(siStartInfo));        siStartInfo.cb = sizeof(siStartInfo);		bResult = CreateProcess(	NULL,		/* application name */									(char *)real_cmdLine,	/* command line */									NULL,				/* process security attributes */									NULL,				/* primary thread security attributes */									TRUE,				/* handles are inherited */									0,					/* creation flags */									env_block,			/* use new environment */									NULL,				/* working directory path */									&siStartInfo,		/* STARTUPINFO pointer */									&piProcInfo);		/* receives PROCESS_INFORMATION */	    if( bResult ) 	    {	    	WaitForSingleObject(piProcInfo.hProcess, (DWORD)(-1L)); /* wait until the process has completed */	    	CloseHandle(piProcInfo.hProcess);			CloseHandle(piProcInfo.hThread);			result = 1;		} 		else 		{			result = 0;		}		/* release memory allocated for environment block */		free(env_block);	}	return result;	}/*  Change History * 961211 KO	Wrote this file. * mm 990115    Rewrote getenv() to make use of _Environ * vss 990121   Moved system function to sysenv.c * mm 990125    Change to allow compilation without warning message * blc 990922   Added _putenv, modified system to use runtime environment * cc  000221   Added errno.h  * cc  000512   Added #include<extras.h> * cc  000609	Changed system to take in path to shell plus commmand line * cc  000612	Added case for Win2000 shell */