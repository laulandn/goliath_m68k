/* ================================================================================================== * HelperAppDialog.cpp															    *    Goliath - a Finder like application that implements WebDAV *    Copyright (C) 1999-2002  Thomas Bednarz * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com * =========================================================================== */ #include "HelperAppDialog.h"#ifndef __ExternalEditContext_h__#include "ExternalEditContext.h"#endif#ifndef __ExternalEditorManager_h__#include "ExternalEditorManager.h"#endif#ifndef __AppLauncher_h__#include "AppLauncher.h"#endif#include "CStringDisplayTable.h"#include "CDAVHeadingTable.h"#include "CNavServicesUtils.h"#include "CDAVItemUtils.h"#include <LPushButton.h>// ---------------------------------------------------------------------------------//		¥ HelperAppDialog// ---------------------------------------------------------------------------------//	HelperAppDialog::HelperAppDialog(LStream* inStream) :	LDialogBox(inStream) ,	mTable(NULL),	mRemoveButton(NULL){}// ---------------------------------------------------------------------------------//		¥ ~HelperAppDialog// ---------------------------------------------------------------------------------//	HelperAppDialog::~HelperAppDialog() {}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------//	void HelperAppDialog::FinishCreateSelf() {    mTable = dynamic_cast<CStringDisplayTable*>(FindPaneByID('flvt'));    Assert_(mTable != nil);	if (!mTable)		return;			CDAVHeadingTable *heading = reinterpret_cast<CDAVHeadingTable*>(FindPaneByID( 'dhdr' ));   	mRemoveButton = dynamic_cast<LPushButton*>(FindPaneByID('RAPP'));	std::map<MessageT, int> colMsgMap;	colMsgMap['COL1'] = 1;    mTable->Setup(NULL, heading, colMsgMap);    heading->InsertCols(1, 0, nil, nil, false);	heading->SetColumnHeading( 1, LStr255(1007, 6), kControlBevelButtonAlignTextCenter, 0);	heading->SetColWidth(310,  1,  1);		ExternalEditorManager *editMgr = ExternalEditorManager::GetExternalEditsMgr();	ExternalEditorDefList eDefList;	editMgr->GetEditorList(eDefList);	for (ExternalEditorDefList::iterator iter = eDefList.begin(); iter != eDefList.end(); ++iter) {		AddAppToList((*iter).first, (*iter).second);	}	}// ---------------------------------------------------------------------------------//		¥ RemoveSelectedApps// ---------------------------------------------------------------------------------//	void HelperAppDialog::RemoveSelectedApps(){	STableCell		cell;	UInt32			numRows,numCols;		std::vector<LOutlineItem*> items;	mTable->GetTableSize(numRows,numCols);	bool atLeastOneIsSelected = false;	for (cell.row=1; cell.row<=numRows; cell.row++) {		if (mTable->CellIsSelected(cell)) {		   LOutlineItem* theItem = mTable->FindItemForRow(cell.row);		   if (NULL != theItem) 		      items.push_back(theItem);   		}	}		for (std::vector<LOutlineItem*>::iterator iter = items.begin(); iter != items.end(); ++iter) {		LOutlineItem *theItem = *iter;		std::string appName;	 	mTable->GetTextForItem(theItem, 0, appName);		mTable->RemoveItem(theItem);		mAppTypes.erase(appName);	}	}// ---------------------------------------------------------------------------------//		¥ EnableControls// ---------------------------------------------------------------------------------//	void HelperAppDialog::EnableControls() {	STableCell		cell;	UInt32			numRows,numCols;		mTable->GetTableSize(numRows,numCols);	bool atLeastOneIsSelected = false;	for (cell.row=1; cell.row<=numRows; cell.row++) {		if (mTable->CellIsSelected(cell)) {			atLeastOneIsSelected = true;			break;   		}	}	if (atLeastOneIsSelected)		mRemoveButton->Enable();	else 		mRemoveButton->Disable();}// ---------------------------------------------------------------------------------//		¥ DoAddApp// ---------------------------------------------------------------------------------//	void HelperAppDialog::DoAddApp() {	FSSpec theSpec;	for (int i=0; i<=63; i++)		theSpec.name[i]=NULL;	if (!CNavServicesUtils::getApplicationNavSrv(&theSpec, 1006, 1))		return;		std::string appname;	if (CDAVItemUtils::IsDirectory(&theSpec)) {		Str31 name;		CDAVItemUtils::GetDirName(theSpec.vRefNum, theSpec.parID, name);		LStr255 tmpStr(name);		appname.append(tmpStr.ConstTextPtr(), tmpStr.Length());	} else {		ConstStringPtr ptr = theSpec.name;		LStr255 tmpStr(ptr);		appname.append(tmpStr.ConstTextPtr(), tmpStr.Length());	}		if (appname.rfind(".app") != std::string::npos) {		appname.erase(appname.size()-4, 4);	}		OSType creator;	if (!AppLauncher::GetCreatorForSpec(theSpec, creator))		return;				AddAppToList(appname, creator);}// ---------------------------------------------------------------------------------//		¥ OnOK// ---------------------------------------------------------------------------------//	void HelperAppDialog::OnOK() {	STableCell		cell;	UInt32			numRows,numCols;		ExternalEditorManager *editMgr = ExternalEditorManager::GetExternalEditsMgr();	ExternalEditorDefList eDefList;	std::vector<LOutlineItem*> items;	mTable->GetTableSize(numRows,numCols);	bool atLeastOneIsSelected = false;	for (cell.row=1; cell.row<=numRows; cell.row++) {	   LOutlineItem* theItem = mTable->FindItemForRow(cell.row);	   if (NULL != theItem) {   			ExternalEditorDef eDef;			std::string appName;	   		mTable->GetTextForItem(theItem, 0, appName);	   		OSType appType = mAppTypes[appName];			eDef.first = appName;			eDef.second = appType;			eDefList.push_back(eDef);   		}	}	editMgr->SetEditorList(eDefList);}// ---------------------------------------------------------------------------------//		¥ AddAppToList// ---------------------------------------------------------------------------------//	void HelperAppDialog::AddAppToList(const std::string& inAppName, const OSType inAppType) {	mAppTypes[inAppName] = inAppType;   	std::vector<std::string> items;	items.push_back(inAppName);	mTable->AddListItem(items, NULL);	}// ---------------------------------------------------------------------------------//		¥ DoDialogLoop// ---------------------------------------------------------------------------------//	void HelperAppDialog::DoDialogLoop() {	PP_PowerPlant::StDialogHandler dialog(1416, GetApplicationInstance());	HelperAppDialog* dlog = dynamic_cast<HelperAppDialog*>(dialog.GetDialog());	Assert_(dlog != nil);		dlog->Show();		while (true) {		dlog->EnableControls();		PP_PowerPlant::MessageT hitMessage = dialog.DoDialog();		if (hitMessage == PP_PowerPlant::msg_Cancel)			break;		else if (hitMessage == PP_PowerPlant::msg_OK) {			dlog->OnOK();			break;		} else if (hitMessage == 'AAPP') {			dlog->DoAddApp();		} else if (hitMessage == 'RAPP') {			dlog->RemoveSelectedApps();		}	}}