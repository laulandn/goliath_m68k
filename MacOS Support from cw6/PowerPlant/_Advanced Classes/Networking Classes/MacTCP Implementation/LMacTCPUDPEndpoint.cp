// ===========================================================================//	LMacTCPUDPEndpoint.cp		PowerPlant 2.1		й1996-1999 Metrowerks Inc.// ===========================================================================// MacTCP version of a UDP endpoint. An instance of this class will normally be// created for you by use of UNetworkFactory.#include <LMacTCPUDPEndpoint.h>#if PP_Target_Carbon		// MacTCP not supported. Remove this file from Carbon targets	#error "Carbon does not support MacTCP"#endif#include <LInternetMapper.h>#include <UNetworkFactory.h>#include <OpenTransport.h>	//included for mapping of error codesPP_Begin_Namespace_PowerPlantUDPNotifyUPP LMacTCPUDPEndpoint::sUDPNotifyUPP = NewUDPNotifyProc(Int_UDPNotifyProc);// ===========================================================================#pragma mark === LMacTCPUDPEndpoint ===// ---------------------------------------------------------------------------//		е LMacTCPUDPEndpoint()// ---------------------------------------------------------------------------//	ConstructorLMacTCPUDPEndpoint::LMacTCPUDPEndpoint(UInt32		inReceiveBufferSize){	mReceiveBufferSize = inReceiveBufferSize;	if (mReceiveBufferSize == 0)		mReceiveBufferSize = MacTCPUDP_RcvBuffer;	mReceiveBuffer = ::NewPtr((SInt32) mReceiveBufferSize);	ThrowIfMemFail_(mReceiveBuffer);	mUDPStream = nil;	mEndpointState = T_UNBND;	mAckSends = false;	mSharedPool = LSharedMemoryPool::GetSharedPool();	mSharedPool->AddPoolUser(this);	mSendQueue = nil;	mLocalAddress = nil;	mMessageQueue = nil;	try {		mLocalAddress = new LInternetAddress(0,0);		mMessageQueue = new LNetMessageQueue(*this);	} catch (...) {		delete mLocalAddress;		mLocalAddress = nil;		delete mMessageQueue;		mMessageQueue = nil;		throw;	}}// ---------------------------------------------------------------------------//		е ~LMacTCPUDPEndpoint()// ---------------------------------------------------------------------------//	DestructorLMacTCPUDPEndpoint::~LMacTCPUDPEndpoint(){	//Release the stream	UDPiopb releaseParam;	releaseParam.ioCompletion = nil;	releaseParam.ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();	releaseParam.udpStream = mUDPStream;	releaseParam.csCode = UDPRelease;	::PBControlSync((ParmBlkPtr)&releaseParam);	mUDPStream = nil;	delete mLocalAddress;	if (mReceiveBuffer) {		::DisposePtr(mReceiveBuffer);	}	if (mSendQueue) {		mSendQueue->KillQueue();		mSendQueue = nil;	}	//Need to delete mMessageQueue before removing memory pool!	delete mMessageQueue;	//Probably always want to RemovePoolUser last since other objects may	//	have dependance on the memory pool and the memory pool might	//	delete itself when we do this.	mSharedPool->RemovePoolUser(this);}// ===========================================================================#pragma mark -#pragma mark ее local address configurationvoidLMacTCPUDPEndpoint::Bind(					LInternetAddress&		inLocalAddress,					UInt32					/* inListenQueueSize */,					Boolean					/* inReusePort */){	//Get/Set the local IP address if necessary	if (mLocalAddress->GetIPAddress() == 0) {		LInternetAddress* tempAddress = GetLocalAddress();		delete tempAddress;	}	//Set the local port	mLocalAddress->SetHostPort(inLocalAddress.GetHostPort());	SUDPParamBlock callParam;	callParam.ioCompletion = nil;	callParam.ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();	callParam.udpStream = mUDPStream;	callParam.csCode = UDPCreate;	callParam.csParam.create.rcvBuff = mReceiveBuffer;	callParam.csParam.create.rcvBuffLen = (UInt32) ::GetPtrSize(mReceiveBuffer);	callParam.csParam.create.localPort = mLocalAddress->GetHostPort();	callParam.csParam.create.notifyProc = sUDPNotifyUPP;	callParam.csParam.create.userDataPtr = (char*)this;	ThrowIfError_(::PBControlSync((ParmBlkPtr)&callParam));	mUDPStream = callParam.udpStream;	//	With a port of 0, it should be the actual port binding.	mLocalAddress->SetHostPort(callParam.csParam.create.localPort);	mEndpointState = T_IDLE;}// ---------------------------------------------------------------------------//		е Unbind// ---------------------------------------------------------------------------voidLMacTCPUDPEndpoint::Unbind(){	if (mEndpointState != T_IDLE) {		Throw_(kOTOutStateErr);	}	StMacTCPUDPOperation operation(TCPRelease, mUDPStream);	SUDPParamBlock& operationPB = operation.GetParamBlock();	if (mUDPStream)		operation.Run();	mUDPStream = nil;	mLocalAddress->SetHostPort(0);	mEndpointState = T_UNBND;}// ---------------------------------------------------------------------------//		е GetLocalAddress// ---------------------------------------------------------------------------LInternetAddress*LMacTCPUDPEndpoint::GetLocalAddress(){	if (mLocalAddress->GetIPAddress() == 0) {		LInternetMapper * theMapper = UNetworkFactory::CreateInternetMapper();		LInternetAddress* tempAddress;		try {			tempAddress = theMapper->GetLocalAddress();			mLocalAddress->SetIPAddress(tempAddress->GetIPAddress());		} catch(...) {		}		delete theMapper;		delete tempAddress;	}	return new LInternetAddress(*mLocalAddress);}// ===========================================================================#pragma mark -#pragma mark ее datagram messagingvoidLMacTCPUDPEndpoint::SendPacketData(					LInternetAddress&		inRemoteHost,					void*					inData,					UInt32					inDataSize){	if (!mUDPStream)		Throw_(kOTOutStateErr);	if (IsAckingSends() || IsQueuingSends()) {		if (!mSendQueue) {			mSendQueue = new LMacTCPUDPSendQueue(this);			mSendQueue->Resume();		}		char * tempData = (char*)inData;		if (!IsAckingSends()) {			// If we are just queuing the data then			// make a copy that we will delete after it's sent			tempData = new char[inDataSize];			::BlockMoveData(inData, tempData, (SInt32) inDataSize);		}		LMacTCPUDPSendData * sendData = new LMacTCPUDPSendData(tempData, inDataSize, inRemoteHost);		ThrowIfNil_(sendData);		//Note: mSendQueue->Append() may block the thread if there is a		//		large amount of data already waiting. This is equivalent to the OT side		//		T_GODATA situation in LOpenTptUDPEndpoint::SendData()		mSendQueue->Append(sendData);	} else {		wdsEntry	WDS[2];		StMacTCPUDPOperation operation(UDPWrite, mUDPStream);		SUDPParamBlock& operationPB = operation.GetParamBlock();		operationPB.csParam.send.remoteHost = inRemoteHost.GetIPAddress();		operationPB.csParam.send.remotePort = inRemoteHost.GetHostPort();		operationPB.csParam.send.wdsPtr = (char*)WDS;		operationPB.csParam.send.reserved = 0;		WDS[0].length = (UInt16) inDataSize;		WDS[0].ptr = (char*)inData;		WDS[1].length = 0;		operation.Run();	}}boolLMacTCPUDPEndpoint::ReceiveFrom(					LInternetAddress&		outRemoteAddress,					void*					outDataBuffer,					UInt32&					ioDataSize,					UInt32					inTimeoutSeconds){	if (!mUDPStream)		Throw_(kOTOutStateErr);	if (inTimeoutSeconds == 0)		inTimeoutSeconds = Timeout_None;	StMacTCPUDPOperation operation(UDPRead, mUDPStream);	SUDPParamBlock& operationPB = operation.GetParamBlock();	operationPB.csParam.receive.timeOut = (UInt16) ((inTimeoutSeconds == Timeout_None) ? 0 : inTimeoutSeconds);	operationPB.csParam.receive.secondTimeStamp = 0;	operation.Run();	ioDataSize = operationPB.csParam.receive.rcvBuffLen;	if (ioDataSize > 0) {		::BlockMoveData(operationPB.csParam.receive.rcvBuff, outDataBuffer, (SInt32) ioDataSize);		outRemoteAddress.SetIPAddress(operationPB.csParam.receive.remoteHost);		outRemoteAddress.SetHostPort(operationPB.csParam.receive.remotePort);		//return the data block back to MacTCP		StMacTCPUDPOperation returnOperation(UDPBfrReturn, mUDPStream);		SUDPParamBlock& returnOperationPB = returnOperation.GetParamBlock();		returnOperationPB.csParam.receive.rcvBuff = operationPB.csParam.receive.rcvBuff;		returnOperation.Run();	} else {		outRemoteAddress.SetIPAddress(0);		outRemoteAddress.SetHostPort(0);	}	return false;}// ===========================================================================#pragma mark -#pragma mark ее acknowledgement of sent data// ---------------------------------------------------------------------------//		е AckSends// ---------------------------------------------------------------------------voidLMacTCPUDPEndpoint::AckSends(){	if (mSendQueue && mSendQueue->IsBusy())			Throw_(kOTOutStateErr);	mAckSends = true;}// ---------------------------------------------------------------------------//		е DontAckSends// ---------------------------------------------------------------------------voidLMacTCPUDPEndpoint::DontAckSends(){	if (mSendQueue && mSendQueue->IsBusy())			Throw_(kOTOutStateErr);	mAckSends = false;}// ---------------------------------------------------------------------------//		е IsAckingSends// ---------------------------------------------------------------------------BooleanLMacTCPUDPEndpoint::IsAckingSends(){	return mAckSends;}// ===========================================================================#pragma mark -#pragma mark ее implementation details// ---------------------------------------------------------------------------//		е AbortThreadOperation// ---------------------------------------------------------------------------voidLMacTCPUDPEndpoint::AbortThreadOperation(LThread * inThread){	StMacTCPUDPOperation * theOperation = (StMacTCPUDPOperation *)StAsyncOperation::GetThreadOperation(inThread);	if (theOperation) {		theOperation->mUDPParamBlock->mOperation = nil;		theOperation->AbortOperation();	}}// ---------------------------------------------------------------------------//		е Int_HandleAsyncEvent// ---------------------------------------------------------------------------//	Called by NotifyProc to handle notifications for this endpoint.//	You will be notified via a Broadcast at primary task time of the event if necessary.//	Warning: This routine will probably be called at interrupt time.voidLMacTCPUDPEndpoint::Int_HandleAsyncEvent(	UInt16		inEventCode,	ICMPReport*	inIcmpMsg,	StreamPtr	/* inStreamPtr */){	try {		switch (inEventCode) {			case UDPDataArrival:				mMessageQueue->Append(new(*mSharedPool) LDataArrived(T_DATA, noErr, nil, 0, nil, false, this));				break;			case UDPICMPReceived: {				//Map MacTCP error code to OT error code as best we can				SInt32 error;				switch(inIcmpMsg->reportType) {					netUnreach:						error = kENETUNREACHErr;						break;					hostUnreach:						error = kEHOSTUNREACHErr;						break;					protocolUnreach:						error = kEPROTOErr;						break;					portUnreach:						error = kEHOSTUNREACHErr;						break;					fragReqd:						error = fragReqd;						break;					sourceRouteFailed:						error = sourceRouteFailed;						break;					timeExceeded:						error = kETIMEErr;						break;					parmProblem:						error = parmProblem;						break;					missingOption:						error = missingOption;						break;					lastICMPMsgType:						error = lastICMPMsgType;						break;					default:						error = 0;						break;				}				mMessageQueue->Append(new(*mSharedPool) LICMPMessage(T_UDERR,															noErr,															error,															inIcmpMsg->remoteHost,															inIcmpMsg->remotePort,															this));				}				break;		}	} catch(...) {	}}// ---------------------------------------------------------------------------//		е Int_TCPNotifyProc	[static]// ---------------------------------------------------------------------------//	The MacTCP asynchronous notification routine (callback).//	Warning: Will probably be called at interrupt time#pragma profile offpascal voidLMacTCPUDPEndpoint::Int_UDPNotifyProc(	StreamPtr		inStreamPtr,	UInt16			inEventCode,	Ptr				inUserPtr,	ICMPReport*		inIcmpMsg){	LMacTCPUDPEndpoint* theUDPEndpoint = (LMacTCPUDPEndpoint*) inUserPtr;	StSetupGlobals globals(*theUDPEndpoint);	theUDPEndpoint->Int_HandleAsyncEvent(inEventCode, inIcmpMsg, inStreamPtr);}#pragma profile resetPP_End_Namespace_PowerPlant