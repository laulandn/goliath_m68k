/*  Metrowerks Standard Library  *//*  $Date: 2000/05/18 20:06:46 $  *  $Revision: 1.2.12.2 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//* *	FINDFILE.win32.c * */#include <cerrno>#include <io.h>#include <ctime>#include <cstring>#define WIN32_LEAN_AND_MEAN#include <windows.h>#if __cplusplusextern "C" {#endifextern int __leap_year(int year);extern const short __month_to_days[2][13];#if __cplusplus}#endifstatic time_t __cdecl __convert_win32time_2timet(FILETIME* wintime);long __cdecl _findfirst(        const char * szWild,        struct _finddata_t * pfd        ){    WIN32_FIND_DATA FileData;    HANDLE          hFile;    DWORD error;        if ((hFile = FindFirstFile(szWild, &FileData)) == INVALID_HANDLE_VALUE) {                switch (error=GetLastError()) {            case ERROR_PATH_NOT_FOUND:            case ERROR_FILE_NOT_FOUND:                errno = ENOENT;            default:                errno = EINVAL;                break;        }        return (-1);    }    pfd->attrib  = (FileData.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)                      ? 0 : FileData.dwFileAttributes;    pfd->time_create  = __convert_win32time_2timet(&FileData.ftCreationTime);    pfd->time_access  = __convert_win32time_2timet(&FileData.ftLastAccessTime);    pfd->time_write   = __convert_win32time_2timet(&FileData.ftLastWriteTime);    pfd->size         = FileData.nFileSizeLow;    strcpy(pfd->name, FileData.cFileName);    return ((long)hFile);}int __cdecl _findnext(long hFile, struct _finddata_t * pfd){    WIN32_FIND_DATA FileData;    DWORD error;    if (!FindNextFile((HANDLE)hFile, &FileData)) {               switch (error=GetLastError()) {                               case ERROR_PATH_NOT_FOUND:            case ERROR_FILE_NOT_FOUND:                errno = ENOENT;                break;            default:                errno = EINVAL;                break;        }        return (-1);    }    pfd->attrib       = (FileData.dwFileAttributes == FILE_ATTRIBUTE_NORMAL)                      ? 0 : FileData.dwFileAttributes;    pfd->time_create  = __convert_win32time_2timet(&FileData.ftCreationTime);    pfd->time_access  = __convert_win32time_2timet(&FileData.ftLastAccessTime);    pfd->time_write   = __convert_win32time_2timet(&FileData.ftLastWriteTime);    pfd->size         = FileData.nFileSizeLow;    strcpy(pfd->name, FileData.cFileName);    return (0);}int __cdecl _findclose(long hFile){    if (!FindClose((HANDLE)hFile)) {        errno = EINVAL;        return (-1);    }    return (0);}static time_t __cdecl __convert_win32time_2timet(FILETIME* wintime){    FILETIME loc_time;    SYSTEMTIME sys_time;    struct tm tmp;    if (!wintime->dwLowDateTime && !wintime->dwHighDateTime) return -1;        /*     * Convert to a broken down local time value     */    if ( !FileTimeToLocalFileTime(wintime, &loc_time) ||         !FileTimeToSystemTime(&loc_time, &sys_time) )    {        return -1;    }			     tmp.tm_sec=sys_time.wSecond;	             tmp.tm_min=sys_time.wMinute;       	             tmp.tm_hour=sys_time.wHour;      /* hours since midnight */	             tmp.tm_mday=sys_time.wDay;       /* day of month */	             tmp.tm_mon=sys_time.wMonth-1;    /* since January(0 for Jan.) */	             tmp.tm_year=sys_time.wYear-1900; /* since 1900 */	             tmp.tm_wday=sys_time.wDayOfWeek; /* since Sunday(0-6)*/	            	            if(!__leap_year(tmp.tm_year))  	              {tmp.tm_yday=__month_to_days[1][tmp.tm_mon]; }	            else	              {tmp.tm_yday=__month_to_days[2][tmp.tm_mon]; }	                                            /* days since jan. 1 */	            tmp.tm_isdst=-1;	                return  mktime(&tmp);}/*     Change Record cc  000209 changed windef.h to #define WIN32_LEAN_AND_MEAN & #include <windows.h> cc  000518 fixed #include  */