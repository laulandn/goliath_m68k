/* ================================================================================================== * AppLauncher.cpp															    *    Goliath - a Finder like application that implements WebDAV *    Copyright (C) 1999-2002  Thomas Bednarz * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com * =========================================================================== */ #ifndef __AppLauncher_h__#include "AppLauncher.h"#endifOSErr FindAProcess(OSType typeToFind, OSType creatorToFind, ProcessSerialNumberPtr processSN);#if PP_Target_Carbon#include <LaunchServices.h>#include <vector>// ---------------------------------------------------------------------------//		¥ OpenFilesForEdit// ---------------------------------------------------------------------------//OSStatus AppLauncher::OpenFilesForEdit(const std::list<FSSpec>& inDocuments, OSType appType) {	FSRef appRef;	LSLaunchFSRefSpec launchSpec;	OSStatus stat;	stat = LSFindApplicationForInfo(appType, NULL, NULL, &appRef, NULL);	if (noErr != stat)		return stat;	std::vector<FSRef> docRefs(inDocuments.size());	launchSpec.appRef = &appRef;	launchSpec.numDocs = inDocuments.size();		int i=0;	for (std::list<FSSpec>::const_iterator iter = inDocuments.begin(); iter != inDocuments.end(); iter++) {		stat = ::FSpMakeFSRef(&(*iter), &docRefs[i]);		if (noErr != stat)			return stat;   		i++;	}	launchSpec.itemRefs = &docRefs[0];	launchSpec.passThruParams = NULL;	launchSpec.asyncRefCon = NULL;		stat = LSOpenFromRefSpec(&launchSpec, NULL);	return stat;}#else// ---------------------------------------------------------------------------//		¥ OpenFilesForEdit// ---------------------------------------------------------------------------//OSStatus AppLauncher::OpenFilesForEdit(const std::list<FSSpec>& inDocuments, OSType appType) {   bool use_remote_apps = true;      OSStatus err;   AEAddressDesc target_desc; // address desc for target application   AEDescList files_list;   AEDesc file_desc, parameter_desc;   AppleEvent the_apple_event;   AppleEvent the_reply;   AliasHandle the_alias;   OSType app_creator_bytes;   LaunchParamBlockRec launch_pb;   /* initialize our records to NULL descriptors */   AECreateDesc(typeNull, NULL, 0, &target_desc);   AECreateDesc(typeNull, NULL, 0, &files_list);   AECreateDesc(typeNull, NULL, 0, &file_desc);   AECreateDesc(typeNull, NULL, 0, &the_apple_event);   AECreateDesc(typeNull, NULL, 0, &the_reply);   AECreateDesc(typeNull, NULL, 0, &parameter_desc);   the_alias = NULL;   app_creator_bytes = appType;   /* create an open documents Apple event */   err = AECreateDesc(typeApplSignature, (Ptr)&app_creator_bytes,                      sizeof(OSType), &target_desc);   if (err != noErr) goto launch_the_document_termination;   err = AECreateAppleEvent(kCoreEventClass, kAEOpenDocuments,                            &target_desc, kAutoGenerateReturnID, kAnyTransactionID,                            &the_apple_event);   if (err != noErr) goto launch_the_document_termination;   /* create a element list the size of the list of files to send in the event */   err = AECreateList(NULL, 0, false, &files_list);   if (err != noErr) goto launch_the_document_termination;   int i=0;   for (std::list<FSSpec>::const_iterator iter = inDocuments.begin(); iter != inDocuments.end(); ++iter) {      err = NewAlias(NULL, &(*iter), &the_alias);      if (err != noErr) goto launch_the_document_termination;      HLock((Handle) the_alias);      err = AECreateDesc(typeAlias, (Ptr) (*the_alias),      GetHandleSize((Handle) the_alias), &file_desc);      HUnlock((Handle) the_alias);      if (err != noErr) goto launch_the_document_termination;      err = AEPutDesc(&files_list, i, &file_desc);      if (err != noErr) goto launch_the_document_termination;       i++;   }      /* add the file list to the open documents event */   err = AEPutParamDesc(&the_apple_event, keyDirectObject, &files_list);   if (err != noErr) goto launch_the_document_termination;   /* send the Apple event */   err = AESend(&the_apple_event, &the_reply, kAENoReply,                kAENormalPriority, kNoTimeOut, NULL, NULL);   /* if the target could not be found */   if (err == connectionInvalid) { /* no such app running? */      HVolumeParam vol_pb;      DTPBRec desktop_pb;      FSSpec application;      GetVolParmsInfoBuffer volinfo;      HIOParam param_pb;            /* search desktop files on local volumes first */      param_pb.ioNamePtr = NULL;      param_pb.ioBuffer = (Ptr) &volinfo;      param_pb.ioReqCount = sizeof(volinfo);      err = fnfErr; /* default return value */      vol_pb.ioNamePtr = NULL;      for (vol_pb.ioVolIndex = 1;PBHGetVInfoSync((HParmBlkPtr) &vol_pb) == noErr;                                                            vol_pb.ioVolIndex++) {         param_pb.ioVRefNum = vol_pb.ioVRefNum;         if (PBHGetVolParmsSync((HParmBlkPtr)&param_pb) == noErr && volinfo.vMServerAdr == 0) {            desktop_pb.ioCompletion = NULL;            desktop_pb.ioVRefNum = vol_pb.ioVRefNum;            desktop_pb.ioNamePtr = NULL;            desktop_pb.ioIndex = 0;            if (PBDTGetPath(&desktop_pb) == noErr) {                  desktop_pb.ioFileCreator = app_creator_bytes;                  desktop_pb.ioNamePtr = application.name;               if (PBDTGetAPPLSync(&desktop_pb) == noErr) {                  application.vRefNum = vol_pb.ioVRefNum;                  application.parID = desktop_pb.ioAPPLParID;                  err = noErr;                  break;               }            }         }      }      /* if this fails, search remove volumes if allowed... */      if (err != noErr && use_remote_apps)         for (vol_pb.ioVolIndex = 1; PBHGetVInfoSync((HParmBlkPtr) &vol_pb) == noErr;                             vol_pb.ioVolIndex++) {            param_pb.ioVRefNum = vol_pb.ioVRefNum;            if (PBHGetVolParmsSync((HParmBlkPtr) &param_pb) ==  noErr                                           && volinfo.vMServerAdr != 0) {               desktop_pb.ioCompletion = NULL;               desktop_pb.ioVRefNum = vol_pb.ioVRefNum;               desktop_pb.ioNamePtr = NULL;               desktop_pb.ioIndex = 0;               if (PBDTGetPath(&desktop_pb) == noErr) {                  desktop_pb.ioFileCreator = app_creator_bytes;                  desktop_pb.ioNamePtr = application.name;                  if (PBDTGetAPPLSync(&desktop_pb) == noErr) {                     application.vRefNum = vol_pb.ioVRefNum;                     application.parID = desktop_pb.ioAPPLParID;                     err = noErr;                     break;                  }               }            }      }      if (err != noErr) goto launch_the_document_termination;      /* coerce the apple event to app parameters */      err = AECoerceDesc(&the_apple_event, typeAppParameters, &parameter_desc);      if (err != noErr) goto launch_the_document_termination;      /* launch the application */      launch_pb.launchBlockID = extendedBlock;      launch_pb.launchEPBLength = extendedBlockLen;      launch_pb.launchFileFlags = 0;      launch_pb.launchControlFlags =      launchContinue + launchNoFileFlags;      launch_pb.launchAppSpec = &application;      HLock((Handle) parameter_desc.dataHandle);      launch_pb.launchAppParameters =      (AppParametersPtr) (*parameter_desc.dataHandle);      err = LaunchApplication(&launch_pb);      HUnlock((Handle) parameter_desc.dataHandle);   }   launch_the_document_termination:      /* clean up, and go.. */   if (the_alias != NULL)       DisposeHandle((Handle) the_alias);   AEDisposeDesc(&parameter_desc);   AEDisposeDesc(&target_desc);   AEDisposeDesc(&file_desc);   AEDisposeDesc(&files_list);   AEDisposeDesc(&the_apple_event);   AEDisposeDesc(&the_reply);   return err;}#endifOSErr FindAProcess(OSType typeToFind, OSType creatorToFind, ProcessSerialNumberPtr processSN) {	ProcessInfoRec tempInfo;	FSSpec procSpec;	Str31 processName;	OSErr myErr = noErr;	processSN->lowLongOfPSN = kNoProcess;	processSN->highLongOfPSN = kNoProcess;	tempInfo.processInfoLength = sizeof(ProcessInfoRec);	tempInfo.processName = processName;	tempInfo.processAppSpec = &procSpec;	do {		myErr = GetNextProcess(processSN);		if (myErr == noErr)			GetProcessInformation(processSN, &tempInfo);    } while ((tempInfo.processSignature != creatorToFind || tempInfo.processType != typeToFind) || myErr != noErr);        return(myErr);}// ---------------------------------------------------------------------------//		¥ RevealFileInFinder// ---------------------------------------------------------------------------//void AppLauncher::RevealFileInFinder(const FSSpec* inEditSpec) {	OSErr                err=0,  err2 = 0;	ProcessSerialNumber  psn;	OSType               fndr_creator = 'MACS';	AppleEvent           ae;	AEDesc               ae_addr_desc;	AEDesc               ae_file_desc;	FSSpec               file_spec;	AliasHandle          file_aliasH = NULL;	unsigned char        nameACu[32 + 1];	nameACu[0] = '\0';           	FindAProcess('FNDR', 'MACS', &psn);	AECreateDesc(typeApplSignature, &fndr_creator, sizeof(fndr_creator), &ae_addr_desc);            	AECreateAppleEvent(kAEMiscStandards, kAEMakeObjectsVisible,						&ae_addr_desc, kAutoGenerateReturnID,						kAnyTransactionID, &ae);                   	FSMakeFSSpec(inEditSpec->vRefNum, inEditSpec->parID, inEditSpec->name, &file_spec);            	NewAlias(NULL, &file_spec, &file_aliasH);                        	if (!err) {		HLock((Handle)file_aliasH);		err = AECreateDesc(typeAlias, *file_aliasH, GetHandleSize((Handle)file_aliasH), &ae_file_desc);                HUnlock((Handle)file_aliasH);	}	AEPutParamDesc(&ae, keyDirectObject, &ae_file_desc);	AESend(&ae, NULL, kAENoReply + kAECanSwitchLayer,				kAENormalPriority, kAEDefaultTimeout, NULL, NULL);            	SetFrontProcess(&psn);	if (file_aliasH) 		DisposeHandle((Handle)file_aliasH);            	if (ae_addr_desc.dataHandle) 		AEDisposeDesc(&ae_addr_desc);	if (ae_file_desc.dataHandle) 		AEDisposeDesc(&ae_file_desc);	if (ae.dataHandle) 		AEDisposeDesc(&ae);		}bool GetCreatorForSpec_Classic(const FSSpec& inSpec, OSType& outCreator);#if PP_Target_Carbonbool GetCreatorForSpec_X(const FSSpec& inSpec, OSType& outCreator);bool GetCreatorForSpec_X(const FSSpec& inSpec, OSType& outCreator) {	FSRef fsref;	OSStatus stat = ::FSpMakeFSRef(&inSpec, &fsref);	if (noErr != stat)		return false;		LSItemInfoRecord itemInfo;		stat = ::LSCopyItemInfoForRef(&fsref, kLSRequestTypeCreator, &itemInfo);	if (noErr != stat)		return false;	outCreator = itemInfo.creator;	return true;}#endifbool GetCreatorForSpec_Classic(const FSSpec& inSpec, OSType& outCreator) {	UInt32 retval = 0;	CInfoPBRec cpb;	FSSpec theSpec(inSpec);	cpb.hFileInfo.ioNamePtr = theSpec.name;	cpb.hFileInfo.ioVRefNum = theSpec.vRefNum;	cpb.hFileInfo.ioFDirIndex = 0;	cpb.hFileInfo.ioDirID = theSpec.parID;	Str63 theItemName;	PBGetCatInfoSync((CInfoPBPtr) &cpb);	if (cpb.hFileInfo.ioFlAttrib & ioDirMask)/* see if we got a directory */ {		if (!(cpb.dirInfo.ioDrUsrWds.frFlags & kHasBundle))			return false;				// look inside the directory for another alias to an application		// it should be at the root level of this directory		short 	searchIndex = 1;		long	dirToSearch = cpb.dirInfo.ioDrDirID;		short	volToSearch = cpb.dirInfo.ioVRefNum;		OSErr	searchError = noErr;		bool	searchContinues = true;		CInfoPBRec thePB;		FSSpec ioSpec;		bool found = false;		while(searchContinues && noErr == searchError) {			thePB.dirInfo.ioFDirIndex = searchIndex;			thePB.hFileInfo.ioNamePtr = (StringPtr)&theItemName;			thePB.dirInfo.ioVRefNum = volToSearch;			thePB.dirInfo.ioDrDirID = dirToSearch;						searchError = PBGetCatInfoSync(&thePB);			if( 0 == (thePB.hFileInfo.ioFlAttrib & ioDirMask) )			{				if(thePB.hFileInfo.ioFlFndrInfo.fdType == kApplicationAliasType || thePB.hFileInfo.ioFlFndrInfo.fdType == 'APPL')				{					searchContinues = false;					LString::CopyPStr(thePB.hFileInfo.ioNamePtr, ioSpec.name, sizeof(ioSpec.name));					ioSpec.vRefNum = thePB.hFileInfo.ioVRefNum;					ioSpec.parID = thePB.hFileInfo.ioFlParID;					Boolean	isFolder, wasAliased;					ResolveAliasFile(&ioSpec, true, &isFolder, &wasAliased);					found = true;				}			}			++searchIndex;		}		if (!found)			return false;		FInfo fndrInfo;		OSErr err = FSpGetFInfo(&ioSpec, &fndrInfo);		if (err != noErr)			return false;		outCreator = fndrInfo.fdCreator;		return true;			} else {		FInfo fndrInfo;		OSErr err = FSpGetFInfo(&theSpec, &fndrInfo);		if (err != noErr)			return false;		outCreator = fndrInfo.fdCreator;		return true;	}	}bool AppLauncher::GetCreatorForSpec(const FSSpec& inSpec, OSType& outCreator) {#if PP_Target_Carbon	long gestaltResponse;	if (noErr == Gestalt(gestaltMenuMgrAttr,&gestaltResponse)		 &&(gestaltResponse &gestaltMenuMgrAquaLayoutMask)) {		return GetCreatorForSpec_X(inSpec, outCreator);	} else #endif		return GetCreatorForSpec_Classic(inSpec, outCreator);}