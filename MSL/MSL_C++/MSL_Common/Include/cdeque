/*  Metrowerks Standard Library  *//*  $Date: 2000/06/09 19:23:50 $  *  $Revision: 1.7.4.4 $  *  $NoKeywords: $  * *		Portions Copyright © 1998-1999 Metrowerks, Inc. *		All rights reserved. *//** **  cdeque **/// WARNING//// cdeque is a non-standard, non-portable header and container.//// WARNING//// It's purpose here is to aid in the implementation of deque.// cdeque is very similar to deque except that it has capacity// and reserve methods like vector.  It guarantees amoritized// constant time push_front and push_back, but it may invalidate// references (when capacity is increased) during these operations.//// cdeque is short for "circular deque".  It is implemented with// a contiguous chunk of memory like vector.  vector elements always// start at the low memory address, and there is an uninitialized chunk// of reserve memory at the high end to grow into.  In contrast, cdeque// maps the memory into a circular path.  The first element can start// anywhere on the circle, and the reserve memory extends from beyond// the last element up to the first element.  That is:// In use     : [first, last)// In reserve : [last, first)//#ifndef _CDEQUE#define _CDEQUE#include <mslconfig>#include <climits>#include <algorithm>#include <iterator>#include <limits>#include <memory>#include <new>#include <stdexcept>#include <string>#ifndef RC_INVOKED#pragma options align=native#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#if _MSL_FORCE_ENUMS_ALWAYS_INT		#pragma enumsalwaysint on	#else		#pragma enumsalwaysint off	#endif#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT		#pragma bool on	#else		#pragma bool off	#endif#endif#ifndef _MSL_NO_CPP_NAMESPACE	namespace Metrowerks {#else	#ifndef Metrowerks		#define Metrowerks	#endif#endiftemplate <class T, class Allocator = _STD::allocator<T> >class cdeque{	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <bool b> struct chooser {};	#endifpublic:	// types:	typedef typename Allocator::reference         reference;	typedef typename Allocator::const_reference   const_reference;	class                                         iterator;	class                                         const_iterator;	typedef typename Allocator::size_type         size_type;	typedef typename Allocator::difference_type   difference_type;	typedef T                                     value_type;	typedef Allocator                             allocator_type;	typedef typename Allocator::pointer           pointer;	typedef typename Allocator::const_pointer     const_pointer;	typedef _STD::reverse_iterator<iterator>       reverse_iterator;	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;	friend class iterator;	class iterator		: public _STD::iterator<_STD::random_access_iterator_tag, value_type,			difference_type, pointer, reference>	{	public:		iterator() {}		reference operator * () const {return *ptr_;}		pointer operator -> () const {return ptr_;}		iterator& operator ++ ()		{			++pos_;			if (++ptr_ == cdeq_->data_ + cdeq_->alloc_.m_)				ptr_ = cdeq_->data_;			return *this;		}		iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}		iterator& operator -- ()		{			--pos_;			if (ptr_ == cdeq_->data_)				ptr_ = cdeq_->data_ + cdeq_->alloc_.m_;			--ptr_;			return *this;		}		iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}		iterator& operator += (difference_type n)		{			if (n < 0)				return (*this) -= -n;			size_type sz = cdeq_->alloc_.m_;			size_type off = cdeq_->start_ + pos_ + static_cast<size_type>(n);			if (off < sz)				ptr_ += n;			else				ptr_ = cdeq_->data_ + (off - sz);			pos_ += static_cast<size_type>(n);			return *this;		}		iterator operator + (difference_type n) const {return iterator(*this) += n;}		iterator& operator -= (difference_type n)		{			if (n < 0)				return (*this) += -n;			if (n <= cdeq_->start_ + pos_)				ptr_ -= n;			else				ptr_ = cdeq_->data_ + (cdeq_->alloc_.m_ - n);			pos_ -= static_cast<size_type>(n);			return *this;		}		iterator operator - (difference_type n) const {return iterator(*this) -= n;}		difference_type operator - (const iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}		reference operator [] (difference_type i) const {iterator tmp(*this); tmp += i; return *tmp;}		friend bool operator ==(const iterator& x, const iterator& y) {return x.pos_ == y.pos_;}  // hh 990720		friend bool operator !=(const iterator& x, const iterator& y) {return x.pos_ != y.pos_;}		friend bool operator < (const iterator& x, const iterator& y) {return x.pos_ <  y.pos_;}		friend bool operator <=(const iterator& x, const iterator& y) {return x.pos_ <= y.pos_;}		friend bool operator > (const iterator& x, const iterator& y) {return x.pos_ >  y.pos_;}		friend bool operator >=(const iterator& x, const iterator& y) {return x.pos_ >= y.pos_;}		friend iterator operator + (difference_type n, const iterator& rhs)			{return iterator(rhs) += n;}	private:		cdeque* cdeq_;		size_type pos_;		pointer ptr_;		iterator(cdeque* cdeq, size_type pos, pointer ptr)			: cdeq_(cdeq),			  pos_(pos),			  ptr_(ptr)		{}		friend class cdeque;		friend class cdeque::const_iterator;	};	friend class const_iterator;	class const_iterator		: public _STD::iterator<_STD::random_access_iterator_tag, value_type,			difference_type, const_pointer, const_reference>	{	public:		const_iterator() {}		const_iterator(const cdeque::iterator& rhs) : cdeq_(rhs.cdeq_), pos_(rhs.pos_), ptr_(rhs.ptr_) {}		const_reference operator * () const {return *ptr_;}		const_pointer operator -> () const {return ptr_;}		const_iterator& operator ++ ()		{			++pos_;			if (++ptr_ == cdeq_->data_ + cdeq_->alloc_.m_)				ptr_ = cdeq_->data_;			return *this;		}		const_iterator operator ++ (int) {const_iterator tmp(*this); ++(*this); return tmp;}		const_iterator& operator -- ()		{			--pos_;			if (ptr_ == cdeq_->data_)				ptr_ = cdeq_->data_ + cdeq_->alloc_.m_;			--ptr_;			return *this;		}		const_iterator operator -- (int) {const_iterator tmp(*this); --(*this); return tmp;}		const_iterator& operator += (difference_type n)		{			if (n < 0)				return (*this) -= -n;			size_type sz = cdeq_->alloc_.m_;			size_type off = cdeq_->start_ + pos_ + static_cast<size_type>(n);			if (off < sz)				ptr_ += n;			else				ptr_ = cdeq_->data_ + (off - sz);			pos_ += static_cast<size_type>(n);			return *this;		}		const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}		const_iterator& operator -= (difference_type n)		{			if (n < 0)				return (*this) += -n;			if (n <= cdeq_->start_ + pos_)				ptr_ -= n;			else				ptr_ = cdeq_->data_ + (cdeq_->alloc_.m_ - n);			pos_ -= static_cast<size_type>(n);			return *this;		}		const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}		difference_type operator - (const const_iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}		const_reference operator [] (difference_type i) const {const_iterator tmp(*this); tmp += i; return *tmp;}		friend bool operator ==(const const_iterator& x, const const_iterator& y) {return x.pos_ == y.pos_;}  // hh 990720		friend bool operator !=(const const_iterator& x, const const_iterator& y) {return x.pos_ != y.pos_;}		friend bool operator < (const const_iterator& x, const const_iterator& y) {return x.pos_ <  y.pos_;}		friend bool operator <=(const const_iterator& x, const const_iterator& y) {return x.pos_ <= y.pos_;}		friend bool operator > (const const_iterator& x, const const_iterator& y) {return x.pos_ >  y.pos_;}		friend bool operator >=(const const_iterator& x, const const_iterator& y) {return x.pos_ >= y.pos_;}		friend const_iterator operator + (difference_type n, const const_iterator& rhs)			{return const_iterator(rhs) += n;}	private:		const cdeque* cdeq_;		size_type pos_;		const_pointer ptr_;		const_iterator(const cdeque* cdeq, size_type pos, const_pointer ptr)			: cdeq_(cdeq),			  pos_(pos),			  ptr_(ptr)		{}		friend class cdeque;	};	// cdeque.cons_ construct/copy/destroy:	explicit cdeque(const Allocator& = Allocator());	explicit cdeque(size_type n);  // hh 990826	explicit cdeque(size_type n, const T& value, const Allocator& = Allocator());#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			cdeque(InputIterator first, InputIterator last, const Allocator& a = Allocator());	#else		template <class InputIterator>			inline			cdeque(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: alloc_(a),				  size_(0),				  start_(0),				  data_(0)			{				choose_init(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif#else	cdeque(const_iterator first, const_iterator last, const Allocator& = Allocator());#endif	cdeque(const cdeque<T,Allocator>& x);	~cdeque();	cdeque<T,Allocator>& operator=(const cdeque<T,Allocator>& x);#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator> void assign(InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void			assign(InputIterator first, InputIterator last)			{				choose_assign(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif#else	void assign(const_iterator first, const_iterator last);#endif	void assign(size_type n, const T& u);	allocator_type get_allocator() const;	// iterators:	iterator               begin();	const_iterator         begin() const;	iterator               end();	const_iterator         end() const;	reverse_iterator       rbegin();	const_reverse_iterator rbegin() const;	reverse_iterator       rend();	const_reverse_iterator rend() const;	// cdeque.capacity_ capacity:	size_type size() const;	size_type max_size() const;	void      resize(size_type sz);  // hh 990826	void      resize(size_type sz, const T& value);	size_type capacity() const;	bool      empty() const;	void      reserve(size_type n);	// element access:	reference       operator[](size_type n);	const_reference operator[](size_type n) const;	const_reference at(size_type n) const;	reference       at(size_type n);	reference       front();	const_reference front() const;	reference       back();	const_reference back() const;	// cdeque.modifiers_ modifiers:	void push_front(const T& x);	void push_back(const T& x);	void pop_front();	void pop_back();	iterator insert(iterator position, const T& x);	void     insert(iterator position, size_type n, const T& x);#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void insert(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>		inline		void		insert(iterator position, InputIterator first, InputIterator last)		{			choose_insert(position, first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());		}	#endif#else	void insert(iterator position, const_iterator first, const_iterator last);#endif	iterator erase(iterator position);	iterator erase(iterator first, iterator last);	void     swap(cdeque<T,Allocator>&);	void     clear();private:	_STD::_EmptyMemberOpt<Allocator, size_type> alloc_;  // m_ is capacity	size_type size_;	size_type start_;	pointer data_;#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void choose_init(InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_init(InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void init(InputIterator first, InputIterator last, _STD::input_iterator_tag);		template <class ForwardIterator>			void init(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag);		template <class InputIterator>			void choose_assign(InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_assign(InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag);		template <class ForwardIterator>			void do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag);		template <class InputIterator>			void choose_insert(iterator position, InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_insert(iterator position, InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void do_insert(iterator position, InputIterator first, InputIterator last, _STD::input_iterator_tag);		template <class ForwardIterator>			void do_insert(iterator position, ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag);	#else		template <class InputIterator>			inline			void			choose_init(InputIterator first, InputIterator last, chooser<true>)			{				init(static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_init(InputIterator first, InputIterator last, chooser<false>)			{				init(first, last, _STD::iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			init(InputIterator first, InputIterator last, _STD::input_iterator_tag)			{				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					for (; first != last; ++first)						push_back(*first);				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					tear_down();					throw;				}				#endif			}		template <class ForwardIterator>			void			init(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)			{				size_ = alloc_.m_ = (size_type)_STD::distance(first, last);				if (size_ > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("cdeque::construction length error");					#else						_STD::__msl_error("cdeque::construction length error\n");					#endif				if (alloc_.m_ > 0)				{					data_ = alloc_.allocate(alloc_.m_);					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						_STD::uninitialized_copy(first, last, data_);					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						alloc_.deallocate(data_, alloc_.m_);						throw;					}					#endif				}			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<true>)			{				assign(static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<false>)			{				do_assign(first, last, _STD::iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag)			{				cdeque temp(first, last, get_allocator());				const cdeque& tempr = temp;				do_assign(tempr.begin(), tempr.end(), _STD::random_access_iterator_tag());			}		template <class ForwardIterator>			void			do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)			{				size_type n = (size_type)_STD::distance(first, last);				if (n > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("cdeque::assign length error");					#else						_STD::__msl_error("cdeque::assign length error\n");					#endif				if (n <= capacity())				{					difference_type n1 = (difference_type)_STD::min(n, size_);					iterator i = begin();					iterator e = i + n1;					for (; i < e; ++i, ++first)						*i = *first;					if (n < size_)						destroy(i, end());					else if (size_ < n)						_STD::uninitialized_copy(first, last, i);					size_ = n;				}				else				{					pointer newdata = alloc_.allocate(n);					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						_STD::uninitialized_copy(first, last, newdata);						tear_down();						data_ = newdata;						size_ = alloc_.m_ = n;						start_ = 0;					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						alloc_.deallocate(newdata, n);						throw;					}					#endif				}			}		template <class InputIterator>			inline			void			choose_insert(iterator position, InputIterator first, InputIterator last, chooser<true>)			{				insert(position, static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_insert(iterator position, InputIterator first, InputIterator last, chooser<false>)			{				do_insert(position, first, last, _STD::iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_insert(iterator position, InputIterator first, InputIterator last, _STD::input_iterator_tag)			{				cdeque temp(first, last, get_allocator());				const cdeque& tempr = temp;				do_insert(position, tempr.begin(), tempr.end(), _STD::random_access_iterator_tag());			}		template <class ForwardIterator>			void			do_insert(iterator position, ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)			{				size_type n = (size_type)_STD::distance(first, last);				if (n == 0)					return;				size_type ms = max_size();				if (n > ms || size_ > ms - n)					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("cdeque::insert length error");					#else						_STD::__msl_error("cdeque::insert length error\n");					#endif				if (size_ + n <= capacity())				{					size_type pb = size_type(position - begin());					size_type pe = size_type(end() - position);					if (pb < pe)					{						size_type oldstart = start_;						if (start_ >= n)							start_ -= n;						else							start_ = alloc_.m_ - (n - start_);						size_type done = 0;						iterator beg = begin();						#ifndef _MSL_NO_EXCEPTIONS						try						{						#endif							if (pb == 0) // insert at begin()								_STD::uninitialized_copy(first, last, beg);							else // pos in [1, size_ / 2)							{								iterator b_n = beg + difference_type(n);								iterator b_n_pb = b_n + difference_type(pb);								iterator b_pb = pb == n ? b_n : beg + difference_type(pb);								iterator t;								if (pb > n)									t = beg + difference_type(2*n);								else									t = b_n_pb;								_STD::uninitialized_copy(b_n, t, beg);								ForwardIterator i = first;								if (pb > n)								{									done = n;									_STD::copy(t, b_n_pb, b_n);									t = b_pb;								}								else if (pb < n)								{									done = pb;									_STD::advance(i, difference_type(n - pb));									_STD::uninitialized_copy(first, i, b_pb);									done = n;									t = b_n;								}								else								{									done = n;									t = b_n;								}								_STD::copy(i, last, t);							}							size_ += n;						#ifndef _MSL_NO_EXCEPTIONS						}						catch (...)						{							destroy(beg, beg + difference_type(done));							start_ = oldstart;							throw;						}						#endif					}					else // pos >= size_ / 2					{						if (pe == 0) // insert at end()							_STD::uninitialized_copy(first, last, end());						else // pos in [size_ / 2, size_)						{							iterator ei = end();							iterator e_n = ei - difference_type(n);							iterator e_pe = pe == n ? e_n : ei - difference_type(pe);							iterator t1, t2;							if (pe >= n)							{								t1 = e_n;								t2 = ei;							}							else							{								t1 = e_pe;								t2 = ei + difference_type(n - pe);							}							_STD::uninitialized_copy(t1, ei, t2);							#ifndef _MSL_NO_EXCEPTIONS							try							{							#endif								if (pe >= n)								{									if (pe > n)										_STD::copy_backward(e_pe, e_n, ei);									_STD::copy(first, last, e_pe);								}								else if (n > pe)								{									ForwardIterator i = first;									_STD::advance(i, difference_type(pe));									_STD::copy(first, i, e_pe);									_STD::uninitialized_copy(i, last, ei);								}							#ifndef _MSL_NO_EXCEPTIONS							}							catch (...)							{								destroy(t2, ei + difference_type(n));								throw;							}							#endif						}						size_ += n;					}				}				else // size_ + n > capacity()				{					size_type newsize = size_ + n;					size_type newcap = _STD::max(alloc_.m_, size_type(1));					while (newsize > newcap)						newcap *= 2;					size_type pos = size_type(position - begin());					pointer newdata = alloc_.allocate(newcap);					size_type done = 0;					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						if (pos > 0)						{							_STD::uninitialized_copy(begin(), position, newdata);							done = pos;						}						_STD::uninitialized_copy(first, last, newdata + pos);						done += n;						if (pos < size_)							_STD::uninitialized_copy(position, end(), newdata + pos + n);						tear_down();						data_ = newdata;						size_ = newsize;						alloc_.m_ = newcap;						start_ = 0;					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						_STD::__destroy(newdata, newdata + done);						alloc_.deallocate(newdata, newcap);						throw;					}					#endif				}			}	#endif#endif	void init(size_type n, const T& value);	void tear_down();	void destroy(iterator first, iterator last);};template <class T, class Allocator>booloperator==(const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y);template <class T, class Allocator>booloperator!=(const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y);template <class T, class Allocator>booloperator< (const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y);template <class T, class Allocator>booloperator> (const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y);template <class T, class Allocator>booloperator>=(const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y);template <class T, class Allocator>booloperator<=(const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y);// specialized algorithms:template <class T, class Allocator>voidswap(cdeque<T,Allocator>& x, cdeque<T,Allocator>& y);// Implementation cdeque#ifndef _MSL_NO_MEMBER_TEMPLATE#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class InputIterator>	inline	void	cdeque<T, Allocator>::choose_init(InputIterator first, InputIterator last, chooser<true>)	{		init(static_cast<size_type>(first), static_cast<value_type>(last));	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	cdeque<T, Allocator>::choose_init(InputIterator first, InputIterator last, chooser<false>)	{		init(first, last, _STD::iterator_traits<InputIterator>::iterator_category());	}	template <class T, class Allocator>	template <class InputIterator>	void	cdeque<T, Allocator>::init(InputIterator first, InputIterator last, _STD::input_iterator_tag)	{		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			for (; first != last; ++first)				push_back(*first);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			tear_down();			throw;		}		#endif	}	template <class T, class Allocator>	template <class ForwardIterator>	void	cdeque<T, Allocator>::init(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)	{		size_ = alloc_.m_ = (size_type)_STD::distance(first, last);		if (size_ > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::construction length error");			#else				_STD::__msl_error("cdeque::construction length error\n");			#endif		if (alloc_.m_ > 0)		{			data_ = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				_STD::uninitialized_copy(first, last, data_);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(data_, alloc_.m_);				throw;			}			#endif		}	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	cdeque<T, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<true>)	{		assign(static_cast<size_type>(first), static_cast<value_type>(last));	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	cdeque<T, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<false>)	{		do_assign(first, last, _STD::iterator_traits<InputIterator>::iterator_category());	}	template <class T, class Allocator>	template <class InputIterator>	void	cdeque<T, Allocator>::do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag)	{		cdeque temp(first, last, get_allocator());		const cdeque& tempr = temp;		do_assign(tempr.begin(), tempr.end(), _STD::random_access_iterator_tag());	}	template <class T, class Allocator>	template <class ForwardIterator>	void	cdeque<T, Allocator>::do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)	{		size_type n = (size_type)_STD::distance(first, last);		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::assign length error");			#else				_STD::__msl_error("cdeque::assign length error\n");			#endif		if (n <= capacity())		{			difference_type n1 = (difference_type)_STD::min(n, size_);			iterator i = begin();			iterator e = i + n1;			for (; i < e; ++i, ++first)				*i = *first;			if (n < size_)				destroy(i, end());			else if (size_ < n)				_STD::uninitialized_copy(first, last, i);			size_ = n;		}		else		{			pointer newdata = alloc_.allocate(n);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				_STD::uninitialized_copy(first, last, newdata);				tear_down();				data_ = newdata;				size_ = alloc_.m_ = n;				start_ = 0;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(newdata, n);				throw;			}			#endif		}	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	cdeque<T, Allocator>::choose_insert(iterator position, InputIterator first, InputIterator last,		chooser<true>)	{		insert(position, static_cast<size_type>(first), static_cast<value_type>(last));	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	cdeque<T, Allocator>::choose_insert(iterator position, InputIterator first, InputIterator last, chooser<false>)	{		do_insert(position, first, last, _STD::iterator_traits<InputIterator>::iterator_category());	}	template <class T, class Allocator>	template <class InputIterator>	void	cdeque<T, Allocator>::do_insert(iterator position, InputIterator first, InputIterator last, _STD::input_iterator_tag)	{		cdeque temp(first, last, get_allocator());		const cdeque& tempr = temp;		do_insert(position, tempr.begin(), tempr.end(), _STD::random_access_iterator_tag());	}	template <class T, class Allocator>	template <class ForwardIterator>	void	cdeque<T, Allocator>::do_insert(iterator position, ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)	{		size_type n = (size_type)_STD::distance(first, last);		if (n == 0)			return;		size_type ms = max_size();		if (n > ms || size_ > ms - n)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::insert length error");			#else				_STD::__msl_error("cdeque::insert length error\n");			#endif		if (size_ + n <= capacity())		{			size_type pb = size_type(position - begin());			size_type pe = size_type(end() - position);			if (pb < pe)			{				size_type oldstart = start_;				if (start_ >= n)					start_ -= n;				else					start_ = alloc_.m_ - (n - start_);				size_type done = 0;				iterator beg = begin();				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					if (pb == 0) // insert at begin()						_STD::uninitialized_copy(first, last, beg);					else // pos in [1, size_ / 2)					{						iterator b_n = beg + difference_type(n);						iterator b_n_pb = b_n + difference_type(pb);						iterator b_pb = pb == n ? b_n : beg + difference_type(pb);						iterator t;						if (pb > n)							t = beg + difference_type(2*n);						else							t = b_n_pb;						_STD::uninitialized_copy(b_n, t, beg);						ForwardIterator i = first;						if (pb > n)						{							done = n;							_STD::copy(t, b_n_pb, b_n);							t = b_pb;						}						else if (pb < n)						{							done = pb;							_STD::advance(i, difference_type(n - pb));							_STD::uninitialized_copy(first, i, b_pb);							done = n;							t = b_n;						}						else						{							done = n;							t = b_n;						}						_STD::copy(i, last, t);					}					size_ += n;				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					destroy(beg, beg + difference_type(done));					start_ = oldstart;					throw;				}				#endif			}			else // pos >= size_ / 2			{				if (pe == 0) // insert at end()					_STD::uninitialized_copy(first, last, end());				else // pos in [size_ / 2, size_)				{					iterator ei = end();					iterator e_n = ei - difference_type(n);					iterator e_pe = pe == n ? e_n : ei - difference_type(pe);					iterator t1, t2;					if (pe >= n)					{						t1 = e_n;						t2 = ei;					}					else					{						t1 = e_pe;						t2 = ei + difference_type(n - pe);					}					_STD::uninitialized_copy(t1, ei, t2);					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						if (pe >= n)						{							if (pe > n)								_STD::copy_backward(e_pe, e_n, ei);							_STD::copy(first, last, e_pe);						}						else if (n > pe)						{							ForwardIterator i = first;							_STD::advance(i, difference_type(pe));							_STD::copy(first, i, e_pe);							_STD::uninitialized_copy(i, last, ei);						}					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						destroy(t2, ei + difference_type(n));						throw;					}					#endif				}				size_ += n;			}		}		else // size_ + n > capacity()		{			size_type newsize = size_ + n;			size_type newcap = _STD::max(alloc_.m_, size_type(1));			while (newsize > newcap)				newcap *= 2;			size_type pos = size_type(position - begin());			pointer newdata = alloc_.allocate(newcap);			size_type done = 0;			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (pos > 0)				{					_STD::uninitialized_copy(begin(), position, newdata);					done = pos;				}				_STD::uninitialized_copy(first, last, newdata + pos);				done += n;				if (pos < size_)					_STD::uninitialized_copy(position, end(), newdata + pos + n);				tear_down();				data_ = newdata;				size_ = newsize;				alloc_.m_ = newcap;				start_ = 0;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				_STD::__destroy(newdata, newdata + done);				alloc_.deallocate(newdata, newcap);				throw;			}			#endif		}	}#endif#endiftemplate <class T, class Allocator>inlinecdeque<T, Allocator>::cdeque(const Allocator& a)	: alloc_(a),	  size_(0),	  start_(0),	  data_(0){}template <class T, class Allocator>inlinecdeque<T, Allocator>::cdeque(size_type n)	: alloc_(Allocator()),	  size_(0),	  start_(0),	  data_(0){	init(n, T());}	  template <class T, class Allocator>inlinecdeque<T, Allocator>::cdeque(size_type n, const T& value, const Allocator& a)	: alloc_(a),	  size_(0),	  start_(0),	  data_(0){	init(n, value);}	  #ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class T, class Allocator>		template <class InputIterator>		inline		cdeque<T, Allocator>::cdeque(InputIterator first, InputIterator last, const Allocator& a)			: alloc_(a),			  size_(0),			  start_(0),			  data_(0)		{			choose_init(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());		}	#endif#else	template <class T, class Allocator>	cdeque<T, Allocator>::cdeque(const_iterator first, const_iterator last, const Allocator& a)		: alloc_(a, size_type(last - first)),		  size_(alloc_.m_),		  start_(0),		  data_(0)	{		if (alloc_.m_ > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::construction length error");			#else				_STD::__msl_error("cdeque::construction length error\n");			#endif		if (alloc_.m_ > 0)		{			data_ = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				_STD::uninitialized_copy(first, last, data_);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(data_, alloc_.m_);				throw;			}			#endif		}	}#endiftemplate <class T, class Allocator>cdeque<T, Allocator>::cdeque(const cdeque<T,Allocator>& x)	: alloc_(x.alloc_, x.size_),	  size_(x.size_),	  start_(0),	  data_(0){	if (alloc_.m_ > 0)	{		data_ = alloc_.allocate(alloc_.m_);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			_STD::uninitialized_copy(x.begin(), x.end(), data_);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(data_, alloc_.m_);			throw;		}		#endif	}}template <class T, class Allocator>voidcdeque<T, Allocator>::init(size_type n, const T& value){	if (n > max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("cdeque::construction length error");		#else			_STD::__msl_error("cdeque::construction length error\n");		#endif	if (n > 0)	{		size_ = alloc_.m_ = n;		data_ = alloc_.allocate(n);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			_STD::uninitialized_fill_n(data_, size_, value);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(data_, n);			throw;		}		#endif	}}template <class T, class Allocator>inlinecdeque<T, Allocator>::~cdeque(){	tear_down();}template <class T, class Allocator>voidcdeque<T, Allocator>::tear_down(){	if (data_ != 0)	{		destroy(begin(), end());		alloc_.deallocate(data_, alloc_.m_);	}}template <class T, class Allocator>voidcdeque<T, Allocator>::destroy(iterator first, iterator last){	if (first != last)	{		size_type diff = size_type(last - first);		size_type e = start_ + diff;		if (e > alloc_.m_)		{			e = alloc_.m_;			_STD::__destroy(data_ + start_, data_ + e);			e = start_ + diff - alloc_.m_;			_STD::__destroy(data_, data_ + e);		}		else			_STD::__destroy(data_ + start_, data_ + e);	}}template <class T, class Allocator>cdeque<T, Allocator>&cdeque<T, Allocator>::operator=(const cdeque<T,Allocator>& x){	if (this != &x)		assign(x.begin(), x.end());	return *this;}#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class T, class Allocator>		template <class InputIterator>		inline		void		cdeque<T, Allocator>::assign(InputIterator first, InputIterator last)		{			choose_assign(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());		}	#endif#else	template <class T, class Allocator>	void	cdeque<T, Allocator>::assign(const_iterator first, const_iterator last)	{		size_type n = (size_type)_STD::distance(first, last);		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::assign length error");			#else				_STD::__msl_error("cdeque::assign length error\n");			#endif		if (n <= capacity())		{			size_type n1 = _STD::min(n, size_);			iterator i = begin();			iterator e = i + n1;			for (; i < e; ++i, ++first)				*i = *first;			if (n < size_)				destroy(i, end());			else if (size_ < n)				_STD::uninitialized_copy(first, last, i);			size_ = n;		}		else		{			pointer newdata = alloc_.allocate(n);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				_STD::uninitialized_copy(first, last, newdata);				tear_down();				data_ = newdata;				size_ = alloc_.m_ = n;				start_ = 0;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(newdata, n);				throw;			}			#endif		}	}#endiftemplate <class T, class Allocator>voidcdeque<T, Allocator>::assign(size_type n, const T& u){	if (n > max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("cdeque::assign length error");		#else			_STD::__msl_error("cdeque::assign length error\n");		#endif	if (n <= capacity())	{		difference_type n1 = (difference_type)_STD::min(n, size_);		iterator i = begin();		iterator e = i + n1;		for (; i < e; ++i)			*i = u;		if (n < size_)			destroy(i, end());		else if (size_ < n)			_STD::uninitialized_fill(i, begin() + difference_type(n), u);		size_ = n;	}	else	{		pointer newdata = alloc_.allocate(n);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			_STD::uninitialized_fill_n(newdata, n, u);			tear_down();			data_ = newdata;			size_ = alloc_.m_ = n;			start_ = 0;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(newdata, n);			throw;		}		#endif	}}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::allocator_typecdeque<T, Allocator>::get_allocator() const{	return alloc_;}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::iteratorcdeque<T, Allocator>::begin(){	return iterator(this, 0, data_ + start_);}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::const_iteratorcdeque<T, Allocator>::begin() const{	return const_iterator(this, 0, data_ + start_);}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::iteratorcdeque<T, Allocator>::end(){	size_type off = start_ + size_;	if (off < alloc_.m_)		return iterator(this, size_, data_ + off);	return iterator(this, size_, data_ + (off - alloc_.m_));}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::const_iteratorcdeque<T, Allocator>::end() const{	size_type off = start_ + size_;	if (off < alloc_.m_)		return const_iterator(this, size_, data_ + off);	return const_iterator(this, size_, data_ + (off - alloc_.m_));}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::reverse_iteratorcdeque<T, Allocator>::rbegin(){	return reverse_iterator(end());}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::const_reverse_iteratorcdeque<T, Allocator>::rbegin() const{	return const_reverse_iterator(end());}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::reverse_iteratorcdeque<T, Allocator>::rend(){	return reverse_iterator(begin());}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::const_reverse_iteratorcdeque<T, Allocator>::rend() const{	return const_reverse_iterator(begin());}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::size_typecdeque<T, Allocator>::size() const{	return size_;}template <class T, class Allocator>typename cdeque<T, Allocator>::size_typecdeque<T, Allocator>::max_size() const{	size_type ma = alloc_.max_size();	size_type mx = _STD::numeric_limits<size_type>::max() / 2;	return _STD::min(ma, mx);}template <class T, class Allocator>voidcdeque<T, Allocator>::resize(size_type sz){	if (sz > size())		insert(end(), sz-size(), T());	else if (sz < size())		erase(begin() + difference_type(sz), end());}template <class T, class Allocator>voidcdeque<T, Allocator>::resize(size_type sz, const T& value){	if (sz > size())		insert(end(), sz-size(), value);	else if (sz < size())		erase(begin() + difference_type(sz), end());}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::size_typecdeque<T, Allocator>::capacity() const{	return alloc_.m_;}template <class T, class Allocator>inlineboolcdeque<T, Allocator>::empty() const{	return size_ == 0;}template <class T, class Allocator>voidcdeque<T, Allocator>::reserve(size_type n){	if (n > max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("cdeque::reserve length error");		#else			_STD::__msl_error("cdeque::reserve length error\n");		#endif	if (n > capacity())	{		pointer newdata = alloc_.allocate(n);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (data_ != 0)			{				_STD::uninitialized_copy(begin(), end(), newdata);				tear_down();			}			alloc_.m_ = n;			data_ = newdata;			start_ = 0;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(newdata, n);			throw;		}		#endif	}}template <class T, class Allocator>typename cdeque<T, Allocator>::referencecdeque<T, Allocator>::operator[](size_type n){	n += start_;	if (n >= alloc_.m_)		n -= alloc_.m_;	return *(data_ + n);}template <class T, class Allocator>typename cdeque<T, Allocator>::const_referencecdeque<T, Allocator>::operator[](size_type n) const{	n += start_;	if (n >= alloc_.m_)		n -= alloc_.m_;	return *(data_ + n);}template <class T, class Allocator>typename cdeque<T, Allocator>::const_referencecdeque<T, Allocator>::at(size_type n) const{	if (n >= size_)		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::out_of_range("cdeque::at index out of range");		#else			_STD::__msl_error("cdeque::at index out of range");		#endif	n += start_;	if (n >= alloc_.m_)		n -= alloc_.m_;	return *(data_ + n);}template <class T, class Allocator>typename cdeque<T, Allocator>::referencecdeque<T, Allocator>::at(size_type n){	if (n >= size_)		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::out_of_range("cdeque::at index out of range");		#else			_STD::__msl_error("cdeque::at index out of range");		#endif	n += start_;	if (n >= alloc_.m_)		n -= alloc_.m_;	return *(data_ + n);}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::referencecdeque<T, Allocator>::front(){	return *(data_ + start_);}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::const_referencecdeque<T, Allocator>::front() const{	return *(data_ + start_);}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::referencecdeque<T, Allocator>::back(){	return (*this)[size_ - 1];}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::const_referencecdeque<T, Allocator>::back() const{	return (*this)[size_ - 1];}template <class T, class Allocator>voidcdeque<T, Allocator>::push_front(const T& x){	if (size_ == max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("cdeque::push_front length error");		#else			_STD::__msl_error("cdeque::push_front length error\n");		#endif	if (size_ < capacity())	{		size_type oldstart = start_;		if (start_ > 0)			--start_;		else			start_ = alloc_.m_ - 1;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			::new (data_ + start_) value_type(x);			++size_;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			start_ = oldstart;			throw;		}		#endif	}	else // size_ + n > capacity()	{		size_type newsize = size_ + 1;		size_type newcap = _STD::max(alloc_.m_, size_type(1));		if (newsize > newcap)			newcap *= 2;		pointer newdata = alloc_.allocate(newcap);		size_type done = 0;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			::new (newdata) value_type(x);			++done;			if (size_ > 0)				_STD::uninitialized_copy(begin(), end(), newdata + 1);			tear_down();			data_ = newdata;			++size_;			alloc_.m_ = newcap;			start_ = 0;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			if (done)				_STD::__destroy(newdata);			alloc_.deallocate(newdata, newcap);			throw;		}		#endif	}}template <class T, class Allocator>voidcdeque<T, Allocator>::push_back(const T& x){	if (size_ == max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("cdeque::push_back length error");		#else			_STD::__msl_error("cdeque::push_back length error\n");		#endif	if (size_ < capacity())	{		::new (&(*this)[size_]) value_type(x);		++size_;	}	else // size_ + n > capacity()	{		size_type newsize = size_ + 1;		size_type newcap = _STD::max(alloc_.m_, size_type(1));		if (newsize > newcap)			newcap *= 2;		size_type pos = size_;		pointer newdata = alloc_.allocate(newcap);		size_type done = 0;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			::new (newdata + size_) value_type(x);			++done;			if (size_ > 0)				_STD::uninitialized_copy(begin(), end(), newdata);			tear_down();			data_ = newdata;			++size_;			alloc_.m_ = newcap;			start_ = 0;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			if (done)				_STD::__destroy(newdata + size_);			alloc_.deallocate(newdata, newcap);			throw;		}		#endif	}}template <class T, class Allocator>voidcdeque<T, Allocator>::pop_front(){		alloc_.destroy(data_ + start_);	--size_;	++start_;	if (start_ >= alloc_.m_)		start_ -= alloc_.m_;}template <class T, class Allocator>voidcdeque<T, Allocator>::pop_back(){		alloc_.destroy(&*(end() - 1));	--size_;}template <class T, class Allocator>inlinetypename cdeque<T, Allocator>::iteratorcdeque<T, Allocator>::insert(iterator position, const T& x){	difference_type pos = position - begin();	insert(position, 1, x);	return begin() + pos;}template <class T, class Allocator>voidcdeque<T, Allocator>::insert(iterator position, size_type n, const T& x){	if (n == 0)		return;	size_type ms = max_size();	if (n > ms || size_ > ms - n)		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("cdeque::insert length error");		#else			_STD::__msl_error("cdeque::insert length error\n");		#endif	if (size_ + n <= capacity())	{		size_type pb = size_type(position - begin());		size_type pe = size_type(end() - position);		if (pb < pe)		{			size_type oldstart = start_;			if (start_ >= n)				start_ -= n;			else				start_ = alloc_.m_ - (n - start_);			size_type done = 0;			iterator beg = begin();			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (pb == 0) // insert at begin()					_STD::uninitialized_fill_n(beg, n, x);				else // pos in [1, size_ / 2)				{					iterator b_n = beg + difference_type(n);					iterator b_n_pb = b_n + difference_type(pb);					iterator b_pb = pb == n ? b_n : beg + difference_type(pb);					iterator t;					if (pb > n)						t = beg + difference_type(2*n);					else						t = b_n_pb;					_STD::uninitialized_copy(b_n, t, beg);					if (pb > n)					{						done = n;						_STD::copy(t, b_n_pb, b_n);						t = b_pb;					}					else if (pb < n)					{						done = pb;						_STD::uninitialized_fill(b_pb, b_n, x);						done = n;						t = b_n;					}					else					{						done = n;						t = b_n;					}					_STD::fill(t, b_n_pb, x);				}				size_ += n;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				destroy(beg, beg + difference_type(done));				start_ = oldstart;				throw;			}			#endif		}		else // pos >= size_ / 2		{			if (pe == 0) // insert at end()				_STD::uninitialized_fill_n(end(), n, x);			else // pos in [size_ / 2, size_)			{				iterator ei = end();				iterator e_n = ei - difference_type(n);				iterator e_pe = pe == n ? e_n : ei - difference_type(pe);				iterator t1, t2;				if (pe >= n)				{					t1 = e_n;					t2 = ei;				}				else				{					t1 = e_pe;					t2 = ei + difference_type(n - pe);				}				_STD::uninitialized_copy(t1, ei, t2);				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					if (pe >= n)					{						if (pe > n)							_STD::copy_backward(e_pe, e_n, ei);						t1 = pe == n ? ei : ei - difference_type(pe - n);						_STD::fill(e_pe, t1, x);					}					else if (n > pe)					{						_STD::fill(e_pe, ei, x);						_STD::uninitialized_fill(ei, t2, x);					}				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					destroy(t2, ei + difference_type(n));					throw;				}				#endif			}			size_ += n;		}	}	else // size_ + n > capacity()	{		size_type newsize = size_ + n;		size_type newcap = _STD::max(alloc_.m_, size_type(1));		while (newsize > newcap)			newcap *= 2;		size_type pos = size_type(position - begin());		pointer newdata = alloc_.allocate(newcap);		size_type done = 0;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (pos > 0)			{				_STD::uninitialized_copy(begin(), position, newdata);				done = pos;			}			_STD::uninitialized_fill_n(newdata + pos, n, x);			done += n;			if (pos < size_)				_STD::uninitialized_copy(position, end(), newdata + pos + n);			tear_down();			data_ = newdata;			size_ = newsize;			alloc_.m_ = newcap;			start_ = 0;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			_STD::__destroy(newdata, newdata + done);			alloc_.deallocate(newdata, newcap);			throw;		}		#endif	}}#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class T, class Allocator>		template <class InputIterator>		inline		void		cdeque<T, Allocator>::insert(iterator position, InputIterator first, InputIterator last)		{			choose_insert(position, first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());		}	#endif#else	template <class T, class Allocator>	void	cdeque<T, Allocator>::insert(iterator position, const_iterator first, const_iterator last)	{		size_type n = (size_type)_STD::distance(first, last);		if (n == 0)			return;		size_type ms = max_size();		if (n > ms || size_ > ms - n)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::insert length error");			#else				_STD::__msl_error("cdeque::insert length error\n");			#endif		if (size_ + n <= capacity())		{			size_type pb = size_type(position - begin());			size_type pe = size_type(end() - position);			if (pb < pe)			{				size_type oldstart = start_;				if (start_ >= n)					start_ -= n;				else					start_ = alloc_.m_ - (n - start_);				size_type done = 0;				iterator beg = begin();				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					if (pb == 0) // insert at begin()						_STD::uninitialized_fill_n(beg, n, x);					else // pos in [1, size_ / 2)					{						iterator b_n = beg + difference_type(n);						iterator b_n_pb = b_n + difference_type(pb);						iterator b_pb = pb == n ? b_n : beg + difference_type(pb);						iterator t;						if (pb > n)							t = beg + difference_type(2*n);						else							t = b_n_pb;						_STD::uninitialized_copy(b_n, t, beg);						if (pb > n)						{							done = n;							_STD::copy(t, b_n_pb, b_n);							t = b_pb;						}						else if (pb < n)						{							done = pb;							_STD::uninitialized_fill(b_pb, b_n, x);							done = n;							t = b_n;						}						else						{							done = n;							t = b_n;						}						_STD::fill(t, b_n_pb, x);					}					size_ += n;				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					destroy(beg, beg + difference_type(done));					start_ = oldstart;					throw;				}				#endif			}			else // pos >= size_ / 2			{				if (pe == 0) // insert at end()					_STD::uninitialized_fill_n(end(), n, x);				else // pos in [size_ / 2, size_)				{					iterator ei = end();					iterator e_n = ei - difference_type(n);					iterator e_pe = pe == n ? e_n : ei - difference_type(pe);					iterator t1, t2;					if (pe >= n)					{						t1 = e_n;						t2 = ei;					}					else					{						t1 = e_pe;						t2 = ei + difference_type(n - pe);					}					_STD::uninitialized_copy(t1, ei, t2);					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						if (pe >= n)						{							if (pe > n)								_STD::copy_backward(e_pe, e_n, ei);							t1 = pe == n ? ei : ei - difference_type(pe - n);							_STD::fill(e_pe, t1, x);						}						else if (n > pe)						{							_STD::fill(e_pe, ei, x);							_STD::uninitialized_fill(ei, t2, x);						}					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						destroy(t2, ei + difference_type(n));						throw;					}					#endif				}				size_ += n;			}		}		else // size_ + n > capacity()		{			size_type newsize = size_ + n;			size_type newcap = _STD::max(alloc_.m_, 1);			while (newsize > newcap)				newcap *= 2;			size_type pos = size_type(position - data_);			pointer newdata = alloc_.allocate(newcap);			size_type done = 0;			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (pos > 0)				{					_STD::uninitialized_copy(begin(), position, newdata);					done = pos;				}				_STD::uninitialized_copy(first, last, newdata + pos);				done += n;				if (pos < size_)					_STD::uninitialized_copy(position, end(), newdata + pos + n);				tear_down();				data_ = newdata;				size_ = newsize;				alloc_.m_ = newcap;				start_ = 0;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				destroy(newdata, newdata + done);				alloc_.deallocate(newdata, newcap);				throw;			}			#endif		}	}#endiftemplate <class T, class Allocator>inlinetypename cdeque<T, Allocator>::iteratorcdeque<T, Allocator>::erase(iterator position){	return erase(position, position + 1);}template <class T, class Allocator>typename cdeque<T, Allocator>::iteratorcdeque<T, Allocator>::erase(iterator first, iterator last){	if (first == last)		return first;	size_type pb = size_type(first - begin());	size_type pe = size_type(end() - last);	size_type diff = size_type(last - first);	if (pb < pe)	{		if (pb == 0)  // erase from beginning, no copying necessary			destroy(first, last);		else  // erase from beginning, needs copying		{			_STD::copy_backward(begin(), first, last);			destroy(begin(), begin() + difference_type(diff));		}		start_ += diff;		if (start_ >= alloc_.m_)			start_ -= alloc_.m_;	}	else  // pb >= pe - erase from end	{		if (pe == 0)  // erase from end, no copying necessary			destroy(first, last);		else  // erase from end, needs copying		{			_STD::copy(last, end(), first);			destroy(first + difference_type(pe), end());		}	}	size_ -= diff;	return first;}template <class T, class Allocator>voidcdeque<T, Allocator>::swap(cdeque<T,Allocator>& x){	if (this != &x)	{		_STD::swap(alloc_, x.alloc_);		_STD::swap(size_, x.size_);		_STD::swap(start_, x.start_);		_STD::swap(data_, x.data_);	}}template <class T, class Allocator>voidcdeque<T, Allocator>::clear(){	destroy(begin(), end());	size_ = start_ = 0;}template <class T, class Allocator>inlinebooloperator==(const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y){	return x.size() == y.size() && _STD::equal(x.begin(), x.end(), y.begin());}template <class T, class Allocator>inlinebooloperator!=(const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y){	return !(x == y);}template <class T, class Allocator>inlinebooloperator< (const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y){	return _STD::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}template <class T, class Allocator>inlinebooloperator> (const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y){	return y < x;}template <class T, class Allocator>inlinebooloperator>=(const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y){	return !(x < y);}template <class T, class Allocator>inlinebooloperator<=(const cdeque<T,Allocator>& x, const cdeque<T,Allocator>& y){	return !(y < x);}template <class T, class Allocator>inlinevoidswap(cdeque<T,Allocator>& x, cdeque<T,Allocator>& y){	x.swap(y);}#if !defined(_MSL_NO_PARTIAL_SPECIALIZATION) && !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_Inhibit_Container_Optimization)	// Specialize for T* to save on code bloat	// hh 990825 changed void* to const void*	// const void*	template <class Allocator>	class cdeque<const void*, Allocator>	{		template <bool b> struct chooser {};	public:		// types:		typedef Allocator::reference                  reference;		typedef Allocator::const_reference            const_reference;		class                                         iterator;		class                                         const_iterator;		typedef typename Allocator::size_type         size_type;		typedef typename Allocator::difference_type   difference_type;		typedef const void*                           value_type;		typedef Allocator                             allocator_type;		typedef typename Allocator::pointer           pointer;		typedef typename Allocator::const_pointer     const_pointer;		typedef _STD::reverse_iterator<iterator>       reverse_iterator;		typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;		friend class iterator;		class iterator			: public _STD::iterator<_STD::random_access_iterator_tag, value_type,				difference_type, pointer, reference>		{		public:			iterator() {}			reference operator * () const {return *ptr_;}			pointer operator -> () const {return ptr_;}			iterator& operator ++ ()			{				++pos_;				if (++ptr_ == cdeq_->data_ + cdeq_->alloc_.m_)					ptr_ = cdeq_->data_;				return *this;			}			iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}			iterator& operator -- ()			{				--pos_;				if (ptr_ == cdeq_->data_)					ptr_ = cdeq_->data_ + cdeq_->alloc_.m_;				--ptr_;				return *this;			}			iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}			iterator& operator += (difference_type n)			{				if (n < 0)					return (*this) -= -n;				size_type sz = cdeq_->alloc_.m_;				size_type off = cdeq_->start_ + pos_ + static_cast<size_type>(n);				if (off < sz)					ptr_ += n;				else					ptr_ = cdeq_->data_ + (off - sz);				pos_ += static_cast<size_type>(n);				return *this;			}			iterator operator + (difference_type n) const {return iterator(*this) += n;}			iterator& operator -= (difference_type n)			{				if (n < 0)					return (*this) += -n;				if (n <= cdeq_->start_ + pos_)					ptr_ -= n;				else					ptr_ = cdeq_->data_ + (cdeq_->alloc_.m_ - n);				pos_ -= static_cast<size_type>(n);				return *this;			}			iterator operator - (difference_type n) const {return iterator(*this) -= n;}			difference_type operator - (const iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}			reference operator [] (difference_type i) const {iterator tmp(*this); tmp += i; return *tmp;}			friend bool operator ==(const iterator& x, const iterator& y) {return x.pos_ == y.pos_;}  // hh 990720			friend bool operator !=(const iterator& x, const iterator& y) {return x.pos_ != y.pos_;}			friend bool operator < (const iterator& x, const iterator& y) {return x.pos_ <  y.pos_;}			friend bool operator <=(const iterator& x, const iterator& y) {return x.pos_ <= y.pos_;}			friend bool operator > (const iterator& x, const iterator& y) {return x.pos_ >  y.pos_;}			friend bool operator >=(const iterator& x, const iterator& y) {return x.pos_ >= y.pos_;}			friend iterator operator + (difference_type n, const iterator& rhs)				{return iterator(rhs) += n;}		private:			cdeque* cdeq_;			size_type pos_;			pointer ptr_;			iterator(cdeque* cdeq, size_type pos, pointer ptr)				: cdeq_(cdeq),				  pos_(pos),				  ptr_(ptr)			{}			friend class cdeque;			friend class cdeque::const_iterator;		};		friend class const_iterator;		class const_iterator			: public _STD::iterator<_STD::random_access_iterator_tag, value_type,				difference_type, const_pointer, const_reference>		{		public:			const_iterator() {}			const_iterator(const cdeque::iterator& rhs) : cdeq_(rhs.cdeq_), pos_(rhs.pos_), ptr_(rhs.ptr_) {}			const_reference operator * () const {return *ptr_;}			const_pointer operator -> () const {return ptr_;}			const_iterator& operator ++ ()			{				++pos_;				if (++ptr_ == cdeq_->data_ + cdeq_->alloc_.m_)					ptr_ = cdeq_->data_;				return *this;			}			const_iterator operator ++ (int) {const_iterator tmp(*this); ++(*this); return tmp;}			const_iterator& operator -- ()			{				--pos_;				if (ptr_ == cdeq_->data_)					ptr_ = cdeq_->data_ + cdeq_->alloc_.m_;				--ptr_;				return *this;			}			const_iterator operator -- (int) {const_iterator tmp(*this); --(*this); return tmp;}			const_iterator& operator += (difference_type n)			{				if (n < 0)					return (*this) -= -n;				size_type sz = cdeq_->alloc_.m_;				size_type off = cdeq_->start_ + pos_ + static_cast<size_type>(n);				if (off < sz)					ptr_ += n;				else					ptr_ = cdeq_->data_ + (off - sz);				pos_ += static_cast<size_type>(n);				return *this;			}			const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}			const_iterator& operator -= (difference_type n)			{				if (n < 0)					return (*this) += -n;				if (n <= cdeq_->start_ + pos_)					ptr_ -= n;				else					ptr_ = cdeq_->data_ + (cdeq_->alloc_.m_ - n);				pos_ -= static_cast<size_type>(n);				return *this;			}			const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}			difference_type operator - (const const_iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}			const_reference operator [] (difference_type i) const {const_iterator tmp(*this); tmp += i; return *tmp;}			friend bool operator ==(const const_iterator& x, const const_iterator& y) {return x.pos_ == y.pos_;}  // hh 990720			friend bool operator !=(const const_iterator& x, const const_iterator& y) {return x.pos_ != y.pos_;}			friend bool operator < (const const_iterator& x, const const_iterator& y) {return x.pos_ <  y.pos_;}			friend bool operator <=(const const_iterator& x, const const_iterator& y) {return x.pos_ <= y.pos_;}			friend bool operator > (const const_iterator& x, const const_iterator& y) {return x.pos_ >  y.pos_;}			friend bool operator >=(const const_iterator& x, const const_iterator& y) {return x.pos_ >= y.pos_;}			friend const_iterator operator + (difference_type n, const const_iterator& rhs)				{return const_iterator(rhs) += n;}		private:			const cdeque* cdeq_;			size_type pos_;			const_pointer ptr_;			const_iterator(const cdeque* cdeq, size_type pos, const_pointer ptr)				: cdeq_(cdeq),				  pos_(pos),				  ptr_(ptr)			{}			friend class cdeque;		};		// cdeque.cons_ construct/copy/destroy:		explicit cdeque(const Allocator& = Allocator());		explicit cdeque(size_type n, const value_type& value = 0, const Allocator& = Allocator());	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			cdeque(InputIterator first, InputIterator last, const Allocator& a = Allocator());	#else		template <class InputIterator>			inline			cdeque(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: alloc_(a),				  size_(0),				  start_(0),				  data_(0)			{				choose_init(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif		cdeque(const cdeque& x);		~cdeque();		cdeque& operator=(const cdeque& x);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator> void assign(InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void			assign(InputIterator first, InputIterator last)			{				choose_assign(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif		void assign(size_type n, const value_type& u);		allocator_type get_allocator() const;		// iterators:		iterator               begin();		const_iterator         begin() const;		iterator               end();		const_iterator         end() const;		reverse_iterator       rbegin();		const_reverse_iterator rbegin() const;		reverse_iterator       rend();		const_reverse_iterator rend() const;		// cdeque.capacity_ capacity:		size_type size() const;		size_type max_size() const;		void      resize(size_type sz, value_type c = 0);		size_type capacity() const;		bool      empty() const;		void      reserve(size_type n);		// element access:		reference       operator[](size_type n);		const_reference operator[](size_type n) const;		const_reference at(size_type n) const;		reference       at(size_type n);		reference       front();		const_reference front() const;		reference       back();		const_reference back() const;		// cdeque.modifiers_ modifiers:		void push_front(const value_type& x);		void push_back(const value_type& x);		void pop_front();		void pop_back();		iterator insert(iterator position, const value_type& x);		void     insert(iterator position, size_type n, const value_type& x);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator> void insert(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void			insert(iterator position, InputIterator first, InputIterator last)			{				choose_insert(position, first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif		iterator erase(iterator position);		iterator erase(iterator first, iterator last);		void     swap(cdeque&);		void     clear();	private:		_STD::_EmptyMemberOpt<Allocator, size_type> alloc_;  // m_ is capacity		size_type size_;		size_type start_;		pointer data_;	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void choose_init(InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_init(InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void init(InputIterator first, InputIterator last, _STD::input_iterator_tag);		template <class ForwardIterator>			void init(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag);		template <class InputIterator>			void choose_assign(InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_assign(InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag);		template <class ForwardIterator>			void do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag);		template <class InputIterator>			void choose_insert(iterator position, InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_insert(iterator position, InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void do_insert(iterator position, InputIterator first, InputIterator last, _STD::input_iterator_tag);		template <class ForwardIterator>			void do_insert(iterator position, ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag);	#else		template <class InputIterator>			inline			void			choose_init(InputIterator first, InputIterator last, chooser<true>)			{				init(static_cast<size_type>(first), reinterpret_cast<value_type>(last));  // hh 981208			}		template <class InputIterator>			inline			void			choose_init(InputIterator first, InputIterator last, chooser<false>)			{				init(first, last, _STD::iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			init(InputIterator first, InputIterator last, _STD::input_iterator_tag)			{				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					for (; first != last; ++first)						push_back(*first);				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					tear_down();					throw;				}				#endif			}		template <class ForwardIterator>			void			init(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)			{				size_ = alloc_.m_ = (size_type)_STD::distance(first, last);				if (size_ > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("cdeque::construction length error");					#else						_STD::__msl_error("cdeque::construction length error\n");					#endif				if (alloc_.m_ > 0)				{					data_ = alloc_.allocate(alloc_.m_);					_STD::copy(first, last, data_);				}			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<true>)			{				assign(static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<false>)			{				do_assign(first, last, _STD::iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag)			{				cdeque temp(first, last, get_allocator());				const cdeque& tempr = temp;				do_assign(tempr.begin(), tempr.end(), _STD::random_access_iterator_tag());			}		template <class ForwardIterator>			void			do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)			{				size_type n = (size_type)_STD::distance(first, last);				if (n > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("cdeque::assign length error");					#else						_STD::__msl_error("cdeque::assign length error\n");					#endif				if (n <= capacity())				{					_STD::copy(first, last, data_);					start_ = 0;					size_ = n;				}				else				{					pointer olddata = data_;					data_ = alloc_.allocate(n);					_STD::copy(first, last, data_);					if (olddata != 0)						alloc_.deallocate(olddata, alloc_.m_);					size_ = alloc_.m_ = n;					start_ = 0;				}			}		template <class InputIterator>			inline			void			choose_insert(iterator position, InputIterator first, InputIterator last,				chooser<true>)			{				insert(position, static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_insert(iterator position, InputIterator first, InputIterator last,				chooser<false>)			{				do_insert(position, first, last, _STD::iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_insert(iterator position, InputIterator first, InputIterator last,				_STD::input_iterator_tag)			{				cdeque temp(first, last, get_allocator());				const cdeque& tempr = temp;				do_insert(position, tempr.begin(), tempr.end(), _STD::random_access_iterator_tag());			}		template <class ForwardIterator>			void			do_insert(iterator position, ForwardIterator first, ForwardIterator last,				_STD::forward_iterator_tag)			{				size_type n = (size_type)_STD::distance(first, last);				if (n == 0)					return;				size_type ms = max_size();				if (n > ms || size_ > ms - n)					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("cdeque::insert length error");					#else						_STD::__msl_error("cdeque::insert length error\n");					#endif				if (size_ + n <= capacity())				{					size_type pb = size_type(position - begin());					size_type pe = size_type(end() - position);					if (pb < pe)					{						if (start_ >= n)							start_ -= n;						else							start_ = alloc_.m_ - (n - start_);						if (pb == 0) // insert at begin()							_STD::copy(first, last, begin());						else // pos in [1, size_ / 2)						{							iterator beg = begin();							_STD::copy(beg + difference_type(n),								beg + difference_type(n + pb), beg);							_STD::copy(first, last, beg + difference_type(pb));						}					}					else // pos >= size_ / 2					{						if (pe == 0) // insert at end()							_STD::copy(first, last, end());						else // pos in [size_ / 2, size_)						{							iterator ei = end();							iterator e_pe = ei - difference_type(pe);							_STD::copy_backward(e_pe, ei, ei + difference_type(n));							_STD::copy(first, last, e_pe);						}					}					size_ += n;				}				else // size_ + n > capacity()				{					size_type newsize = size_ + n;					size_type newcap = _STD::max(alloc_.m_, size_type(1));					while (newsize > newcap)						newcap *= 2;					size_type pos = size_type(position - begin());					pointer newdata = alloc_.allocate(newcap);					if (pos > 0)						_STD::copy(begin(), position, newdata);					_STD::copy(first, last, newdata + pos);					if (pos < size_)						_STD::copy(position, end(), newdata + pos + n);					tear_down();					data_ = newdata;					size_ = newsize;					alloc_.m_ = newcap;					start_ = 0;				}			}	#endif		void init(size_type n, const value_type& value);		void tear_down();	};	// Implementation cdeque<const void*>#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class InputIterator>	inline	void	cdeque<const void*, Allocator>::choose_init(InputIterator first, InputIterator last, chooser<true>)	{		init(static_cast<size_type>(first), reinterpret_cast<value_type>(last));  // hh 981208	}	template <class Allocator>	template <class InputIterator>	inline	void	cdeque<const void*, Allocator>::choose_init(InputIterator first, InputIterator last, chooser<false>)	{		init(first, last, _STD::iterator_traits<InputIterator>::iterator_category());	}	template <class Allocator>	template <class InputIterator>	void	cdeque<const void*, Allocator>::init(InputIterator first, InputIterator last, _STD::input_iterator_tag)	{		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			for (; first != last; ++first)				push_back(*first);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			tear_down();			throw;		}		#endif	}	template <class Allocator>	template <class ForwardIterator>	void	cdeque<const void*, Allocator>::init(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)	{		size_ = alloc_.m_ = (size_type)_STD::distance(first, last);		if (size_ > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::construction length error");			#else				_STD::__msl_error("cdeque::construction length error\n");			#endif		if (alloc_.m_ > 0)		{			data_ = alloc_.allocate(alloc_.m_);			_STD::copy(first, last, data_);		}	}	template <class Allocator>	template <class InputIterator>	inline	void	cdeque<const void*, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<true>)	{		assign(static_cast<size_type>(first), static_cast<value_type>(last));	}	template <class Allocator>	template <class InputIterator>	inline	void	cdeque<const void*, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<false>)	{		do_assign(first, last, _STD::iterator_traits<InputIterator>::iterator_category());	}	template <class Allocator>	template <class InputIterator>	void	cdeque<const void*, Allocator>::do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag)	{		cdeque temp(first, last, get_allocator());		const cdeque& tempr = temp;		do_assign(tempr.begin(), tempr.end(), _STD::random_access_iterator_tag());	}	template <class Allocator>	template <class ForwardIterator>	void	cdeque<const void*, Allocator>::do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)	{		size_type n = (size_type)_STD::distance(first, last);		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::assign length error");			#else				_STD::__msl_error("cdeque::assign length error\n");			#endif		if (n <= capacity())		{			_STD::copy(first, last, data_);			start_ = 0;			size_ = n;		}		else		{			pointer olddata = data_;			data_ = alloc_.allocate(n);			_STD::copy(first, last, data_);			if (olddata != 0)				alloc_.deallocate(olddata, alloc_.m_);			size_ = alloc_.m_ = n;			start_ = 0;		}	}	template <class Allocator>	template <class InputIterator>	inline	void	cdeque<const void*, Allocator>::choose_insert(iterator position, InputIterator first, InputIterator last,		chooser<true>)	{		insert(position, static_cast<size_type>(first), static_cast<value_type>(last));	}	template <class Allocator>	template <class InputIterator>	inline	void	cdeque<const void*, Allocator>::choose_insert(iterator position, InputIterator first, InputIterator last,		chooser<false>)	{		do_insert(position, first, last, _STD::iterator_traits<InputIterator>::iterator_category());	}	template <class Allocator>	template <class InputIterator>	void	cdeque<const void*, Allocator>::do_insert(iterator position, InputIterator first, InputIterator last,		_STD::input_iterator_tag)	{		cdeque temp(first, last, get_allocator());		const cdeque& tempr = temp;		do_insert(position, tempr.begin(), tempr.end(), _STD::random_access_iterator_tag());	}	template <class Allocator>	template <class ForwardIterator>	void	cdeque<const void*, Allocator>::do_insert(iterator position, ForwardIterator first, ForwardIterator last,		_STD::forward_iterator_tag)	{		size_type n = (size_type)_STD::distance(first, last);		if (n == 0)			return;		size_type ms = max_size();		if (n > ms || size_ > ms - n)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::insert length error");			#else				_STD::__msl_error("cdeque::insert length error\n");			#endif		if (size_ + n <= capacity())		{			size_type pb = size_type(position - begin());			size_type pe = size_type(end() - position);			if (pb < pe)			{				if (start_ >= n)					start_ -= n;				else					start_ = alloc_.m_ - (n - start_);				if (pb == 0) // insert at begin()					_STD::copy(first, last, begin());				else // pos in [1, size_ / 2)				{					iterator beg = begin();					_STD::copy(beg + difference_type(n),						beg + difference_type(n + pb), beg);					_STD::copy(first, last, beg + difference_type(pb));				}			}			else // pos >= size_ / 2			{				if (pe == 0) // insert at end()					_STD::copy(first, last, end());				else // pos in [size_ / 2, size_)				{					iterator ei = end();					iterator e_pe = ei - difference_type(pe);					_STD::copy_backward(e_pe, ei, ei + difference_type(n));					_STD::copy(first, last, e_pe);				}			}			size_ += n;		}		else // size_ + n > capacity()		{			size_type newsize = size_ + n;			size_type newcap = _STD::max(alloc_.m_, size_type(1));			while (newsize > newcap)				newcap *= 2;			size_type pos = size_type(position - begin());			pointer newdata = alloc_.allocate(newcap);			if (pos > 0)				_STD::copy(begin(), position, newdata);			_STD::copy(first, last, newdata + pos);			if (pos < size_)				_STD::copy(position, end(), newdata + pos + n);			tear_down();			data_ = newdata;			size_ = newsize;			alloc_.m_ = newcap;			start_ = 0;		}	}#endif	template <class Allocator>	inline	cdeque<const void*, Allocator>::cdeque(const Allocator& a)		: alloc_(a),		  size_(0),		  start_(0),		  data_(0)	{	}	template <class Allocator>	inline	cdeque<const void*, Allocator>::cdeque(size_type n, const value_type& value, const Allocator& a)		: alloc_(a),		  size_(0),		  start_(0),		  data_(0)	{		init(n, value);	}	  #ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class InputIterator>	inline	cdeque<const void*, Allocator>::cdeque(InputIterator first, InputIterator last, const Allocator& a)		: alloc_(a),		  size_(0),		  start_(0),		  data_(0)	{		choose_init(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());	}#endif	template <class Allocator>	cdeque<const void*, Allocator>::cdeque(const cdeque& x)		: alloc_(x.alloc_, x.size_),		  size_(x.size_),		  start_(0),		  data_(0)	{		if (alloc_.m_ > 0)		{			data_ = alloc_.allocate(alloc_.m_);			_STD::copy(x.begin(), x.end(), data_);		}	}	template <class Allocator>	void	cdeque<const void*, Allocator>::init(size_type n, const value_type& value)	{		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::construction length error");			#else				_STD::__msl_error("cdeque::construction length error\n");			#endif		if (n > 0)		{			size_ = alloc_.m_ = n;			data_ = alloc_.allocate(n);			_STD::fill_n(data_, n, value);		}	}	template <class Allocator>	inline	cdeque<const void*, Allocator>::~cdeque()	{		tear_down();	}	template <class Allocator>	inline	void	cdeque<const void*, Allocator>::tear_down()	{		if (data_ != 0)			alloc_.deallocate(data_, alloc_.m_);	}	template <class Allocator>	cdeque<const void*, Allocator>&	cdeque<const void*, Allocator>::operator=(const cdeque& x)	{		if (this != &x)			assign(x.begin(), x.end());		return *this;	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class InputIterator>	inline	void	cdeque<const void*, Allocator>::assign(InputIterator first, InputIterator last)	{		choose_assign(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());	}#endif	template <class Allocator>	void	cdeque<const void*, Allocator>::assign(size_type n, const value_type& u)	{		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::assign length error");			#else				_STD::__msl_error("cdeque::assign length error\n");			#endif		if (n <= capacity())		{			_STD::fill_n(data_, n, u);			size_ = n;			start_ = 0;		}		else		{			pointer olddata = data_;			data_ = alloc_.allocate(n);			_STD::fill_n(data_, n, u);			if (olddata != 0)				alloc_.deallocate(olddata, alloc_.m_);			size_ = alloc_.m_ = n;			start_ = 0;		}	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::allocator_type	cdeque<const void*, Allocator>::get_allocator() const	{		return alloc_;	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::iterator	cdeque<const void*, Allocator>::begin()	{		return iterator(this, 0, data_ + start_);	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::const_iterator	cdeque<const void*, Allocator>::begin() const	{		return const_iterator(this, 0, data_ + start_);	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::iterator	cdeque<const void*, Allocator>::end()	{		size_type off = start_ + size_;		if (off < alloc_.m_)			return iterator(this, size_, data_ + off);		return iterator(this, size_, data_ + (off - alloc_.m_));	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::const_iterator	cdeque<const void*, Allocator>::end() const	{		size_type off = start_ + size_;		if (off < alloc_.m_)			return const_iterator(this, size_, data_ + off);		return const_iterator(this, size_, data_ + (off - alloc_.m_));	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::reverse_iterator	cdeque<const void*, Allocator>::rbegin()	{		return reverse_iterator(end());	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::const_reverse_iterator	cdeque<const void*, Allocator>::rbegin() const	{		return const_reverse_iterator(end());	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::reverse_iterator	cdeque<const void*, Allocator>::rend()	{		return reverse_iterator(begin());	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::const_reverse_iterator	cdeque<const void*, Allocator>::rend() const	{		return const_reverse_iterator(begin());	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::size_type	cdeque<const void*, Allocator>::size() const	{		return size_;	}	template <class Allocator>	typename cdeque<const void*, Allocator>::size_type	cdeque<const void*, Allocator>::max_size() const	{		size_type ma = alloc_.max_size();		size_type mx = _STD::numeric_limits<size_type>::max() / 2;		return _STD::min(ma, mx);	}	template <class Allocator>	void	cdeque<const void*, Allocator>::resize(size_type sz, value_type c)	{		if (sz > size())			insert(end(), sz-size(), c);		else if (sz < size())			erase(begin() + difference_type(sz), end());	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::size_type	cdeque<const void*, Allocator>::capacity() const	{		return alloc_.m_;	}	template <class Allocator>	inline	bool	cdeque<const void*, Allocator>::empty() const	{		return size_ == 0;	}	template <class Allocator>	void	cdeque<const void*, Allocator>::reserve(size_type n)	{		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::reserve length error");			#else				_STD::__msl_error("cdeque::reserve length error\n");			#endif		if (n > capacity())		{			pointer newdata = alloc_.allocate(n);			if (data_ != 0)			{				_STD::copy(begin(), end(), newdata);				tear_down();			}			alloc_.m_ = n;			data_ = newdata;			start_ = 0;		}	}	template <class Allocator>	typename cdeque<const void*, Allocator>::reference	cdeque<const void*, Allocator>::operator[](size_type n)	{		n += start_;		if (n >= alloc_.m_)			n -= alloc_.m_;		return *(data_ + n);	}	template <class Allocator>	typename cdeque<const void*, Allocator>::const_reference	cdeque<const void*, Allocator>::operator[](size_type n) const	{		n += start_;		if (n >= alloc_.m_)			n -= alloc_.m_;		return *(data_ + n);	}	template <class Allocator>	typename cdeque<const void*, Allocator>::const_reference	cdeque<const void*, Allocator>::at(size_type n) const	{		if (n >= size_)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::out_of_range("cdeque::at index out of range");			#else				_STD::__msl_error("cdeque::at index out of range");			#endif		n += start_;		if (n >= alloc_.m_)			n -= alloc_.m_;		return *(data_ + n);	}	template <class Allocator>	typename cdeque<const void*, Allocator>::reference	cdeque<const void*, Allocator>::at(size_type n)	{		if (n >= size_)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::out_of_range("cdeque::at index out of range");			#else				_STD::__msl_error("cdeque::at index out of range");			#endif		n += start_;		if (n >= alloc_.m_)			n -= alloc_.m_;		return *(data_ + n);	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::reference	cdeque<const void*, Allocator>::front()	{		return *(data_ + start_);	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::const_reference	cdeque<const void*, Allocator>::front() const	{		return *(data_ + start_);	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::reference	cdeque<const void*, Allocator>::back()	{		return (*this)[size_ - 1];	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::const_reference	cdeque<const void*, Allocator>::back() const	{		return (*this)[size_ - 1];	}	template <class Allocator>	void	cdeque<const void*, Allocator>::push_front(const value_type& x)	{		if (size_ == max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::push_front length error");			#else				_STD::__msl_error("cdeque::push_front length error\n");			#endif		if (size_ < capacity())		{			size_type oldstart = start_;			if (start_ > 0)				--start_;			else				start_ = alloc_.m_ - 1;			*(data_ + start_) = x;			++size_;		}		else // size_ + n > capacity()		{			size_type newsize = size_ + 1;			size_type newcap = _STD::max(alloc_.m_, size_type(1));			if (newsize > newcap)				newcap *= 2;			pointer newdata = alloc_.allocate(newcap);			size_type done = 0;			*newdata = x;			++done;			if (size_ > 0)				_STD::copy(begin(), end(), newdata + 1);			tear_down();			data_ = newdata;			++size_;			alloc_.m_ = newcap;			start_ = 0;		}	}	template <class Allocator>	void	cdeque<const void*, Allocator>::push_back(const value_type& x)	{		if (size_ == max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::push_back length error");			#else				_STD::__msl_error("cdeque::push_back length error\n");			#endif		if (size_ < capacity())		{			(*this)[size_] = x;			++size_;		}		else // size_ + n > capacity()		{			size_type newsize = size_ + 1;			size_type newcap = _STD::max(alloc_.m_, size_type(1));			if (newsize > newcap)				newcap *= 2;			size_type pos = size_;			pointer newdata = alloc_.allocate(newcap);			*(newdata + size_) = x;			if (size_ > 0)				_STD::copy(begin(), end(), newdata);			tear_down();			data_ = newdata;			++size_;			alloc_.m_ = newcap;			start_ = 0;		}	}	template <class Allocator>	void	cdeque<const void*, Allocator>::pop_front()	{			--size_;		++start_;		if (start_ >= alloc_.m_)			start_ -= alloc_.m_;	}	template <class Allocator>	inline	void	cdeque<const void*, Allocator>::pop_back()	{			--size_;	}	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::iterator	cdeque<const void*, Allocator>::insert(iterator position, const value_type& x)	{		size_type pos = size_type(position - begin());		insert(position, 1, x);		return begin() + difference_type(pos);	}	template <class Allocator>	void	cdeque<const void*, Allocator>::insert(iterator position, size_type n, const value_type& x)	{		if (n == 0)			return;		size_type ms = max_size();		if (n > ms || size_ > ms - n)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("cdeque::insert length error");			#else				_STD::__msl_error("cdeque::insert length error\n");			#endif		if (size_ + n <= capacity())		{			size_type pb = size_type(position - begin());			size_type pe = size_type(end() - position);			if (pb < pe)			{				if (start_ >= n)					start_ -= n;				else					start_ = alloc_.m_ - (n - start_);				if (pb == 0) // insert at begin()					_STD::fill_n(begin(), n, x);				else // pos in [1, size_ / 2)				{					iterator beg = begin();					_STD::copy(beg + difference_type(n),						beg + difference_type(n + pb), beg);					_STD::fill_n(beg + difference_type(pb), n, x);				}			}			else // pos >= size_ / 2			{				if (pe == 0) // insert at end()					_STD::fill_n(end(), n, x);				else // pos in [size_ / 2, size_)				{					_STD::copy_backward(position, end(), end() + difference_type(n));					_STD::fill_n(position, n, x);				}			}			size_ += n;		}		else // size_ + n > capacity()		{			size_type newsize = size_ + n;			size_type newcap = _STD::max(alloc_.m_, size_type(1));			while (newsize > newcap)				newcap *= 2;			size_type pos = size_type(position - begin());			pointer newdata = alloc_.allocate(newcap);			if (pos > 0)				_STD::copy(begin(), position, newdata);			_STD::fill_n(newdata + pos, n, x);			if (pos < size_)				_STD::copy(position, end(), newdata + pos + n);			tear_down();			data_ = newdata;			size_ = newsize;			alloc_.m_ = newcap;			start_ = 0;		}	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class InputIterator>	inline	void	cdeque<const void*, Allocator>::insert(iterator position, InputIterator first, InputIterator last)	{		choose_insert(position, first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());	}#endif	template <class Allocator>	inline	typename cdeque<const void*, Allocator>::iterator	cdeque<const void*, Allocator>::erase(iterator position)	{		return erase(position, position + 1);	}	template <class Allocator>	typename cdeque<const void*, Allocator>::iterator	cdeque<const void*, Allocator>::erase(iterator first, iterator last)	{		if (first == last)			return first;		size_type pb = size_type(first - begin());		size_type pe = size_type(end() - last);		size_type diff = size_type(last - first);		if (pb < pe)		{			if (pb != 0)  // erase from beginning, needs copying				_STD::copy_backward(begin(), first, last);			start_ += diff;			if (start_ >= alloc_.m_)				start_ -= alloc_.m_;		}		else if (pe != 0)  // erase from end, needs copying			_STD::copy(last, end(), first);		size_ -= diff;		return first;	}	template <class Allocator>	void	cdeque<const void*, Allocator>::swap(cdeque& x)	{		if (this != &x)		{			_STD::swap(alloc_, x.alloc_);			_STD::swap(size_, x.size_);			_STD::swap(start_, x.start_);			_STD::swap(data_, x.data_);		}	}	template <class Allocator>	inline	void	cdeque<const void*, Allocator>::clear()	{		size_ = start_ = 0;	}	template <class Allocator>	inline	bool	operator==(const cdeque<const void*, Allocator>& x, const cdeque<const void*, Allocator>& y)	{		return x.size() == y.size() && _STD::equal(x.begin(), x.end(), y.begin());	}	template <class Allocator>	inline	bool	operator!=(const cdeque<const void*, Allocator>& x, const cdeque<const void*, Allocator>& y)	{		return !(x == y);	}	template <class Allocator>	inline	bool	operator< (const cdeque<const void*,Allocator>& x, const cdeque<const void*,Allocator>& y)	{		return _STD::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());	}	template <class Allocator>	inline	bool	operator> (const cdeque<const void*,Allocator>& x, const cdeque<const void*,Allocator>& y)	{		return y < x;	}	template <class Allocator>	inline	bool	operator>=(const cdeque<const void*,Allocator>& x, const cdeque<const void*,Allocator>& y)	{		return !(x < y);	}	template <class Allocator>	inline	bool	operator<=(const cdeque<const void*,Allocator>& x, const cdeque<const void*,Allocator>& y)	{		return !(y < x);	}	template <class Allocator>	inline	void	swap(cdeque<const void*,Allocator>& x, cdeque<const void*,Allocator>& y)	{		x.swap(y);	}	// T*	template <class T, class Allocator>	class cdeque<T*, Allocator>		: private cdeque<const void*, Allocator::rebind<const void*>::other>	{		typedef cdeque<const void*, Allocator::rebind<const void*>::other> base;		typedef base::allocator_type base_allocator;	public:		// types:		typedef typename Allocator::reference         reference;		typedef typename Allocator::const_reference   const_reference;		class                                         iterator;		class                                         const_iterator;		typedef typename Allocator::size_type         size_type;		typedef typename Allocator::difference_type   difference_type;		typedef T*                                    value_type;		typedef Allocator                             allocator_type;		typedef typename Allocator::pointer           pointer;		typedef typename Allocator::const_pointer     const_pointer;		typedef _STD::reverse_iterator<iterator>       reverse_iterator;		typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;		class iterator			: public _STD::iterator<_STD::random_access_iterator_tag, value_type,				difference_type, pointer, reference>		{		public:			iterator() {}			explicit iterator(const base::iterator& i) : i_(i) {}			operator base::iterator() const {return i_;}			reference operator * () const {return reference(*i_);}			pointer operator -> () const {return pointer(i_.operator->());}			iterator& operator ++ () {++i_; return *this;}			iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}			iterator& operator -- () {--i_; return *this;}			iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}			iterator& operator += (difference_type n) {i_ += n; return *this;}			iterator operator + (difference_type n) const {return iterator(*this) += n;}			iterator& operator -= (difference_type n) {i_ -= n; return *this;}			iterator operator - (difference_type n) const {return iterator(*this) -= n;}			difference_type operator - (const iterator& rhs) const {return i_ - rhs.i_;}			reference operator [] (difference_type i) const {return reference(i_[i]);}			friend bool operator ==(const iterator& x, const iterator& y) {return x.i_ == y.i_;}  // hh 990720			friend bool operator !=(const iterator& x, const iterator& y) {return x.i_ != y.i_;}			friend bool operator < (const iterator& x, const iterator& y) {return x.i_ <  y.i_;}			friend bool operator <=(const iterator& x, const iterator& y) {return x.i_ <= y.i_;}			friend bool operator > (const iterator& x, const iterator& y) {return x.i_ >  y.i_;}			friend bool operator >=(const iterator& x, const iterator& y) {return x.i_ >= y.i_;}			friend iterator operator + (difference_type n, const iterator& rhs)				{return iterator(rhs) += n;}		private:			base::iterator i_;			friend class cdeque::const_iterator;		};				class const_iterator			: public _STD::iterator<_STD::random_access_iterator_tag, value_type,				difference_type, const_pointer, const_reference>		{		public:			const_iterator() {}			const_iterator(const cdeque::iterator& rhs) : i_(rhs.i_) {}			explicit const_iterator(const base::const_iterator& i) : i_(i) {}			operator base::const_iterator() const {return i_;}			const_reference operator * () const {return const_reference(*i_);}			const_pointer operator -> () const {return const_pointer(i_.operator->());}			const_iterator& operator ++ () {++i_; return *this;}			const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}			const_iterator& operator -- () {--i_; return *this;}			const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}			const_iterator& operator += (difference_type n) {i_ += n; return *this;}			const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}			const_iterator& operator -= (difference_type n) {i_ -= n; return *this;}			const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}			difference_type operator - (const const_iterator& rhs) const {return i_ - rhs.i_;}			const_reference operator [] (difference_type i) const {return const_reference(i_[i]);}			friend bool operator ==(const const_iterator& x, const const_iterator& y) {return x.i_ == y.i_;}  // hh 990720			friend bool operator !=(const const_iterator& x, const const_iterator& y) {return x.i_ != y.i_;}			friend bool operator < (const const_iterator& x, const const_iterator& y) {return x.i_ <  y.i_;}			friend bool operator <=(const const_iterator& x, const const_iterator& y) {return x.i_ <= y.i_;}			friend bool operator > (const const_iterator& x, const const_iterator& y) {return x.i_ >  y.i_;}			friend bool operator >=(const const_iterator& x, const const_iterator& y) {return x.i_ >= y.i_;}			friend const_iterator operator + (difference_type n, const const_iterator& rhs)				{return const_iterator(rhs) += n;}		private:			base::const_iterator i_;		};				// cdeque.cons_ construct/copy/destroy:		explicit cdeque(const Allocator& = Allocator());		explicit cdeque(size_type n, const value_type& value = 0, const Allocator& = Allocator());	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			cdeque(InputIterator first, InputIterator last, const Allocator& a = Allocator());		template <class InputIterator> void assign(InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			cdeque(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: base(_STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),				       _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last), base_allocator(a))			{			}		template <class InputIterator>			inline			void			assign(InputIterator first, InputIterator last)			{				base::assign(_STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),				             _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));			}	#endif		void assign(size_type n, const value_type& u);		allocator_type get_allocator() const;		// iterators:		iterator               begin();		const_iterator         begin() const;		iterator               end();		const_iterator         end() const;		reverse_iterator       rbegin();		const_reverse_iterator rbegin() const;		reverse_iterator       rend();		const_reverse_iterator rend() const;		// cdeque.capacity_ capacity:		size_type size() const;		size_type max_size() const;		void      resize(size_type sz, value_type c = 0);		size_type capacity() const;		bool      empty() const;		void      reserve(size_type n);		// element access:		reference       operator[](size_type n);		const_reference operator[](size_type n) const;		const_reference at(size_type n) const;		reference       at(size_type n);		reference       front();		const_reference front() const;		reference       back();		const_reference back() const;		// cdeque.modifiers_ modifiers:		void push_front(const value_type& x);		void push_back(const value_type& x);		void pop_front();		void pop_back();		iterator insert(iterator position, const value_type& x);		void     insert(iterator position, size_type n, const value_type& x);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void insert(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void			insert(iterator position, InputIterator first, InputIterator last)			{				base::insert(position, _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),				                       _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));			}	#endif		iterator erase(iterator position);		iterator erase(iterator first, iterator last);		void     swap(cdeque&);		void     clear();	};	// Implementation cdeque<T*>	template <class T, class Allocator>	inline	cdeque<T*, Allocator>::cdeque(const Allocator& a)		: base(base_allocator(a))	{	}	template <class T, class Allocator>	inline	cdeque<T*, Allocator>::cdeque(size_type n, const value_type& value, const Allocator& a)		: base(n, value, base_allocator(a))	{	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class InputIterator>	inline	cdeque<T*, Allocator>::cdeque(InputIterator first, InputIterator last, const Allocator& a)		: base(_STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),		       _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last), base_allocator(a))	{	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	cdeque<T*, Allocator>::assign(InputIterator first, InputIterator last)	{		base::assign(_STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),		             _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));	}#endif	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::assign(size_type n, const value_type& u)	{		base::assign(n, u);	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::allocator_type	cdeque<T*, Allocator>::get_allocator() const	{		return base::get_allocator();	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::iterator	cdeque<T*, Allocator>::begin()	{		return iterator(base::begin());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::const_iterator	cdeque<T*, Allocator>::begin() const	{		return const_iterator(base::begin());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::iterator	cdeque<T*, Allocator>::end()	{		return iterator(base::end());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::const_iterator	cdeque<T*, Allocator>::end() const	{		return const_iterator(base::end());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::reverse_iterator	cdeque<T*, Allocator>::rbegin()	{		return reverse_iterator(end());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::const_reverse_iterator	cdeque<T*, Allocator>::rbegin() const	{		return const_reverse_iterator(end());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::reverse_iterator	cdeque<T*, Allocator>::rend()	{		return reverse_iterator(begin());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::const_reverse_iterator	cdeque<T*, Allocator>::rend() const	{		return const_reverse_iterator(begin());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::size_type	cdeque<T*, Allocator>::size() const	{		return base::size();	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::size_type	cdeque<T*, Allocator>::max_size() const	{		return base::max_size();	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::resize(size_type sz, value_type c)	{		base::resize(sz, c);	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::size_type	cdeque<T*, Allocator>::capacity() const	{		return base::capacity();	}	template <class T, class Allocator>	inline	bool	cdeque<T*, Allocator>::empty() const	{		return base::empty();	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::reserve(size_type n)	{		base::reserve(n);	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::reference	cdeque<T*, Allocator>::operator[](size_type n)	{		return reference(base::operator[](n));	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::const_reference	cdeque<T*, Allocator>::operator[](size_type n) const	{		return const_reference(base::operator[](n));	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::const_reference	cdeque<T*, Allocator>::at(size_type n) const	{		return const_reference(base::at(n));	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::reference	cdeque<T*, Allocator>::at(size_type n)	{		return reference(base::at(n));	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::reference	cdeque<T*, Allocator>::front()	{		return reference(base::front());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::const_reference	cdeque<T*, Allocator>::front() const	{		return const_reference(base::front());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::reference	cdeque<T*, Allocator>::back()	{		return reference(base::back());	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::const_reference	cdeque<T*, Allocator>::back() const	{		return const_reference(base::back());	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::push_front(const value_type& x)	{		base::push_front(x);	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::push_back(const value_type& x)	{		base::push_back(x);	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::pop_front()	{		base::pop_front();	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::pop_back()	{		base::pop_back();	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::iterator	cdeque<T*, Allocator>::insert(iterator position, const value_type& x)	{		return iterator(base::insert(position, x));	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::insert(iterator position, size_type n, const value_type& x)	{		base::insert(position, n, x);	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class InputIterator>	inline	void	cdeque<T*, Allocator>::insert(iterator position, InputIterator first, InputIterator last)	{		base::insert(position, _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),		                       _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));	}#endif	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::iterator	cdeque<T*, Allocator>::erase(iterator position)	{		return iterator(base::erase(position));	}	template <class T, class Allocator>	inline	typename cdeque<T*, Allocator>::iterator	cdeque<T*, Allocator>::erase(iterator first, iterator last)	{		return iterator(base::erase(first, last));	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::swap(cdeque& rhs)	{		base::swap((base&)rhs);	}	template <class T, class Allocator>	inline	void	cdeque<T*, Allocator>::clear()	{		base::clear();	}	template <class T, class Allocator>	inline	bool	operator==(const cdeque<T*, Allocator>& x, const cdeque<T*, Allocator>& y)	{		return x.size() == y.size() && _STD::equal(x.begin(), x.end(), y.begin());	}	template <class T, class Allocator>	inline	bool	operator!=(const cdeque<T*, Allocator>& x, const cdeque<T*, Allocator>& y)	{		return !(x == y);	}	template <class T, class Allocator>	inline	bool	operator< (const cdeque<T*,Allocator>& x, const cdeque<T*,Allocator>& y)	{		return _STD::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());	}	template <class T, class Allocator>	inline	bool	operator> (const cdeque<T*,Allocator>& x, const cdeque<T*,Allocator>& y)	{		return y < x;	}	template <class T, class Allocator>	inline	bool	operator>=(const cdeque<T*,Allocator>& x, const cdeque<T*,Allocator>& y)	{		return !(x < y);	}	template <class T, class Allocator>	inline	bool	operator<=(const cdeque<T*,Allocator>& x, const cdeque<T*,Allocator>& y)	{		return !(y < x);	}	template <class T, class Allocator>	inline	void	swap(cdeque<T*,Allocator>& x, cdeque<T*,Allocator>& y)	{		x.swap(y);	}#endif // !defined(_MSL_NO_PARTIAL_SPECIALIZATION) && !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_Inhibit_Container_Optimization)#ifndef _MSL_NO_CPP_NAMESPACE	} // namespace Metrowerks #endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#pragma enumsalwaysint reset#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#pragma bool reset#endif#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endif#pragma options align=reset#endif // RC_INVOKED#endif // _CDEQUE// hh 981005 rewrote// hh 981208 changed static_cast to reinterpret_cast on the value_type (pointer specialization only)// hh 981220 Rewrote iterators to gain higher performance// hh 981220 Added typename to appropriate return types// hh 981220 Modifed some method signitures to simplified syntax// hh 981220 Added class modifier to several friend declarations// hh 990120 changed names of MSIPL flags.// hh 990720 Made iterator comparison functions global friends// hh 990825 changed void* to const void*// hh 990826 Seperated out calls involving T()// hh 991116 Fixed pointer conversion bug in T* specialization by introducing __convert_iterator// hh 000129 Moved into namespace Metrowerks// hh 000129 Renamed to cdeque.