/* *	CFM68K_Startup.c		-	Default init/startup/termination routines for Metrowerks C++ (CFM68K) *								Cloned from the PPC runtime version * *	Copyright © 1993-1997 Metrowerks, Inc. All Rights Reserved. * * *	THEORY OF OPERATION * *	This version of the CFM68K startup code is intended to be used for stand-alone *	applications, shared libraries, and dropins that consist of a single fragment, *	with well-defined entry and exit points. It is not to be used for multi-fragment *	programs which may throw exceptions across fragment boundaries. * *	The startup file defines 3 entry-points: * *		__start			This should be the Main Entry-Point for an Application. *						It is not used for Shared Libraries or DropIns. *						__start() sets up the exception-handling info, calls all *						static initializers, calls main(), and calls exit() *						to terminate the program. (Monolithic applications need *						not un-register the exception-handling info) * *		__initialize	This should be the Initialization Entry-Point for a *						Shared Library or DropIn. It must not be used for Applications. *						__initialize() registers the exception-handling info for *						the shared library or dropin, and calls all static initializers. * *		__terminate		This should be the Termination Entry-Point for a *						Shared Library or DropIn. It must not be used for Applications. *						__terminate() calls all destructors for static/global objects, *						then unregisters the exception-handling info for the *						shared library or dropin before the fragment is unloaded. * *	The new zero-runtime-overhead exception-handling mechanism requires that we *	keep track of all loaded fragments and their code/data section ranges--we *	cannot use the OS data structures to do this--so we must call routines which *	register and unregister the exception-handling info as a fragment is loaded/unloaded. * */#include <CodeFragments.h>#include <Exception68K.h>#include <NMWException.h>#include <stdlib.h>#include <Types.h>	/*	external data	*/extern far segment_map SEGMAPNAME[];	/*	private data	*/static long fragmentID;						/*	ID given to fragment by exception-handling	*/	/*	prototypes	*/#ifdef __cplusplusextern "C" {#endif#pragma internal onvoid __InitCode__(void);#pragma internal resetlong main(long argc, char **argv);pascal OSErr __initialize(const CFragInitBlock *theInitBlock);pascal void __terminate(void);pascal void __start(void);#ifdef __cplusplus}#endifchar *GetA5TOC(void) = 0x200D;			/* move.l a5,d0 *//* *	The linker will replace this dummy routine with a linker generated routine containing *	a list of calls to all our static initialization routines ... * *					MOVEA.L		(A1),A5 *					LINK		A6,#$FFF8 *					BSR.L		__InitCode0__ *					... *					BSR.L		__InitCodeN__ *					UNLK		A6 *					RTS * *	NB: for now this will only work under the single segment model */void __InitCode__(void){}/* *	__initialize	-	Default initialization routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF initialization routine in the container *	for any monolithic shared-library or drop-in. * *	1.	Register the exception-handling info for the shared library or dropin *	2.	Call all static initializers * */pascal OSErr __initialize(const CFragInitBlock *theInitBlock){#pragma unused (theInitBlock)	/* register this code fragment with the Exception Handling mechanism */	fragmentID = __register_fragment(SEGMAPNAME, GetA5TOC());		/* call all static initializers */	__InitCode__();		/* return success to Code Fragment Manager */	return(noErr);}/* *	__start	-	Default startup routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF main routine in the container *	for any monolithic application. The program startup/termination sequence is: * *	1.	Register the exception-handling info for the application *	2.	Call all static initializers *	3.	Set up default values for 'argc' and 'argv' and call main() *	4.	Call exit() to perform required cleanup and termination, including *		destroying all static objects, closing open files, closing console window, etc. * *	We defer all details of proper program termination to the ANSI exit() routine. * */pascal void __start(void){	char *argv = 0;	/* register this code fragment with the Exception Handling mechanism */	fragmentID = __register_fragment(SEGMAPNAME, GetA5TOC());		/* call all static initializers */	__InitCode__();		/* call main(argc, argv) */	main(0L, &argv);		/* call exit() to terminate the program properly--will not return */	exit(0);		/* unregister this code fragment with the Exception Handling mechanism */	__unregister_fragment(fragmentID);}/* *	__terminate	-	Default termination routine for Metrowerks C++ (PowerPC) * *	This routine should be specified as the PEF termination routine in the container *	for any monolithic shared-library or drop-in. * *	1.	Destroy all static objects *	2.	Un-register the exception-handling info for the shared library or dropin * */pascal void __terminate(void){	/* destroy all static objects */	__destroy_global_chain();		/* unregister this code fragment with the Exception Handling mechanism */	__unregister_fragment(fragmentID);}