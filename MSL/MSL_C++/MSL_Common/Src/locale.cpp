/*  Metrowerks Standard Library  *//*  $Date: 2000/06/09 19:25:32 $  *  $Revision: 1.1.8.3 $  *  $NoKeywords: $  * *		Portions Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//** **  locale.cpp **/#include <locale>#ifndef _MSL_NO_IO#include <ios>#include <streambuf>#include <stdexcept>#include <typeinfo>#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#if _MSL_FORCE_ENUMS_ALWAYS_INT		#pragma enumsalwaysint on	#else		#pragma enumsalwaysint off	#endif#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT		#pragma bool on	#else		#pragma bool off	#endif#endif#ifndef _MSL_NO_CPP_NAMESPACE	namespace std {#endif#ifndef _MSL_NO_LOCALEsize_t locale::id::id_count_s = 0;_RefCountedPtr<__locale_imp<true> > locale::global_s;#ifdef _MSL_NO_MEMBER_TEMPLATE	#define MAKE_LOCALE(MyFacet)                              \		locale::locale(const locale& other, MyFacet* f)       \		{                                                     \			if (f == 0)                                       \				imp_ = other.imp_;                            \			else {                                            \				imp_ = new __locale_imp<true>(*other.imp_);   \				imp_->replace(*f);                            \				imp_->name() = "*";                           \			}                                                 \		}	MAKE_LOCALE(_STD::collate<char>)	MAKE_LOCALE(_STD::ctype<char>)	typedef _STD::codecvt<char, char, mbstate_t> __codecvt1;	MAKE_LOCALE(__codecvt1)	MAKE_LOCALE(_STD::numpunct<char>)	MAKE_LOCALE(_STD::num_get<char>)	typedef _STD::num_get<char, char*> __num_get1;	MAKE_LOCALE(__num_get1)	MAKE_LOCALE(_STD::num_put<char>)	MAKE_LOCALE(_STD::timepunct<char>)	MAKE_LOCALE(_STD::time_get<char>)	MAKE_LOCALE(_STD::time_put<char>)	MAKE_LOCALE(_STD::moneypunct<char>)	typedef _STD::moneypunct<char, true> __moneypunct1;	MAKE_LOCALE(__moneypunct1)	MAKE_LOCALE(_STD::money_get<char>)	MAKE_LOCALE(_STD::money_put<char>)	#ifndef _MSL_NO_WCHART		MAKE_LOCALE(_STD::collate<wchar_t>)		MAKE_LOCALE(_STD::ctype<wchar_t>)		typedef _STD::codecvt<wchar_t, char, mbstate_t> __codecvt2;		MAKE_LOCALE(__codecvt2)		MAKE_LOCALE(_STD::numpunct<wchar_t>)		MAKE_LOCALE(_STD::num_get<wchar_t>)		MAKE_LOCALE(_STD::num_put<wchar_t>)		MAKE_LOCALE(_STD::timepunct<wchar_t>)		MAKE_LOCALE(_STD::time_get<wchar_t>)		MAKE_LOCALE(_STD::time_put<wchar_t>)		MAKE_LOCALE(_STD::moneypunct<wchar_t>)		typedef _STD::moneypunct<wchar_t, true> __moneypunct2;		MAKE_LOCALE(__moneypunct2)		MAKE_LOCALE(_STD::money_get<wchar_t>)		MAKE_LOCALE(_STD::money_put<wchar_t>)	#endif	#undef MAKE_LOCALE#endif#ifdef _MSL_NO_MEMBER_TEMPLATE	bool	locale::operator()(const string& s1, const string& s2) const	{		return _USE_FACET(_STD::collate<char>, *this).compare(			s1.data(), s1.data()+s1.size(), s2.data(), s2.data()+s2.size()		) < 0;	}	#ifndef _MSL_NO_WCHART		bool		locale::operator()(const wstring& s1, const wstring& s2) const		{			return _USE_FACET(_STD::collate<wchar_t>, *this).compare(				s1.data(), s1.data()+s1.size(), s2.data(), s2.data()+s2.size()			) < 0;		}	#endif#endiflocalelocale::global(const locale& loc){	_RefCountedPtr<__locale_imp<true> > result = global_s;	if (result == 0)		result = classic().imp_;	global_s = loc.imp_;	if (loc.name() != "*")		setlocale(LC_ALL, loc.name().c_str());	return locale(result);}const locale&locale::classic(){	static locale C = make_classic();	return C;}localelocale::make_classic(){	_RefCountedPtr<__locale_imp<true> > result = new __locale_imp<true>;	result->name() = "C";	return locale(result);}#ifndef _MSL_NO_WCHART	// ctype<wchar_t>	template<>	locale::id ctype<wchar_t>::id;	// hh 980803 added.  non-standard	template<>	wstring	ctype<wchar_t>::widen(const string& s) const	{		wstring result;		result.resize(s.size());		const char* s0 = s.c_str();		widen(s0, s0 + s.size(), &result[0]);		return result;	}	template<>	const wchar_t*	ctype<wchar_t>::do_is(const wchar_t* low, const wchar_t* high, mask* vec) const	{		const wchar_t* p;		for (p = low; p < high; ++p)			vec[p-low] = classify(*p);		return high;	}	template<>	const wchar_t*	ctype<wchar_t>::do_scan_is(mask m, const wchar_t* low, const wchar_t* high) const	{		const wchar_t* p;		for (p = low; p < high; ++p)			if (classify(*p) & m)				break;		return p;	}	template<>	const wchar_t*	ctype<wchar_t>::do_scan_not(mask m, const wchar_t* low, const wchar_t* high) const	{		const wchar_t* p;		for (p = low; p < high; ++p)			if (!(classify(*p) & m))				break;		return p;	}	template<>	const wchar_t*	ctype<wchar_t>::do_toupper(wchar_t* low, const wchar_t* high) const	{		for (;low < high; ++low)			*low = towupper(*low);		return high;	}	template<>	const wchar_t*	ctype<wchar_t>::do_tolower(wchar_t* low, const wchar_t* high) const	{		for (;low < high; ++low)			*low = towlower(*low);		return high;	}	template<>	const char*	ctype<wchar_t>::do_widen(const char* low, const char* high, wchar_t* dest) const	{		while (low < high)			*dest++ = wchar_t(*low++);		return high;	}	template<>	const wchar_t*	ctype<wchar_t>::do_narrow(const wchar_t* low, const wchar_t* high, char dfault, char* dest) const	{		while (low < high)			*dest++ = do_narrow(*low++, dfault);		return high;	}	// hh 990330	template<>	ctype_base::mask	ctype<wchar_t>::classify(wchar_t c) const	{		if (iswpunct(c))			return punct;		bool cn = (bool)iswcntrl(c);		bool s = (bool)iswspace(c);		if (cn & !s)			return mask(0x01);		else if (cn & s)			return mask(0x02);		else if (!cn & s)			return mask(0x04);		if (iswxdigit(c))		{			if (iswdigit(c))				return mask(xdigit | digit);			if (iswlower(c))				return mask(xdigit | lower);			return mask(xdigit | upper);		}		if (iswlower(c))			return lower;		if (iswupper(c))			return upper;		return mask(0);	}#endif// ctype<char>// hh 990109#define __ct ctype_base::mask(0x01)#define __mt ctype_base::mask(0x02)#define __sp ctype_base::mask(0x04)#define __pt ctype_base::mask(0x08)#define __hd ctype_base::mask(0x30)#define __lw ctype_base::mask(0x40)#define __up ctype_base::mask(0x80)#define __hl ctype_base::mask(0x60)#define __hu ctype_base::mask(0xA0)ctype_base::mask __mask_map[ctype<char>::table_size] ={//	 -0    -1    -2    -3    -4    -5    -6    -7    -8    -9    -A    -B    -C    -D    -E    -F	__ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __mt, __mt, __mt, __mt, __mt, __ct, __ct, // 0-	__ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, __ct, // 1-	__sp, __pt, __pt, __pt, __pt, __pt, __pt, __pt, __pt, __pt, __pt, __pt, __pt, __pt, __pt, __pt, // 2-	__hd, __hd, __hd, __hd, __hd, __hd, __hd, __hd, __hd, __hd, __pt, __pt, __pt, __pt, __pt, __pt, // 3-	__pt, __hu, __hu, __hu, __hu, __hu, __hu, __up, __up, __up, __up, __up, __up, __up, __up, __up, // 4-	__up, __up, __up, __up, __up, __up, __up, __up, __up, __up, __up, __pt, __pt, __pt, __pt, __pt, // 5-	__pt, __hl, __hl, __hl, __hl, __hl, __hl, __lw, __lw, __lw, __lw, __lw, __lw, __lw, __lw, __lw, // 6-	__lw, __lw, __lw, __lw, __lw, __lw, __lw, __lw, __lw, __lw, __lw, __pt, __pt, __pt, __pt, __ct  // 7-};template <>ctype<char>::ctype(const mask* tab, bool del, size_t refs)	: locale::facet(refs),	table_(tab),	owns_(del){	if (table_ == 0)	{		table_ = classic_table();		owns_ = false;	}}template <>ctype<char>::~ctype(){	if (owns_)		delete [] table_;}template<>const char*ctype<char>::is(const char* low, const char* high, mask* vec) const{	for (const char* p = low; p < high; ++low)		vec[p-low] = table_[(unsigned char)*p];	return high;}template<>const char*ctype<char>::scan_is(mask m, const char* low, const char* high) const{	const char* p;	for (p = low; p < high; ++p)		if (table_[(unsigned char)*p] & m)			break;	return p;}template<>const char*ctype<char>::scan_not(mask m, const char* low, const char* high) const{	const char* p;	for (p = low; p < high; ++p)		if (!(table_[(unsigned char)*p] & m))			break;	return p;}template<>locale::id ctype<char>::id;template<>const char*ctype<char>::do_toupper(char* low, const char* high) const{	for (;low < high; ++low)		*low = char(_CSTD::toupper(*low));	return high;}template<>const char*ctype<char>::do_tolower(char* low, const char* high) const{	for (;low < high; ++low)		*low = char(_CSTD::tolower(*low));	return high;}// ctype_byname<char>template<>ctype_byname<char>::ctype_byname(const char* name, size_t refs)	: ctype(0, false, refs),	loc_(name),	facet_(_USE_FACET(ctype<char>, loc_)){}// codecvt<char, char, mbstate_t>template <>codecvt<char, char, mbstate_t>::codecvt(size_t refs)	: _Generic_codecvt(refs){}template <>locale::id codecvt<char, char, mbstate_t>::id;// hh 990109  No longer used//	template <>//	codecvt_base::result//	codecvt<char, char, mbstate_t>::do_nothing(//		const char* from, const char* from_end, const char*& from_next,//		char* to, char* to_limit, char*& to_next) const//	{//		size_t len = size_t(from_end - from);//		size_t temp = size_t(to_limit - to);//		result r = noconv;//		if (len > temp)//			len = temp;//		from_next = from;//		to_next = to;//		memcpy(to, from, len);//		return r;//	}#ifndef _MSL_NO_WCHART	// codecvt<wchar_t, char, mbstate_t>	template <>	codecvt<wchar_t, char, mbstate_t>::codecvt(size_t refs)		: _Generic_codecvt(refs)	{	}	template <>	locale::id codecvt<wchar_t, char, mbstate_t>::id;	template <>	codecvt_base::result	codecvt<wchar_t, char, mbstate_t>::do_out(mbstate_t&,		const wchar_t* from, const wchar_t* from_end, const wchar_t*& from_next,		char* to, char* to_limit, char*& to_next) const	{		size_t fromlen = size_t(from_end - from);		size_t tolen = size_t(to_limit - to);		size_t n = fromlen * sizeof(wchar_t);		result r = ok;		if (tolen < n)		{			r = partial;			fromlen = tolen / sizeof(wchar_t);			if (fromlen == 0)				return error;			n = fromlen * sizeof(wchar_t);		}		tolen = n;		memcpy(to, from, n);		from_next = from + fromlen;		to_next = to + tolen;		return r;	}	template <>	codecvt_base::result	codecvt<wchar_t, char, mbstate_t>::do_in(mbstate_t&,		const char* from, const char* from_end, const char*& from_next,		wchar_t* to, wchar_t* to_limit, wchar_t*& to_next) const	{		size_t fromlen = size_t(from_end - from);		if (fromlen % sizeof(wchar_t) != 0)			return error;		size_t tolen = size_t(to_limit - to);		size_t n = fromlen;		result r = ok;		if (tolen * sizeof(wchar_t) < n)		{			r = partial;			fromlen = n = tolen * sizeof(wchar_t);			if (fromlen == 0)				return error;		}		else			tolen = n / sizeof(wchar_t);		memcpy(to, from, n);		from_next = from + fromlen;		to_next = to + tolen;		return r;	}#endif// numpunct<char>template <>numpunct<char>::numpunct(size_t refs)	: _Generic_numpunct(refs){}template <>locale::id numpunct<char>::id;#ifndef _MSL_NO_WCHART	// numpunct<wchar_t>	template <>	numpunct<wchar_t>::numpunct(size_t refs)		: _Generic_numpunct(refs)	{	}	template <>	locale::id numpunct<wchar_t>::id;#endif// timepunct<char>template <>timepunct<char>::timepunct(size_t refs)	: _Generic_timepunct(refs){}template <>locale::id timepunct<char>::id;template <>const char*timepunct<char>::do_weekday_name(size_t d) const{	static const char* name[] = {		"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", ""	};	if (d < 7)		return name[d];	return name[7];}template <>const char*timepunct<char>::do_month_name(size_t m) const{	static const char* name[] = {		"January", "February", "March", "April", "May", "June",		"July", "August", "September", "October", "November", "December", ""	};	if (m < 12)		return name[m];	return name[12];}template <>const char*timepunct<char>::do_am_pm(int hour) const{	static const char* name[] = {"am", "pm"};	return name[hour/12];}#ifndef _MSL_NO_WCHART	// timepunct<wchar_t>	template <>	timepunct<wchar_t>::timepunct(size_t refs)		: _Generic_timepunct(refs)	{	}	template <>	locale::id timepunct<wchar_t>::id;	template <>	const wchar_t*	timepunct<wchar_t>::do_weekday_name(size_t d) const	{		static const wchar_t* name[] = {			L"Sunday", L"Monday", L"Tuesday", L"Wednesday", L"Thursday", L"Friday", L"Saturday", L""		};		if (d < 7)			return name[d];		return name[7];	}	template <>	const wchar_t*	timepunct<wchar_t>::do_month_name(size_t m) const	{		static const wchar_t* name[] = {			L"January", L"February", L"March", L"April", L"May", L"June",			L"July", L"August", L"September", L"October", L"November", L"December", L""		};		if (m < 12)			return name[m];		return name[12];	}	template <>	const wchar_t*	timepunct<wchar_t>::do_am_pm(int hour) const	{		static const wchar_t* name[] = {L"am", L"pm"};		return name[hour/12];	}#endif// moneypunct<char, false>template <>moneypunct<char, false>::moneypunct(size_t refs)	: _Generic_moneypunct(refs){}template <>locale::id moneypunct<char, false>::id;// moneypunct<char, true>template <>moneypunct<char, true>::moneypunct(size_t refs)	: _Generic_moneypunct(refs){}template <>locale::id moneypunct<char, true>::id;#ifndef _MSL_NO_WCHART	// moneypunct<wchar_t, false>	template <>	moneypunct<wchar_t, false>::moneypunct(size_t refs)		: _Generic_moneypunct(refs)	{	}	template <>	locale::id moneypunct<wchar_t, false>::id;	// moneypunct<wchar_t, true>	template <>	moneypunct<wchar_t, true>::moneypunct(size_t refs)		: _Generic_moneypunct(refs)	{	}	template <>	locale::id moneypunct<wchar_t, true>::id;#endif#endif  // _MSL_NO_LOCALE#ifndef _No_Floating_Point	// Binary Coded Decimal class	// hh 980802 Added to assist in the printing of floating point values#ifdef _MSL_EXTENDED_PRECISION_OUTP	_BCD::_BCD(size_t x)		: exp_(0)	{		for (; x != 0; x /= 10)			mantissa_ += char(x % 10);		reverse(mantissa_.begin(), mantissa_.end());		if (mantissa_.size() > 0)			exp_ = short(mantissa_.size() - 1);	}#endif	_BCD::_BCD(long double x, int limit)		: exp_(0)	{	// hh 990401	#ifdef _MSL_EXTENDED_PRECISION_OUTP		if (limit <= DECIMAL_DIG)		{	#else		limit;	#endif			char buff[40];			sprintf(buff, "%#.*Le", 31,  x);			mantissa_ = buff;			// Get exponent			string::iterator i = mantissa_.begin() + 35;			while (i != mantissa_.end())			{				exp_ *= 10;				exp_ += short(*i - '0');				++i;			}			i = mantissa_.begin() + 34;			if (*i == '-')				exp_ = short(-exp_);			--i;			// Remove exponent and decimal point			mantissa_.erase(i, mantissa_.end());			mantissa_.erase(mantissa_.begin() + 1);			for (i = mantissa_.begin(); i != mantissa_.end(); ++i)				*i -= '0';	#ifdef _MSL_EXTENDED_PRECISION_OUTP		}		else		{			if (x > 0)			{				int exp;				long double frac = frexpl(x, &exp);				_BCD scale = __two_exp(short(exp));				const short num_bits_extract = numeric_limits<size_t>::digits;				const _BCD inc_scale = __two_exp(-num_bits_extract);				_BCD temp;				while (frac != 0)				{					long double integer;					frac = modfl(ldexpl(frac, num_bits_extract), &integer);					scale *= inc_scale;					if (integer != 0)					{						temp = scale;						temp *= _BCD((size_t)integer);						*this += temp;					}				}			}		}	#endif	}	string	_BCD::to_string(int precision, int& exponent) const	{				string result(mantissa_, 0, size_t(precision+1));		exponent = exp_;		string::iterator i = result.end() - 1;		if (precision < result.size())		{			if (*i >= 5)			{				--i;				while (true)				{					if (*i < 9)					{						(*i)++;						break;					}					*i = char();					if (i == result.begin())					{						result.insert(result.begin(), char(1));						result.resize(result.size()-1);						++exponent;						break;					}					--i;				}			}			result.resize(result.size()-1);		}		string::iterator e = result.end();		for (i = result.begin(); i < e; ++i)			*i += '0';		return result;	}	long double	_BCD::to_long_double() const	{		if (mantissa_.size() == 0)			return 0;	#if 1		string str(mantissa_);		string::iterator e = str.end();		for (string::iterator i = str.begin(); i < e; ++i)			*i += '0';		str.insert(1, 1, '.');		if (exp_ != 0)		{			str.append(1, 'e');			if (exp_ >= 0)				str.append(1, '+');			else				str.append(1, '-');			int exp = abs(int(exp_));			string::size_type e1 = str.size();			while (exp > 0)			{				str.append(1, char(exp % 10 + '0'));				exp /= 10;			}			reverse(str.begin() + e1, str.end());		}		return strtod(str.c_str(), 0);	#else		string::const_iterator e = mantissa_.end();		string::const_iterator i = mantissa_.begin();		long double first_guess = *i;		int exponent = exp_;		for (++i; i < e; ++i)		{			long double temp1 = first_guess * 10;			long double temp2 = temp1 + *i;			if (*i != 0 && temp1 == temp2)				break;			first_guess = temp2;			--exponent;		}		first_guess = ldexp(first_guess, exponent);		if (exponent < 0)			first_guess /= pow(5.L, -exponent);		else			first_guess *= pow(5.L, exponent);		_BCD feedback1(first_guess);		if (feedback1 == *this || isinf(first_guess))			return first_guess;		if (feedback1 < *this)		{			long double next_guess = nextafter(first_guess, static_cast<long double>(INFINITY));			if (isinf(next_guess))				return next_guess;			_BCD feedback2(next_guess);			while (feedback2 < *this)			{				feedback1 = feedback2;				first_guess = next_guess;				next_guess = nextafter(next_guess, static_cast<long double>(INFINITY));				if (isinf(next_guess))					return next_guess;				feedback2 = _BCD(next_guess);			}			_BCD difflow = *this - feedback1;			_BCD diffhigh = feedback2 - *this;			if (difflow <= diffhigh)				return first_guess;			return next_guess;		}		long double next_guess = nextafter(first_guess, static_cast<long double>(-INFINITY));		_BCD feedback2(next_guess);		while (feedback2 > *this)		{			feedback1 = feedback2;			first_guess = next_guess;			next_guess = nextafter(next_guess, static_cast<long double>(-INFINITY));			feedback2 = _BCD(next_guess);		}		_BCD difflow = *this - feedback2;		_BCD diffhigh = feedback1 - *this;		if (difflow <= diffhigh)			return next_guess;		return first_guess;	#endif	}#ifdef _MSL_EXTENDED_PRECISION_OUTP	_BCD::_BCD(const char* mantissa, int exponent)		: mantissa_(mantissa),		  exp_((short)exponent)	{		string::iterator i = mantissa_.begin();		string::iterator e = mantissa_.end();		while (i < e)			*i++ -= '0';		trim();	}	_BCD&	_BCD::operator += (_BCD rhs)	{		if (rhs.mantissa_.size() == 0)			return *this;		if (mantissa_.size() == 0)		{			*this = rhs;			return *this;		}		if (exp_ > rhs.exp_)		{			rhs.mantissa_.insert(rhs.mantissa_.begin(), size_t(exp_ - rhs.exp_), char());			rhs.exp_ = exp_;		}		else if (exp_ < rhs.exp_)		{			mantissa_.insert(mantissa_.begin(), size_t(rhs.exp_ - exp_), char());			exp_ = rhs.exp_;		}		if (rhs.mantissa_.size() > mantissa_.size())			mantissa_.resize(rhs.mantissa_.size(), char());		else if (rhs.mantissa_.size() < mantissa_.size())			rhs.mantissa_.resize(mantissa_.size(), char());		string::iterator i = mantissa_.end() - 1;		string::iterator b = mantissa_.begin();		string::const_iterator j = rhs.mantissa_.end() - 1;		char carry = char();		for (; i > b; --i, --j)		{			*i += char(*j + carry);			if (*i > 9)			{				carry = char(*i / 10);				*i %= char(10);			}			else				carry = char();		}		*i += char(*j + carry);		if (*i > 9)		{			carry = char(*i / 10);			*i %= char(10);			mantissa_.insert(b, carry);			++exp_;		}		trim();		return *this;	}	_BCD&	_BCD::operator -= (_BCD rhs)	{		if (rhs.mantissa_.size() == 0)			return *this;		if (exp_ > rhs.exp_)		{			rhs.mantissa_.insert(rhs.mantissa_.begin(), size_t(exp_ - rhs.exp_), char());			rhs.exp_ = exp_;		}		if (rhs.mantissa_.size() > mantissa_.size())			mantissa_.resize(rhs.mantissa_.size(), char());		else if (rhs.mantissa_.size() < mantissa_.size())			rhs.mantissa_.resize(mantissa_.size(), char());		string::iterator i = mantissa_.end() - 1;		string::iterator b = mantissa_.begin();		string::const_iterator j = rhs.mantissa_.end() - 1;		for (; i > b; --i, --j)		{			if (*i < *j)			{				string::iterator k = i - 1;				while (*k == 0)					--k;				while (k != i)				{					--*k;					*++k += char(10);				}			}			*i -= *j;		}		*i -= *j;		for (; *i == 0; ++i)			{}		if (i > b)		{			exp_ -= static_cast<short>(i-b);			mantissa_.erase(b, i);		}		trim();		return *this;	}	_BCD&	_BCD::operator *= (_BCD rhs)	{	// hh 990401		if (mantissa_.size() == 0)			return *this;		if (rhs.mantissa_.size() == 0)		{			*this = rhs;			return *this;		}		_BCD lhs(*this);		unsigned long accumulator = 0;		long lhs_sz = static_cast<long>(lhs.mantissa_.size());		long rhs_sz = static_cast<long>(rhs.mantissa_.size());		string::const_iterator lhs_beg = lhs.mantissa_.begin();		string::const_iterator rhs_beg = rhs.mantissa_.begin();		mantissa_.clear();		mantissa_.resize(static_cast<string::size_type>(lhs_sz + rhs_sz - 1), char());		string::iterator ip = mantissa_.end();		for (long i = (long)mantissa_.size()-1; i >= 0; --i)		{			long k = rhs_sz - 1;			long j = i - k;			if (j < 0)			{				j = 0;				k = i;			}			string::const_iterator jp = lhs_beg + j;			string::const_iterator kp = rhs_beg + k + 1;			for (; j < lhs_sz && k >= 0; --k, ++j, ++jp)				accumulator += (unsigned long)*jp * *--kp;			*--ip = char(accumulator % 10);			accumulator /= 10;		}		exp_ = short(lhs.exp_ + rhs.exp_);		while (accumulator > 0)		{			mantissa_.insert(mantissa_.begin(), char(accumulator % 10));			accumulator /= 10;			++exp_;		}		trim();		return *this;	}	_BCD	__two_exp(short x)	{		static const _BCD one_half("5", -1);		static const _BCD two("2", 0);		switch (x)		{		case -64:			{			static const _BCD one_two_to_the_negative_sixtyfourth("542101086242752217003726400434970855712890625", -20);			return one_two_to_the_negative_sixtyfourth;			}		case -53:			{			static const _BCD one_two_to_the_negative_fiftythird("11102230246251565404236316680908203125", -16);			return one_two_to_the_negative_fiftythird;			}		case -32:			{			static const _BCD one_two_to_the_negative_thirtysecond("23283064365386962890625", -10);			return one_two_to_the_negative_thirtysecond;			}		case -16:			{			static const _BCD one_two_to_the_negative_sixteenth("152587890625", -5);			return one_two_to_the_negative_sixteenth;			}		case -8:			{			static const _BCD one_twohundredfiftysixth("390625", -3);			return one_twohundredfiftysixth;			}		case -7:			{			static const _BCD one_onehundredtwentyeighth("78125", -3);			return one_onehundredtwentyeighth;			}		case -6:			{			static const _BCD one_sixtyfourth("15625", -2);			return one_sixtyfourth;			}		case -5:			{			static const _BCD one_thirtysecond("3125", -2);			return one_thirtysecond;			}		case -4:			{			static const _BCD one_sixteenth("625", -2);			return one_sixteenth;			}		case -3:			{			static const _BCD one_eighth("125", -1);			return one_eighth;			}		case -2:			{			static const _BCD one_fourth("25", -1);			return one_fourth;			}		case -1:			return one_half;		case 0:			{			static const _BCD one("1", 0);			return one;			}		case 1:			return two;		case 2:			{			static const _BCD four("4", 0);			return four;			}		case 3:			{			static const _BCD eight("8", 0);			return eight;			}		case 4:			{			static const _BCD sixteen("16", 1);			return sixteen;			}		case 5:			{			static const _BCD thirtytwo("32", 1);			return thirtytwo;			}		case 6:			{			static const _BCD sixtyfour("64", 1);			return sixtyfour;			}		case 7:			{			static const _BCD onehundredtwentyeight("128", 2);			return onehundredtwentyeight;			}		case 8:			{			static const _BCD twohundredfiftysix("256", 2);			return twohundredfiftysix;			}		}		_BCD temp = __two_exp(short(x/2));		temp *= temp;		if (x % 2)		{			if (x > 0)				temp *= two;			else				temp *= one_half;		}		return temp;	}	bool	operator < (const _BCD& x, const _BCD& y)	{		bool x_zero = x.mantissa_.empty();		bool y_zero = y.mantissa_.empty();		if (x_zero && !y_zero)			return true;		if (x_zero && y_zero)			return false;		if (y_zero)			return false;		return x.exp_ < y.exp_ || x.exp_ == y.exp_ && x.mantissa_ < y.mantissa_;	}#endif // _MSL_EXTENDED_PRECISION_OUTP#endif // _No_Floating_Point#ifndef _MSL_NO_CPP_NAMESPACE	}#endif#endif // _MSL_NO_IO// hh 980811 reworded dhex, uhex and lhex defines// hh 980816 ARM/Standard neutral for-scoping// hh 980902 #ifdef'd out exception code when ndef MSIPL_EXCEPT// hh 980915 Modified file so that it would work without MSIPL_EXPLICIT_FUNC_TEMPLATE_ARG// hh 981018 Modified _BCD helper class to not round if it uses sprintf// hh 981111 Removed dependence on compiler support for default template args in string declarations// hh 990109 Created a C lib independent ctype_base::mask (suggested by bc).// hh 990109 do_nothing no longer used// hh 990120 changed name of MSIPL flags// hh 990328 Fixed bug in floating point output rounding// hh 990330 Rewrote classify().  It was completely bonkers// hh 990401 _BCD::operator *= uses a long long.  Put this and any code that uses it//           inside of #ifdef __MSL_LONGLONG_SUPPORT__// hh 000130 Installed _MSL_NO_LOCALE// hh 000130 Installed _MSL_EXTENDED_PRECISION_OUTP// hh 000604 Rewrote codecvt<wchar_t, char, mbstate_t>::do_in and do_out.