// ===========================================================================//	LPeriodical.cp				PowerPlant 2.1		й1993-1999 Metrowerks Inc.// ===========================================================================////	An abstract building block class for objects that want to receive a//	function call at regular intervals////	ее Queues//	This class maintains two static queues: Idler and Repeater. You//	add/remove Periodicals from these queues using StartIdling/StopIdling//	and StartRepeating/StopRepeating.////	Calling DevoteTimeToIdlers/DevoteTimeToRepeaters calls the SpendTime//	function for each Periodical in the respective Queue.////	It is up to the caller (Client) to determine the meaning of each//	Queue and when to devote time to the Periodicals in them. The//	PowerPlant LApplication class devotes time to Idlers at Null Event//	time, and devotes time to Repeaters after every event.////	ее Derived Classes//	Classes derived from LPeriodical must define a SpendTime function, as//	this is a pure virtual function in LPeriodical.#ifdef PowerPlant_PCH	#include PowerPlant_PCH#endif#include <LPeriodical.h>#include <TArrayIterator.h>PP_Begin_Namespace_PowerPlant// ---------------------------------------------------------------------------//	Class VariablesTArray<LPeriodical*>*	LPeriodical::sIdlerQ = nil;TArray<LPeriodical*>*	LPeriodical::sRepeaterQ = nil;// ---------------------------------------------------------------------------//	е LPeriodical							Default Constructor		  [public]// ---------------------------------------------------------------------------LPeriodical::LPeriodical(){}// ---------------------------------------------------------------------------//	е ~LPeriodical							Destructor				  [public]// ---------------------------------------------------------------------------LPeriodical::~LPeriodical(){	StopIdling();	StopRepeating();}#pragma mark -// ---------------------------------------------------------------------------//	е StartIdling													  [public]// ---------------------------------------------------------------------------//	Put Periodical in the Idler queuevoidLPeriodical::StartIdling(){	if (sIdlerQ == nil) {			// Create queue if it doesn't exist		sIdlerQ = new TArray<LPeriodical*>;	}									// Add to end of Idler queue if it isn't									//   already in there	if (sIdlerQ->FetchIndexOf(this) == LArray::index_Bad) {		sIdlerQ->AddItem(this);	}}// ---------------------------------------------------------------------------//	е StopIdling													  [public]// ---------------------------------------------------------------------------//	Remove Periodical from the Idler queuevoidLPeriodical::StopIdling(){	if (sIdlerQ != nil) {		sIdlerQ->Remove(this);	}}// ---------------------------------------------------------------------------//	е IsIdling														  [public]// ---------------------------------------------------------------------------//	Return whether a Periodical is in the Idler queueboolLPeriodical::IsIdling() const{	return ( (sIdlerQ != nil)  &&			 sIdlerQ->ContainsItem(const_cast<LPeriodical*>(this)) );}// ---------------------------------------------------------------------------//	е DevoteTimeToIdlers									 [static] [public]// ---------------------------------------------------------------------------//	Call SpendTime function for each Periodical in the Idler queuevoidLPeriodical::DevoteTimeToIdlers(	const EventRecord&	inMacEvent){	if (sIdlerQ != nil) {		TArrayIterator<LPeriodical*> iterator(*sIdlerQ);		LPeriodical	*theIdler;		while (iterator.Next(theIdler)) {			theIdler->SpendTime(inMacEvent);		}	}}#pragma mark -// ---------------------------------------------------------------------------//	е StartRepeating												  [public]// ---------------------------------------------------------------------------//	Put Periodical in the Repeater queuevoidLPeriodical::StartRepeating(){	if (sRepeaterQ == nil) {		// Create queue if it doesn't exist		sRepeaterQ = new TArray<LPeriodical*>;	}									// Add to end of Repeater queue if it									//   isn't already in there	if (sRepeaterQ->FetchIndexOf(this) == LArray::index_Bad) {		sRepeaterQ->AddItem(this);	}}// ---------------------------------------------------------------------------//	е StopRepeating													  [public]// ---------------------------------------------------------------------------//	Remove Periodical from the Repeater queuevoidLPeriodical::StopRepeating(){	if (sRepeaterQ != nil) {		sRepeaterQ->Remove(this);	}}// ---------------------------------------------------------------------------//	е IsRepeating													  [public]// ---------------------------------------------------------------------------//	Return whether a Periodical is in the Repeater queueboolLPeriodical::IsRepeating() const{	return ( (sRepeaterQ != nil)  &&			 sRepeaterQ->ContainsItem(const_cast<LPeriodical*>(this)) );}// ---------------------------------------------------------------------------//	е DevoteTimeToRepeaters									 [static] [public]// ---------------------------------------------------------------------------//	Call SpendTime function for each Periodical in the Repeater queuevoidLPeriodical::DevoteTimeToRepeaters(	const EventRecord&	inMacEvent){	if (sRepeaterQ != nil) {		TArrayIterator<LPeriodical*> iterator(*sRepeaterQ);		LPeriodical	*theRepeater;		while (iterator.Next(theRepeater)) {			theRepeater->SpendTime(inMacEvent);		}	}}#pragma mark -// ---------------------------------------------------------------------------//	е DeleteIdlerAndRepeaterQueues							 [static] [public]// ---------------------------------------------------------------------------//	Delete the internal queues (Arrays) used to store pointers to Idler//	and Repeater objects. This does NOT delete the Idler and Repeater//	objects themselves.////	Normally, you will only use this routine to clean up memory when//	terminating a code resource or fragment.////	You don't need to call this when quitting an application, since the queues//	will disappear when the System deallocates the app's heap. However, you//	may want to call this if you are fastidious about always deleting every//	object that is created via new.voidLPeriodical::DeleteIdlerAndRepeaterQueues(){	delete sIdlerQ;	sIdlerQ = nil;	delete sRepeaterQ;	sRepeaterQ = nil;}PP_End_Namespace_PowerPlant