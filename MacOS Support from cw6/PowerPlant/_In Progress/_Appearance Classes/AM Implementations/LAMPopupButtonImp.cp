// ===========================================================================//	LAMPopupButtonImp.cp		PowerPlant 2.1		©1997-2000 Metrowerks Inc.// ===========================================================================#ifdef PowerPlant_PCH	#include PowerPlant_PCH#endif#include <LAMPopupButtonImp.h>#include <LPopupButton.h>#include <PP_Resources.h>#include <UDrawingUtils.h>#include <UEnvironment.h>#include <UQDOperators.h>#include <UTextTraits.h>PP_Begin_Namespace_PowerPlant// ---------------------------------------------------------------------------//	Static Variables////		There is a bug in AM 1.1 in Mac OS 8.5 where the titles of//		PopupButtons and PopupGroupBoxes don't dim when inactive. To//		workaround this bug, we replace the QuickDraw bottleneck function//		for drawing text before drawing such controls.static RGBColor	sEmbeddedTextColor;static CQDProcs	sColorizedTextProcs;static bool		sQDProcsInited = false;// ---------------------------------------------------------------------------//	¥ LAMPopupButtonImp					Stream/Default Constructor	  [public]// ---------------------------------------------------------------------------//	Do not access inStream. It may be nil. Read Stream data in Init()LAMPopupButtonImp::LAMPopupButtonImp(	LStream*	inStream)	: LAMControlImp(inStream){		// This class requires the special empty MENU resource in order		// to prevent the Toolbox from mucking with the real MenuHandle.		// Signal and throw if we can't find this menu.	MenuHandle	emptyMenuH = LMenuController::GetEmptyMenuH();	if (emptyMenuH == nil) {		SignalStringLiteral_("LAMPopupButtonImp requires MENU 12345. "							 "Add EmptyMenu.rsrc to your project.");		Throw_(resNotFound);	}	mMenuHandleTag = kControlPopupButtonMenuHandleTag;	if (not sQDProcsInited) {		::SetStdCProcs(&sColorizedTextProcs);		sColorizedTextProcs.textProc = NewQDTextProc(ColorizedStdText);		sQDProcsInited = true;	}}// ---------------------------------------------------------------------------//	¥ ~LAMPopupButtonImp					Destructor				  [public]// ---------------------------------------------------------------------------LAMPopupButtonImp::~LAMPopupButtonImp(){}#pragma mark -// ---------------------------------------------------------------------------//	¥ FindHotSpot													  [public]// ---------------------------------------------------------------------------SInt16LAMPopupButtonImp::FindHotSpot(	Point		/* inPoint */) const{	return kControlMenuPart;}// ---------------------------------------------------------------------------//	¥ TrackHotSpot													  [public]// ---------------------------------------------------------------------------BooleanLAMPopupButtonImp::TrackHotSpot(	SInt16		inHotSpot,	Point		inPoint,	SInt16		inModifiers){	StPopupMenuSetter	setMenu(mControlPane, GetMacMenuH());	StoreEmbeddedTextColor();	StCQDProcsState	qdProcs(true, &sColorizedTextProcs,								(CGrafPtr) UQDGlobals::GetCurrentPort());	return LAMControlImp::TrackHotSpot(inHotSpot, inPoint, inModifiers);}// ---------------------------------------------------------------------------//	¥ DrawSelf														  [public]// ---------------------------------------------------------------------------voidLAMPopupButtonImp::DrawSelf(){	StPopupMenuSetter	setMenu(mControlPane, GetMacMenuH());	StoreEmbeddedTextColor();	StCQDProcsState	qdProcs(true, &sColorizedTextProcs,								(CGrafPtr) UQDGlobals::GetCurrentPort());	LAMControlImp::DrawSelf();}#pragma mark -// ---------------------------------------------------------------------------//	¥ PostSetValue													  [public]// ---------------------------------------------------------------------------voidLAMPopupButtonImp::PostSetValue(){		// If the MenuHandle stored in the Toolbox Control is our		// special emtpy menu, then setting the control value will		// draw an empty selection. So we need to explicitly draw		// the popup box to show the proper menu item.	MenuHandle	menuH = nil;	::GetControlData(mMacControlH, 0, mMenuHandleTag,						sizeof(MenuHandle), (Ptr) &menuH, nil);	if (menuH == LMenuController::GetEmptyMenuH()) {		mControlPane->Draw(nil);	}}// ---------------------------------------------------------------------------//	¥ SetDataTag													  [public]// ---------------------------------------------------------------------------voidLAMPopupButtonImp::SetDataTag(	SInt16			/* inPartCode */,	FourCharCode	inTag,	Size			inDataSize,	void*			inDataPtr){	if (inTag == mMenuHandleTag) {		MenuHandle	menuH = *(MenuHandle*) inDataPtr;			// AM version 1.0.2 and earlier don't support setting the			// MenuHandle to nil via the data tag. As a workaround, we			// install a special menu that has no items.		if (menuH == nil) {			menuH = LMenuController::GetEmptyMenuH();		}		::SetControlData(mMacControlH, kControlNoPart, inTag,							inDataSize, (Ptr) &menuH);	}}// ---------------------------------------------------------------------------//	¥ GetMacMenuH												   [protected]// ---------------------------------------------------------------------------MenuHandleLAMPopupButtonImp::GetMacMenuH() const{	MenuHandle		menuH = nil;	LPopupButton*	popup = dynamic_cast<LPopupButton*>(mControlPane);	if (popup != nil) {		menuH = popup->GetMacMenuH();	}	return menuH;}#pragma mark -// ---------------------------------------------------------------------------//	¥ StoreEmbeddedTextColor									   [protected]// ---------------------------------------------------------------------------voidLAMPopupButtonImp::StoreEmbeddedTextColor(){	TextTraitsRecord	textTraits;	UTextTraits::LoadTextTraits(mTextTraitsID, textTraits);	sEmbeddedTextColor = textTraits.color;	bool	dimColor = (not (IsActive() && IsEnabled())) &&					   (UEnvironment::GetAppearanceVersion() >= 0x0110);	if (sEmbeddedTextColor == Color_Black) {		SInt16	bitDepth;		bool	hasColor;		mControlPane->GetDeviceInfo(bitDepth, hasColor);		mControlPane->GetEmbeddedTextColor(								bitDepth, hasColor,								not dimColor,								sEmbeddedTextColor);	} else if (dimColor) {		UTextDrawing::DimTextColor(sEmbeddedTextColor);	}}// ---------------------------------------------------------------------------//	¥ ColorizedStdText											   [protected]// ---------------------------------------------------------------------------pascal voidLAMPopupButtonImp::ColorizedStdText(	SInt16	inByteCount,	Ptr		inTextPtr,	Point	inNumer,	Point	inDenom){	RGBColor	saveForeColor;	::GetForeColor(&saveForeColor);	::RGBForeColor(&sEmbeddedTextColor);	::StdText(inByteCount, inTextPtr, inNumer, inDenom);	::RGBForeColor(&saveForeColor);}PP_End_Namespace_PowerPlant