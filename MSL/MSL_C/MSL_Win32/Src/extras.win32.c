/*  Metrowerks Standard Library  *//*  $Date: 2000/08/19 19:49:57 $  *  $Revision: 1.1.2.5.2.4 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. */#include <crtl.h>#include <cerrno>#include <extras.h>     #include <direct.h>#include <fcntl.h>#include <malloc.h>#include <io.h>     			/* cc 000219 *//*#include <ctype.h>*//*#include <cstddef>*//*#include <climits>*/          /* mm 990329 *//*#include <cstdio>*//*#include <cstdlib>*//*#include <cstring>*//*#include <ctime>*//*#include <cwchar>*//*#include <wctype.h>*//*#include <unistd.h>*//*#include <stdarg.h>*/#define WIN32_LEAN_AND_MEAN#include <windows.h>#if (__dest_os == __win32_os  || __dest_os == __wince_os)/* This function should be equivalent to the ANSI "exit" without the ExitProcess * call. This function is needed so that a DLL can clean up itself and return * to Windows which finishes cleaning up the process (other DLLs and the main * application might not have destructed yet). * I would have just separated this code out of exit but that code is already too * separated... */  /*     for the shared version of msl on windows _CleanUpMSL must be contained only    in the shared library.  It was moved to this file for that purpose only.    The reason is that each object attached to a process including msl, must    have it's own destructor chain.          The destructor chain inside _CleanupMSL() now calls destructors for MSL only    (including the C and C++ library).  The whole purpose of this routine is to     do nothing until we are sure that all objects (a process and possibly other dll's)    which are attached to the shared msl have had a chance to clean themselves up.    The msl DLL now has it's own version of abort and exit which refer only to the    destructor chain of msl.  abort and exit are statically linked in by things     linking against the shared msl so that abort and exit will reference their    individual static objects when calling their own destructor chain.        Note this change assumes there are exactly two distinct ways that a dll unloads.        1. When the process exits through ExitProcess, the dll receives a DLL_PROCESS_DETACH     message.        2. The dll was loaded manually by LoadLibrary and unloaded by FreeLibrary.  FreeLibrary    will also send a DLL_PROCESS_DETACH message to the dll entry point which MUST call    __destroy_global_chain();  (see _CRT_INIT(HINSTANCE, DWORD, LPVOID) in dllmaincrt.c)        I see no compelling reason nor a safe way to have a single destructor chain.        m.f.  000807 */#define max_funcs	64  #include <critical_regions.h> #include <abort_exit.h>#include <pool_alloc.h>			/*  mf 980825  *//* static void (*atexit_funcs[50])(void); *//* extern void (*atexit_funcs[max_funcs])(void); *//* static long	atexit_curr_func = 0; *//*extern long	atexit_curr_func; */_MSL_IMP_EXP_RUNTIME extern void				__destroy_global_chain(void);void _CleanUpMSL(){	extern int *__get_MSL_init_count(void);	if (--(*__get_MSL_init_count()) > 0) return;			/*	__begin_critical_region(atexit_funcs_access);		while (atexit_curr_func > 0)		(*atexit_funcs[--atexit_curr_func])();		__end_critical_region(atexit_funcs_access);	*/	__destroy_global_chain();  /* __destroy_global_chain(); needs to be called before	                              destroying the standard handles, since some destructor	                              called by __destroy_global_chain may be legally using	                              one of these handles	                           */		if (__stdio_exit)	{		(*__stdio_exit)();		__stdio_exit = 0;	}			__kill_critical_regions();		if (__console_exit)	{		(*__console_exit)();		__console_exit = 0;	}	#ifndef _MSL_PRO4_MALLOC	__pool_free_all();	#else	__pool_free_all(&__malloc_pool);	#endif}#endif	/* __dest_os == win32 */int _chdrive(int drive){    char path[3];        if (drive < 1 || drive > 31) {    	return -1;    }    path[0] = (char) ('A' + drive -1);    path[1] = ':';    path[2] = 0x00;        if (SetCurrentDirectory(path))    {        return 0;    }    else    {        return -1;    }}int _getpid(void){	return GetCurrentProcessId();}// Core functionality for dup() and startup code.// Returns 0 for success or Win32 error code.unsigned long __dup_core(void *handle, void **dup_handle){	if (!DuplicateHandle(				GetCurrentProcess(),				handle,				GetCurrentProcess(), 				dup_handle,				SYNCHRONIZE,				TRUE,				DUPLICATE_SAME_ACCESS))	{		// there was an error		*dup_handle = INVALID_HANDLE_VALUE;		_doserrno = GetLastError();		return _doserrno;	}	else	{		return 0;	}}int _dup(int handle){		int h;	  	h = GetHandle();  		return _dup2(handle, h);}int _dup2(int handle, int h){	HANDLE new_handle;	DWORD err;	/* closing h if it is open */ 	_close(h);		/* reset */		errno = ENOERR;			/* check to see if handle passed in is valid */	if (handle >= NUM_HANDLES || !_HandleTable[handle])    {		errno = EBADF;        return -1;    }	/* duplicate win32 handle info */	err = __dup_core(_HandleTable[handle]->handle, &new_handle);		if (err != NO_ERROR)    {		errno = EBADF;        return -1;    }    			if (h >= NUM_HANDLES)    {		errno = EBADF;        return -1;    }		_HandleTable[h] = (FileStruct *)malloc(sizeof(FileStruct));		/* Set up the translate mode flag */	_HandleTable[h]->translate = _HandleTable[handle]->translate;	_HandleTable[h]->append = 0;				_HandleTable[h]->handle = new_handle; 		return h;}unsigned _getdiskfree(unsigned drive, struct _diskfree_t *dfs){	char path[4];		if (drive > 26) 		return -1;	else {		path[0] = (char) (drive + 'A' -1);		path[1] = ':';		path[2] = '\\';		path[3] = 0x00;	}		if (!GetDiskFreeSpace(drive ? path : NULL,			&(dfs->sectors_per_cluster), &(dfs->bytes_per_sector),&(dfs->avail_clusters),&(dfs->total_clusters)))		return -1;	return 0;}char *_getdcwd(int drive, char *buffer, int maxlen){	int n;	char dir[_MAX_PATH];	char *file;		if (drive != 0) {		char dstr[4];				if (drive > 26) {			errno = EACCES;			return NULL;		}				dstr[0] = (char) (drive + 'A' -1);		dstr[1] = ':';		dstr[2] = '.';		dstr[3] = 0x00;		n = GetFullPathName(dstr,sizeof(dir),dir,&file);	}	else		n = GetCurrentDirectory(sizeof(dir),dir);			if (!n || ++n > sizeof(dir))		return NULL;				if (!buffer) {		if (!(buffer = (char *) malloc(n > maxlen ? n : maxlen))) {			errno = ENOMEM;			return NULL;		}	}	else 		if (n > maxlen) {			errno = ERANGE;			return NULL;		}			return strcpy(buffer,dir);}int _getdrive(){	char	dir[_MAX_PATH];	int		drive = 0;		if (GetCurrentDirectory(sizeof(dir),dir))		if (dir[1] == ':')			drive = toupper(dir[0]) - 'A' - 1;				return drive;	}unsigned long _getdrives(){	return GetLogicalDrives();}void _searchenv(const char *filename, const char *varname, char *pathname){    char buffer[1024], *cp;        GetEnvironmentVariable(varname, buffer, sizeof(buffer));    SearchPath(buffer, filename, "", _MAX_PATH, pathname, &cp);}// Return operating system file handle (as opposed to C file handle)long _get_osfhandle(int filehandle){    if (filehandle < 0 || filehandle > NUM_HANDLES || _HandleTable[filehandle] == NULL)    {        return -1;    }    return (long)_HandleTable[filehandle]->handle;}// Open an operating system handle as a C file handleint _open_osfhandle(long ofshandle, int flags){    int h;        h = GetHandle();    if (h == -1)    {        return -1;    }	_HandleTable[h] = (FileStruct *)malloc(sizeof(FileStruct));	if (!_HandleTable[h])	{	    return -1;	}	        _HandleTable[h]->handle = (HANDLE)ofshandle;    _HandleTable[h]->translate = (flags & O_BINARY) == 0;    _HandleTable[h]->append = (flags & O_APPEND) != 0;        return h;}int GetHandle(){    int i;        for (i=0; i<256; i++)    {        if (_HandPtr == NUM_HANDLES)        {            _HandPtr = 3;        }        if (_HandleTable[_HandPtr] == 0)        {            return _HandPtr++;        }        _HandPtr++;    }    return -1;}int _doserrno = 0;// Allocate memory on the stack__declspec(naked) char * _alloca(size_t /*size*/)  /* hh 980122 removed unused arg size */{    asm    {     	pop		ecx				// pop return address     	pop		eax				// get amount to alloc     	sub		esp, eax		// subtract from stack pointer     	mov		eax, esp		// and return the new stack pointer     	push	eax				// leave something for the caller to pop     	jmp		ecx    }    }char * _fullpath(char * absPath, const char * relPath, size_t maxLength) {	// Take paths such as:	// A:\DIR\file	// DIR\file	// .\file	// file	// \DIR\DIRB\..\file	// ..\DIR\file	//	// And convert them to:	// A:\DIR\file	// There are several ways a pathname can start:	// [Drive Letter]:	// \[Root Directory or File]	// [Directory or File in Current Path]	char * TempBuffer = 0;	const char * const kSlashDotDot = "\\..";	const char * const kSlashDot = "\\.";	const int kSlashDotDotLen = strlen(kSlashDotDot);	const int kSlashDotLen = strlen(kSlashDot);	char * searchStart;	char * foundStr;		if (strlen(relPath) == 0)		return 0;	// First add the drive letter and current directory if necessary	// to the path.	if ((strlen(relPath) > 1) && (relPath[1] == ':')) {		// The given path has a drive in the name..		// Just move it to TempBuffer.		TempBuffer = _strdup(relPath);				if (!TempBuffer) {			// _strdup error.			return 0;		}	} else if (relPath[0] == '\\') {		char * CurrentPath;				// I took this technique from the _getcwd function.		int CurrentDirLength = GetCurrentDirectory(0, NULL);		CurrentPath = (char *)malloc(CurrentDirLength+1);				if (!CurrentPath) {			// Memory allocation error			return 0;		}				if (!_getcwd(CurrentPath, CurrentDirLength+1)) {			// _getcwd failed.			free(CurrentPath);			return 0;		}		if (CurrentPath[1] != ':') {			// I got a bogus path from _getcwd			free(CurrentPath);			return 0;		}		CurrentPath[2] = 0;	// Make the string just the letter and a colon		TempBuffer = (char *)malloc(strlen(CurrentPath)+strlen(relPath)+1);				if (!TempBuffer) {			// Memory allocation error.			free(CurrentPath);			return 0;		}		TempBuffer[0] = 0;		strcat(TempBuffer, CurrentPath);		strcat(TempBuffer, relPath);		free(CurrentPath);	} else {		// Set TempBuffer to the current drive and path plus a \ if not one isn't		// already there plus relPath.				// I took this technique from the _getcwd function.		int CurrentDirLength = GetCurrentDirectory(0, NULL);		int Temp;		// Allocate space for the current path, the relPath, a slash, and null		// character.		TempBuffer = (char *)malloc(CurrentDirLength+strlen(relPath)+2);		if (!TempBuffer) {			// Memory allocation error.			return 0;		}				if (!_getcwd(TempBuffer, CurrentDirLength+1)) {			// _getcwd failed.			free(TempBuffer);			return 0;			}				if ((strlen(TempBuffer) < 3) || (TempBuffer[1] != ':')) {			// I got a bogus path from _getcwd			free(TempBuffer);			return 0;		}				// Add a '\' character to the end of the current path if there isn't already		// one there.		Temp = strlen(TempBuffer);		if (TempBuffer[Temp-1] != '\\') {			TempBuffer[Temp] = '\\';			TempBuffer[Temp+1] = 0;		}						strcat(TempBuffer, relPath);	}	// Now I have a string in TempBuffer that contains the full 	// path including the drive letter. Now I have to clean all	// the "." and ".." directories out.//	printf("At Checkpoint 1: TempBuffer = %s\n", TempBuffer);	// Clean out the "\.."'s.	searchStart = TempBuffer;	while((foundStr = strstr(searchStart, kSlashDotDot)) != NULL)	{		char *prevSlash = foundStr - 1;		searchStart = foundStr + kSlashDotDotLen;		// If the next character after the '\..' is not a slash or end		// of string, then don't collapse the '\..' sequence as there		// may be a file or directory whose name starts with '..'		if((*searchStart != 0) && (*searchStart != '\\'))			continue;				// Back up until the previous slash is found. Also skip '\.\'s		// between the current position and the previous slash		while((*prevSlash != '\\') || ((prevSlash[1] == '.') && (prevSlash[2] == '\\')))		{			prevSlash--;			if(prevSlash == TempBuffer)			{				free(TempBuffer);				return 0;			}		}				if(*searchStart == 0)		{			// Don't truncate the trailing '\' if it's right after the			// drive letter			if(prevSlash[-1] == ':')				prevSlash += 1;			*prevSlash = 0;			break;		}		memmove(prevSlash, searchStart,				TempBuffer + strlen(TempBuffer) - searchStart + 1);		searchStart = prevSlash;	}	// Clean out the "\."'s.	searchStart = TempBuffer;	while ((foundStr = strstr(searchStart, kSlashDot)) != NULL)	{		searchStart = foundStr + kSlashDotLen;		if(*searchStart == 0)		{			// Don't truncate the trailing '\' if it's right after the			// drive letter			if(foundStr[-1] == ':')				foundStr += 1;			*foundStr = 0;			break;		}		// If the next character after the '\.' is not a slash then don't		// collapse the '\.' sequence as there may be a file or directory		// whose name starts with '.'		if(*searchStart != '\\')			continue;		memmove(foundStr, searchStart,				TempBuffer + strlen(TempBuffer) - searchStart + 1);		searchStart = foundStr;	}	// TempBuffer is the final string.	if ((strlen(TempBuffer) + 1) > maxLength) {		free(TempBuffer);				return 0;	}		if (absPath == 0) {		absPath = (char *)malloc(maxLength);				if (absPath == 0) {			free(TempBuffer);			return 0;		}	}			strcpy(absPath, TempBuffer);		free(TempBuffer);	return absPath;}/* Change History961120 KO	Made a fix to _fullpath.961212 KO	Made wcslen and wcscpy work better and added swprintf (which probably won't work			too well.) hh 980122 Replaced <windows.h> with the following TWO includes because it is seriously          broken.  The following 2 includes must be carefully ordered as shown, because          they are broken too.hh 980122 needed <cstdarg> for va_starthh 980122 removed unused arg sizemf 980227 added splitpath and _strlwr to support MFCmf 980228 removed wcskeb abd wcscpy as they are now in wstring.cvss 980310 removed - defined in wprintf.cblc 980324 added wide character functions used in WinCEmf  980505 commented out implementation of functions that use win32 api's not available in           cemf  980515 added a couple of non-standard wchar routines _itow,_wrevstr           blc 990312 added _strset, _strnset, _strspnp, _wcsspnpmm  990329 Make _itoa and _itow work for largest negative value WB1-5143, IL9903-2106           blc 990331 Fixed double spacing problem with mm's last check inblc 990825 Added wctype.h include for towupper and towlowercc  000208 Added _umask supportcc  000209 removed io.h and _umask supportmm  000209 Corrected my 990329 fix to make it work for radices other than 10cc  000219 Added io.h, _dup() and _dup2() cc  000510 Moved common source to extras.ccc  000515 Fixed #includecc  000708 fixed _fullpathejs cc  000724 fixed _dup/_dup2 to use common core and duplicate the MSL wrapper handles            as well as the Win32 handles.*/