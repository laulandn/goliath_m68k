/* amd math header file */#ifndef __amd_singleprecision_math_for_k63dnow__#define __amd_singleprecision_math_for_k63dnow__#ifdef __cplusplus	#ifdef _MSL_USING_NAMESPACE		namespace std {	#endif	extern "C" {#endif      float modff(float x, float *iptr);     float acosf(float x);	 float fabsf(float x);	 float asinf(float x);	 float atanf(float x);	 float atan2f(float x, float y);	 float cosf(float x);	 float sinf(float x);		 float tanf(float x);	 float coshf(float x);	 float sinhf(float x);	 float tanhf(float x);	 float expf(float x);	 float frexpf(float x, int *exp);	 float ldexpf(float x, int exp);	 float logf(float x);	 float log2f(float x);	 float log10f(float x);	 float powf(float x, float y);	 float sqrtf(float x);	 float ceilf(float x);	 float floorf(float x);	 float fmodf(float x, float y);#ifdef __cplusplus	#ifdef _MSL_USING_NAMESPACE		}	#endif	}#endif/*# include <tgmath.h>    // has float overloads with same name as standard double version(e.g. float cos) # include <math_integral.h>*//* #pragma k63d_calls on  This is set in cmath */#pragma cplusplus on#define __PIO2__ 1.57079632679489661923132169163975f#define __PI  3.1415926535897932384626433832795f#define __two_over_pi .636619772367581343075535053490057f#define __four_over_pi 1.27323954473516268615107010698011f#define __SQRT_FLT_EPSILON__ 3.4526698300e-04f#define __sqrt2_m1  .41421356237f#ifndef __ln2//#define __ln2  0.6931471805599f#endif#ifdef __cplusplusextern "C" {#endif  //sin(n*pi/4),cos(n*pi/4),sin(n*pi/4)extern  const float __sincos_poly[];                                    extern  const float __sincos_on_quadrant[];extern  const float __tan_on_octant[] ;/*_MSL_IMP_EXP  const float  __one_over_F[];_MSL_IMP_EXP  const float  __ln_F[];*/#ifdef __cplusplus}#endifconst int __tmp_float[4]={0x3E800000,0x3Cbe6080,0x34372200,0x2da44152};static const float  __four_over_pi_m1[]={*(float*)&__tmp_float[0],*(float*)&__tmp_float[1],                                         *(float*)&__tmp_float[2],*(float*)&__tmp_float[3]}; /*                                          static const float  __four_over_pi_m1[]={.25f,.1953125e-1,                                          .370815396308898925781250000000e-2,                                          .14077207369689325760698e-6};                                                         */              #ifdef __cplusplus	#ifdef _MSL_USING_NAMESPACE		namespace std {#endif                 #endif         __inline  float sinf(float x){                                             float z=__two_over_pi*x ; //note: |z-n|<=.5 i.e. we choose n so that |n*pi/2 - x|< .5*(pi/2)=pi/4, then use the poly for [0,pi/4], but//      also notice that n(mod(4)) gives which quadrant we're in and enables us to use the trig addition identities.//      Exactly one of these terms drops out because either sin(n*pi/2) or cos(n*pi/2) is 0.#define __FAST_MATH_MODE__ 0 #if __FAST_MATH_MODE__  _INT32 n= (_INT32)z; //note: truncation insures |n|<z and cos/sin(x)=cos/sin(n*pi/4+frac_part)  const float frac_part= z -(float)(n<<1) ;#else                                      //note we multiply n by 2 below because the polynomial we are using is for [o,pi/4]. n is the nearest multiple// of pi/2 not pi/4.//  frac_part is the remainder(mod(pi/4))// i.e. the actual arg that will be evaluated is frac_part*(pi/4)// note: since n is signed n<<1 may pad rightmost bit w/a one. _INT32 n= (__HI(x)&0x80000000) ? (_INT32)(z -.5f) : (_INT32)(z + .5f) ;   const float frac_part= ((((x - (float)(n*2)) + __four_over_pi_m1[0]*x) + __four_over_pi_m1[1]*x)+  	                                              __four_over_pi_m1[2]*x) + __four_over_pi_m1[3]*x/*) +  	                                               __four_over_pi_m1[4]*x  */; #endif      float xsq;       //assumes 2's complement integer storage for negative numbers.    n&=0x00000003;   if(fabsf(frac_part) < __SQRT_FLT_EPSILON__)   {    n<<=1;   //index into __sincos_on_quadrant array    return __sincos_on_quadrant[n] + (__sincos_on_quadrant[n+1]*frac_part*__sincos_poly[9]);   }      xsq=frac_part*frac_part;   if(n&0x00000001)  // we are at a multiple of pi/2 thus cos(n*pi/4)= 0   {    n<<=1;   //index into __sincos_on_quadrant array    z=((( __sincos_poly[0]*xsq +__sincos_poly[2])*xsq + __sincos_poly[4])*xsq + __sincos_poly[6])*xsq +     __sincos_poly[8];    return z*__sincos_on_quadrant[n];// sin(frac_part)*cos(n*pi/4);  note: n*pi/4 is a multiple of pi/2(not pi)    //return z;// sin(frac_part)*cos(n*pi/4);  note: n*pi/4 is a multiple of pi/2(not pi)   }    // if here we are near a multiple of pi so sin(n*pi/4) =0    n<<=1;   //index into __sincos_on_quadrant array    z= ((((__sincos_poly[1]*xsq +__sincos_poly[3])*xsq + __sincos_poly[5])*xsq + __sincos_poly[7])*xsq + __sincos_poly[9])*frac_part;    //return z;// sin(frac_part)*cos(n*pi/4);  note: n*pi/4 is a multiple of pi/2(not pi)       return z*__sincos_on_quadrant[n+1];// sin(frac_part)*cos(n*pi/4);  note: n*pi/4 is a multiple of pi/2(not pi)    }  __inline  float cosf(float x){    float z=__two_over_pi*x ;     #define __FAST_MATH_MODE__ 0 #if __FAST_MATH_MODE__  _INT32 n= (_INT32)z; //note: truncation insures |n|<z and cos/sin(x)=cos/sin(n*pi/4+frac_part)  const float frac_part= z -(float)(n<<1) ;#else                                      //note we multiply n by 2 below because the polynomial we are using is for [o,pi/4]. n is the nearest multiple// of pi/2 not pi/4.//  frac_part is the remainder(mod(pi/4))// i.e. the actual arg that will be evaluated is frac_part*(pi/4)// note: since n is signed n<<1 may pad rightmost bit w/a one. _INT32 n= (__HI(x)&0x80000000) ? (_INT32)(z -.5f) : (_INT32)(z + .5f) ;   const float frac_part= ((((x - (float)(n*2)) + __four_over_pi_m1[0]*x) + __four_over_pi_m1[1]*x)+  	                                              __four_over_pi_m1[2]*x) + __four_over_pi_m1[3]*x/*) +  	                                               __four_over_pi_m1[4]*x  */; #endif  	float xsq;    n&=0x00000003;   if(fabsf(frac_part) < __SQRT_FLT_EPSILON__)   {     n<<=1;   //index into __sincos_on_quadrant array     return __sincos_on_quadrant[n+1] - (__sincos_on_quadrant[n]*frac_part);   }         //use identity cos(x)=cos(n*pi/4 + frac_part)=cos(n*pi/4)cos(frac_part)- sin(n*pi/4)sin(frac_part)   xsq=frac_part*frac_part;   if(n&0x00000001)  // we are at a multiple of pi/2 thus cos(n*pi/4)= 0   {        n<<=1;   //index into __sincos_on_quadrant array      z= -((((__sincos_poly[1]*xsq +__sincos_poly[3])*xsq + __sincos_poly[5])*xsq + __sincos_poly[7])*xsq + __sincos_poly[9])*frac_part;     return z*__sincos_on_quadrant[n];   }    n<<=1;   //index into __sincos_on_quadrant array    // if here we are near a multiple of pi so sin(n*pi/4) =0         z=((( __sincos_poly[0]*xsq +__sincos_poly[2])*xsq + __sincos_poly[4])*xsq + __sincos_poly[6])*xsq + __sincos_poly[8];     return z*__sincos_on_quadrant[n+1];// sin(frac_part)*cos(n*pi/4);  note: n*pi/4 is a multiple of pi/2(not pi)}__inline   void __sincos( float x, const float* v){    	                                          // sin(x)=sin(n*pi/4 + frac_part)=sin(n*pi/4)cos(frac_part)+ cos(n*pi/4)sin(frac_part)      static const long long __negate_lo=0x8000000000000000;    float z=__four_over_pi*x ;    _INT32 n=(_INT32)z;    // note fract_part is the remainder(mod(pi/4))    // i.e. the actual arg that will be evaluated is frac_part*(pi/4)	const float frac_part= ((((x - (float)n) + __four_over_pi_m1[0]*x) + __four_over_pi_m1[1]*x)+  	                                              __four_over_pi_m1[2]*x) + __four_over_pi_m1[3]*x/*) +  	                                               __four_over_pi_m1[4]*x  */; 	float xsq=frac_part*frac_part;	float x_vect[2]={xsq, xsq};	float last_mult[2]={1.0f,frac_part};   n&=0x00000007;  // n is now the octant in which x resides // calculate sin and cos in parallel      asm                  	   {	    movq mm0,x_vect[0]	    movq mm1,mm0	    pfmul mm0,__sincos_poly[0]	    mov ecx,n	    pfadd mm0,__sincos_poly[8]	    pfmul mm0,mm1	    imul ecx,12	    pfadd mm0,__sincos_poly[16]	    pfmul mm0,mm1	    mov eax, v	    pfadd mm0,__sincos_poly[24]	    pfmul mm0,mm1	    pfadd mm0,__sincos_poly[32]	    pfmul mm0,last_mult[0]                                                              // now mm0= | cos(frac_part) | sin(frac_part) |	                                          // we now use the trig identities	                                          // cos(x)=cos(n*pi/4 + frac_part)=cos(n*pi/4)cos(frac_part)- sin(n*pi/4)sin(frac_part)   	                                          // sin(x)=sin(n*pi/4 + frac_part)=sin(n*pi/4)cos(frac_part)+ cos(n*pi/4)sin(frac_part)        movq  mm1,mm0                         // note this step is very awkward on the K6 and can be completed much easier                                              // using the K7 instruction pfswapd	    pfmul mm0,__tan_on_octant[ecx+4]   // mm0= |cos(n*pi/4)cos(frac_part) | sin(n*pi/4)sin(frac_part) |  	    pxor mm0,__negate_lo                  // mm0= |cos(n*pi/4)cos(frac_part) | -sin(n*pi/4)sin(frac_part) |                      pfacc mm0,mm0                         // mm0= |cos(x) | cos(x)|           movd  dword ptr[eax+4],mm0            // v[1]=sin(x)        pfmul mm1,__tan_on_octant[ecx]     // mm1= |sin(n*pi/4)cos(frac_part) | cos(n*pi/4)sin(frac_part) |         pfacc mm1,mm1                         // mm1= |sin(x) | sin(x)|          movd  dword ptr[eax],mm1                        // v[0]=sin(x)        ;movq qword ptr[eax],mm0              // v= | cos(x) | sin(x) |        	   }    return ;    }  __inline  float tanf(float x) {  float z[2];  // z[0] will hold sin(x) and z[1] cos(x)  __sincos(x,&z[0]);   return z[0]/z[1] ;    }__inline float sqrtf( float x){  asm{		movd 		mm0, x;		pfrsqrt 	mm1, mm0;		movq		mm2, mm1;		pfmul		mm1, mm1;		pfrsqit1	mm1, mm0;		pfrcpit2	mm1, mm2;		pfmul		mm0, mm1;		movd		x, mm0;	}		return x;}   __inline float fmodf( float x, float y){                                         // some unique integer Q  such that R < y                                         // we do this indirectly by computing Q*y                                         // and return x-Q*y     _UINT32 exp_shift;                  // shift only enough to fit in eax::edx     _UINT32 exp_diff,quotient=0,scaled_x,scaled_y;  //quotient=quotient_hi+quotient_lo     float z=fabsf(x), y_hi,y_lo, f_quotient[3];         y=fabsf(y);     if(z < y)       return x;            exp_diff=((__UHI(x)&0x7f800000)-(__HI(y)&0x7f800000))>>23;     exp_shift=exp_diff&0x0000001f ;  // shift at most 31 to insure quotient is < 2^^32 -1                                       // i.e. quotient will fit in 32 bit register.     scaled_x=(__UHI(x)&0x007fffff) + 0x00800000;     scaled_y=(__UHI(y)&0x007fffff) + 0x00800000;     exp_diff-=exp_shift;     exp_diff<<=23;        asm   {    mov eax,0    mov edx,scaled_x    mov ecx,scaled_y    shl ecx,1                        // multiply divisor by two, to avoid overflow(i.e. to insure quotient is < 2^^32 -1 )    div ecx    mov quotient, eax   }      quotient >>= (31 - exp_shift);    // truncates instead of round to nearest(this is correct since we want                                      // largest integer such that (x-Q*y < y).  Round to nearest may produce one too large.                                     // multiply quotient term by 2^^exp_diff , if exp_diff > 32 this product will be rounded and                                      // will not be affected by the least significant bits of the original y.   __UHI(z)-=exp_diff;   __UHI(y_hi)=__UHI(y)&0x7ffff000;     // the division of y into two floats(y_lo,y_hi) w/ at most 12 significant bits                                     // and quotient in 3 parts each w/12 or fewer sig bits guarantees                                     // that all intermediate products are exact.  This also guarantees                                     // that the final subtraction operation when ordered correctly is                                     // exact.  Also note that we use a full 32 bit quotient.  This gives                                     // an extra 8 bits of precision for larger quotients which cannot be                                     // represented exactly as an IEEE float(which has only 24 significant bits).                                     // still this quotient is inadequate for dividend/divisor pairs whose exponents differ                                      // by more than 32                                      y_lo=y-y_hi;       f_quotient[0]=(float)(quotient&0x00000fff);  /*if(quotient&0xfffff000) { // this is what we have to do to take advantage of the 32 bit quotient.*/  f_quotient[1]=(float)(quotient&0x00fff000);  f_quotient[2]=(float)(quotient&0xff000000);  z= fabsf((float)((((y_hi*f_quotient[2] -z) + y_hi*f_quotient[1]) + y_hi*f_quotient[0]) +                     (y_lo*f_quotient[2]    +( y_lo*f_quotient[1]  + y_lo*f_quotient[0]))));    /* }  else   z=fabsf( (y_hi*f_quotient[0] -z) + y_lo*f_quotient[0]);   */  __HI(z)|=signbit(x);  return z;                       }	/*--------------------atanf-------------------------------*/   __inline float atanf(float x){       float z,z_square;  int index=-1,inv=0;  const  int sign=(int)(__UHI(x)&0x80000000);  /* poly # 4964-- poly for  [0,tan(pi/8)]  */                        static const float  atan_coeff[]={.999999999f,-.3333333213f,.19999886356f,-.14281650536f,                                    .11041179874f, -.084597554152f,.04714243524f/*.76f */};                          /* data for argument reduction  */   static const float  one_over_xi[]={2.414213562f, 1.49660575f,1.00000000f,                                      .668178618f,  .414213568f,.198912367f};                                       static const float  onep_one_over_xisqr_hi[]={6.82842f,3.239828f,2.0f,  /*   6.828427125f  */                                                1.446462f,  1.17157292f,1.039566130f};                                         static const float  onep_one_over_xisqr_lo[]={.000007135f,0.00000082f,.0f,  /*   6.828427125f  */                                                0.00000063f, 0.0f, 0.0f};                                                                                   static const float atan_xi_hi[]= {0.0f,.39269f,.5890486f,  .7853981f,       /* .3926990817f  */                                   .981747f,1.178097f, 1.374446f};                                     static const  float atan_xi_lo[]={0.0f,.000009081698724f,.000000023f,.000000063f,       /* .3926990817f  */                                    .000000704f, .00000025f,  .00000079f};                                         static const float  one_over_xi_hi[]={2.414213f, 1.49660575f,1.00000000f,                                       .668178618f,.414213568f,.198912367f};                                         static const float  one_over_xi_lo[]={.000000562f, 0.0f,0.0f,                                         0.0f,0.0f,0.0f};                                           float tmp_x[2];                                                                                __HI(x) &=0x7fffffff;  /*  |x| */      if(x >=  2.414213565f)             /* x is <= 1.0 */ //0x401A827A  {   z=1.0f/x;     inv++ ;  }   else if(.4142135624f <  x)     //0x3ED413CD  //(4.14213583e-01  {     index++;  // index is now 0    switch((*(int*)&x)&0x7f800000)    {            case 0x3F000000: /* .5  <= x < 1 */             if((*(int*)&x) >= 0x3F08D5B9)  index++;  //0.5345111 == tan(5pi/32)       if((*(int*)&x) >= 0x3F521801) index++;   //0.8206788      break;      case 0x3F800000: /* 1 <= x < 2    */       index+=2;       if((*(int*)&x) >= 0x3F9bf7ec) index++;   //1.2185035       if((*(int*)&x) >= 0x3FEF789E) index++;  //1.8708684       break;     case 0x40000000: /* 2 <= x <  2.414213565f   */      index+=4;      break;          }      z=1.0f/(one_over_xi_hi[index]+(one_over_xi_lo[index]+x));   tmp_x[1]=one_over_xi_hi[index] -  onep_one_over_xisqr_hi[index]*z;   tmp_x[0]=one_over_xi_lo[index] -  onep_one_over_xisqr_lo[index]*z;      z=(one_over_xi_hi[index] -  onep_one_over_xisqr_hi[index]*z) +     (one_over_xi_lo[index] -  onep_one_over_xisqr_lo[index]*z);   } else   z=x;   z_square=z*z;  z+= z*z_square*(atan_coeff[1]+ z_square*(atan_coeff[2]+         z_square*(atan_coeff[3]+ z_square*(atan_coeff[4]+          z_square*(atan_coeff[5]+ z_square*atan_coeff[6])) ))   );     z+=atan_xi_lo[index+1];   z+=atan_xi_hi[index+1];      if(inv)   {    z-=__PIO2__;    if(sign)         return z;         return -z;  }      (*(_INT32*)&z)|=sign;   return z;    }/*--------------------atan2f-------------------------------*/   __inline float atan2f( float y, float x){// need to figure out which quadrant we're in first// note |atanf(y/x)| < pi/2 and will return quadrant 1 if y and x// have the same sign and quadrant 4 if the signs differ.const _INT32 _sign_x=(_INT32)(__UHI(x)&0x80000000);const _INT32 _sign_y=(_INT32)(__UHI(y)&0x80000000);if(_sign_x == _sign_y){  if(_sign_x)  //we know both x, y<0 and angle is in quad 3	return atanf(y/x) -__PI;  if(x)   return atanf(y/x);  else   return __PIO2__ ;  }// signs differif( x < 0.0f)  // (x,y) in quadrant 2 {  return __PI + atanf(y/x); } // (x,y) in quadrant 4 if(x)  return atanf(y/x);  __HI(y)=_sign_y+ 0x3FC90FDB;  return y;}   /*---------------------------------------------------------*/   __inline float acosf( float x){     return  __PIO2__ -asinf(x); }/*---------------------------------------------------------------*/   __inline float asinf( float x){if(fabsf(x) < 1.0f) return atanf(x/sqrtf(1.0f - x*x));else if(x == 1.0f)  return __PIO2__ ;else if(x == -1.0f)    return -__PIO2__ ; return NAN;}   __inline float fabsf(float x)            {             __HI(x)&=0x7fffffff;             return  x;            }   __inline float coshf( float arg){   	return .5f*(expf(arg)+ expf(-arg));}   __inline float sinhf( float arg){		if(fabsf(arg) > 1.192092896e-07F)    	return .5f*(expf(arg)- expf(-arg));    else     return arg ;    	}	   __inline float tanhf( float arg){if(fabsf(arg) > 1.192092896e-07F)		return 1.0f - 2.0f/(expf(2.0f*arg)+1.0f);else    return arg ;}   __inline float ceilf (float x)			{			 _INT32 i=(_INT32)x;                float y=x-(float)i;              if((!(*(_INT32*)&y)) || (__HI(x)&0x7f800000) >= 0x4B800000)                return x ;               // x is already an int             else if(__HI(x)&0x80000000)                   return (float)i;                                return (float)++i;			}					   __inline float floorf(float x)			{			 _INT32 i=(_INT32)x;               // signed int              float y=(float)i-x;       // since order of evaluation is NOT guaranteed                                       // this is not guaranteed to work with all compilers for -0                                       // I currently have no "cheap" work around to this.                                                                              if((!(*(_INT32*)&y)) || (__HI(x)&0x7f800000) >= 0x4B800000)               return x ;               // x is already an int             else if(__HI(x)&0x80000000)                    return (float)--i;                     // x < 0 -> int conversion of x above rounded toward zero(so decrement)                             return (float)i;			}/* ldexp:			when underflow code is enabled this will return results identical to the exteneded precision fscale instruction on any x86 fpu 100% of the time. 			*/   __inline float ldexpf(float x, _INT32 n)  			{  						 _INT32 new_biased_exp = (_INT32)((0x7f800000&__UHI(x))>>23);			 // takes care of C9X inf/nan compliance and MUST be first to filter out these cases     			 switch(__HI(x)&0x7f800000)                {               case 0x7f800000:                return x;                         // takes care of nan and inf                break;               case 0:                           // may be either 0 or subnormal#ifdef __No_Gradual_Underflow__                return 0.0f ;                     // flush subnormal to zero(as if x was originally 0) and -0 -> 0                break;#else                                                            if(!(__HI(x)&0x007fffff))                   return x;    // return only if x==0                               do                  {                      __UHI(x)= __UHI(x)<<1; //the more we shift the less significance                      n-- ;                    }                   while(!(__HI(x)&0x00800000) ) ;                                  // no break so we drop down, x is now guaranteed to be normal                 // The multiplication of x and 2^^n may still produce a denormalized result               #endif                               } // end of switch           new_biased_exp+=n ;            switch(new_biased_exp)            {#ifndef __No_Gradual_Underflow__             case 0:   //barely subnormal(only lowest bit will be lost)              __UHI(x)=((0x00800000|__UHI(x)&0x007fffff)>>1) +               (__HI(x)&0x80000000);              return x;              break;#endif               case 255:  //infinity              __UHI(x)=( __UHI(x)&0x80000000)|0x7f800000;               return x;                           break;             default:              if(!(new_biased_exp&0xffffff00)) // for normal neither the sign bit(underflow)                {                               // nor any bit above 7(overflow) should be set                                               // (255 or 0x000000ff is a full exponent)                __UHI(x)=(__HI(x)&0x807fffff) + (((_UINT32)new_biased_exp)<<23);                        return x ;                                                                            }               break;            }               if(n > 0)//exponent has overflowed               {                              __UHI(x)=( __UHI(x)&0x80000000)|0x7f800000;                 return x;                          }   #ifdef __No_Gradual_Underflow__               __UHI(x)=__HI(x)&0x80000000;                return x;         //result of x*2^^n is subnormal#else               if(new_biased_exp <= -24)                 {                 __UHI(x)=__HI(x)&0x80000000;                 return x;                                                                         }                                     new_biased_exp=(_INT32)(0xffffffff - (_UINT32)(new_biased_exp + 1));                                        __UHI(x)=((0x00800000|__UHI(x)&0x007fffff)>>(new_biased_exp+1)) +                 (__HI(x)&0x80000000);                return x;#endif                }      __inline float frexpf(float x, int* exp) {  switch( __HI(x)&0x7f800000 )  {   case 0x7f800000:   case 0:    *exp=0;  // here if zero,inf,or nan    return x;    break;  }    _INT32 tmp_int=(_INT32)(0x3F000000 + (__UHI(x)&0x807fffff));  *exp=((__HI(x)&0x7F800000)>>23)-126;  return *((float*)&tmp_int); }   //log    __inline float log10f( float x) { switch( __HI(x)&0xff800000 )  {   default:   {#   define __log10_2  0.301029995664f      float   __log10_sqrt2 = 0.150514997831990597606869447362247f;      //poly 2302--misses double result by > 1 ulp but < 2 ulp .0034%    const float _log10_poly[] =     {	 0.868588961f,	 0.289530878375f,	 0.173569242f,	 0.1307240643f    };   float y,zsq;   _INT32 _exp,tmp;   if(__HI(x)&0x80000000)      return NAN;         _exp = (__HI(x) >> 23) - 126;    if(__HI(x)&=0x007fffff)       __HI(x)|= 0x3f000000;   else	   return --_exp* __log10_2;	 if( __HI(x) < 0x3F3504F3) 	              	x+=__sqrt2_m1*x;     else       __log10_sqrt2=0.0f;         x = 1.0f -(2.0f/(x + 1.0f));	 zsq = x*x;	 y=(((_log10_poly[3]*zsq + _log10_poly[2])*zsq + _log10_poly[1])*zsq + _log10_poly[0])*x;	 tmp= (_INT32)y;         //truncated toward zero     y-=(float)tmp;	 return (_exp*__log10_2 + tmp) + (y- __log10_sqrt2);        }  case 0x7f800000:  case 0xff800000:    if(__HI(x)&0x007fffff)      return x;    else     {     if(__HI(x)&0x80000000)       return NAN;     else      return INFINITY;    }      case 0:  // will fix for denormals later  case 0x80000000:    return -INFINITY ;    }//end of switch }#ifdef __cplusplus	#ifdef _MSL_USING_NAMESPACE		}#endif                 #endif     	#pragma cplusplus reset/* #pragma k63d_calls reset */#endif	/* __amd_singleprecision_math_for_k63dnow__ *//* CHANGES::    MF  000407  --cast everything to gid rid of implicit type conversion warnings*/    