/*  Metrowerks Standard Library  *//*  $Date: 2000/08/22 19:38:08 $  *  $Revision: 1.1.6.13.2.4 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//**************************************************************************	Project...:	Standard C99 math library/ ANSI/ISO C Standard Lib		 **	Name......:	math_x87.h		        								 **   Author..... Matthew D. Fassiotto                                     **	Purpose...:	to provide fast/accurate double precision implementations                of the standard C double functions as specified by math.h                This is intended for any cpu that natively executes or                emulates the  X87 extended precision instruction set.                    Notes: This is not completely compliant with every detail of the           ratified C99 standard nor are all the functions implemented.           We are missing erf,erfc, lgamma, gamma, fma, nextafter, et.           al.. Unless we hear demand for these there is no plan to            implement the remaining functions.                         This header gets included automatically by math.h.  It is not a           standalone header meant to be included directly by any application.           We do not support any source file including this header directly.           This header depends on macros and other types defined in math.h           which must be defined before this header is inlcuded.  Therefore           you are guaranteed this will NOT compile when included directly.                       The functions below have previously shipped in coff object files           as part of the CodeWarrior Professional product(e.g. math.obj).           Most of these have been moved into this header to:                        1. Take advantage of the MWerks compiler's ability to efficiently               inline assembly blocks, which will eliminate the function call               and allow other performance optimizations such as better                register allocation and reduced memory spillage.                           2. Allow this part of the library to be compiled into various               object formats(such as elf or coff).                           3. Allow these functions to take on various calling conventions               on the fly.  For instance, if targeting a K6 3DNOW! chip the               statement "return x;" will be compiled so that x is returned               in the mmx register "MM0" where normally x would be popped               from the fpu stack.                             4. Nice and easy to debug!                                      Special thanks to Fred Tydeman for finding several difficult           bugs!!			*************************************************************************/#ifndef __math_x87__#define __math_x87__#define __SET_ERRNO__#ifdef __SET_ERRNO__/*# include <errno.h>*/# include <cerrno>#endif#ifdef __cplusplus	extern "C" {#endifshort relation(double , double );#ifdef __cplusplus    }          #endif	    #define __EQUAL 0x4000    #define __GREATERTHAN 0    #define __LESSTHAN 0x0100    #define __UNORDERED 0x4500	#define isgreater(x, y) (!relation(x, y))	#define isgreaterequal(x, y) (!((relation(x, y)>>8) % 2))	#define isless(x, y) (relation(x, y) == __LESSTHAN)	#define islessequal(x, y) (relation(x, y)%__UNORDERED )	#define islessgreater(x, y) (relation(x, y) <= __LESSTHAN)	#define isunordered(x, y) (relation(x, y) == __UNORDERED)    #define isequal(x, y) (relation(x, y) == __EQUAL)    /* roundtol and rinttol are obsolete and are replaced by lround and lrint respectively.  For backward compatibility w/older versions of CWarrior, we provide macros,but they are now deprecated, and may be removed in future versions of Codewarrior.(HINT: start using the standard lrint,lround)*/#define roundtol lround#define rinttol  lrint/*    rounding functions:     Here is how I have interpreted C/C99 w/ regard to these functions and a brief explanation   of why one rounding function might be useful over the others.  My own opinion which I believe    to be correct is that the ANSI C committee has made an earnest attempt at tieing the C language with   the universally accepted binary floating point standard IEEE 754.  The addition of all    the new rounding functions supplies the user with an easy, flexible (and standard) means of   using directed rounding as specified by IEEE 754 in their code.   *//*In the table below we assume:   1. the IEEE 754 default rounding mode(round to nearest) is set in the FPU: 2. sizeof(int)=sizeof(long)=4 bytes,sizeof(long long)=sizeof(double)=8 bytes. 3. we are using both the range and full precision  of the extended based X87 instruction set when necessary    (e.g. the extended range -> DBL_MAX+DBL_MAX != INF ) 4. the type double is in the 8 byte double precision format as specified by IEEE 754. 5. U means undefined behavior sample input expression  | rint  |    lrint    |    llrint    |  round  |    lround    |  trunc  |  ceil  | floor  ----------------------------------------------------------------------------------------------------------------        -1.5             | -2.0  |     -2      |     -2       |  -2.0   |     -2       |  -1.0   | -1.0   | -2.0   ----------------------------------------------------------------------------------------------------------------           -0.5             | -0.0  |      0      |      0       |  -1.0   |     -1       |  -0.0   | -0.0   | -1.0   ----------------------------------------------------------------------------------------------------------------        1.801439851e16     | 2^^54 | U(overflow) |     2^^54    |         |      U       |  -1.0   | -1.0   | -2.0   ----------------------------------------------------------------------------------------------------------------   Note that the rounding preserves the sign of 0.rint, lrint , and llrint:------------------------These are unique amongst the rounding functions in that they don't check or set the rounding mode before rounding.  An example of where one might improve the performance of their code would befloat to int conversion.Consider the following simple program.#include <math.h>#include <stdio.h>int main(){ float x=sqrt(2.0); int i  = x ; printf("x=%g i=%i\n",x,i); return 0;}      an example of the generated code for the statement "int i = x;" is: int i  = x ;     fld        dword ptr [ebp]-0x10         <--- load x onto fp stack     fnstcw      [ebp]-0x12                  <--- backup control word which contains the current rounding mode     or         word ptr [ebp]-0x12,0x0c00   <--- set rounding mode to "toward zero" without disturbing the rest                                                  of the control word          fldcw       [ebp]-0x12                  <--- load the control word with new rounding mode     fistp      dword ptr [ebp]-0x08         <--- round and store integer i     and        word ptr [ebp]-0x12,0xf3ff   <--- restore previous control word     fldcw       [ebp]-0x12                  <--- load previous control word   On the other hand consider,#include <math.h>#include <stdio.h>#include <fenv.h>int main(){  float x; int i ; fesetround(FE_TOWARDZERO); x=sqrt(2.0); i = lrint(x) ; printf("x=%g i=%i\n",x,i); return 0;} now if we inline the lrint routine, the codegen for "i = lrint(x) ;"is simply: i = lrint(x) ;fld        xfrndintfistp      iof course there is the overhead from setting the rounding mode to "toward zero" before calling lrint,but this only needs to be performed once and not every time we convert a float to an int.  Manipulating the control word is an extremely expensive operation, each instruction taking multiple cycles to complete execution.The performance savings here can be significant.Also, keep in mind that changing the rounding mode must be performed carefully as it affects the results of ALL floating point operations in an executing thread (eg. addition and multiplication).llrint is similar to lrint, but is necessary only when you are computing with numbers where everysignificant bit in the floating point number is integral (e.g. x > pow(2.0,53.0).This library assumes at least a 32 bit 386 processor and therefore the 8 byte integral type long longis not natural to the targetted 4 byte architecture and requires "extra" instructions to implementthe same operations as would be required for a natural 4 byte integral type (long and int).*/    #ifndef _INLINE#define _INLINE __inline#endif   /* 	EJS 000822: due to a bug generating precompiled	headers, we can't include this code if precompiling */#if !(__option(precompile))#ifdef __cplusplus   extern "C" {#endif    extern const short __TO_INFINITY;   /* mask to change rounding mode to "toward +inf" on 16 bit control word*/ extern const short __TO_M_INFINITY; /* mask to change rounding mode to "toward -inf" on 16 bit control word*/ extern const short __TRUNC;         /* mask to change rounding mode to "toward zero" on 16 bit control word*/   extern const short __SIXTYFOURBITS; /* sets precision to "full" or 64 significant bits(full extended format) */ extern const float __HALF; extern const float __ONE;            /* used instead of instruction fld1 */#ifdef __cplusplus             }#endif                                                                                                                   #ifdef __cplusplus	#ifdef _MSL_USING_NAMESPACE		namespace std {	#endif	extern "C" {#endif#pragma only_std_keywords off _INLINE double rint(double x){ asm {	fld x	frndint	fstp x }	return x ;}_INLINE long lrint(double x){ long ret_val; asm {	fld x	frndint	fistp ret_val  }	return ret_val ;}_INLINE long long llrint(double x){ long long ret_val; asm {	fld x	frndint	fistp ret_val  }	return ret_val ;}	_INLINE double trunc(double x){short TEMP ;  asm {	fld x	fstcw TEMP	fldcw __TRUNC	frndint	fldcw TEMP	fstp x }  return x ;}       _INLINE double ceil(double x){short TEMP ;  asm { 	fld x 	fstcw TEMP		    ; save caller's current mode	fldcw __TO_INFINITY	; positive infldcw __SIXTYFOURBITSy(rc=2)	frndint	fldcw TEMP		    ; restore caller's mode	fstp x }	return x ;}_INLINE double floor(double x){short TEMP ;  asm { 	fld x 	fstcw TEMP		; save caller's current mode; save caller's current mode	fldcw __TO_M_INFINITY	frndint	fldcw TEMP		; restore caller's mode	fstp x }	return x ;}_INLINE double round(double x){short TEMP ; asm {  fld x  ftst  fstsw ax  and ax,0x0100  jne SUBTRACT  fadd __HALF  jmp GOSUBTRACT:  fsub __HALFGO:      fstcw TEMP  fldcw __TRUNC  frndint  fldcw TEMP  fstp x } return x;}_INLINElong lround(double x){ short __TEMP ; long _ret_val;  asm {  fld x  ftst  fstsw ax  and ax,0x0100  jne SUBTRACT    ; c0 gets set by ftst when x is a nan  fadd __HALF     ; but whether you add or substract .5 from the nan is irrelevant  jmp GOSUBTRACT:  fsub __HALFGO:      fstcw __TEMP  fldcw __TRUNC  frndint  fistp dword ptr[_ret_val]  fldcw __TEMP } return _ret_val;}_INLINE long long llround(double x){  short __TEMP ;  long long _ret_val;   asm {  fld x  ftst  fstsw ax  and ax,0x0100  jne LL_SUBTRACT    ; c0 gets set by ftst when x is a nan  fadd __HALF     ; but whether you add or substract .5 from the nan is irrelevant  jmp LL_GOLL_SUBTRACT:  fsub __HALFLL_GO:      fstcw __TEMP  fldcw __TRUNC  frndint  fistp qword ptr[_ret_val]  fldcw __TEMP }  return _ret_val;}/* nearbyint:This function is a bit of a hack since there is no way to tailorthe frndint instruction to NOT set the inexact exception flag.  some may see the setting of the inexact flag as an unecessary side effect of floatingpoint computation as it is well understood that we get rounded (inexact)results during computation.  If the user wishes to catch all meaningful floating pointexceptions in an application I suggest the use of the fesetenv function from fenv.h to mask just the inexact exception flag and unmask the rest.  nearbyint has the overheadof clearing the exception flag set on the status word.  This operation is computationallyexpensive. */_INLINE double nearbyint(double x){  char temp[28] ; /* 28 bytes of storage for fp environment */ asm {  fld x  frndint		 ; rounded according to current rounding mode  fnstenv temp  and    word ptr[temp+4],0xffcf ; clears inexact exception  fldenv temp  fstp x          }  return x;}/* scaling functions, algebraic functions (non transcendental): ldexp(scalbn),frexp, modf, fmod , sqrt  */  _INLINE double fmod(double x, double y){ asm {	fld y	fabs			; to insure sign of x is returned	fld xagain:	    fprem	fnstsw ax			test ax, 0x0400	; check for C2 bit	jnz again	fstp st(1)		; pop divisor	fstp x}return x ;} _INLINE double frexp(double x, int *exponent){ asm { 	fld x	ftst			; need to check if x=0 due to  behavior of fxtract	fnstsw ax	test ax, 0x4000	; check if C3 bit is set	jz normal_frexp	mov ECX,exponent 		fist dword ptr[ECX]	jmp frexp_donenormal_frexp:		fxtract			; st=Sx st(1)=n	fld __HALF		; 2^-1	fmul			; scale significand,pop __HALF 	fxch			; put exponent on top of stack	fld1	fadd     		; increase exponent by 1, overwrite exponent  pop 1					mov ECX,exponent	fistp dword ptr[ECX]frexp_done:	   	fstp x}	return x ;}		_INLINE double ldexp(double x, int exponent){  asm  {	fild exponent	; esp=address of LDEXP				    ; esp increments in bytes	fld x	        ; load x	fscale			; st=x st(1)=n	fstp st(1)	fstp x  }	return x ;}	_INLINE double modf(double x, double *iptr) { short __TEMP ;    asm   {	fld x	fld st	fstcw __TEMP		; backup caller's mode	fldcw __TRUNC	frndint			; st=I st(1)=x	fld st	fldcw __TEMP		; restore caller's mode	;mov ECX,[esp+12]	mov ECX,iptr        ; this instruction is probably not necessary come back and test	fstp qword ptr[ECX]	fsub	fstp x  }	return x ;}	_INLINE double sqrt(double x){#ifdef __SET_ERRNO__if(x >=0.0){#endif	asm 	{		fld x		fsqrt		fstp x	}		return x ;#ifdef __SET_ERRNO__	}#ifdef __SET_ERRNO__ errno=EDOM ;#endifreturn NAN ;#endif}	_INLINE double fabs(double x){	asm 	{		fld x		fabs		fstp x	}		return x ;}/* transcendentals:log, log10,log2, log1p, atan, atan2, atanh, acosh, asinh, exp2, expm1.Some of the other transcendentals such as pow are too large to inlineand are therefore located in one of the .obj files math_wrapper.obj,math.obj, or fpce.obj*/_INLINE double tanh(double x){ return 1.0 - 2.0/(exp(2.0*x)+1.0);}_INLINE double log(double x){#ifdef __SET_ERRNO__ if(x >=0.0)  {#endif asm {  fld x  fld1      	; st=1.0 st(1)=x  fxch  fyl2x	        ; st=1.0*log (x)  fldln2	    ;           2  fmul  fstp x   } return x; } #ifdef __SET_ERRNO__ errno=EDOM ;#endifreturn NAN ;}_INLINE  double log10(double  x){#ifdef __SET_ERRNO__ if(x >=0.0)  {#endif  asm {  fld x  fld1    ; st=1.0 st(1)=x  fxch  fyl2x		           ; st=1.0*log (x)  fldlg2               ;           2  fmul  fstp x  } return x ;} #ifdef __SET_ERRNO__ errno=EDOM ;#endifreturn NAN ;}_INLINE double logb(double x){	asm	{		fld x		fxtract		fxch		fstp x		fstp st	}		return x ;}					_INLINE double log2(double x){asm{    fld1	fld x	fyl2x	fstp x}    return x ;}	                 _INLINE double log1p(double x){short __TEMP ;  static const long long	LOG_ONEPX_MAX =0x3fda82795703f2d4 ;  /*.4142135d   */ static const long long	LOG_ONEPX_MIN =0xbfd2bec333018866;  /*-.29d*/ asm{	fstcw __TEMP	fldcw __SIXTYFOURBITS	fld x           	fcom LOG_ONEPX_MAX	fstsw ax	sahf	fld1	fxch	jnbe logp1_big_num	fcom LOG_ONEPX_MIN	fstsw ax	sahf	jc logp1_big_num	fyl2xp1             ; st=log	 	jmp logp1_donelogp1_big_num:                        ;st=x st(1)=1	fadd st,st(1)       ; st=1+x,st(1)=1	fyl2xlogp1_done:	    fldln2	fmul	fldcw __TEMP	fstp x}return x ;}_INLINE double expm1(double x){ 	short __TEMP ; switch(__HI(x)&0x7ff00000) {	default:	 asm	 {	 		           		fstcw __TEMP		fldcw __TRUNC        ; round x toward zero, if x*log2(e) < 1		fld x                ; we use the fast algorithm		fldl2e		fmul		fld  st              ; make a copy of x*log2(e)	    frndint              	    ftst		fstsw ax            		and ax, 0x4000       ; check if C3 bit is set, we've already filtered out nans above 		jz big_num           ; so we don't worry about the c0,c2 bits		fxch		f2xm1		fstp st(1)		jmp expm1_done	big_num:	    	    fsub st(1),st       ; dangerous only if x is an infinity, these are also filtered out 	    fxch	            ; in switch(using the intel extended range makes it impossible for x*log2e 		f2xm1               ; to overflow.		fld1		fadd		fscale		fld1		fsub		fstp st(1)	expm1_done:			fldcw __TEMP          ; restore the callers rounding mode		fstp x			 } /* end of asm block	*/	 return x ; 	 case 0x7ff00000: {  if(isnan(x))   return x;    /* x is an infinity */   if(__HI(x)&0x80000000)   return -1.0 ;  /*x=-INFINITY*/     return (double)INFINITY ; }  }	/* end of switch*/}_INLINE double exp2(double x){short __TEMP ; asm {	fstcw __TEMP	fldcw __SIXTYFOURBITS	fld x    fld st	frndint             ;st=int part, st(1)=whole number	fxch	fsub st,st(1)       ;st=whole-int=frac st(1)=int part	f2xm1	fld1	fadd                ; st=2^frac , st(1)=int part	fscale	fldcw __TEMP	fstp st(1)	fstp x}	return x ;}_INLINE double asinh(double x ){if(fabs(x) < 2.2204460492503131e-016)   return x; /* error is O(10^-48) */else{ asm  {	fld x 	fld st	fmul st,st(1)		; st=x^2 ,  st(1)=x	fadd __ONE	        ; st=x^2 +1 st(1)=x	fsqrt	fadd    			; st= x + sqrt(x^2 + 1)	fld1	fxch	fyl2x	fldln2	fmul	fstp x  } 	}return x;}_INLINE double atanh(double x ){#ifdef __SET_ERRNO__ if(fabs(x) > 1.0){   errno=EDOM;  return NAN;} else#endif if(fabs(x) < 2.2204460492503131e-016)   return x; /* error is O(10^-48) */asm{ fld x fld st fsub __ONE  ; st=(x-1), st(1)=x, st2=1 fchs fxch fadd __ONE fld  __ONE fxch fyl2x                ; st1*ln(st) fldln2 fmul                  fxch fld  __ONE fxch fyl2x fldln2 fmul fsubr st,st(1) fmul __HALF fstp st(1) fstp x } return x;}_INLINE double acosh(double x){  asm  {   fld  x ; x   fcom __ONE   fstsw ax   sahf   jb seterrno   fld st   fmul st,st(1)   fsub __ONE   fsqrt   fadd   fld1   fxch   fyl2x   fldln2   fmul   fstp x } return x; asm {seterrno:      fstp st  }#ifdef __SET_ERRNO__ errno=EDOM ;#endifreturn NAN ;}_INLINE double atan(double x) { asm {	fld x	fld1	fpatan	fstp x } return x ; }_INLINE double atan2(double y, double x)  { asm {	fld y	; load y	fld x	; st= st(1)=y	fpatan			; atan(y/x)	fstp x } return x ; }/*           from C9X(7.7.12.3): NaN arguments are treated as missing data: 	                 if one argument is a NaN and the other numeric, then                     fmax chooses the numeric value.                      fmin is analogous to fmax in its treatment of NaNs.*/                         extern  _INLINE  double fmin(double x, double y) {   asm	{	 fld x	 fcom y              ; st=x, y never loaded onto stack simply returned if x > y	 fstsw ax	 and ax,0x4700       ; sift out condition codes C0-C3(bits 14,8-10)          	 jz done_fmin        ; ax=0 -> c0-c3=0 or x > y	 and ax,0x0400       ; C2 bit set iff at least one of x or y is unordered	                     	 jz _copy_xtoy       ; copy x into y                         ; one or more operand at this point is                          ; guaranteed to be a nan	          	 fxam                ; checking if x is a nan, if x is numeric we move x to y	 fstsw ax  	 and ax,0x4400       ; at least one of C3,C2 is set -> x is not a nan->y=nan 	 jz done_fmin        ; x is a nan when ax=0 so we return original y(skip copy)_copy_xtoy: 	            fst y               ; copy x into y(i.e. x is numeric so the and is false)     	                         done_fmin:     fstp st     	}      return y ;}_INLINE  double fmax ( double x, double y) {   asm	{	 fld y	 fcom x              ; st=y, x never loaded onto stack simply returned if x > y	 fstsw ax	 and ax,0x4700       ; sift out condition codes C0-C3(bits 14,8-10)          	 jz _copy_ytox       ; ax=0 -> c0-c3=0 or y > x		 and ax,0x0400       ; C2 bit set iff at least one of x or y is unordered	                     	 jz done_fmax                                ; one or more operand at this point is                          ; guaranteed to be a nan	          	 fxam                ; checking if y is a nan, if y is numeric we move y to x	 fstsw ax  	 and ax,0x4400       ; if at least one of C3,C2 is set y is not a nan->x=nan 	 jz done_fmax        ; so copy y -> x_copy_ytox: 	      fst x               ; copy x into y(i.e. x is numeric so the and is false)     	                         done_fmax:     fstp st	}      return x;}/*The fdim function determines the positive difference between its arguments:x - y if x > y+0 if x <= yA range error may occur.note : unlike fmin/max the standard says nothing about how fdim behaves when one or moreoperand is a nan(we just return x-y=nan in this case), since the coding is simplified.*/_INLINE  double fdim ( double x, double y ) { double z=0.0; asm	{	 fld y	 fcom x              ; st=y, x never loaded onto stack simply return 0 if y > x	 fstsw ax	 and ax,0x4700       ; sift out condition codes C0-C3(bits 14,8-10)          	 jz done_fdim        ; ax=0 -> c0-c3=0 or x > y	 fsubr x             ; st=x-y	 fst  z              ; z=x-ydone_fdim:                            fstp st	}	return z ;}/*_INLINE  double copysign(double x , double y){   asm   {     fld x       ; load x     mov eax, dword ptr[esp+16]	; just want the first byte of y     mov ecx, dword ptr[esp+8]  ; sign of x     xor eax,ecx     and eax,0x80000000	 jz done	 fchs                       ; change sign of x only when 	                            ; sign(x) != sign(y)done:     ret	    }    }*/_INLINE  double hypot( double x, double y )  {  short _TEMP;  double z;  asm  {	fstcw _TEMP	fldcw __SIXTYFOURBITS	 fld x	fld st	fld y	fld st			; st=st1=real  st2=st3=imag	fxch st(2)		; st=imag, st1=real=st2=real st3=imag	fadd			; st=real+imag st(1)=real st(2)=imag	fmul st,st	fxch st(2)		; st=imag, st1=real st2=(real+imag)^2	fmul			; st=imag*real st(1)=real+imag	fadd st,st	fsub	fsqrt	fldcw _TEMP	fstp z}return z ;}/* remainder functions   double_t remquo    ( double_t x, double_t y, int *quo );   this only works for values of x and y such that the difference   in binary exponents of x and y is no more than 64. Have a solution using   array of long longs , but haven't thought about how to do efficiently.*/_INLINE	double remquo ( double x, double y, int *quo ) {  double z;  short __TEMP;  long long dummy;  asm  {    	fld  y	fld  xremquo_compute_again:			fprem1	fnstsw ax        ; check C2 bit	and   ah,0x04	jnz remquo_compute_again	fstp z	; now compute the quotient and store in _big_int	;lea ECX,dummy ;_big_int		fld x	fld y	fdiv	fstcw __TEMP	fldcw __TRUNC	fistp qword ptr[dummy]  ; st=quo, st(1)=x	fldcw __TEMP	fstp st  }	    *quo=(int)((unsigned int)(dummy&0x000000007fffffff) +            ((((unsigned int)(dummy>>32))&0x80000000)));  return z ;}/*_INLINE double llremquo ( double x, double y, long long *quo ) {  double z;  short __TEMP;    asm  {    	fld  y	fld  xremquo_compute_again:			fprem1	fnstsw ax        ; check C2 bit	and   ah,0x04	jnz remquo_compute_again	fstp z	; now compute the quotient and store in _big_int	mov ECX,quo		fld y	fld x	fdiv	fstcw __TEMP	fldcw __TRUNC	fistp qword ptr[ECX]  }	    return z ;}*/_INLINEdouble  remainder ( double x, double y) {  double z;  asm  {	fld y	fld xcompute_again:			fprem1	fnstsw ax	and   ah,0x04	jnz compute_again	fstp z	fstp st  ; clear stack  }	   return z;  }#ifdef __cplusplus}	#ifdef _MSL_USING_NAMESPACE		}	#endif	#endif#pragma only_std_keywords reset #endif /* !(__option(precompile))  */#endif /* __math_x87__ *//* mf-- 040598-- updated fmax,fmin,fdim to C9X to return a non-nan value when                  exactly one argument is a nan.   mf-- 042098-- fixed round and roundtol        mf-- 060898-- performance enhancements, __declspec(naked)                 whenever possible(shrinks codesize by about 10% when combined                 with other minor fixes(elimination of local variables etc.)     mf-- 061098   fixed bug in acosh(was using fmul instead of fmul st,st(1)(i.e. was popping)				    mf-- 071098   rewrote copysign   mf-- 071398   bug in asinh(wasn't restoring ebp)   mf-- 111398   log10 wasn't popping argument from fp stack when errno occured   mf-- 072199   moved most math_wrapper.c functions into this file. I left a few                  in math_wrapper.c because they are too big to _INLINE (like pow).                  fixed bug in fmin(IR9907-1375)(completely rewrote fmin/max/dim                 math_wrapper.c routines were sharing an unprotected/volitale static(TEMP).                   Each routine now has it's own local to make it threadsafe.   mf--061300    rounding mode for modf was wrong.  should be truncate, haven't a clue how this                 was changed.                  mf-- 061200   added #pragma only_std_keywords off       mf-- 061300   added some optimizations such as qword ptr[_ret_val]                 mf-- 061400   logb/remainder had a stack leak, added a pop   ejs  082200   don't include inline assembly in precompiled header                   */                 