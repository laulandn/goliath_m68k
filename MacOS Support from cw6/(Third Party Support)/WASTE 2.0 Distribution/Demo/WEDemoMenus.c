/* *	WASTE Demo Project: *	Menu Handling * *	Copyright © 1993-2000 Marco Piovanelli *	All Rights Reserved * *	C port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __ALIASES__#include <Aliases.h>#endif#ifndef __DEVICES__#include <Devices.h>#endif#ifndef __ERRORS__#include <Errors.h>#endif#ifndef __FONTS__#include <Fonts.h>#endif#ifndef __GESTALT__#include <Gestalt.h>#endif#ifndef __WEDEMO__#include "WEDemo.h"#endif#ifndef __MEASURES__#include "Measures.h"#endifconst WESelector gStyleTags [ ] ={	weTagPlain,	weTagBold,	weTagItalic,	weTagUnderline,	weTagOutline,	weTagShadow,	weTagCondensed,	weTagExtended,	weTagStrikethrough};const WESelector gAlignmentTags [ ] ={	weTagAlignmentDefault,	0,								//	separator line	weTagAlignmentLeft,	weTagAlignmentCenter,	weTagAlignmentRight,	weTagAlignmentFull};const WESelector gDirectionTags [ ] ={	weTagDirectionDefault,	0,								//	separator line	weTagDirectionLeftToRight,	weTagDirectionRightToLeft};const Fixed gStandardLineSpacings [ ] ={	weLineSpacingSingle,	weLineSpacingOneAndHalf,	weLineSpacingDouble};static void PrepareFileMenu ( MenuRef inFileMenu, WindowRef inWindow ){	int				item ;	if ( ! inFileMenu )	{		return ;	}	//	first disable all items	for ( item = CountMenuItems ( inFileMenu ) ; item >= 1 ; item -- )	{		DisableMenuItem ( inFileMenu, item ) ;	}	//	New, Open, and Quit are always enabled	EnableMenuItem ( inFileMenu, kItemNew ) ;	EnableMenuItem ( inFileMenu, kItemOpen ) ;	EnableMenuItem ( inFileMenu, kItemQuit ) ;	//	enable Close, Page Setup, Print and Save As if there is an active window	if ( inWindow )	{		EnableMenuItem ( inFileMenu, kItemClose ) ;		EnableMenuItem ( inFileMenu, kItemSaveAs ) ;		EnableMenuItem ( inFileMenu, kItemPageSetup ) ;		EnableMenuItem ( inFileMenu, kItemPrint ) ;		// enable Save is the active window is dirty		if ( WEGetModCount ( GetWindowWE ( inWindow ) ) > 0 )		{			EnableMenuItem ( inFileMenu, kItemSave ) ;		}	}}static void PrepareEditMenu ( MenuRef inEditMenu, WindowRef inWindow ){	WEReference		we ;	int				item ;	Str255			itemText ;	WEActionKind	actionKind ;	SInt32			selStart ;	SInt32			selEnd ;	if ( ! inEditMenu )	{		return ;	}	//	first, disable all items	for ( item = CountMenuItems ( inEditMenu ) ; item >= 1 ; item -- )	{		DisableMenuItem ( inEditMenu, item ) ;	}	//	by default, the Undo menu item should read "Can't Undo"	GetIndString ( itemText, kUndoStringsID, 1 ) ;	SetMenuItemText ( inEditMenu, kItemUndo, itemText ) ;	GetIndString ( itemText, kUndoStringsID, 2 ) ;	SetMenuItemText ( inEditMenu, kItemRedo, itemText ) ;	if ( inWindow )	{		we = GetWindowWE ( inWindow ) ;		//	enable Paste if there's anything pasteable on the Clipboard		if ( WECanPaste ( we ) )		{			EnableMenuItem ( inEditMenu, kItemPaste ) ;		}		// enable Undo if anything can be undone		if ( ( actionKind = WEGetIndUndoInfo ( 1, we ) ) > weAKNone )		{			EnableMenuItem ( inEditMenu, kItemUndo ) ;			if ( actionKind > weAKObjectChange )			{				actionKind = weAKUnspecified ;			}			// change the Undo menu item to "Undo" + name of action			GetIndString ( itemText, kUndoStringsID, 2 * actionKind + 1 ) ;			SetMenuItemText ( inEditMenu, kItemUndo, itemText ) ;		}		// enable Redo if anything can be redone		if ( ( actionKind = WEGetIndUndoInfo ( -1, we ) ) > weAKNone )		{			EnableMenuItem ( inEditMenu, kItemRedo ) ;			if ( actionKind > weAKObjectChange )			{				actionKind = weAKUnspecified ;			}			//	change the Redo menu item to "Redo" + name of action			GetIndString ( itemText, kUndoStringsID, 2 * actionKind + 2 ) ;			SetMenuItemText ( inEditMenu, kItemRedo, itemText ) ;		}		// enable Select All if there is anything to select		if ( WEGetTextLength ( we ) > 0 )		{			EnableMenuItem ( inEditMenu, kItemSelectAll ) ;		}		// get current selection range		WEGetSelection ( & selStart, & selEnd, we ) ;		if ( selStart != selEnd )		{			// enable Cut, Copy, and Clear if the selection range is not empty			EnableMenuItem ( inEditMenu, kItemCut ) ;			EnableMenuItem ( inEditMenu, kItemCopy ) ;			EnableMenuItem ( inEditMenu, kItemClear ) ;		}	}}static void PrepareFontMenu ( MenuRef inFontMenu, WEReference inWE ){	static SInt16 *		availableFonts = nil ;	static ItemCount	fontCount = 0 ;	Boolean *			present = nil ;	Str255				itemText ;	int					item ;	Boolean				isContinuous = false ;	char				markChar ;	if ( ! inFontMenu )	{		return ;	}	if ( ! availableFonts )	{		//	first time-only initialization		//	count menu items		fontCount = CountMenuItems ( inFontMenu ) ;		//	allocate a buffer for holding font family numbers		if ( ( availableFonts = ( SInt16 * ) NewPtrClear ( fontCount * sizeof ( SInt16 ) ) ) == nil )		{			return ;		//	duh!		}		//	fill in the array of available fonts		for ( item = 0 ; item < fontCount ; item ++ )		{			//	get nth available size			GetMenuItemText ( inFontMenu, item + 1, itemText ) ;			GetFNum ( itemText, & availableFonts [ item ] ) ;		}	}	//	allocate a temporary buffer for the Boolean values	if ( ( present = ( Boolean * ) NewPtrClear ( fontCount ) ) == nil )	{		return ;		//	whoops! out of memory	}	if ( inWE )	{		//	determine which fonts are present over the selection range		WEMatchAttributes ( kCurrentSelection, kCurrentSelection, weTagFontFamily,			sizeof ( SInt16 ), fontCount, availableFonts, present, & isContinuous, inWE ) ;	}	//	mark menu items corresponding to fonts used in the selection range	//	if there is only one font used throughout the selection range, check it	//	if more than one font is used in the selection range, mark them with dashes	markChar = isContinuous ? checkMark : '-' ;	for ( item = 0 ; item < fontCount ; item ++ )	{		SetItemMark ( inFontMenu, item + 1, present [ item ] ? markChar : 0 ) ;	}	//	dispose of the temporary buffer	DisposePtr ( ( Ptr ) present ) ;}static void PrepareSizeMenu ( MenuRef inSizeMenu, WEReference inWE ){	static Fixed	availableSizes [ kItemLastSize ] = { 0 } ;	Boolean			present [ kItemLastSize ] ;	Boolean			isContinuous = false ;	int				item ;	char			markChar ;	if ( ! inSizeMenu )	{		return ;	}	if ( availableSizes [ 0 ] == 0 )	{		Str255		itemText ;		//	first time-only initialization		//	fill in the array of available font sizes		for ( item = 0 ; item < kItemLastSize ; item ++ )		{			GetMenuItemText ( inSizeMenu, item + 1, itemText ) ;			StringToMeasure ( itemText, kUnitPoint, & availableSizes [ item ] ) ;		}	}	//	zero out Boolean array	BlockZero ( present, sizeof ( present ) ) ;	if ( inWE )	{		//	determine which sizes are present over the selection range		WEMatchAttributes ( kCurrentSelection, kCurrentSelection, weTagFontSize,			sizeof ( Fixed ), kItemLastSize, availableSizes, present, & isContinuous, inWE ) ;	}	//	mark menu items corresponding to sizes used in the selection range	//	if there is only one size used throughout the selection range, check it	//	if more than one size is used in the selection range, mark them with dashes	markChar = isContinuous ? checkMark : '-' ;	for ( item = 0 ; item < kItemLastSize ; item ++ )	{		SetItemMark ( inSizeMenu, item + 1, present [ item ] ? markChar : 0 ) ;	}}static void PrepareStyleMenu ( MenuRef inStyleMenu, WEReference inWE ){	const int		kNumStyles = 9 ;	WESelector		attribute ;	const Boolean	trueValue [ 1 ] = { true } ;	int				item ;	char			markChar ;	Boolean			isPresent [ kNumStyles ] ;	Boolean			isContinuous [ kNumStyles ] ;	if ( ! inStyleMenu )	{		return ;	}	//	clear isPresent/isContinuous arrays	BlockZero ( isPresent, sizeof ( isPresent ) ) ;	BlockZero ( isContinuous, sizeof ( isContinuous ) ) ;	if ( inWE )	{		for ( item = 0 ; item < kNumStyles ; item ++ )		{			//	get nth style attribute			attribute = gStyleTags [ item ] ;			//	see whether it's present and/or continuous over the current selection range			WEMatchAttributes ( kCurrentSelection, kCurrentSelection, attribute,				sizeof ( Boolean ), 1, trueValue, & isPresent [ item ], & isContinuous [ item ], inWE ) ;		}	}	//	mark Style menu items	for ( item = 0 ; item < kNumStyles ; item ++ )	{		markChar = isPresent [ item ] ? ( isContinuous [ item ] ? checkMark : '-' ) : 0 ;		SetItemMark ( inStyleMenu, item + 1, markChar ) ;	}}static void PrepareTextColorMenu ( MenuRef inColorMenu, WEReference inWE ){	int					item ;	RGBColor			availableColors [ kItemLastTextColor ] ;	Boolean				present [ kItemLastTextColor ] ;	const MCEntry *		entry ;	Boolean				isContinuous = false ;	char				markChar ;	if ( ! inColorMenu )	{		return ;	}	//	zero out arrays	BlockZero ( availableColors, sizeof ( availableColors ) ) ;	BlockZero ( present, sizeof ( present ) ) ;	if ( inWE )	{		//	fill in the array of available colors		for ( item = 0 ; item < kItemLastTextColor ; item ++ )		{			//	get nth available color			if ( ( entry = GetMCEntry ( kMenuTextColor, item + 1 ) ) != nil )			{				availableColors [ item ] = entry -> mctRGB2 ;			}		}		//	determine which colors are present over the selection range		WEMatchAttributes ( kCurrentSelection, kCurrentSelection, weTagTextColor,			sizeof ( RGBColor ), kItemLastTextColor, availableColors, present, & isContinuous, inWE ) ;	}	//	mark menu items corresponding to colors used in the selection range	//	if there is only one color used throughout the selection range, check it	//	if more than one color is used in the selection range, mark them with dashes	markChar = isContinuous ? checkMark : '-' ;	for ( item = 0 ; item < kItemLastTextColor ; item ++ )	{		SetItemMark ( inColorMenu, item + 1, present [ item ] ? markChar : 0 ) ;	}}static void PrepareBackgroundColorMenu ( MenuRef inColorMenu, WEReference inWE ){	int					item ;	const RGBColor		rgbWhite = { 0xFFFF, 0xFFFF, 0xFFFF } ;	RGBColor			availableColors [ kItemLastBackgroundColor ] ;	Boolean				present [ kItemLastBackgroundColor ] ;	const MCEntry *		entry ;	Boolean				isContinuous = false ;	char				markChar ;	if ( ! inColorMenu )	{		return ;	}	//	zero out arrays	BlockZero ( availableColors, sizeof ( availableColors ) ) ;	BlockZero ( present, sizeof ( present ) ) ;	if ( inWE )	{		//	fill in the array of available colors		for ( item = 0 ; item < kItemLastBackgroundColor ; item ++ )		{			//	get nth available color			if ( ( entry = GetMCEntry ( kMenuBackgroundColor, item + 1 ) ) != nil )			{				availableColors [ item ] = entry -> mctRGB2 ;			}			else			{				availableColors [ item ] = rgbWhite ;			}		}		//	determine which colors are present over the selection range		WEMatchAttributes ( kCurrentSelection, kCurrentSelection, weTagBackgroundColor,			sizeof ( RGBColor ), kItemLastBackgroundColor, availableColors, present, & isContinuous, inWE ) ;	}	//	mark menu items corresponding to colors used in the selection range	//	if there is only one color used throughout the selection range, check it	//	if more than one color is used in the selection range, mark them with dashes	markChar = isContinuous ? checkMark : '-' ;	for ( item = 0 ; item < kItemLastBackgroundColor ; item ++ )	{		SetItemMark ( inColorMenu, item + 1, present [ item ] ? markChar : 0 ) ;	}}static void PrepareAlignmentMenu ( MenuRef inAlignmentMenu, WEReference inWE ){	int					item ;	Boolean				present [ kItemLastAlignment ] ;	Boolean				isContinuous = false ;	char				markChar ;	if ( ! inAlignmentMenu )	{		return ;	}	//	zero out present array	BlockZero ( present, sizeof ( present ) ) ;	if ( inWE )	{		//	determine which alignments are present over the selection range		WEMatchAttributes ( kCurrentSelection, kCurrentSelection, weTagAlignment,			sizeof ( WESelector ), kItemLastAlignment, gAlignmentTags,			present, & isContinuous, inWE ) ;	}	//	mark menu items corresponding to alignments used in the selection range	markChar = isContinuous ? checkMark : '-' ;	for ( item = 0 ; item < kItemLastAlignment ; item ++ )	{		SetItemMark ( inAlignmentMenu, item + 1, present [ item ] ? markChar : 0 ) ;	}}static void PrepareDirectionMenu ( MenuRef inDirectionMenu, WEReference inWE ){	int					item ;	Boolean				present [ kItemLastDirection ] ;	Boolean				isContinuous = false ;	char				markChar ;	if ( ! inDirectionMenu )	{		return ;	}	//	zero out present array	BlockZero ( present, sizeof ( present ) ) ;	if ( inWE )	{		//	determine which alignments are present over the selection range		WEMatchAttributes ( kCurrentSelection, kCurrentSelection, weTagDirection,			sizeof ( WESelector ), kItemLastDirection, gDirectionTags,			present, & isContinuous, inWE ) ;	}	//	mark menu items corresponding to alignments used in the selection range	markChar = isContinuous ? checkMark : '-' ;	for ( item = 0 ; item < kItemLastDirection ; item ++ )	{		SetItemMark ( inDirectionMenu, item + 1, present [ item ] ? markChar : 0 ) ;	}}static void PrepareLineSpacingMenu ( MenuRef inLineSpacingMenu, WEReference inWE ){	int					item ;	Boolean				present [ kItemLastLineSpacing ] ;	Boolean				isContinuous = false ;	char				markChar ;	if ( ! inLineSpacingMenu )	{		return ;	}	//	zero out present array	BlockZero ( present, sizeof ( present ) ) ;	if ( inWE )	{		//	determine which alignments are present over the selection range		WEMatchAttributes ( kCurrentSelection, kCurrentSelection, weTagLineSpacing,			sizeof ( Fixed ), kItemLastLineSpacing, gStandardLineSpacings,			present, & isContinuous, inWE ) ;	}	//	mark menu items corresponding to line spacings used in the selection range	markChar = isContinuous ? checkMark : '-' ;	for ( item = 0 ; item < kItemLastLineSpacing ; item ++ )	{		SetItemMark ( inLineSpacingMenu, item + 1, present [ item ] ? markChar : 0 ) ;	}}static void PrepareFeaturesMenu ( MenuRef inFeaturesMenu, WEReference inWE ){	int			item ;	Boolean		features [ kItemLastFeature + 1 ] ;	SInt32		translucencyThreshold = 0 ;	if ( ! inFeaturesMenu )	{		return ;	}	BlockZero ( features, sizeof ( features ) ) ;	if ( inWE )	{		features [ kItemAutoScroll ] = WEFeatureFlag ( weFAutoScroll, weBitTest, inWE ) ;		features [ kItemOutlineHilite ] = WEFeatureFlag ( weFOutlineHilite, weBitTest, inWE ) ;		features [ kItemReadOnly ] = WEFeatureFlag ( weFReadOnly, weBitTest, inWE ) ;		features [ kItemIntelligentCutAndPaste ] = WEFeatureFlag ( weFIntCutAndPaste, weBitTest, inWE ) ;		features [ kItemDragAndDrop ] = WEFeatureFlag ( weFDragAndDrop, weBitTest, inWE ) ;		features [ kItemTranslucentDrags ] = ( WEGetInfo ( weTranslucencyThreshold, & translucencyThreshold, inWE ) == noErr ) && ( translucencyThreshold > 0 ) ;		features [ kItemOffscreenDrawing ] = WEFeatureFlag ( weFDrawOffscreen, weBitTest, inWE ) ;		features [ kItemMonoStyled ] = WEFeatureFlag ( weFMonoStyled, weBitTest, inWE ) ;		features [ kItemFontKeyboardSync ] = ! WEFeatureFlag ( weFNoKeyboardSync, weBitTest, inWE ) ;		features [ kItemICSupport ] = ! WEFeatureFlag ( weFInhibitICSupport, weBitTest, inWE ) ;	}	for ( item = 1 ; item <= kItemLastFeature ; item ++ )	{		MacCheckMenuItem ( inFeaturesMenu, item, features [ item ] ) ;	}}void PrepareMenus ( void ){	// get a pointer to the frontmost window, if any	WindowRef window = FrontWindow ( ) ;	// get associated WE instance	WEReference we = window ? GetWindowWE ( window ) : nil ;	PrepareFileMenu ( GetMenuHandle ( kMenuFile ), window ) ;	PrepareEditMenu ( GetMenuHandle ( kMenuEdit ), window ) ;	PrepareFontMenu ( GetMenuHandle ( kMenuFont ), we ) ;	PrepareSizeMenu ( GetMenuHandle ( kMenuSize ), we ) ;	PrepareStyleMenu ( GetMenuHandle ( kMenuStyle ), we ) ;	PrepareTextColorMenu ( GetMenuHandle ( kMenuTextColor ), we ) ;	PrepareBackgroundColorMenu ( GetMenuHandle ( kMenuBackgroundColor ), we ) ;	PrepareAlignmentMenu ( GetMenuHandle ( kMenuAlignment ), we ) ;	PrepareDirectionMenu ( GetMenuHandle ( kMenuDirection ), we ) ;	PrepareLineSpacingMenu ( GetMenuHandle ( kMenuLineSpacing ), we ) ;	PrepareFeaturesMenu ( GetMenuHandle ( kMenuFeatures ), we ) ;}OSStatus DoNew ( void ){	// create a new window from scratch	return CreateWindow ( nil, nil ) ;}OSStatus SaveWindow ( const FSSpec * pFileSpec, OSType inFileType, Boolean inStationery, WindowRef window ){	WEReference			we = GetWindowWE ( window ) ;	OSStatus			err;	//	switch off file type	switch ( inFileType )	{		case kTypeText :		{			if ( ( err = WriteTextFile ( pFileSpec, we ) ) != noErr )			{				goto cleanup ;			}			break ;		}		case kTypeUnicodeText :		{			if ( ( err = WriteUnicodeTextFile ( pFileSpec, we ) ) != noErr )			{				goto cleanup ;			}			break ;		}		default :		{			return badFileFormat ;		}	}	if ( inStationery )	{		//	set the stationery bit on the file we just saved		if ( ( err = FSpSetIsStationery ( pFileSpec ) ) != noErr )		{			goto cleanup ;		}	}	else	{		//	reset the window title and proxy icon to reflect the new file's name and type		SetWTitle ( window, pFileSpec->name ) ;		SetWindowProxyFSSpec ( window, pFileSpec ) ;		//	mark the window as clean		SetWindowModified ( window, false ) ;	}cleanup :	return err ;}OSStatus DoSave ( WindowRef window ){	FSSpec		spec ;	OSStatus	err;	//	get the file spec associated with this window, if any	if ( ( err = GetWindowProxyFSSpec ( window, & spec ) ) == noErr )	{		err = SaveWindow ( & spec, ( * GetWindowDocument ( window ) ) -> docType, false, window ) ;	}	else	{		//	if no file was previously associated with this window, or if the		//	alias resolution failed, prompt the user for a new destination		err = DoSaveAs ( window ) ;	}	return err;}OSStatus DoQuit ( SavingOption saving ){	WindowRef	window ;	OSStatus	err ;	// close all windows	do	{		if ( ( window = FrontWindow ( ) ) != nil )		{			if ( ( err = DoClose ( kNavSaveChangesQuittingApplication, saving, window ) ) != noErr )			{				return err;			}		}	} while ( window != nil ) ;	// set a flag so we drop out of the event loop	gExiting = true ;	return noErr ;}void DoAppleChoice ( UInt16 menuItem ){	if ( menuItem == kItemAbout )	{		DoAboutBox( kDialogAboutBox );	}#if ! TARGET_API_MAC_CARBON	else	{		//	open desk accessories (this is not required under Carbon)		Str255 deskAccessoryName ;		GetMenuItemText ( GetMenuHandle ( kMenuApple ), menuItem, deskAccessoryName ) ;		OpenDeskAcc ( deskAccessoryName ) ;	}#endif}void DoFileChoice ( UInt16 menuItem ){	WindowRef window = FrontWindow();	switch ( menuItem )	{		case kItemNew :		{			DoNew ( ) ;			break ;		}		case kItemOpen :		{			DoOpen ( ) ;			break ;		}		case kItemClose :		{			DoClose ( kNavSaveChangesClosingDocument, savingAsk, window ) ;			break ;		}		case kItemSave :		{			DoSave ( window ) ;			break ;		}		case kItemSaveAs :		{			DoSaveAs ( window ) ;			break ;		}		case kItemPageSetup :		{			DoPageSetup ( window ) ;			break ;		}		case kItemPrint :		{			DoPrint ( window ) ;			break ;		}		case kItemQuit :		{			DoQuit ( savingAsk ) ;			break ;		}	}}void DoEditChoice ( UInt16 menuItem ){	WindowRef		window ;	WEReference		we ;	// do nothing is no window is active	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}	we = GetWindowWE ( window ) ;	switch ( menuItem )	{		case kItemUndo :		{ 			WEUndo ( we ) ;			break ;		}		case kItemRedo :		{			WERedo ( we ) ;			break ;		}		case kItemCut :		{			WECut ( we ) ;			break ;		}		case kItemCopy :		{			WECopy ( we ) ;			break ;		}		case kItemPaste :		{			WEPaste ( we ) ;			break ;		}		case kItemClear :		{			WEDelete ( we ) ;			break ;		}		case kItemSelectAll :		{			int saveFeature = WEFeatureFlag ( weFAutoScroll, weBitClear, we ) ;			WESetSelection ( 0, 0x7FFFFFFF, we ) ;			WEFeatureFlag ( weFAutoScroll, saveFeature, we ) ;			break ;		}	}}void DoFontChoice ( UInt16 menuItem, Boolean forceFont ){	const int		kMaxAttributes = 8 ;	const Boolean	kTrueValue = true ;	WindowRef		window ;	ItemCount		attributeCount = 0 ;	WESelector		attributeTags [ kMaxAttributes ] ;	const void *	attributeValues [ kMaxAttributes ] ;	ByteCount		attributeSizes [ kMaxAttributes ] ;#if TARGET_API_MAC_CARBON	FMFontFamily	fontFamily = 0 ;	FMFontStyle		fontStyle = 0 ;	int				qdStyle ;#else	SInt16			fontFamily = 0 ;	Str255			fontName ;#endif	OSStatus		err ;	//	do nothing if there is no front window	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}#if TARGET_API_MAC_CARBON	//	when using hierarchical font menus in Carbon/Sonata, a menu selection	//	can map to *both* a font family number *and* a set of "intrinsic" styles	err = GetFontFamilyFromMenuSelection ( GetMenuHandle ( kMenuFont ), menuItem, & fontFamily, & fontStyle ) ;#else	GetMenuItemText ( GetMenuHandle ( kMenuFont ), menuItem, fontName ) ;	GetFNum ( fontName, & fontFamily ) ;#endif	//	add font family attribute	attributeTags [ attributeCount ] = forceFont ? weTagForceFontFamily : weTagFontFamily ;	attributeValues [ attributeCount ] = & fontFamily ;	attributeSizes [ attributeCount ] = sizeof ( fontFamily ) ;	attributeCount ++ ;#if TARGET_API_MAC_CARBON	//	add intrinsic styles, if any	for ( qdStyle = 0 ; qdStyle < 7 ; qdStyle ++ )	{		if ( fontStyle & ( 1 << qdStyle ) )		{			attributeTags [ attributeCount ] = gStyleTags [ qdStyle + 1 ] ;			attributeValues [ attributeCount ] = & kTrueValue ;			attributeSizes [ attributeCount ] = sizeof ( kTrueValue ) ;			attributeCount ++ ;		}	}#endif /*TARGET_API_MAC_CARBON*/	//	set all the attributes at once	err = WESetAttributes ( kCurrentSelection, kCurrentSelection, attributeCount,		attributeTags, attributeValues, attributeSizes, GetWindowWE ( window ) ) ;}void DoSizeChoice ( UInt16 menuItem ){	WindowRef		window ;	Str255			itemText ;	Fixed			fontSize ;	WESelector		attributeTag ;	OSStatus		err ;	//	do nothing if there is no front window	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}	if ( menuItem <= kItemLastSize )	{		GetMenuItemText ( GetMenuHandle ( kMenuSize ), menuItem, itemText ) ;		StringToMeasure ( itemText, kUnitPoint, & fontSize ) ;		attributeTag = weTagFontSize ;	}	else if ( menuItem == kItemSmaller )	{		fontSize = - ( 1 << 16 ) ;		attributeTag = weTagAddFontSize ;	}	else if ( menuItem == kItemLarger )	{		fontSize = + ( 1 << 16 ) ;		attributeTag = weTagAddFontSize ;	}	else	{		return ;	}	//	set the size of the selection	err = WESetOneAttribute ( kCurrentSelection, kCurrentSelection, attributeTag,		& fontSize, sizeof ( fontSize ), GetWindowWE ( window ) ) ;}void DoStyleChoice ( UInt16 menuItem ){	WindowRef 			window ;	WEReference			we ;	WESelector			attributeTag ;	Boolean				value ;	Boolean				isPresent ;	Boolean				isContinuous ;	OSStatus			err ;	//	do nothing if there is no front window	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}	we = GetWindowWE ( window ) ;	switch ( menuItem )	{		case kItemPlainText :		case kItemBold :		case kItemItalic :		case kItemUnderline :		case kItemOutline :		case kItemShadow :		case kItemCondensed :		case kItemExtended :		case kItemStrikethrough :		{			//	map menu item to corresponding style tag			attributeTag = gStyleTags [ menuItem - kItemPlainText ] ;			//	we shouldn't blindly set an attribute, but rather toggle it			//	if it's already present *and* continuous over the selection range			value = true ;			err = WEMatchAttributes ( kCurrentSelection, kCurrentSelection, attributeTag,				sizeof ( value ), 1, & value, & isPresent, & isContinuous, we ) ;			value = ! ( isPresent & isContinuous ) ;			//	set it			err = WESetOneAttribute ( kCurrentSelection, kCurrentSelection, attributeTag,				& value, sizeof ( value ), we ) ;			break ;		}		case kItemNudgeUp :		{			const Fixed kNudgeUpValue = + ( 1 << 16 ) ;			//	increase vertical shift			err = WESetOneAttribute ( kCurrentSelection, kCurrentSelection, weTagAddVerticalShift,				& kNudgeUpValue, sizeof ( kNudgeUpValue ), we ) ;			break ;		}		case kItemNudgeDown :		{			const Fixed kNudgeDownValue = - ( 1 << 16 ) ;			//	decrease vertical shift			err = WESetOneAttribute ( kCurrentSelection, kCurrentSelection, weTagAddVerticalShift,				& kNudgeDownValue, sizeof ( kNudgeDownValue ), we ) ;			break ;		}	}}void DoTextColorChoice ( UInt16 menuItem ){	WindowRef 			window ;	RGBColor			color = { 0x0000, 0x0000, 0x0000 } ;	const MCEntry *		entry ;	// do nothing if there is no front window	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}	// find the color corresponding to the chosen menu item	if ( ( entry = GetMCEntry ( kMenuTextColor, menuItem ) ) != nil )	{		color = entry -> mctRGB2 ;	}	//	set the color of the selection	WESetOneAttribute ( kCurrentSelection, kCurrentSelection, weTagTextColor,		& color, sizeof ( color ), GetWindowWE ( window ) ) ;}void DoBackgroundColorChoice ( UInt16 menuItem ){	WindowRef 			window ;	WESelector			attributeTags [ 2 ] ;	void *				attributeValues [ 2 ] ;	ByteCount			attributeValueSizes [ 2 ] ;	RGBColor			color = { 0xFFFF, 0xFFFF, 0xFFFF } ;	SInt16				transferMode = srcOr ;	const MCEntry *		entry ;	//	do nothing if there is no front window	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}	//	find the color corresponding to the chosen menu item	if ( ( entry = GetMCEntry ( kMenuBackgroundColor, menuItem ) ) != nil )	{		color = entry -> mctRGB2 ;		transferMode = srcCopy ;	}	//	setting the background color alone has no visible effect	//	unless we also set the QuickDraw text transfer mode to srcCopy	attributeTags [ 0 ] = weTagBackgroundColor ;	attributeValues [ 0 ] = & color ;	attributeValueSizes [ 0 ] = sizeof ( RGBColor ) ;	attributeTags [ 1 ] = weTagTransferMode ;	attributeValues [ 1 ] = & transferMode ;	attributeValueSizes [ 1 ] = sizeof ( SInt16 ) ;	WESetAttributes ( kCurrentSelection, kCurrentSelection, 2, attributeTags,		attributeValues, attributeValueSizes, GetWindowWE ( window ) ) ;}void DoAlignmentChoice ( UInt16 menuItem ){	WindowRef		window ;	WESelector		alignmentTag ;	if ( ( window = FrontWindow( ) ) == nil )	{		return ;	}	alignmentTag = gAlignmentTags [ menuItem - 1 ] ;	WESetOneAttribute ( kCurrentSelection, kCurrentSelection, weTagAlignment,		& alignmentTag, sizeof ( alignmentTag ), GetWindowWE ( window ) ) ;}void DoDirectionChoice ( UInt16 menuItem ){	WindowRef		window ;	WESelector		direction ;	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}	direction = gDirectionTags [ menuItem - 1 ] ;	WESetOneAttribute ( kCurrentSelection, kCurrentSelection, weTagDirection,		& direction, sizeof ( direction ), GetWindowWE ( window ) ) ;}void DoLineSpacingChoice ( UInt16 menuItem ){	WindowRef		window ;	Fixed			lineSpacing ;	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}	lineSpacing = gStandardLineSpacings [ menuItem - 1 ] ;	WESetOneAttribute ( kCurrentSelection, kCurrentSelection, weTagLineSpacing,		& lineSpacing, sizeof ( lineSpacing ), GetWindowWE ( window ) ) ;}void DoFeatureChoice ( UInt16 menuItem ){	WindowRef		window ;	WEReference		we ;	if ( ( window = FrontWindow ( ) ) == nil )	{		return ;	}	we = GetWindowWE ( window ) ;	switch ( menuItem )	{		case kItemAutoScroll:		{			WEFeatureFlag ( weFAutoScroll, weBitToggle, we ) ;			break;		}		case kItemOutlineHilite:		{			WEFeatureFlag ( weFOutlineHilite, weBitToggle, we ) ;			break;		}		case kItemReadOnly:		{			WEFeatureFlag ( weFReadOnly, weBitToggle, we ) ;			break;		}		case kItemIntelligentCutAndPaste:		{			WEFeatureFlag ( weFIntCutAndPaste, weBitToggle, we ) ;			break;		}		case kItemDragAndDrop:		{			WEFeatureFlag ( weFDragAndDrop, weBitToggle, we ) ;			break;		}		case kItemTranslucentDrags:		{			SInt32 translucencyThreshold = 0 ;			if ( WEGetInfo ( weTranslucencyThreshold, & translucencyThreshold, we ) == noErr )			{				translucencyThreshold = kStandardTranslucencyThreshold - translucencyThreshold ;				WESetInfo ( weTranslucencyThreshold, & translucencyThreshold, we ) ;			}			break;		}		case kItemOffscreenDrawing:		{			WEFeatureFlag ( weFDrawOffscreen, weBitToggle, we ) ;			break;		}		case kItemMonoStyled:		{			WEFeatureFlag ( weFMonoStyled, weBitToggle, we ) ;			break;		}		case kItemFontKeyboardSync:		{			WEFeatureFlag ( weFNoKeyboardSync, weBitToggle, we ) ;			break ;		}		case kItemICSupport:		{			WEFeatureFlag ( weFInhibitICSupport, weBitToggle, we ) ;			break ;		}	}}void DoMenuChoice ( UInt32 menuChoice, EventModifiers modifiers ){	const SInt16		menuID = ( menuChoice >> 16 ) ;	const UInt16		menuItem = ( menuChoice & 0x0000FFFF ) ;	// dispatch on menuID	switch ( menuID )	{		case kMenuApple :		{			DoAppleChoice ( menuItem ) ;			break ;		}		case kMenuFile :		{			DoFileChoice ( menuItem ) ;			break ;		}		case kMenuEdit :		{			DoEditChoice ( menuItem ) ;			break ;		}		case kMenuFont :		{			//	Normally, applying a font on a selection range only changes the portions			//	of the selection that have compatible text encodings.			//	For example, applying Palatino to a range consisting of mixed Roman and			//	Japanese text only affects the Roman portion and the Roman characters			//	in the Japanese portion -- it doesn't affect Kanji or Kana characters			//	since Palatino doesn't contain the necessary glyphs.			//	Nevertheless, power users should be allowed to force a font regardless			//	of text encoding.  This is accomplished by holding down a modifier key			//	(option or control) while choosing a font from the Font menu.			DoFontChoice ( menuItem, ( modifiers & ( optionKey | controlKey ) ) != 0 ) ;			break ;		}		case kMenuSize :		{			DoSizeChoice ( menuItem ) ;			break ;		}		case kMenuStyle :		{			DoStyleChoice ( menuItem ) ;			break ;		}		case kMenuTextColor :		{			DoTextColorChoice ( menuItem ) ;			break ;		}		case kMenuBackgroundColor :		{			DoBackgroundColorChoice ( menuItem ) ;			break ;		}		case kMenuAlignment :		{			DoAlignmentChoice ( menuItem ) ;			break ;		}		case kMenuDirection :		{			DoDirectionChoice ( menuItem ) ;			break ;		}		case kMenuLineSpacing :		{			DoLineSpacingChoice ( menuItem ) ;			break ;		}		case kMenuFeatures :		{			DoFeatureChoice ( menuItem ) ;			break ;		}	}	HiliteMenu ( 0 ) ;}OSStatus InitializeMenus ( void ){	Handle			menuBar = nil ;	MenuRef			menu ;#if TARGET_API_MAC_CARBON	ItemCount		submenuCount ;	ItemCount		itemCount ;	SInt32			gestaltResponse ;#endif	OSStatus		err ;	//	get the 'MBAR' resource	menuBar = GetNewMBar ( kMenuBarID ) ;	if ( ( err = ResError ( ) ) != noErr )	{		goto cleanup ;	}	err = memFullErr ;	if ( ! menuBar )	{		goto cleanup ;	}	//	install the menu bar	SetMenuBar ( menuBar ) ;#if TARGET_API_MAC_CARBON	//	create the Font menu	if ( ( menu = GetMenuHandle ( kMenuFont ) ) != nil )	{		if ( ( err = CreateStandardFontMenu ( menu, 0, kMenuFontFirstSubmenu, 0, & submenuCount ) ) != noErr )		{			goto cleanup ;		}	}	//	if we're running on a system with the Aqua user interface,	//	remove the Quit item from the File menu, as a Quit item is	//	automatically added for us to the Application menu	if ( ( Gestalt ( gestaltMenuMgrAttr, & gestaltResponse ) == noErr ) &&		 ( gestaltResponse & gestaltMenuMgrAquaLayoutMask ) )	{		if ( ( menu = GetMenuHandle ( kMenuFile ) ) != nil )		{			//	assume the Quit item is the last item in the File menu and follows a separator line			itemCount = CountMenuItems ( menu ) ;			if ( itemCount > 2 )			{				DeleteMenuItem ( menu, itemCount ) ;				DeleteMenuItem ( menu, itemCount - 1 ) ;			}		}	}#else	//	set up the Apple menu (this is not required under Carbon)	if ( ( menu = GetMenuHandle ( kMenuApple ) ) != nil )	{		AppendResMenu ( menu, kTypeDeskAccessory ) ;	}	if ( ( menu = GetMenuHandle ( kMenuFont ) ) != nil )	{		// create the Font menu		AppendResMenu ( menu, kTypeFont ) ;	}#endif /* ! TARGET_API_MAC_CARBON */	//	insert submenus into the hierarchical portion of the menu list	if ( ( menu = GetMenu ( kMenuTextColor ) ) != nil )	{		InsertMenu ( menu, kInsertHierarchicalMenu ) ;	}	if ( ( menu = GetMenu ( kMenuBackgroundColor ) ) != nil )	{		InsertMenu ( menu, kInsertHierarchicalMenu ) ;	}	if ( ( menu = GetMenu ( kMenuAlignment ) ) != nil )	{		InsertMenu ( menu, kInsertHierarchicalMenu ) ;	}	if ( ( menu = GetMenu ( kMenuDirection ) ) != nil )	{		InsertMenu ( menu, kInsertHierarchicalMenu ) ;	}	if ( ( menu = GetMenu ( kMenuLineSpacing ) ) != nil )	{		InsertMenu ( menu, kInsertHierarchicalMenu ) ;	}	//	draw the menu bar	DrawMenuBar ( ) ;	//	clear result code	err = noErr ;cleanup :	ForgetHandle ( & menuBar ) ;	return err ;}