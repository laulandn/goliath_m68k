/* *	WASTE Demo Project: *	Navigation Dialogs * *	Copyright © 1993-2000 Marco Piovanelli *	All Rights Reserved * *	C port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __NAVIGATION__#include <Navigation.h>#endif#ifndef __WEDEMO__#include "WEDemo.h"#endif//	numbers for custom dialog items in our Save dialog boxenum{	kItemFormatPopup			=	1,	kItemStationeryCheckbox		=	2} ;//	menu items in the format popup menuenum{	kItemTextFormat				=	1,	kItemUnicodeTextFormat		=	2} ;//	user structure passed to the NavEventFilter callbacktypedef struct NavCallbackData{	ControlRef		formatPopup ;	ControlRef		stationeryCheckbox ;	SInt16			extraItemsID ;	SInt16			numItems ;	OSType			fileType ;	Boolean			isStationery ;} NavCallbackData ;static pascal void NavEventFilter	(		NavEventCallbackMessage		inSelector,		NavCBRec *					inPB,		void *						inUserData	){	NavCallbackData *		cd = ( NavCallbackData * ) inUserData ;	switch ( inSelector )	{		case kNavCBEvent :		{			EventRecord *	event = inPB -> eventData . eventDataParms . event ;			//	intercept window events directed to windows behind the dialog			if ( ( event->what == updateEvt ) || ( event->what == activateEvt ) )			{				if ( ( WindowRef ) event->message != inPB->window )				{					DoWindowEvent ( event ) ;				}			}						//	intercept clicks in our custom items, if any			else if ( cd && ( event -> what == mouseDown ) )			{				switch ( inPB -> eventData . itemHit - cd -> numItems )				{					case kItemFormatPopup :					{						if ( cd -> formatPopup )						{							switch ( GetControlValue ( cd -> formatPopup ) )							{								case kItemTextFormat :								{									cd -> fileType = kTypeText ;									break ;								}								case kItemUnicodeTextFormat :								{									cd -> fileType = kTypeUnicodeText ;									break ;								}							}						}						break ;					}					case kItemStationeryCheckbox :					{						if ( cd -> stationeryCheckbox )						{							cd -> isStationery = 1 - cd -> isStationery ;							SetControlValue ( cd -> stationeryCheckbox, cd -> isStationery ) ;						}						break ;					}				}			}			break ;		}		case kNavCBCustomize :		{			//	do we need extra items?			if ( ! cd )			{				return ;			}			//	request an area for the extra items			if ( ( inPB -> customRect . right == 0 ) && ( inPB -> customRect . bottom == 0 ) )			{				inPB -> customRect . right = inPB -> customRect . left + 240 ;				inPB -> customRect . bottom = inPB -> customRect . top + 30 ;			}			break ;		}		case kNavCBStart :		{			DialogRef	dialog = GetDialogFromWindow ( inPB -> window ) ;			Handle		extraItems ;			OSStatus	err ;			//	do we need extra items?			if ( ! cd )			{				return ;			}			//	get the DITL resource containing the extra items			if ( ( extraItems = GetResource ( FOUR_CHAR_CODE ( 'DITL' ), cd -> extraItemsID ) ) == nil )			{				return ;			}			DetachResource ( extraItems ) ;			//	add it to the nav dialog control list			err = NavCustomControl ( inPB -> context, kNavCtlAddControlList, extraItems ) ;			DisposeHandle ( extraItems ) ;			if ( err != noErr )			{				return ;			}			//	count existing dialog items			if ( ( err = NavCustomControl ( inPB -> context, kNavCtlGetFirstControlID, & cd -> numItems ) ) != noErr )			{				return ;			}			//	get handles to our custom controls			if ( ( err = GetDialogItemAsControl (dialog, cd -> numItems + kItemFormatPopup, & cd -> formatPopup ) ) != noErr )			{				return ;			}			if ( ( err = GetDialogItemAsControl ( dialog, cd -> numItems + kItemStationeryCheckbox, & cd -> stationeryCheckbox ) ) != noErr )			{				return ;			}			//	set up the format popup			SetControlValue ( cd -> formatPopup, ( cd -> fileType == kTypeText ) ? kItemTextFormat : kItemUnicodeTextFormat ) ;			break ;		}	}}static OSStatus CreateNavTypeList	(		OSType					inApplicationSignature,		UInt16					inNumTypes,		const OSType *			inSFTypeList,		NavTypeListHandle *		outNavTypeList	){	OSStatus	err ;	//	allocate the type list handle	* outNavTypeList = ( NavTypeListHandle ) NewHandleClear ( ( sizeof ( NavTypeList ) - sizeof ( OSType ) ) +		( inNumTypes * sizeof ( OSType ) ) ) ;	if ( ( err = MemError ( ) ) != noErr )	{		return err ;	}	//	fill it in	( ** outNavTypeList ) -> componentSignature = inApplicationSignature ;	( ** outNavTypeList ) -> osTypeCount = inNumTypes ;	BlockMoveData ( inSFTypeList, ( ** outNavTypeList ) -> osType, inNumTypes * sizeof ( OSType ) ) ;	return noErr ;}OSStatus DoOpen ( void ){	const OSType				openableTypes [ ] = { kTypeText, kTypeUnicodeText } ;	const ProcessSerialNumber	thisApp = { 0, kCurrentProcess } ;	NavReplyRecord *			reply = nil ;	NavDialogOptions *			options = nil ;	NavEventUPP					eventProc = nil ;	NavTypeListHandle			typeList = nil ;	AEDesc						targetDesc ;	AppleEvent					openEvent ;	AppleEvent					replyEvent ;	OSStatus					err ;	InitDesc ( & targetDesc ) ;	InitDesc ( & openEvent ) ;	InitDesc ( & replyEvent ) ;	//	allocate space for reply and options	reply = ( NavReplyRecord * ) NewPtrClear ( sizeof ( * reply ) ) ;	if ( ( err = MemError ( ) ) != noErr )	{		goto cleanup ;	}	options = ( NavDialogOptions * ) NewPtrClear ( sizeof ( * options ) ) ;	if ( ( err = MemError ( ) ) != noErr )	{		goto cleanup ;	}	//	allocate type list handle	if ( ( err = CreateNavTypeList ( sigWASTEDemo, sizeof ( openableTypes ) / sizeof ( openableTypes [ 0 ] ),		openableTypes, & typeList ) ) != noErr )	{		goto cleanup ;	}	//	init dialog options	if ( ( err = NavGetDefaultDialogOptions ( options ) ) != noErr )	{		goto cleanup ;	}	//	create event UPP	err = memFullErr ;	if ( ( eventProc = NewNavEventUPP ( NavEventFilter ) ) == nil )	{		goto cleanup ;	}	//	do the dialog	if ( ( err = NavGetFile ( nil, reply, options, eventProc, nil, nil, typeList, nil ) ) != noErr )	{		goto cleanup ;	}	//	make sure the reply is valid	err = userCanceledErr ;	if ( ! reply -> validRecord )	{		goto cleanup ;	}	//	build an open Apple event	if ( ( err = AECreateDesc ( typeProcessSerialNumber, & thisApp, sizeof ( thisApp ), & targetDesc ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AECreateAppleEvent ( kCoreEventClass, kAEOpenDocuments, & targetDesc,		kAutoGenerateReturnID, kAnyTransactionID, & openEvent ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEPutParamDesc ( & openEvent, keyDirectObject, & reply -> selection ) ) != noErr )	{		goto cleanup ;	}	//	send it	if ( ( err = AESend ( & openEvent, & replyEvent, kAENoReply + kAEAlwaysInteract,		kAENormalPriority, kAEDefaultTimeout, nil, nil ) ) != noErr )	{		goto cleanup ;	}cleanup :	if ( reply != nil )	{		NavDisposeReply ( reply ) ;		DisposePtr ( ( Ptr ) reply ) ;	}	if ( options != nil )	{		DisposePtr ( ( Ptr ) options ) ;	}	if ( eventProc != nil )	{		DisposeNavEventUPP ( eventProc ) ;	}	ForgetHandle ( ( Handle * ) & typeList ) ;	AEDisposeDesc ( & targetDesc ) ;	AEDisposeDesc ( & openEvent ) ;	AEDisposeDesc ( & replyEvent ) ;	return err;}OSStatus DoSaveAs ( WindowRef window ){	FSSpec						spec ;	NavCallbackData				cd ;	NavReplyRecord *			reply = nil ;	NavDialogOptions *			options = nil ;	NavEventUPP					eventProc = nil ;	AEKeyword					keyword ;	DescType					actualType ;	Size						actualSize ;	OSStatus					err ;	BlockZero ( & cd, sizeof ( cd ) ) ;	cd . extraItemsID = kDITLSaveAsExtras ;	cd . fileType = ( * GetWindowDocument ( window ) ) -> docType ;	//	allocate space for reply and options	reply = ( NavReplyRecord * ) NewPtrClear ( sizeof ( * reply ) ) ;	if ( ( err = MemError ( ) ) != noErr )	{		goto cleanup ;	}	options = ( NavDialogOptions * ) NewPtrClear ( sizeof ( * options ) ) ;	if ( ( err = MemError ( ) ) != noErr )	{		goto cleanup ;	}	//	init dialog options	if ( ( err = NavGetDefaultDialogOptions ( options ) ) != noErr )	{		goto cleanup ;	}	options -> dialogOptionFlags |= kNavNoTypePopup ;	GetWTitle ( window, options->savedFileName ) ;	//	create event UPP	err = memFullErr ;	if ( ( eventProc = NewNavEventUPP ( NavEventFilter ) ) == nil )	{		goto cleanup ;	}	//	do the dialog	if ( ( err = NavPutFile ( nil, reply, options, eventProc, kTypeText, sigWASTEDemo, & cd ) ) != noErr )	{		goto cleanup ;	}	//	make sure the reply is valid	err = userCanceledErr ;	if ( ! reply -> validRecord )	{		goto cleanup ;	}	//	get the selected file	if ( ( err = AEGetNthPtr ( & reply->selection, 1, typeFSS, & keyword, & actualType, & spec, sizeof ( spec ), & actualSize ) ) != noErr )	{		goto cleanup ;	}	//	save the window to the selected file	if ( ( err = SaveWindow ( & spec, cd . fileType, cd . isStationery, window ) ) != noErr )	{		goto cleanup ;	}	//	notify Navigation Services we're done with the file	if ( ( err = NavCompleteSave ( reply, kNavTranslateInPlace ) ) != noErr )	{		goto cleanup ;	}cleanup :	if ( reply != nil )	{		NavDisposeReply ( reply ) ;		DisposePtr ( ( Ptr ) reply ) ;	}	if ( options != nil )	{		DisposePtr ( ( Ptr ) options ) ;	}	if ( eventProc != nil )	{		DisposeNavEventUPP ( eventProc ) ;	}	return err;}OSStatus DoClose ( NavAskSaveChangesAction action, SavingOption saving, WindowRef window ){	NavDialogOptions *			options = nil ;	NavEventUPP					eventProc = nil ;	NavAskSaveChangesResult		result ;	OSStatus					err;	//	is this window dirty?	if ( WEGetModCount ( GetWindowWE ( window ) ) > 0 )	{		//	do we have to ask the user whether to save changes?		if ( saving == savingAsk )		{			//	set up dialog options for NavAskSaveChanges			options = ( NavDialogOptions * ) NewPtrClear ( sizeof ( * options ) ) ;			if ( ( err = MemError ( ) ) != noErr )			{				goto cleanup ;			}			if ( ( err = NavGetDefaultDialogOptions ( options ) ) != noErr )			{				goto cleanup ;			}			GetWTitle ( window, options -> savedFileName ) ;			GetIndString ( options -> clientName, kMiscStringsID, 2 ) ;			//	create event UPP			err = memFullErr ;			if ( ( eventProc = NewNavEventUPP ( NavEventFilter ) ) == nil )			{				goto cleanup ;			}			//	display the Save Changes dialog			if ( ( err = NavAskSaveChanges ( options, action , & result, eventProc, nil ) ) != noErr )			{				goto cleanup ;			}			switch ( result )			{				case kNavAskSaveChangesSave :				{					saving = savingYes ;					break ;				}				case kNavAskSaveChangesDontSave :				{					saving = savingNo ;					break ;				}				case kNavAskSaveChangesCancel :				{					err = userCanceledErr ;					goto cleanup ;				}			}		}		if ( saving == savingYes )		{			if ( ( err = DoSave ( window ) ) != noErr )			{				return err ;			}		}	}	// destroy the window	DestroyWindow ( window ) ;	//	clear result code	err = noErr ;cleanup :	//	clean up	if ( options != nil )	{		DisposePtr ( ( Ptr ) options ) ;	}	if ( eventProc != nil )	{		DisposeNavEventUPP ( eventProc ) ;	}	//	return result code	return err ;}