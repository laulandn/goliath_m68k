/*  Metrowerks Standard Library  *//*  $Date: 2000/06/09 19:24:04 $  *  $Revision: 1.14.4.3 $  *  $NoKeywords: $  * *		Portions Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//** ** deque **/#ifndef _DEQUE#define _DEQUE#include <mslconfig>#include <iterator>#include <new>#include <memory>#include <algorithm>#include <limits>#include <cdeque>#ifndef RC_INVOKED#pragma options align=native#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#if _MSL_FORCE_ENUMS_ALWAYS_INT		#pragma enumsalwaysint on	#else		#pragma enumsalwaysint off	#endif#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT		#pragma bool on	#else		#pragma bool off	#endif#endif#ifndef _MSL_NO_CPP_NAMESPACE	namespace std {#endiftemplate <class T, class Allocator = allocator<T> >class deque{	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <bool b> struct chooser {};	#endifpublic:	// types:	typedef typename Allocator::reference         reference;	typedef typename Allocator::const_reference   const_reference;	class                                         iterator;	class                                         const_iterator;	typedef typename Allocator::size_type         size_type;	typedef typename Allocator::difference_type   difference_type;	typedef T                                     value_type;	typedef Allocator                             allocator_type;	typedef typename Allocator::pointer           pointer;	typedef typename Allocator::const_pointer     const_pointer;	typedef _STD::reverse_iterator<iterator>       reverse_iterator;	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;private:	typedef _MSL_REBIND (pointer) buf_allocator;	typedef Metrowerks::cdeque<pointer, buf_allocator> buf_type;public:	friend class iterator;	class iterator		: public _STD::iterator<random_access_iterator_tag, T, difference_type, pointer, reference>	{	public:		iterator() {}		reference operator * () const {return *cur_;}		pointer operator -> () const {return cur_;}		iterator& operator ++ ()		{			++pos_;			if (++cur_ == end_)			{				difference_type buf_size = end_ - *beg_;				++beg_;				pointer beg = *beg_;				cur_ = beg;				end_ = beg + buf_size;			}			return *this;		}		iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}		iterator& operator -- ()		{			--pos_;			pointer beg = *beg_;			if (cur_ != beg)				--cur_;			else			{				difference_type buf_size = end_ - beg;				--beg_;				end_ = *beg_ + buf_size;				cur_ = end_ - 1;			}			return *this;		}		iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}		iterator& operator += (difference_type n)		{			if (n < 0)				return (*this) -= -n;			pos_ += static_cast<size_type>(n);			difference_type room = end_ - cur_ ;			if (n < room)				cur_ += n;			else			{				difference_type buf_size = end_ - *beg_;				n -= room;				beg_ += n / buf_size + 1;				pointer beg = *beg_;				cur_ = beg + n % buf_size;				end_ = beg + buf_size;			}			return *this;		}		iterator operator + (difference_type n) const {return iterator(*this) += n;}		iterator& operator -= (difference_type n)		{			if (n < 0)				return (*this) += -n;			pos_ -= static_cast<size_type>(n);			pointer beg = *beg_;			difference_type room = cur_ - beg + 1;			if (n < room)				cur_ -= n;			else			{				difference_type buf_size = end_ - beg;				n -= room;				beg_ -= n / buf_size + 1;				end_ = *beg_ + buf_size;				cur_ = end_ - 1 - n % buf_size;			}			return *this;		}		iterator operator - (difference_type n) const {return iterator(*this) -= n;}		difference_type operator - (const iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}		reference operator [] (difference_type i) const {iterator tmp(*this); tmp += i; return *tmp;}		friend bool operator ==(const iterator& x, const iterator& y) {return x.cur_ == y.cur_;}  // hh 990720		friend bool operator !=(const iterator& x, const iterator& y) {return x.cur_ != y.cur_;}		friend bool operator < (const iterator& x, const iterator& y) {return x.pos_ <  y.pos_;}		friend bool operator <=(const iterator& x, const iterator& y) {return x.pos_ <= y.pos_;}		friend bool operator > (const iterator& x, const iterator& y) {return x.pos_ >  y.pos_;}		friend bool operator >=(const iterator& x, const iterator& y) {return x.pos_ >= y.pos_;}		friend iterator operator + (difference_type n, const iterator& rhs)			{return iterator(rhs) += n;}	private:		buf_type::iterator beg_;		pointer cur_;		pointer end_;		size_type pos_;		iterator(const buf_type::iterator& beg, pointer cur, pointer end, size_type pos)			: beg_(beg),			  cur_(cur),			  end_(end),			  pos_(pos)		{}		friend class deque;		friend class deque::const_iterator;	};	friend class const_iterator;	class const_iterator		: public _STD::iterator<random_access_iterator_tag, T, difference_type, const_pointer, const_reference>	{	public:		const_iterator() {}		const_iterator(const deque::iterator& rhs) : beg_(rhs.beg_), cur_(rhs.cur_), end_(rhs.end_), pos_(rhs.pos_) {}		const_reference operator * () const {return *cur_;}		const_pointer operator -> () const {return cur_;}		const_iterator& operator ++ ()		{			++pos_;			if (++cur_ == end_)			{				difference_type buf_size = end_ - *beg_;				++beg_;				pointer beg = *beg_;				cur_ = beg;				end_ = beg + buf_size;			}			return *this;		}		const_iterator operator ++ (int) {const_iterator tmp(*this); ++(*this); return tmp;}		const_iterator& operator -- ()		{			--pos_;			pointer beg = *beg_;			if (cur_ != beg)				--cur_;			else			{				difference_type buf_size = end_ - beg;				--beg_;				end_ = *beg_ + buf_size;				cur_ = end_ - 1;			}			return *this;		}		const_iterator operator -- (int) {const_iterator tmp(*this); --(*this); return tmp;}		const_iterator& operator += (difference_type n)		{			if (n < 0)				return (*this) -= -n;			pos_ += static_cast<size_type>(n);			difference_type room = end_ - cur_ ;			if (n < room)				cur_ += n;			else			{				difference_type buf_size = end_ - *beg_;				n -= room;				beg_ += n / buf_size + 1;				pointer beg = *beg_;				cur_ = beg + n % buf_size;				end_ = beg + buf_size;			}			return *this;		}		const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}		const_iterator& operator -= (difference_type n)		{			if (n < 0)				return (*this) += -n;			pos_ -= static_cast<size_type>(n);			pointer beg = *beg_;			difference_type room = cur_ - beg + 1;			if (n < room)				cur_ -= n;			else			{				difference_type buf_size = end_ - beg;				n -= room;				beg_ -= n / buf_size + 1;				end_ = *beg_ + buf_size;				cur_ = end_ - 1 - n % buf_size;			}			return *this;		}		const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}		difference_type operator - (const const_iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}		const_reference operator [] (difference_type i) const {const_iterator tmp(*this); tmp += i; return *tmp;}		friend bool operator ==(const const_iterator& x, const const_iterator& y) {return x.cur_ == y.cur_;}  // hh 990720		friend bool operator !=(const const_iterator& x, const const_iterator& y) {return x.cur_ != y.cur_;}		friend bool operator < (const const_iterator& x, const const_iterator& y) {return x.pos_ <  y.pos_;}		friend bool operator <=(const const_iterator& x, const const_iterator& y) {return x.pos_ <= y.pos_;}		friend bool operator > (const const_iterator& x, const const_iterator& y) {return x.pos_ >  y.pos_;}		friend bool operator >=(const const_iterator& x, const const_iterator& y) {return x.pos_ >= y.pos_;}		friend const_iterator operator + (difference_type n, const const_iterator& rhs)			{return const_iterator(rhs) += n;}	private:		buf_type::const_iterator beg_;		const_pointer cur_;		const_pointer end_;		size_type pos_;		const_iterator(const buf_type::const_iterator& beg, const_pointer cur, const_pointer end, size_type pos)			: beg_(beg),			  cur_(cur),			  end_(end),			  pos_(pos)		{}		friend class deque;	};	// _lib.deque.cons_ construct/copy/destroy:	explicit deque(const Allocator& = Allocator());	explicit deque(size_type n);  // hh 990826	explicit deque(size_type n, const T& value, const Allocator& = Allocator());	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <class InputIterator>			inline			deque(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: alloc_(a, default_bufsize_s),				  buf_(buf_allocator(a)),				  start_(0),				  size_(0)			{				choose_init(first, last, chooser<numeric_limits<InputIterator>::is_integer>());			}	#else		deque(const_iterator first, const_iterator last, const Allocator& = Allocator());		deque(const value_type* first, const value_type* last, const Allocator& = Allocator());	#endif	deque(const deque<T,Allocator>& x);	~deque();	deque<T,Allocator>& operator=(const deque<T,Allocator>& x);	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <class InputIterator>			inline			void assign(InputIterator first, InputIterator last)			{				choose_assign(first, last, chooser<numeric_limits<InputIterator>::is_integer>());			}	#else		void assign(const_iterator first, const_iterator last);		void assign(const value_type* first, const value_type* last);	#endif	void assign(size_type n, const T& t);	allocator_type get_allocator() const;	// iterators:	iterator               begin();	const_iterator         begin() const;	iterator               end();	const_iterator         end() const;	reverse_iterator       rbegin();	const_reverse_iterator rbegin() const;	reverse_iterator       rend();	const_reverse_iterator rend() const;	// _lib.deque.capacity_ capacity:	size_type size() const;	size_type max_size() const;	void      resize(size_type sz);  // hh 990826	void      resize(size_type sz, const T& value);	bool      empty() const;	// element access:	reference       operator[](size_type n);	const_reference operator[](size_type n) const;	reference       at(size_type n);	const_reference at(size_type n) const;	reference       front();	const_reference front() const;	reference       back();	const_reference back() const;	// _lib.deque.modifiers_ modifiers:	void push_front(const T& x);	void push_back(const T& x);	iterator insert(iterator position, const T& x);	void     insert(iterator position, size_type n, const T& x);	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <class InputIterator>			inline			void insert(iterator position, InputIterator first, InputIterator last)			{				choose_insert(position, first, last, chooser<numeric_limits<InputIterator>::is_integer>());			}	#else		void insert(iterator position, const_iterator first, const_iterator last);		void insert(iterator position, const value_type* first, const value_type* last);	#endif	void pop_front();	void pop_back();	iterator erase(iterator position);	iterator erase(iterator first, iterator last);	void     swap(deque<T,Allocator>&);	void     clear();private:	static const size_type min_buf_size_s = 8;	static const size_type min_foot_print_s = 512;	static const size_type default_bufsize_s = sizeof(T) * min_buf_size_s < min_foot_print_s ?	                                           min_foot_print_s / sizeof(T) : min_buf_size_s;	_EmptyMemberOpt<Allocator, size_type> alloc_;  // alloc_.m_ is bufsize_	buf_type buf_;	size_type start_;	size_type size_;	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <class InputIterator>			inline			void			choose_init(InputIterator first, InputIterator last, chooser<true>)			{				init(static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_init(InputIterator first, InputIterator last, chooser<false>)			{				init(first, last, iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			init(InputIterator first, InputIterator last, input_iterator_tag)			{				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					for (; first != last; ++first)						push_back(*first);				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					tear_down();					throw;				}				#endif			}		template <class ForwardIterator>			void			init(ForwardIterator first, ForwardIterator last, forward_iterator_tag)			{				size_ = (size_type)distance(first, last);				if (size_ > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw length_error("deque::construction length error");					#else						__msl_error("deque::construction length error\n");					#endif				if (size_ > 0)				{					init_buf();					if (alloc_.m_ < size_)						alloc_.m_ = size_;					pointer tmp = alloc_.allocate(alloc_.m_);					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						buf_.front() = tmp;						buf_.push_back(0);						start_ = (alloc_.m_ - size_) / 2;						uninitialized_copy(first, last, tmp + start_);					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						alloc_.deallocate(tmp, alloc_.m_);						throw;					}					#endif				}			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<true>)			{				assign(static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<false>)			{				do_assign(first, last, iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_assign(InputIterator first, InputIterator last, input_iterator_tag)			{				deque temp(first, last, get_allocator());				const deque& tempr = temp;				do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());			}		template <class ForwardIterator>			void			do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)			{				size_type n = (size_type)distance(first, last);				if (n > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw length_error("deque::assign length error");					#else						__msl_error("deque::assign length error\n");					#endif				if (buf_.empty())					init_buf();				while (n > capacity())				{					pointer tmp = alloc_.allocate(alloc_.m_);					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						buf_.back() = tmp;						buf_.push_back(0);					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						alloc_.deallocate(tmp, alloc_.m_);						buf_.back() = 0;						throw;					}					#endif				}				destroy(begin(), end());				size_ = 0;				start_ = (capacity() - n) / 2;				while (start_ >= alloc_.m_)				{					buf_.pop_back();					pointer& p = buf_.back();					alloc_.deallocate(p, alloc_.m_);					p = 0;					start_ = (capacity() - n) / 2;				}				uninitialized_copy(first, last, begin());				size_ = n;			}		template <class InputIterator>			inline			void			choose_insert(iterator position, InputIterator first, InputIterator last,				chooser<true>)			{				insert(position, static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_insert(iterator position, InputIterator first, InputIterator last,				chooser<false>)			{				do_insert(position, first, last, iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_insert(iterator position, InputIterator first, InputIterator last,				input_iterator_tag)			{				deque temp(first, last, get_allocator());				const deque& tempr = temp;				do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());			}		template <class ForwardIterator>			void			do_insert(iterator position, ForwardIterator first, ForwardIterator last,				forward_iterator_tag)			{				size_type n = (size_type)distance(first, last);				if (n == 0)					return;				size_type ms = max_size();				if (n > ms || size_ > ms - n)					#ifndef _MSL_NO_EXCEPTIONS						throw length_error("deque::insert length error");					#else						__msl_error("deque::insert length error\n");					#endif				if (buf_.empty())					init_buf();				size_type pb = position.pos_ - start_;				size_type pe = size_ - pb;				if (pb <= pe)  // hh 981210				{					size_type new_buffers = 0;					size_type oldstart = start_;					buf_type orig_buf;					bool buf_invalidated = false;					if (start_ < n)						buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);					else						start_ -= n;					size_type done = 0;					iterator beg = begin();					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						if (pb == 0) // insert at begin()							uninitialized_copy(first, last, beg);						else // pos in [1, size_ / 2)						{							iterator b_n = beg + difference_type(n);							iterator b_n_pb = b_n + difference_type(pb);							iterator b_pb = pb == n ? b_n : beg + difference_type(pb);							iterator t;							if (pb > n)								t = beg + difference_type(2*n);							else								t = b_n_pb;							uninitialized_copy(b_n, t, beg);							ForwardIterator i = first;							if (pb > n)							{								done = n;								copy(t, b_n_pb, b_n);								t = b_pb;							}							else if (pb < n)							{								done = pb;								advance(i, difference_type(n - pb));								uninitialized_copy(first, i, b_pb);								done = n;								t = b_n;							}							else							{								done = n;								t = b_n;							}							copy(i, last, t);						}						size_ += n;					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						destroy(beg, beg + difference_type(done));						for (size_type i = 0; i < new_buffers; ++i)  // hh 981210						{							alloc_.deallocate(buf_.front(), alloc_.m_);							buf_.pop_front();						}						if (buf_invalidated)							buf_.swap(orig_buf);						start_ = oldstart;						throw;					}					#endif				}				else // pos >= size_ / 2				{					size_type new_buffers = 0;					buf_type orig_buf;					bool buf_invalidated = false;					size_type e = capacity() - (start_ + size_);					bool done = false;					if (e < n)						buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);					iterator t2;					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						if (pe == 0) // insert at end()							uninitialized_copy(first, last, end());						else // pos in [size_ / 2, size_)						{							iterator ei = end();							iterator e_n = ei - difference_type(n);							iterator e_pe = pe == n ? e_n : ei - difference_type(pe);							iterator t1;							if (pe >= n)							{								t1 = e_n;								t2 = ei;							}							else							{								t1 = e_pe;								t2 = ei + difference_type(n - pe);							}							uninitialized_copy(t1, ei, t2);							done = true;							if (pe >= n)							{								if (pe > n)									copy_backward(e_pe, e_n, ei);								copy(first, last, e_pe);							}							else if (n > pe)							{								ForwardIterator i = first;								advance(i, difference_type(pe));								copy(first, i, e_pe);								uninitialized_copy(i, last, ei);							}						}						size_ += n;					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						if (done)							destroy(t2, end() + difference_type(n));						for (size_type i = 0; i < new_buffers; ++i)  // hh 981210						{							buf_.pop_back();							pointer& p = buf_.back();							alloc_.deallocate(p, alloc_.m_);							p = 0;						}						if (buf_invalidated)							buf_.swap(orig_buf);						throw;					}					#endif				}				invalidate_iterators();			}	#endif	void init(size_type n, const T& value);	void tear_down();	void destroy(iterator first, iterator last);	void invalidate_iterators();	iterator make_iterator(size_type pos);	const_iterator make_iterator(size_type pos) const;	void init_buf();	size_type capacity() const;	bool grow_buf_front(size_type oldstart, buf_type& orig_buf, size_type& new_buffers, size_type n);	bool grow_buf_back(size_type e, buf_type& orig_buf, size_type& new_buffers, size_type n);};template <class T, class Allocator>booloperator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);template <class T, class Allocator>booloperator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y);template <class T, class Allocator>booloperator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);template <class T, class Allocator>booloperator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y);template <class T, class Allocator>booloperator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);template <class T, class Allocator>booloperator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);// specialized algorithms:template <class T, class Allocator>voidswap(deque<T,Allocator>& x, deque<T,Allocator>& y);// Implementation dequetemplate <class T, class Allocator>inlinevoiddeque<T, Allocator>::invalidate_iterators(){	while (start_ >= 3 * alloc_.m_ / 2)	{		alloc_.deallocate(buf_.front(), alloc_.m_);		buf_.pop_front();		start_ -= alloc_.m_;	}}template <class T, class Allocator>typename deque<T, Allocator>::iteratordeque<T, Allocator>::make_iterator(size_type pos){	buf_type::iterator b = buf_.begin();	pointer cur;	pointer beg;	if (pos < alloc_.m_)	{		if (!buf_.empty())			beg = *b;		else			beg = 0;		cur = beg + pos;	}	else	{		b += difference_type(pos / alloc_.m_);		beg = *b;		cur = beg + pos % alloc_.m_;	}	return iterator(b, cur, beg + alloc_.m_, pos);}template <class T, class Allocator>typename deque<T, Allocator>::const_iteratordeque<T, Allocator>::make_iterator(size_type pos) const{	buf_type::const_iterator b = buf_.begin();	const_pointer cur;	const_pointer beg;	if (pos < alloc_.m_)	{		if (!buf_.empty())			beg = *b;		else			beg = 0;		cur = beg + pos;	}	else	{		b += difference_type(pos / alloc_.m_);		beg = *b;		cur = beg + pos % alloc_.m_;	}	return const_iterator(b, cur, beg + alloc_.m_, pos);}template <class T, class Allocator>inlinevoiddeque<T, Allocator>::init_buf(){	buf_.reserve(2);	buf_.resize(1);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::size_typedeque<T, Allocator>::capacity() const{	return (buf_.size() - 1) * alloc_.m_;}template <class T, class Allocator>booldeque<T, Allocator>::grow_buf_front(size_type#ifndef _MSL_NO_EXCEPTIONS	oldstart#endif, buf_type& orig_buf, size_type& new_buffers, size_type n){	bool buf_invalidated = false;	size_type nc = n;	nc -= start_;	while (true)	{		pointer tmp = alloc_.allocate(alloc_.m_);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (!buf_invalidated && buf_.size() == buf_.capacity())			{				buf_.swap(orig_buf);				buf_invalidated = true;				buf_.reserve(2*orig_buf.capacity());				buf_.assign(orig_buf.begin(), orig_buf.end());			}			buf_.push_front(tmp);			++new_buffers;  // hh 981210			start_ += alloc_.m_;			if (nc <= alloc_.m_)			{				if (size_ != 0)  // hh 981210					start_ -= n;				else					start_ = (capacity() - n) / 2;				break;			}			nc -= alloc_.m_;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(tmp, alloc_.m_);			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210			{				alloc_.deallocate(buf_.front(), alloc_.m_);				buf_.pop_front();			}			if (buf_invalidated)				buf_.swap(orig_buf);			start_ = oldstart;			throw;		}		#endif	}	return buf_invalidated;}template <class T, class Allocator>booldeque<T, Allocator>::grow_buf_back(size_type e, buf_type& orig_buf, size_type& new_buffers, size_type n){	bool buf_invalidated = false;	size_type nc = n;	nc -= e;	while (true)	{		pointer tmp = alloc_.allocate(alloc_.m_);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (!buf_invalidated && buf_.size() == buf_.capacity())			{				buf_.swap(orig_buf);				buf_invalidated = true;				buf_.reserve(2*orig_buf.capacity());				buf_.assign(orig_buf.begin(), orig_buf.end());			}			buf_.back() = tmp;			buf_.push_back(0);			++new_buffers;			if (nc <= alloc_.m_)				break;			nc -= alloc_.m_;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(tmp, alloc_.m_);			if (!buf_.empty())				buf_.back() = 0;			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210			{				buf_.pop_back();				pointer& p = buf_.back();				alloc_.deallocate(p, alloc_.m_);				p = 0;			}			if (buf_invalidated)				buf_.swap(orig_buf);			throw;		}		#endif	}	return buf_invalidated;}template <class T, class Allocator>deque<T, Allocator>::deque(const Allocator& a)	: alloc_(a, default_bufsize_s),#ifndef _MSL_NO_MEMBER_TEMPLATE	  buf_(buf_allocator(a)),#endif	  start_(0),	  size_(0){}template <class T, class Allocator>deque<T, Allocator>::deque(size_type n)	: alloc_(Allocator(), default_bufsize_s),#ifndef _MSL_NO_MEMBER_TEMPLATE	  buf_(buf_allocator(alloc_)),#endif	  start_(0),	  size_(0){	init(n, T());}template <class T, class Allocator>deque<T, Allocator>::deque(size_type n, const T& value, const Allocator& a)	: alloc_(a, default_bufsize_s),#ifndef _MSL_NO_MEMBER_TEMPLATE	  buf_(buf_allocator(a)),#endif	  start_(0),	  size_(0){	init(n, value);}#ifdef _MSL_NO_MEMBER_TEMPLATE	template <class T, class Allocator>	deque<T, Allocator>::deque(const_iterator first, const_iterator last, const Allocator& a)		: alloc_(a, default_bufsize_s),	#ifndef _MSL_NO_MEMBER_TEMPLATE		  buf_(buf_allocator(a)),	#endif		  start_(0),		  size_(size_type(last - first))	{		if (size_ > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::construction length error");			#else				__msl_error("deque::construction length error\n");			#endif		if (size_ > 0)		{			init_buf();			if (alloc_.m_ < size_)				alloc_.m_ = size_;			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				buf_.front() = tmp;				buf_.push_back(0);				start_ = (alloc_.m_ - size_) / 2;				uninitialized_copy(first, last, tmp + start_);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				throw;			}			#endif		}	}	template <class T, class Allocator>	deque<T, Allocator>::deque(const value_type* first, const value_type* last, const Allocator& a)		: alloc_(a, default_bufsize_s),	#ifndef _MSL_NO_MEMBER_TEMPLATE		  buf_(buf_allocator(a)),	#endif		  start_(0),		  size_(size_type(last - first))	{		if (size_ > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::construction length error");			#else				__msl_error("deque::construction length error\n");			#endif		if (size_ > 0)		{			init_buf();			if (alloc_.m_ < size_)				alloc_.m_ = size_;			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				buf_.front() = tmp;				buf_.push_back(0);				start_ = (alloc_.m_ - size_) / 2;				uninitialized_copy(first, last, tmp + start_);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				throw;			}			#endif		}	}#endiftemplate <class T, class Allocator>voiddeque<T, Allocator>::init(size_type n, const T& value){	if (n > max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw length_error("deque::construction length error");		#else			__msl_error("deque::construction length error\n");		#endif	if (n > 0)	{		init_buf();		if (alloc_.m_ < n)			alloc_.m_ = n;		pointer tmp = alloc_.allocate(alloc_.m_);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			buf_.front() = tmp;			buf_.push_back(0);			size_ = n;			start_ = (alloc_.m_ - size_) / 2;			uninitialized_fill_n(tmp + start_, size_, value);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(tmp, alloc_.m_);			throw;		}		#endif	}}template <class T, class Allocator>deque<T, Allocator>::deque(const deque<T,Allocator>& x)	: alloc_(x.alloc_, default_bufsize_s),#ifndef _MSL_NO_MEMBER_TEMPLATE	  buf_(buf_allocator(alloc_)),#endif	  start_(0),	  size_(x.size_){	if (size_ > 0)	{		init_buf();		if (alloc_.m_ < size_)			alloc_.m_ = size_;		pointer tmp = alloc_.allocate(alloc_.m_);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			buf_.front() = tmp;			buf_.push_back(0);			start_ = (alloc_.m_ - size_) / 2;			uninitialized_copy(x.begin(), x.end(), tmp + start_);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(tmp, alloc_.m_);			throw;		}		#endif	}}template <class T, class Allocator>inlinedeque<T, Allocator>::~deque(){	tear_down();}template <class T, class Allocator>voiddeque<T, Allocator>::tear_down(){	if (!buf_.empty())	{		destroy(begin(), end());		buf_type::iterator e = --buf_.end();		for (buf_type::iterator i = buf_.begin(); i != e; ++i)			alloc_.deallocate(*i, alloc_.m_);	}}template <class T, class Allocator>voiddeque<T, Allocator>::destroy(iterator first, iterator last){	if (first != last)	{		size_type diff = size_type(last - first);		size_type i = first.pos_;		size_type w = i / alloc_.m_;		i %= alloc_.m_;		size_type e = min(alloc_.m_, i + diff);		buf_type::iterator bi = buf_.begin() + difference_type(w);		pointer p = *bi;		__destroy(p + i, p + e);		diff -= e - i;		if (diff == 0)			return;		++bi;		while (diff >= alloc_.m_)		{			p = *bi;			__destroy(p, p + alloc_.m_);			++bi;			diff -= alloc_.m_;		}		if (diff > 0)		{			p = *bi;			__destroy(p, p + diff);		}	}}template <class T, class Allocator>inlinedeque<T,Allocator>&deque<T, Allocator>::operator=(const deque<T,Allocator>& x){	if (this != &x)		assign(x.begin(), x.end());	return *this;}#ifdef _MSL_NO_MEMBER_TEMPLATE	template <class T, class Allocator>	void	deque<T, Allocator>::assign(const_iterator first, const_iterator last)	{		size_type n = (size_type)distance(first, last);		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::assign length error");			#else				__msl_error("deque::assign length error\n");			#endif		if (buf_.empty())			init_buf();		while (n > capacity())		{			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				buf_.back() = tmp;				buf_.push_back(0);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				buf_.back() = 0;				throw;			}			#endif		}		destroy(begin(), end());		size_ = 0;		start_ = (capacity() - n) / 2;		while (start_ >= alloc_.m_)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;			start_ = (capacity() - n) / 2;		}		uninitialized_copy(first, last, begin());		size_ = n;	}	template <class T, class Allocator>	void	deque<T, Allocator>::assign(const value_type* first, const value_type* last)	{		size_type n = (size_type)distance(first, last);		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::assign length error");			#else				__msl_error("deque::assign length error\n");			#endif		if (buf_.empty())			init_buf();		while (n > capacity())		{			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				buf_.back() = tmp;				buf_.push_back(0);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				buf_.back() = 0;				throw;			}			#endif		}		destroy(begin(), end());		size_ = 0;		start_ = (capacity() - n) / 2;		while (start_ >= alloc_.m_)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;			start_ = (capacity() - n) / 2;		}		uninitialized_copy(first, last, begin());		size_ = n;	}#endiftemplate <class T, class Allocator>voiddeque<T, Allocator>::assign(size_type n, const T& t){	if (n > max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw length_error("deque::assign length error");		#else			__msl_error("deque::assign length error\n");		#endif	if (buf_.empty())		init_buf();	while (n > capacity())	{		pointer tmp = alloc_.allocate(alloc_.m_);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			buf_.back() = tmp;			buf_.push_back(0);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			alloc_.deallocate(tmp, alloc_.m_);			buf_.back() = 0;			throw;		}		#endif	}	destroy(begin(), end());	size_ = 0;	start_ = (capacity() - n) / 2;	while (start_ >= alloc_.m_)	{		buf_.pop_back();		pointer& p = buf_.back();		alloc_.deallocate(p, alloc_.m_);		p = 0;		start_ = (capacity() - n) / 2;	}	uninitialized_fill_n(begin(), n, t);	size_ = n;}template <class T, class Allocator>inlinetypename deque<T, Allocator>::allocator_typedeque<T, Allocator>::get_allocator() const{	return alloc_;}template <class T, class Allocator>inlinetypename deque<T, Allocator>::iteratordeque<T, Allocator>::begin(){	return make_iterator(start_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::const_iteratordeque<T, Allocator>::begin() const{	return make_iterator(start_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::iteratordeque<T, Allocator>::end(){		return make_iterator(start_ + size_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::const_iteratordeque<T, Allocator>::end() const{		return make_iterator(start_ + size_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::reverse_iteratordeque<T, Allocator>::rbegin(){	return reverse_iterator(end());}template <class T, class Allocator>inlinetypename deque<T, Allocator>::const_reverse_iteratordeque<T, Allocator>::rbegin() const{	return const_reverse_iterator(end());}template <class T, class Allocator>inlinetypename deque<T, Allocator>::reverse_iteratordeque<T, Allocator>::rend(){	return reverse_iterator(begin());}template <class T, class Allocator>inlinetypename deque<T, Allocator>::const_reverse_iteratordeque<T, Allocator>::rend() const{	return const_reverse_iterator(begin());}template <class T, class Allocator>inlinetypename deque<T, Allocator>::size_typedeque<T, Allocator>::size() const{	return size_;}template <class T, class Allocator>inlinetypename deque<T, Allocator>::size_typedeque<T, Allocator>::max_size() const{	return alloc_.max_size();}template <class T, class Allocator>inlinevoiddeque<T, Allocator>::resize(size_type sz){	if (sz > size())		insert(end(), sz-size(), T());	else if (sz < size())		erase(begin() + difference_type(sz), end());}template <class T, class Allocator>voiddeque<T, Allocator>::resize(size_type sz, const T& value){	if (sz > size())		insert(end(), sz-size(), value);	else if (sz < size())		erase(begin() + difference_type(sz), end());}template <class T, class Allocator>inlinebooldeque<T, Allocator>::empty() const{	return size_ == 0;}template <class T, class Allocator>inlinetypename deque<T, Allocator>::referencedeque<T, Allocator>::operator[](size_type n){	size_type i = n + start_;	return *(buf_[i / alloc_.m_] + i % alloc_.m_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::const_referencedeque<T, Allocator>::operator[](size_type n) const{	size_type i = n + start_;	return *(buf_[i / alloc_.m_] + i % alloc_.m_);}template <class T, class Allocator>typename deque<T, Allocator>::referencedeque<T, Allocator>::at(size_type n){	if (n >= size_)		#ifndef _MSL_NO_EXCEPTIONS			throw out_of_range("deque::at index out of range");		#else			__msl_error("deque::at index out of range");		#endif	size_type i = n + start_;	return *(buf_[i / alloc_.m_] + i % alloc_.m_);}template <class T, class Allocator>typename deque<T, Allocator>::const_referencedeque<T, Allocator>::at(size_type n) const{	if (n >= size_)		#ifndef _MSL_NO_EXCEPTIONS			throw out_of_range("deque::at index out of range");		#else			__msl_error("deque::at index out of range");		#endif	size_type i = n + start_;	return *(buf_[i / alloc_.m_] + i % alloc_.m_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::referencedeque<T, Allocator>::front(){	return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::const_referencedeque<T, Allocator>::front() const{	return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::referencedeque<T, Allocator>::back(){	size_type i = start_ + size_ - 1;	return *(buf_[i / alloc_.m_] + i % alloc_.m_);}template <class T, class Allocator>inlinetypename deque<T, Allocator>::const_referencedeque<T, Allocator>::back() const{	size_type i = start_ + size_ - 1;	return *(buf_[i / alloc_.m_] + i % alloc_.m_);}template <class T, class Allocator>voiddeque<T, Allocator>::push_front(const T& x){	if (size_ > max_size() - 1)		#ifndef _MSL_NO_EXCEPTIONS			throw length_error("deque::push_front length error");		#else			__msl_error("deque::push_front length error\n");		#endif	if (buf_.empty())		init_buf();	size_type new_buffers = 0;	size_type oldstart = start_;	buf_type orig_buf;	bool buf_invalidated = false;	if (start_ == 0)		buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, 1);	else		--start_;	#ifndef _MSL_NO_EXCEPTIONS	try	{	#endif		if (start_ < alloc_.m_)			::new (buf_.front() + start_) value_type(x);		else			::new (buf_[start_ / alloc_.m_] + start_ % alloc_.m_) value_type(x);		++size_;	#ifndef _MSL_NO_EXCEPTIONS	}	catch (...)	{		if (new_buffers)		{			alloc_.deallocate(buf_.front(), alloc_.m_);			buf_.pop_front();		}		if (buf_invalidated)			buf_.swap(orig_buf);		start_ = oldstart;		throw;	}	#endif	invalidate_iterators();}template <class T, class Allocator>voiddeque<T, Allocator>::push_back(const T& x){	if (size_ > max_size() - 1)		#ifndef _MSL_NO_EXCEPTIONS			throw length_error("deque::push_back length error");		#else			__msl_error("deque::push_back length error\n");		#endif	if (buf_.empty())		init_buf();	{		size_type new_buffers = 0;		buf_type orig_buf;		bool buf_invalidated = false;		if (capacity() == start_ + size_)			buf_invalidated = grow_buf_back(0, orig_buf, new_buffers, 1);		size_type pos = start_ + size_;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (pos < alloc_.m_)				::new (buf_.front() + pos) value_type(x);			else				::new (buf_[pos / alloc_.m_] + pos % alloc_.m_) value_type(x);			++size_;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210			{				buf_.pop_back();				pointer& p = buf_.back();				alloc_.deallocate(p, alloc_.m_);				p = 0;			}			if (buf_invalidated)				buf_.swap(orig_buf);			throw;		}		#endif	}	invalidate_iterators();}template <class T, class Allocator>typename deque<T, Allocator>::iteratordeque<T, Allocator>::insert(iterator position, const T& x){	difference_type pos = position - begin();	insert(position, 1, x);	return begin() + pos;}template <class T, class Allocator>voiddeque<T, Allocator>::insert(iterator position, size_type n, const T& x){	if (n == 0)		return;	size_type ms = max_size();	if (n > ms || size_ > ms - n)		#ifndef _MSL_NO_EXCEPTIONS			throw length_error("deque::insert length error");		#else			__msl_error("deque::insert length error\n");		#endif	if (buf_.empty())		init_buf();	size_type pb = position.pos_ - start_;	size_type pe = size_ - pb;	if (pb <= pe)  // hh 981210	{		size_type new_buffers = 0;		size_type oldstart = start_;		buf_type orig_buf;		bool buf_invalidated = false;		if (start_ < n)			buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);		else			start_ -= n;		size_type done = 0;		iterator beg = begin();		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (pb == 0) // insert at begin()				uninitialized_fill_n(beg, n, x);			else // pos in [1, size_ / 2)			{				iterator b_n = beg + difference_type(n);				iterator b_n_pb = b_n + difference_type(pb);				iterator b_pb = pb == n ? b_n : beg + difference_type(pb);				iterator t;				if (pb > n)					t = beg + difference_type(2*n);				else					t = b_n_pb;				uninitialized_copy(b_n, t, beg);				if (pb > n)				{					done = n;					copy(t, b_n_pb, b_n);					t = b_pb;				}				else if (pb < n)				{					done = pb;					uninitialized_fill(b_pb, b_n, x);					done = n;					t = b_n;				}				else				{					done = n;					t = b_n;				}				fill(t, b_n_pb, x);			}			size_ += n;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			destroy(beg, beg + difference_type(done));			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210			{				alloc_.deallocate(buf_.front(), alloc_.m_);				buf_.pop_front();			}			if (buf_invalidated)				buf_.swap(orig_buf);			start_ = oldstart;			throw;		}		#endif	}	else // pos >= size_ / 2	{		size_type new_buffers = 0;		buf_type orig_buf;		bool buf_invalidated = false;		size_type e = capacity() - (start_ + size_);		bool done = false;		if (e < n)			buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);		iterator t2;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (pe == 0) // insert at end()				uninitialized_fill_n(end(), n, x);			else // pos in [size_ / 2, size_)			{				iterator ei = end();				iterator e_n = ei - difference_type(n);				iterator e_pe = pe == n ? e_n : ei - difference_type(pe);				iterator t1;				if (pe >= n)				{					t1 = e_n;					t2 = ei;				}				else				{					t1 = e_pe;					t2 = ei + difference_type(n - pe);				}				uninitialized_copy(t1, ei, t2);				done = true;				if (pe >= n)				{					if (pe > n)						copy_backward(e_pe, e_n, ei);					t1 = pe == n ? ei : ei - difference_type(pe - n);					fill(e_pe, t1, x);				}				else if (n > pe)				{					fill(e_pe, ei, x);					uninitialized_fill(ei, t2, x);				}			}			size_ += n;		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			if (done)				destroy(t2, end() + difference_type(n));			for (size_type i = 0; i < new_buffers; ++i)  // hh 981210			{				buf_.pop_back();				pointer& p = buf_.back();				alloc_.deallocate(p, alloc_.m_);				p = 0;			}			if (buf_invalidated)				buf_.swap(orig_buf);			throw;		}		#endif	}	invalidate_iterators();}#ifdef _MSL_NO_MEMBER_TEMPLATE	template <class T, class Allocator>	void	deque<T, Allocator>::insert(iterator position, const_iterator first, const_iterator last)	{		size_type n = (size_type)distance(first, last);		if (n == 0)			return;		size_type ms = max_size();		if (n > ms || size_ > ms - n)			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::insert length error");			#else				__msl_error("deque::insert length error\n");			#endif		if (buf_.empty())			init_buf();		size_type pb = position.pos_ - start_;		size_type pe = size_ - pb;		if (pb <= pe)  // hh 981210		{			size_type new_buffers = 0;			size_type oldstart = start_;			buf_type orig_buf;			bool buf_invalidated = false;			if (start_ < n)				buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);			else				start_ -= n;			size_type done = 0;			iterator beg = begin();			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (pb == 0) // insert at begin()					uninitialized_copy(first, last, beg);				else // pos in [1, size_ / 2)				{					iterator b_n = beg + difference_type(n);					iterator b_n_pb = b_n + difference_type(pb);					iterator b_pb = pb == n ? b_n : beg + difference_type(pb);					iterator t;					if (pb > n)						t = beg + difference_type(2*n);					else						t = b_n_pb;					uninitialized_copy(b_n, t, beg);					const_iterator i = first;					if (pb > n)					{						done = n;						copy(t, b_n_pb, b_n);						t = b_pb;					}					else if (pb < n)					{						done = pb;						advance(i, difference_type(n - pb));						uninitialized_copy(first, i, b_pb);						done = n;						t = b_n;					}					else					{						done = n;						t = b_n;					}					copy(i, last, t);				}				size_ += n;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				destroy(beg, beg + difference_type(done));				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210				{					alloc_.deallocate(buf_.front(), alloc_.m_);					buf_.pop_front();				}				if (buf_invalidated)					buf_.swap(orig_buf);				start_ = oldstart;				throw;			}			#endif		}		else // pos >= size_ / 2		{			size_type new_buffers = 0;			buf_type orig_buf;			bool buf_invalidated = false;			size_type e = capacity() - (start_ + size_);			bool done = false;			if (e < n)				buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);			iterator t2;			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (pe == 0) // insert at end()					uninitialized_copy(first, last, end());				else // pos in [size_ / 2, size_)				{					iterator ei = end();					iterator e_n = ei - difference_type(n);					iterator e_pe = pe == n ? e_n : ei - difference_type(pe);					iterator t1;					if (pe >= n)					{						t1 = e_n;						t2 = ei;					}					else					{						t1 = e_pe;						t2 = ei + difference_type(n - pe);					}					uninitialized_copy(t1, ei, t2);					done = true;					if (pe >= n)					{						if (pe > n)							copy_backward(e_pe, e_n, ei);						copy(first, last, e_pe);					}					else if (n > pe)					{						const_iterator i = first;						advance(i, difference_type(pe));						copy(first, i, e_pe);						uninitialized_copy(i, last, ei);					}				}				size_ += n;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				if (done)					destroy(t2, end() + difference_type(n));				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210				{					buf_.pop_back();					pointer& p = buf_.back();					alloc_.deallocate(p, alloc_.m_);					p = 0;				}				if (buf_invalidated)					buf_.swap(orig_buf);				throw;			}			#endif		}		invalidate_iterators();	}	template <class T, class Allocator>	void	deque<T, Allocator>::insert(iterator position, const value_type* first, const value_type* last)	{		size_type n = (size_type)distance(first, last);		if (n == 0)			return;		size_type ms = max_size();		if (n > ms || size_ > ms - n)			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::insert length error");			#else				__msl_error("deque::insert length error\n");			#endif		if (buf_.empty())			init_buf();		size_type pb = position.pos_ - start_;		size_type pe = size_ - pb;		if (pb <= pe)  // hh 981210		{			size_type new_buffers = 0;			size_type oldstart = start_;			buf_type orig_buf;			bool buf_invalidated = false;			if (start_ < n)				buf_invalidated = grow_buf_front(oldstart, orig_buf, new_buffers, n);			else				start_ -= n;			size_type done = 0;			iterator beg = begin();			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (pb == 0) // insert at begin()					uninitialized_copy(first, last, beg);				else // pos in [1, size_ / 2)				{					iterator b_n = beg + difference_type(n);					iterator b_n_pb = b_n + difference_type(pb);					iterator b_pb = pb == n ? b_n : beg + difference_type(pb);					iterator t;					if (pb > n)						t = beg + difference_type(2*n);					else						t = b_n_pb;					uninitialized_copy(b_n, t, beg);					const value_type* i = first;					if (pb > n)					{						done = n;						copy(t, b_n_pb, b_n);						t = b_pb;					}					else if (pb < n)					{						done = pb;						advance(i, difference_type(n - pb));						uninitialized_copy(first, i, b_pb);						done = n;						t = b_n;					}					else					{						done = n;						t = b_n;					}					copy(i, last, t);				}				size_ += n;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				destroy(beg, beg + difference_type(done));				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210				{					alloc_.deallocate(buf_.front(), alloc_.m_);					buf_.pop_front();				}				if (buf_invalidated)					buf_.swap(orig_buf);				start_ = oldstart;				throw;			}			#endif		}		else // pos >= size_ / 2		{			size_type new_buffers = 0;			buf_type orig_buf;			bool buf_invalidated = false;			size_type e = capacity() - (start_ + size_);			bool done = false;			if (e < n)				buf_invalidated = grow_buf_back(e, orig_buf, new_buffers, n);			iterator t2;			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (pe == 0) // insert at end()					uninitialized_copy(first, last, end());				else // pos in [size_ / 2, size_)				{					iterator ei = end();					iterator e_n = ei - difference_type(n);					iterator e_pe = pe == n ? e_n : ei - difference_type(pe);					iterator t1;					if (pe >= n)					{						t1 = e_n;						t2 = ei;					}					else					{						t1 = e_pe;						t2 = ei + difference_type(n - pe);					}					uninitialized_copy(t1, ei, t2);					done = true;					if (pe >= n)					{						if (pe > n)							copy_backward(e_pe, e_n, ei);						copy(first, last, e_pe);					}					else if (n > pe)					{						const value_type* i = first;						advance(i, difference_type(pe));						copy(first, i, e_pe);						uninitialized_copy(i, last, ei);					}				}				size_ += n;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				if (done)					destroy(t2, end() + difference_type(n));				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210				{					buf_.pop_back();					pointer& p = buf_.back();					alloc_.deallocate(p, alloc_.m_);					p = 0;				}				if (buf_invalidated)					buf_.swap(orig_buf);				throw;			}			#endif		}		invalidate_iterators();	}#endiftemplate <class T, class Allocator>voiddeque<T, Allocator>::pop_front(){	__destroy(&front());	++start_;	if (--size_ == 0)	{		for (size_type i = buf_.size() - 2; i > 0; --i)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;		}		start_ = alloc_.m_ / 2;	}}template <class T, class Allocator>voiddeque<T, Allocator>::pop_back(){	__destroy(&back());	--size_;	while (capacity() - (start_ + size_) >= 3 * alloc_.m_ / 2)	{		buf_.pop_back();		pointer& p = buf_.back();		alloc_.deallocate(p, alloc_.m_);		p = 0;	}	if (size_ == 0)	{		for (size_type i = buf_.size() - 2; i > 0; --i)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;		}		start_ = alloc_.m_ / 2;	}}template <class T, class Allocator>inlinetypename deque<T, Allocator>::iteratordeque<T, Allocator>::erase(iterator position){	return erase(position, position + 1);}template <class T, class Allocator>typename deque<T, Allocator>::iteratordeque<T, Allocator>::erase(iterator first, iterator last){	if (first == last)		return first;	const size_type pb = first.pos_ - start_;	const size_type pe = size_ - (last.pos_ - start_);	const size_type diff = size_type(last - first);	if (pb < pe)	{		if (pb == 0)  // erase from beginning, no copying necessary		{			destroy(first, last);			start_ += diff;			size_ -= diff;		}		else  // erase from beginning, needs copying		{			iterator bi = begin();			copy_backward(bi, first, last);			destroy(bi, bi + difference_type(diff));			start_ += diff;			size_ -= diff;			invalidate_iterators();		}	}	else  // pb >= pe - erase from end	{		if (pe == 0)  // erase from end, no copying necessary			destroy(first, last);		else  // erase from end, needs copying		{			iterator ei = end();			copy(last, ei, first);			destroy(first + difference_type(pe), ei);			invalidate_iterators();		}		size_ -= diff;		while (capacity() - (start_ + size_) >= 3 * alloc_.m_ / 2)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;		}	}	if (size_ == 0)	{		for (size_type i = buf_.size() - 2; i > 0; --i)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;		}		start_ = alloc_.m_ / 2;	}	return make_iterator(start_ + pb);}template <class T, class Allocator>voiddeque<T, Allocator>::swap(deque<T,Allocator>& x){	if (this != &x)	{		_STD::swap(alloc_, x.alloc_);		_STD::swap(buf_, x.buf_);		_STD::swap(start_, x.start_);		_STD::swap(size_, x.size_);	}}template <class T, class Allocator>voiddeque<T, Allocator>::clear(){	if (!buf_.empty())  // hh 981209	{		destroy(begin(), end());		size_ = 0;		for (size_type i = buf_.size() - 2; i > 0; --i)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;		}		start_ = alloc_.m_ / 2;	}}template <class T, class Allocator>inlinebooloperator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y){	return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());}template <class T, class Allocator>inlinebooloperator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y){	return !(x == y);}template <class T, class Allocator>inlinebooloperator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y){	return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}template <class T, class Allocator>inlinebooloperator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y){	return y < x;}template <class T, class Allocator>inlinebooloperator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y){	return !(x < y);}template <class T, class Allocator>inlinebooloperator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y){	return !(y < x);}template <class T, class Allocator>inlinevoidswap(deque<T,Allocator>& x, deque<T,Allocator>& y){	x.swap(y);}#if !defined(_MSL_NO_PARTIAL_SPECIALIZATION) && !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_Inhibit_Container_Optimization)	// Specialize for T* to save on code bloat	// hh 990825 changed void* to const void*	// const void*	template <class Allocator>	class deque<const void*, Allocator>	{		template <bool b> struct chooser {};	public:		// types:		typedef typename Allocator::reference         reference;		typedef typename Allocator::const_reference   const_reference;		class                                         iterator;		class                                         const_iterator;		typedef typename Allocator::size_type         size_type;		typedef typename Allocator::difference_type   difference_type;		typedef const void*                           value_type;		typedef Allocator                             allocator_type;		typedef typename Allocator::pointer           pointer;		typedef typename Allocator::const_pointer     const_pointer;		typedef _STD::reverse_iterator<iterator>       reverse_iterator;		typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;	private:		typedef _MSL_REBIND (pointer) buf_allocator;		typedef Metrowerks::cdeque<pointer, buf_allocator> buf_type;	public:		friend class iterator;		class iterator			: public _STD::iterator<random_access_iterator_tag, value_type, difference_type, pointer, reference>		{		public:			iterator() {}			reference operator * () const {return *cur_;}			pointer operator -> () const {return cur_;}			iterator& operator ++ ()			{				++pos_;				if (++cur_ == end_)				{					difference_type buf_size = end_ - *beg_;					++beg_;					pointer beg = *beg_;					cur_ = beg;					end_ = beg + buf_size;				}				return *this;			}			iterator operator ++ (int) {iterator tmp(*this); ++(*this); return tmp;}			iterator& operator -- ()			{				--pos_;				pointer beg = *beg_;				if (cur_ != beg)					--cur_;				else				{					difference_type buf_size = end_ - beg;					--beg_;					end_ = *beg_ + buf_size;					cur_ = end_ - 1;				}				return *this;			}			iterator operator -- (int) {iterator tmp(*this); --(*this); return tmp;}			iterator& operator += (difference_type n)			{				if (n < 0)					return (*this) -= -n;				pos_ += static_cast<size_type>(n);				difference_type room = end_ - cur_ ;				if (n < room)					cur_ += n;				else				{					difference_type buf_size = end_ - *beg_;					n -= room;					beg_ += n / buf_size + 1;					pointer beg = *beg_;					cur_ = beg + n % buf_size;					end_ = beg + buf_size;				}				return *this;			}			iterator operator + (difference_type n) const {return iterator(*this) += n;}			iterator& operator -= (difference_type n)			{				if (n < 0)					return (*this) += -n;				pos_ -= static_cast<size_type>(n);				pointer beg = *beg_;				difference_type room = cur_ - beg + 1;				if (n < room)					cur_ -= n;				else				{					difference_type buf_size = end_ - beg;					n -= room;					beg_ -= n / buf_size + 1;					end_ = *beg_ + buf_size;					cur_ = end_ - 1 - n % buf_size;				}				return *this;			}			iterator operator - (difference_type n) const {return iterator(*this) -= n;}			difference_type operator - (const iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}			reference operator [] (difference_type i) const {iterator tmp(*this); tmp += i; return *tmp;}			friend bool operator ==(const iterator& x, const iterator& y) {return x.cur_ == y.cur_;}  // hh 990720			friend bool operator !=(const iterator& x, const iterator& y) {return x.cur_ != y.cur_;}			friend bool operator < (const iterator& x, const iterator& y) {return x.pos_ <  y.pos_;}			friend bool operator <=(const iterator& x, const iterator& y) {return x.pos_ <= y.pos_;}			friend bool operator > (const iterator& x, const iterator& y) {return x.pos_ >  y.pos_;}			friend bool operator >=(const iterator& x, const iterator& y) {return x.pos_ >= y.pos_;}			friend iterator operator + (difference_type n, const iterator& rhs)				{return iterator(rhs) += n;}		private:			buf_type::iterator beg_;			pointer cur_;			pointer end_;			size_type pos_;			iterator(const buf_type::iterator& beg, pointer cur, pointer end, size_type pos)				: beg_(beg),				  cur_(cur),				  end_(end),				  pos_(pos)			{}			friend class deque;			friend class deque::const_iterator;		};		friend class const_iterator;		class const_iterator			: public _STD::iterator<random_access_iterator_tag, value_type, difference_type, const_pointer, const_reference>		{		public:			const_iterator() {}			const_iterator(const deque::iterator& rhs) : beg_(rhs.beg_), cur_(rhs.cur_), end_(rhs.end_), pos_(rhs.pos_) {}			const_reference operator * () const {return *cur_;}			const_pointer operator -> () const {return cur_;}			const_iterator& operator ++ ()			{				++pos_;				if (++cur_ == end_)				{					difference_type buf_size = end_ - *beg_;					++beg_;					pointer beg = *beg_;					cur_ = beg;					end_ = beg + buf_size;				}				return *this;			}			const_iterator operator ++ (int) {const_iterator tmp(*this); ++(*this); return tmp;}			const_iterator& operator -- ()			{				--pos_;				pointer beg = *beg_;				if (cur_ != beg)					--cur_;				else				{					difference_type buf_size = end_ - beg;					--beg_;					end_ = *beg_ + buf_size;					cur_ = end_ - 1;				}				return *this;			}			const_iterator operator -- (int) {const_iterator tmp(*this); --(*this); return tmp;}			const_iterator& operator += (difference_type n)			{				if (n < 0)					return (*this) -= -n;				pos_ += static_cast<size_type>(n);				difference_type room = end_ - cur_ ;				if (n < room)					cur_ += n;				else				{					difference_type buf_size = end_ - *beg_;					n -= room;					beg_ += n / buf_size + 1;					pointer beg = *beg_;					cur_ = beg + n % buf_size;					end_ = beg + buf_size;				}				return *this;			}			const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}			const_iterator& operator -= (difference_type n)			{				if (n < 0)					return (*this) += -n;				pos_ -= static_cast<size_type>(n);				pointer beg = *beg_;				difference_type room = cur_ - beg + 1;				if (n < room)					cur_ -= n;				else				{					difference_type buf_size = end_ - beg;					n -= room;					beg_ -= n / buf_size + 1;					end_ = *beg_ + buf_size;					cur_ = end_ - 1 - n % buf_size;				}				return *this;			}			const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}			difference_type operator - (const const_iterator& rhs) const {return difference_type(pos_ - rhs.pos_);}			const_reference operator [] (difference_type i) const {const_iterator tmp(*this); tmp += i; return *tmp;}			friend bool operator ==(const const_iterator& x, const const_iterator& y) {return x.cur_ == y.cur_;}  // hh 990720			friend bool operator !=(const const_iterator& x, const const_iterator& y) {return x.cur_ != y.cur_;}			friend bool operator < (const const_iterator& x, const const_iterator& y) {return x.pos_ <  y.pos_;}			friend bool operator <=(const const_iterator& x, const const_iterator& y) {return x.pos_ <= y.pos_;}			friend bool operator > (const const_iterator& x, const const_iterator& y) {return x.pos_ >  y.pos_;}			friend bool operator >=(const const_iterator& x, const const_iterator& y) {return x.pos_ >= y.pos_;}			friend const_iterator operator + (difference_type n, const const_iterator& rhs)				{return const_iterator(rhs) += n;}		private:			buf_type::const_iterator beg_;			const_pointer cur_;			const_pointer end_;			size_type pos_;			const_iterator(const buf_type::const_iterator& beg, const_pointer cur, const_pointer end, size_type pos)				: beg_(beg),				  cur_(cur),				  end_(end),				  pos_(pos)			{}			friend class deque;		};		// _lib.deque.cons_ construct/copy/destroy:		explicit deque(const Allocator& = Allocator());		explicit deque(size_type n, const value_type& value = 0, const Allocator& = Allocator());		template <class InputIterator>			deque(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: alloc_(a, default_bufsize_s),				  buf_(buf_allocator(a)),				  start_(0),				  size_(0)			{				choose_init(first, last, chooser<numeric_limits<InputIterator>::is_integer>());			}		deque(const deque& x);		~deque();		deque& operator=(const deque& x);		template <class InputIterator>			inline			void assign(InputIterator first, InputIterator last)			{				choose_assign(first, last, chooser<numeric_limits<InputIterator>::is_integer>());			}		void assign(size_type n, const value_type& t);		allocator_type get_allocator() const;		// iterators:		iterator               begin();		const_iterator         begin() const;		iterator               end();		const_iterator         end() const;		reverse_iterator       rbegin();		const_reverse_iterator rbegin() const;		reverse_iterator       rend();		const_reverse_iterator rend() const;		// _lib.deque.capacity_ capacity:		size_type size() const;		size_type max_size() const;		void      resize(size_type sz, value_type c = 0);		bool      empty() const;		// element access:		reference       operator[](size_type n);		const_reference operator[](size_type n) const;		reference       at(size_type n);		const_reference at(size_type n) const;		reference       front();		const_reference front() const;		reference       back();		const_reference back() const;		// _lib.deque.modifiers_ modifiers:		void push_front(const value_type& x);		void push_back(const value_type& x);		iterator insert(iterator position, const value_type& x);		void     insert(iterator position, size_type n, const value_type& x);		template <class InputIterator>			inline			void insert(iterator position, InputIterator first, InputIterator last)			{				choose_insert(position, first, last, chooser<numeric_limits<InputIterator>::is_integer>());			}		void pop_front();		void pop_back();		iterator erase(iterator position);		iterator erase(iterator first, iterator last);		void     swap(deque&);		void     clear();	private:		static const size_type min_buf_size_s = 8;		static const size_type min_foot_print_s = 512;		static const size_type default_bufsize_s = sizeof(value_type) * min_buf_size_s < min_foot_print_s ?		                                           min_foot_print_s / sizeof(value_type) : min_buf_size_s;		_EmptyMemberOpt<Allocator, size_type> alloc_;  // alloc_.m_ is bufsize_		buf_type buf_;		size_type start_;		size_type size_;		template <class InputIterator>			inline			void			choose_init(InputIterator first, InputIterator last, chooser<true>)			{				init(static_cast<size_type>(first), reinterpret_cast<value_type>(last));  // hh 981208			}		template <class InputIterator>			inline			void			choose_init(InputIterator first, InputIterator last, chooser<false>)			{				init(first, last, iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			init(InputIterator first, InputIterator last, input_iterator_tag)			{				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					for (; first != last; ++first)						push_back(*first);				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					tear_down();					throw;				}				#endif			}		template <class ForwardIterator>			void			init(ForwardIterator first, ForwardIterator last, forward_iterator_tag)			{				size_ = (size_type)distance(first, last);				if (size_ > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw length_error("deque::construction length error");					#else						__msl_error("deque::construction length error\n");					#endif				if (size_ > 0)				{					init_buf();					if (alloc_.m_ < size_)						alloc_.m_ = size_;					pointer tmp = alloc_.allocate(alloc_.m_);					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						buf_.front() = tmp;						buf_.push_back(0);						start_ = (alloc_.m_ - size_) / 2;						copy(first, last, tmp + start_);					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						alloc_.deallocate(tmp, alloc_.m_);						throw;					}					#endif				}			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<true>)			{				assign(static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<false>)			{				do_assign(first, last, iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_assign(InputIterator first, InputIterator last, input_iterator_tag)			{				deque temp(first, last, get_allocator());				const deque& tempr = temp;				do_assign(tempr.begin(), tempr.end(), random_access_iterator_tag());			}		template <class ForwardIterator>			void			do_assign(ForwardIterator first, ForwardIterator last, forward_iterator_tag)			{				size_type n = (size_type)distance(first, last);				if (n > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw length_error("deque::assign length error");					#else						__msl_error("deque::assign length error\n");					#endif				if (buf_.empty())					init_buf();				while (n > capacity())				{					pointer tmp = alloc_.allocate(alloc_.m_);					#ifndef _MSL_NO_EXCEPTIONS					try					{					#endif						buf_.back() = tmp;						buf_.push_back(0);					#ifndef _MSL_NO_EXCEPTIONS					}					catch (...)					{						alloc_.deallocate(tmp, alloc_.m_);						throw;					}					#endif				}				start_ = (capacity() - n) / 2;				while (start_ >= alloc_.m_)				{					buf_.pop_back();					pointer& p = buf_.back();					alloc_.deallocate(p, alloc_.m_);					p = 0;					start_ = (capacity() - n) / 2;				}				copy(first, last, begin());				size_ = n;			}		template <class InputIterator>			inline			void			choose_insert(iterator position, InputIterator first, InputIterator last,				chooser<true>)			{				insert(position, static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_insert(iterator position, InputIterator first, InputIterator last,				chooser<false>)			{				do_insert(position, first, last, iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_insert(iterator position, InputIterator first, InputIterator last,				input_iterator_tag)			{				deque temp(first, last, get_allocator());				const deque& tempr = temp;				do_insert(position, tempr.begin(), tempr.end(), random_access_iterator_tag());			}		template <class ForwardIterator>			void			do_insert(iterator position, ForwardIterator first, ForwardIterator last,				forward_iterator_tag)			{				size_type n = (size_type)distance(first, last);				if (n == 0)					return;				size_type ms = max_size();				if (n > ms || size_ > ms - n)					#ifndef _MSL_NO_EXCEPTIONS						throw length_error("deque::insert length error");					#else						__msl_error("deque::insert length error\n");					#endif				if (buf_.empty())					init_buf();				size_type pb = position.pos_ - start_;				size_type pe = size_ - pb;				if (pb <= pe)  // hh 981210				{					if (start_ < n)						grow_buf_front(n);					else						start_ -= n;					if (pb == 0) // insert at begin()						copy(first, last, begin());					else // pos in [1, size_ / 2)					{						iterator b = begin();						copy(b + difference_type(n), b + difference_type(n + pb), b);						copy(first, last, b + difference_type(pb));					}					size_ += n;				}				else // pos >= size_ / 2				{					size_type e = capacity() - (start_ + size_);					if (e < n)						grow_buf_back(e, n);					if (pe == 0) // insert at end()						copy(first, last, end());					else // pos in [size_ / 2, size_)					{						iterator e = end();						iterator p = e - difference_type(pe);						copy_backward(p, e, e + difference_type(n));						copy(first, last, p);					}					size_ += n;				}				invalidate_iterators();			}		void init(size_type n, const value_type& value);		void tear_down();		void invalidate_iterators();		iterator make_iterator(size_type pos);		const_iterator make_iterator(size_type pos) const;		void init_buf();		size_type capacity() const;		void grow_buf_front(size_type n);		void grow_buf_back(size_type e, size_type n);	};	// Implementation deque<const void*>	template <class Allocator>	inline	void	deque<const void*, Allocator>::invalidate_iterators()	{		while (start_ >= 3 * alloc_.m_ / 2)		{			alloc_.deallocate(buf_.front(), alloc_.m_);			buf_.pop_front();			start_ -= alloc_.m_;		}	}	template <class Allocator>	typename deque<const void*, Allocator>::iterator	deque<const void*, Allocator>::make_iterator(size_type pos)	{		buf_type::iterator b = buf_.begin();		pointer cur;		pointer beg;		if (pos < alloc_.m_)		{			if (!buf_.empty())				beg = *b;			else				beg = 0;			cur = beg + pos;		}		else		{			b += difference_type(pos / alloc_.m_);			beg = *b;			cur = beg + pos % alloc_.m_;		}		return iterator(b, cur, beg + alloc_.m_, pos);	}	template <class Allocator>	typename deque<const void*, Allocator>::const_iterator	deque<const void*, Allocator>::make_iterator(size_type pos) const	{		buf_type::const_iterator b = buf_.begin();		const_pointer cur;		const_pointer beg;		if (pos < alloc_.m_)		{			if (!buf_.empty())				beg = *b;			else				beg = 0;			cur = beg + pos;		}		else		{			b += difference_type(pos / alloc_.m_);			beg = *b;			cur = beg + pos % alloc_.m_;		}		return const_iterator(b, cur, beg + alloc_.m_, pos);	}	template <class Allocator>	inline	void	deque<const void*, Allocator>::init_buf()	{		buf_.reserve(2);		buf_.resize(1);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::size_type	deque<const void*, Allocator>::capacity() const	{		return (buf_.size() - 1) * alloc_.m_;	}	template <class Allocator>	void	deque<const void*, Allocator>::grow_buf_front(size_type n)	{		bool buf_invalidated = false;		size_type oldstart = start_;		size_type new_buffers = 0;		buf_type orig_buf;		size_type nc = n;		nc -= start_;		while (true)		{			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (!buf_invalidated && buf_.size() == buf_.capacity())				{					buf_.swap(orig_buf);					buf_invalidated = true;					buf_.reserve(2*orig_buf.capacity());					buf_.assign(orig_buf.begin(), orig_buf.end());				}				buf_.push_front(tmp);				++new_buffers;  // hh 981210				start_ += alloc_.m_;				if (nc <= alloc_.m_)				{					if (size_ != 0)  // hh 981210						start_ -= n;					else						start_ = (capacity() - n) / 2;					break;				}				nc -= alloc_.m_;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210				{					alloc_.deallocate(buf_.front(), alloc_.m_);					buf_.pop_front();				}				if (buf_invalidated)					buf_.swap(orig_buf);				start_ = oldstart;				throw;			}			#endif		}	}	template <class Allocator>	void	deque<const void*, Allocator>::grow_buf_back(size_type e, size_type n)	{		bool buf_invalidated = false;		buf_type orig_buf;		size_type new_buffers = 0;		size_type nc = n;		nc -= e;		while (true)		{			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				if (!buf_invalidated && buf_.size() == buf_.capacity())				{					buf_.swap(orig_buf);					buf_invalidated = true;					buf_.reserve(2*orig_buf.capacity());					buf_.assign(orig_buf.begin(), orig_buf.end());				}				buf_.back() = tmp;				buf_.push_back(0);				++new_buffers;				if (nc <= alloc_.m_)					break;				nc -= alloc_.m_;			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				if (!buf_.empty())					buf_.back() = 0;				for (size_type i = 0; i < new_buffers; ++i)  // hh 981210				{					buf_.pop_back();					pointer& p = buf_.back();					alloc_.deallocate(p, alloc_.m_);					p = 0;				}				if (buf_invalidated)					buf_.swap(orig_buf);				throw;			}			#endif		}	}	template <class Allocator>	deque<const void*, Allocator>::deque(const Allocator& a)		: alloc_(a, default_bufsize_s),		  buf_(buf_allocator(a)),		  start_(0),		  size_(0)	{	}	template <class Allocator>	deque<const void*, Allocator>::deque(size_type n, const value_type& value, const Allocator& a)		: alloc_(a, default_bufsize_s),		  buf_(buf_allocator(a)),		  start_(0),		  size_(0)	{		init(n, value);	}	template <class Allocator>	void	deque<const void*, Allocator>::init(size_type n, const value_type& value)	{		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::construction length error");			#else				__msl_error("deque::construction length error\n");			#endif		if (n > 0)		{			init_buf();			if (alloc_.m_ < n)				alloc_.m_ = n;			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				buf_.front() = tmp;				buf_.push_back(0);				size_ = n;				start_ = (alloc_.m_ - size_) / 2;				fill_n(tmp + start_, size_, value);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				throw;			}			#endif		}	}	template <class Allocator>	deque<const void*, Allocator>::deque(const deque& x)		: alloc_(x.alloc_, default_bufsize_s),		  buf_(buf_allocator(alloc_)),		  start_(0),		  size_(x.size_)	{		if (size_ > 0)		{			init_buf();			if (alloc_.m_ < size_)				alloc_.m_ = size_;			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				buf_.front() = tmp;				buf_.push_back(0);				start_ = (alloc_.m_ - size_) / 2;				copy(x.begin(), x.end(), tmp + start_);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				throw;			}			#endif		}	}	template <class Allocator>	inline	deque<const void*, Allocator>::~deque()	{		tear_down();	}	template <class Allocator>	void	deque<const void*, Allocator>::tear_down()	{		if (!buf_.empty())		{			buf_type::iterator e = --buf_.end();			for (buf_type::iterator i = buf_.begin(); i != e; ++i)				alloc_.deallocate(*i, alloc_.m_);		}	}	template <class Allocator>	deque<const void*,Allocator>&	deque<const void*, Allocator>::operator=(const deque& x)	{		if (this != &x)			assign(x.begin(), x.end());		return *this;	}	template <class Allocator>	void	deque<const void*, Allocator>::assign(size_type n, const value_type& t)	{		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::assign length error");			#else				__msl_error("deque::assign length error\n");			#endif		if (buf_.empty())			init_buf();		while (n > capacity())		{			pointer tmp = alloc_.allocate(alloc_.m_);			#ifndef _MSL_NO_EXCEPTIONS			try			{			#endif				buf_.back() = tmp;				buf_.push_back(0);			#ifndef _MSL_NO_EXCEPTIONS			}			catch (...)			{				alloc_.deallocate(tmp, alloc_.m_);				buf_.back() = 0;				throw;			}			#endif		}		start_ = (capacity() - n) / 2;		while (start_ >= alloc_.m_)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;			start_ = (capacity() - n) / 2;		}		fill_n(begin(), n, t);		size_ = n;	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::allocator_type	deque<const void*, Allocator>::get_allocator() const	{		return alloc_;	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::iterator	deque<const void*, Allocator>::begin()	{		return make_iterator(start_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::const_iterator	deque<const void*, Allocator>::begin() const	{		return make_iterator(start_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::iterator	deque<const void*, Allocator>::end()	{			return make_iterator(start_ + size_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::const_iterator	deque<const void*, Allocator>::end() const	{			return make_iterator(start_ + size_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::reverse_iterator	deque<const void*, Allocator>::rbegin()	{		return reverse_iterator(end());	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::const_reverse_iterator	deque<const void*, Allocator>::rbegin() const	{		return const_reverse_iterator(end());	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::reverse_iterator	deque<const void*, Allocator>::rend()	{		return reverse_iterator(begin());	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::const_reverse_iterator	deque<const void*, Allocator>::rend() const	{		return const_reverse_iterator(begin());	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::size_type	deque<const void*, Allocator>::size() const	{		return size_;	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::size_type	deque<const void*, Allocator>::max_size() const	{		return alloc_.max_size();	}	template <class Allocator>	void	deque<const void*, Allocator>::resize(size_type sz, value_type c)	{		if (sz > size())			insert(end(), sz-size(), c);		else if (sz < size())			erase(begin() + difference_type(sz), end());	}	template <class Allocator>	inline	bool	deque<const void*, Allocator>::empty() const	{		return size_ == 0;	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::reference	deque<const void*, Allocator>::operator[](size_type n)	{		size_type i = n + start_;		return *(buf_[i / alloc_.m_] + i % alloc_.m_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::const_reference	deque<const void*, Allocator>::operator[](size_type n) const	{		size_type i = n + start_;		return *(buf_[i / alloc_.m_] + i % alloc_.m_);	}	template <class Allocator>	typename deque<const void*, Allocator>::reference	deque<const void*, Allocator>::at(size_type n)	{		if (n >= size_)			#ifndef _MSL_NO_EXCEPTIONS				throw out_of_range("deque::at index out of range");			#else				__msl_error("deque::at index out of range");			#endif		size_type i = n + start_;		return *(buf_[i / alloc_.m_] + i % alloc_.m_);	}	template <class Allocator>	typename deque<const void*, Allocator>::const_reference	deque<const void*, Allocator>::at(size_type n) const	{		if (n >= size_)			#ifndef _MSL_NO_EXCEPTIONS				throw out_of_range("deque::at index out of range");			#else				__msl_error("deque::at index out of range");			#endif		size_type i = n + start_;		return *(buf_[i / alloc_.m_] + i % alloc_.m_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::reference	deque<const void*, Allocator>::front()	{		return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::const_reference	deque<const void*, Allocator>::front() const	{		return *(buf_[start_ / alloc_.m_] + start_ % alloc_.m_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::reference	deque<const void*, Allocator>::back()	{		size_type i = start_ + size_ - 1;		return *(buf_[i / alloc_.m_] + i % alloc_.m_);	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::const_reference	deque<const void*, Allocator>::back() const	{		size_type i = start_ + size_ - 1;		return *(buf_[i / alloc_.m_] + i % alloc_.m_);	}	template <class Allocator>	void	deque<const void*, Allocator>::push_front(const value_type& x)	{		if (size_ > max_size() - 1)			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::push_front length error");			#else				__msl_error("deque::push_front length error\n");			#endif		if (buf_.empty())			init_buf();		if (start_ == 0)			grow_buf_front(1);		else			--start_;		if (start_ < alloc_.m_)			*(buf_.front() + start_) = x;		else			*(buf_[start_ / alloc_.m_] + start_ % alloc_.m_) = x;		++size_;		invalidate_iterators();	}	template <class Allocator>	void	deque<const void*, Allocator>::push_back(const value_type& x)	{		if (size_ > max_size() - 1)			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::insert length error");			#else				__msl_error("deque::insert length error\n");			#endif		if (buf_.empty())			init_buf();		{			if (capacity() == start_ + size_)				grow_buf_back(0, 1);			size_type pos = start_ + size_;			if (pos < alloc_.m_)				*(buf_.front() + pos) = x;			else				*(buf_[pos / alloc_.m_] + pos % alloc_.m_) = x;			++size_;		}		invalidate_iterators();	}	template <class Allocator>	typename deque<const void*, Allocator>::iterator	deque<const void*, Allocator>::insert(iterator position, const value_type& x)	{		difference_type pos = position - begin();		insert(position, 1, x);		return begin() + pos;	}	template <class Allocator>	void	deque<const void*, Allocator>::insert(iterator position, size_type n, const value_type& x)	{		if (n == 0)			return;		size_type ms = max_size();		if (n > ms || size_ > ms - n)			#ifndef _MSL_NO_EXCEPTIONS				throw length_error("deque::insert length error");			#else				__msl_error("deque::insert length error\n");			#endif		if (buf_.empty())			init_buf();		size_type pb = position.pos_ - start_;		size_type pe = size_ - pb;		if (pb <= pe)  // hh 981210		{			size_type new_buffers = 0;			size_type oldstart = start_;			if (start_ < n)				grow_buf_front(n);			else				start_ -= n;			if (pb == 0) // insert at begin()				fill_n(begin(), n, x);			else // pos in [1, size_ / 2)			{				iterator b = begin();				copy(b + difference_type(n), b + difference_type(n + pb), b);				fill_n(b + difference_type(pb), n, x);			}			size_ += n;		}		else // pos >= size_ / 2		{			size_type e = capacity() - (start_ + size_);			if (e < n)				grow_buf_back(e, n);			if (pe == 0) // insert at end()				fill_n(end(), n, x);			else // pos in [size_ / 2, size_)			{				iterator e = end();				iterator p = e - difference_type(pe);				copy_backward(p, e, e + difference_type(n));				fill_n(p, n, x);			}			size_ += n;		}		invalidate_iterators();	}	template <class Allocator>	inline	void	deque<const void*, Allocator>::pop_front()	{		++start_;		if (--size_ == 0)		{			for (size_type i = buf_.size() - 2; i > 0; --i)			{				buf_.pop_back();				pointer& p = buf_.back();				alloc_.deallocate(p, alloc_.m_);				p = 0;			}			start_ = alloc_.m_ / 2;		}	}	template <class Allocator>	inline	void	deque<const void*, Allocator>::pop_back()	{		--size_;		while (capacity() - (start_ + size_) >= 3 * alloc_.m_ / 2)		{			buf_.pop_back();			pointer& p = buf_.back();			alloc_.deallocate(p, alloc_.m_);			p = 0;		}		if (size_ == 0)		{			for (size_type i = buf_.size() - 2; i > 0; --i)			{				buf_.pop_back();				pointer& p = buf_.back();				alloc_.deallocate(p, alloc_.m_);				p = 0;			}			start_ = alloc_.m_ / 2;		}	}	template <class Allocator>	inline	typename deque<const void*, Allocator>::iterator	deque<const void*, Allocator>::erase(iterator position)	{		return erase(position, position + 1);	}	template <class Allocator>	typename deque<const void*, Allocator>::iterator	deque<const void*, Allocator>::erase(iterator first, iterator last)	{		if (first == last)			return first;		const size_type pb = first.pos_ - start_;		const size_type pe = size_ - (last.pos_ - start_);		const size_type diff = size_type(last - first);		if (pb < pe)		{			if (pb == 0)  // erase from beginning, no copying necessary			{				start_ += diff;				size_ -= diff;			}			else  // erase from beginning, needs copying			{				copy_backward(begin(), first, last);				start_ += diff;				size_ -= diff;				invalidate_iterators();			}		}		else  // pb >= pe - erase from end		{			if (pe != 0)  // erase from end, needs copying			{				copy(last, end(), first);				invalidate_iterators();			}			size_ -= diff;			while (capacity() - (start_ + size_) >= 3 * alloc_.m_ / 2)			{				buf_.pop_back();				pointer& p = buf_.back();				alloc_.deallocate(p, alloc_.m_);				p = 0;			}		}		if (size_ == 0)		{			for (size_type i = buf_.size() - 2; i > 0; --i)  // hh 991005			{				buf_.pop_back();				pointer& p = buf_.back();				alloc_.deallocate(p, alloc_.m_);				p = 0;			}			start_ = alloc_.m_ / 2;		}		return make_iterator(start_ + pb);	}	template <class Allocator>	void	deque<const void*, Allocator>::swap(deque& x)	{		if (this != &x)		{			_STD::swap(alloc_, x.alloc_);			_STD::swap(buf_, x.buf_);			_STD::swap(start_, x.start_);			_STD::swap(size_, x.size_);		}	}	template <class Allocator>	void	deque<const void*, Allocator>::clear()	{		if (!buf_.empty())  // hh 981209		{			size_ = 0;			for (size_type i = buf_.size() - 2; i > 0; --i)			{				buf_.pop_back();				pointer& p = buf_.back();				alloc_.deallocate(p, alloc_.m_);				p = 0;			}			start_ = alloc_.m_ / 2;		}	}	template <class Allocator>	inline	bool	operator==(const deque<const void*,Allocator>& x, const deque<const void*,Allocator>& y)	{		return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());	}	template <class Allocator>	inline	bool	operator!=(const deque<const void*,Allocator>& x, const deque<const void*,Allocator>& y)	{		return !(x == y);	}	template <class Allocator>	inline	bool	operator< (const deque<const void*,Allocator>& x, const deque<const void*,Allocator>& y)	{		return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());	}	template <class Allocator>	inline	bool	operator> (const deque<const void*,Allocator>& x, const deque<const void*,Allocator>& y)	{		return y < x;	}	template <class Allocator>	inline	bool	operator>=(const deque<const void*,Allocator>& x, const deque<const void*,Allocator>& y)	{		return !(x < y);	}	template <class Allocator>	inline	bool	operator<=(const deque<const void*,Allocator>& x, const deque<const void*,Allocator>& y)	{		return !(y < x);	}	template <class Allocator>	inline	void	swap(deque<const void*,Allocator>& x, deque<const void*,Allocator>& y)	{		x.swap(y);	}	// T*	template <class T, class Allocator>	class deque<T*, Allocator>		: private deque<const void*, Allocator::rebind<const void*>::other>	{		typedef deque<const void*, Allocator::rebind<const void*>::other> base;		typedef base::allocator_type base_allocator;	public:		// types:		typedef typename Allocator::reference         reference;		typedef typename Allocator::const_reference   const_reference;		class                                         iterator;		class                                         const_iterator;		typedef typename Allocator::size_type         size_type;		typedef typename Allocator::difference_type   difference_type;		typedef T*                                    value_type;		typedef Allocator                             allocator_type;		typedef typename Allocator::pointer           pointer;		typedef typename Allocator::const_pointer     const_pointer;		typedef _STD::reverse_iterator<iterator>       reverse_iterator;		typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;		class iterator			: public _STD::iterator<random_access_iterator_tag, value_type,				difference_type, pointer, reference>		{		public:			iterator() {}			explicit iterator(const base::iterator& i) : i_(i) {}			operator base::iterator() const {return i_;}			reference operator * () const {return reference(*i_);}			pointer operator -> () const {return pointer(i_.operator->());}			iterator& operator ++ () {++i_; return *this;}			iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}			iterator& operator -- () {--i_; return *this;}			iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}			iterator& operator += (difference_type n) {i_ += n; return *this;}			iterator operator + (difference_type n) const {return iterator(*this) += n;}			iterator& operator -= (difference_type n) {i_ -= n; return *this;}			iterator operator - (difference_type n) const {return iterator(*this) -= n;}			difference_type operator - (const iterator& rhs) const {return i_ - rhs.i_;}			reference operator [] (difference_type i) const {return reference(i_[i]);}			friend bool operator ==(const iterator& x, const iterator& y) {return x.i_ == y.i_;}  // hh 990720			friend bool operator !=(const iterator& x, const iterator& y) {return x.i_ != y.i_;}			friend bool operator < (const iterator& x, const iterator& y) {return x.i_ <  y.i_;}			friend bool operator <=(const iterator& x, const iterator& y) {return x.i_ <= y.i_;}			friend bool operator > (const iterator& x, const iterator& y) {return x.i_ >  y.i_;}			friend bool operator >=(const iterator& x, const iterator& y) {return x.i_ >= y.i_;}			friend iterator operator + (difference_type n, const iterator& rhs)				{return iterator(rhs) += n;}		private:			base::iterator i_;			friend class deque::const_iterator;		};		class const_iterator			: public _STD::iterator<random_access_iterator_tag, value_type,				difference_type, const_pointer, const_reference>		{		public:			const_iterator() {}			const_iterator(const deque::iterator& rhs) : i_(rhs.i_) {}			explicit const_iterator(const base::const_iterator& i) : i_(i) {}			operator base::const_iterator() const {return i_;}			const_reference operator * () const {return const_reference(*i_);}			const_pointer operator -> () const {return const_pointer(i_.operator->());}			const_iterator& operator ++ () {++i_; return *this;}			const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}			const_iterator& operator -- () {--i_; return *this;}			const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}			const_iterator& operator += (difference_type n) {i_ += n; return *this;}			const_iterator operator + (difference_type n) const {return const_iterator(*this) += n;}			const_iterator& operator -= (difference_type n) {i_ -= n; return *this;}			const_iterator operator - (difference_type n) const {return const_iterator(*this) -= n;}			difference_type operator - (const const_iterator& rhs) const {return i_ - rhs.i_;}			const_reference operator [] (difference_type i) const {return const_reference(i_[i]);}			friend bool operator ==(const const_iterator& x, const const_iterator& y) {return x.i_ == y.i_;}  // hh 990720			friend bool operator !=(const const_iterator& x, const const_iterator& y) {return x.i_ != y.i_;}			friend bool operator < (const const_iterator& x, const const_iterator& y) {return x.i_ <  y.i_;}			friend bool operator <=(const const_iterator& x, const const_iterator& y) {return x.i_ <= y.i_;}			friend bool operator > (const const_iterator& x, const const_iterator& y) {return x.i_ >  y.i_;}			friend bool operator >=(const const_iterator& x, const const_iterator& y) {return x.i_ >= y.i_;}			friend const_iterator operator + (difference_type n, const const_iterator& rhs)				{return const_iterator(rhs) += n;}		private:			base::const_iterator i_;		};		// _lib.deque.cons_ construct/copy/destroy:		explicit deque(const Allocator& = Allocator());		explicit deque(size_type n, const value_type& value = 0, const Allocator& = Allocator());		template <class InputIterator>			inline			deque(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: base(__convert_iterator<__implicit_convert<pointer, InputIterator> >(first),				       __convert_iterator<__implicit_convert<pointer, InputIterator> >(last), base_allocator(a))			{			}		template <class InputIterator>			inline			void assign(InputIterator first, InputIterator last)			{				base::assign(__convert_iterator<__implicit_convert<pointer, InputIterator> >(first),				             __convert_iterator<__implicit_convert<pointer, InputIterator> >(last));			}		void assign(size_type n, const value_type& t);		allocator_type get_allocator() const;		// iterators:		iterator               begin();		const_iterator         begin() const;		iterator               end();		const_iterator         end() const;		reverse_iterator       rbegin();		const_reverse_iterator rbegin() const;		reverse_iterator       rend();		const_reverse_iterator rend() const;		// _lib.deque.capacity_ capacity:		size_type size() const;		size_type max_size() const;		void      resize(size_type sz, value_type c = 0);		bool      empty() const;		// element access:		reference       operator[](size_type n);		const_reference operator[](size_type n) const;		reference       at(size_type n);		const_reference at(size_type n) const;		reference       front();		const_reference front() const;		reference       back();		const_reference back() const;		// _lib.deque.modifiers_ modifiers:		void push_front(const value_type& x);		void push_back(const value_type& x);		iterator insert(iterator position, const value_type& x);		void     insert(iterator position, size_type n, const value_type& x);		template <class InputIterator>			void insert(iterator position, InputIterator first, InputIterator last)			{				base::insert(position, __convert_iterator<__implicit_convert<pointer, InputIterator> >(first),				                       __convert_iterator<__implicit_convert<pointer, InputIterator> >(last));			}		void pop_front();		void pop_back();		iterator erase(iterator position);		iterator erase(iterator first, iterator last);		void     swap(deque&);		void     clear();	};	// Implementation deque<T*>	template <class T, class Allocator>	inline	deque<T*, Allocator>::deque(const Allocator& a)		: base(base_allocator(a))	{	}	template <class T, class Allocator>	inline	deque<T*, Allocator>::deque(size_type n, const value_type& value, const Allocator& a)		: base(n, value, base_allocator(a))	{	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::assign(size_type n, const value_type& t)	{		base::assign(n, t);	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::allocator_type	deque<T*, Allocator>::get_allocator() const	{		return base::get_allocator();	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::iterator	deque<T*, Allocator>::begin()	{		return iterator(base::begin());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::const_iterator	deque<T*, Allocator>::begin() const	{		return const_iterator(base::begin());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::iterator	deque<T*, Allocator>::end()	{			return iterator(base::end());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::const_iterator	deque<T*, Allocator>::end() const	{			return const_iterator(base::end());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::reverse_iterator	deque<T*, Allocator>::rbegin()	{		return reverse_iterator(end());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::const_reverse_iterator	deque<T*, Allocator>::rbegin() const	{		return const_reverse_iterator(end());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::reverse_iterator	deque<T*, Allocator>::rend()	{		return reverse_iterator(begin());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::const_reverse_iterator	deque<T*, Allocator>::rend() const	{		return const_reverse_iterator(begin());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::size_type	deque<T*, Allocator>::size() const	{		return base::size();	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::size_type	deque<T*, Allocator>::max_size() const	{		return base::max_size();	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::resize(size_type sz, value_type c)	{		base::resize(sz, c);	}	template <class T, class Allocator>	inline	bool	deque<T*, Allocator>::empty() const	{		return base::empty();	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::reference	deque<T*, Allocator>::operator[](size_type n)	{		return reference(base::operator[](n));	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::const_reference	deque<T*, Allocator>::operator[](size_type n) const	{		return const_reference(base::operator[](n));	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::reference	deque<T*, Allocator>::at(size_type n)	{		return reference(base::at(n));	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::const_reference	deque<T*, Allocator>::at(size_type n) const	{		return const_reference(base::at(n));	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::reference	deque<T*, Allocator>::front()	{		return reference(base::front());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::const_reference	deque<T*, Allocator>::front() const	{		return const_reference(base::front());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::reference	deque<T*, Allocator>::back()	{		return reference(base::back());	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::const_reference	deque<T*, Allocator>::back() const	{		return const_reference(base::back());	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::push_front(const value_type& x)	{		base::push_front(x);	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::push_back(const value_type& x)	{		base::push_back(x);	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::iterator	deque<T*, Allocator>::insert(iterator position, const value_type& x)	{		return iterator(base::insert(position, x));	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::insert(iterator position, size_type n, const value_type& x)	{		base::insert(position, n, x);	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::pop_front()	{		base::pop_front();	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::pop_back()	{		base::pop_back();	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::iterator	deque<T*, Allocator>::erase(iterator position)	{		return iterator(base::erase(position));	}	template <class T, class Allocator>	inline	typename deque<T*, Allocator>::iterator	deque<T*, Allocator>::erase(iterator first, iterator last)	{		return iterator(base::erase(first, last));	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::swap(deque& x)	{		base::swap((base&)x);	}	template <class T, class Allocator>	inline	void	deque<T*, Allocator>::clear()	{		base::clear();	}	template <class T, class Allocator>	inline	bool	operator==(const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)	{		return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());	}	template <class T, class Allocator>	inline	bool	operator!=(const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)	{		return !(x == y);	}	template <class T, class Allocator>	inline	bool	operator< (const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)	{		return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());	}	template <class T, class Allocator>	inline	bool	operator> (const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)	{		return y < x;	}	template <class T, class Allocator>	inline	bool	operator>=(const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)	{		return !(x < y);	}	template <class T, class Allocator>	inline	bool	operator<=(const deque<T*,Allocator>& x, const deque<T*,Allocator>& y)	{		return !(y < x);	}	template <class T, class Allocator>	inline	void	swap(deque<T*,Allocator>& x, deque<T*,Allocator>& y)	{		x.swap(y);	}#endif // !defined(_MSL_NO_PARTIAL_SPECIALIZATION) && !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_Inhibit_Container_Optimization)#ifndef _MSL_NO_CPP_NAMESPACE	} // namespace std#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#pragma enumsalwaysint reset#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#pragma bool reset#endif#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endif#pragma options align=reset#endif // RC_INVOKED#endif // _DEQUE// hh 971220 fixed MOD_INCLUDE// hh 971221 Changed filename from deque.h to deque// hh 971221 Made include guards standard// hh 971221 Added qualified name to const_iterator// hh 971221 Added qualified name to iterator// hh 971230 added RC_INVOKED wrapper// hh 980105 changed pointer & reference to const versions in const_iterator base class// hh 980105 rewrote some constructors to get rid of unused arg dq warning// hh 980111 <string> added so deque could throw a stdexcept// hh 980111 made at and operator[] standard compliant// hh 980713 Temporarily moved member templates into class definition to support compiler// hh 980902 #ifdef'd out exception code when ndef MSIPL_EXCEPT// hh 981027 rewrote// hh 981208 changed static_cast to reinterpret_cast on the value_type (pointer specialization only)// hh 981209 Protected clear() from an empty buf_// hh 981210 Modified insertion into front half to preserve outstanding iterators under exceptions//           and made it more efficient when the initial size is zero.// hh 981210 Added forgotten for loop in insert// hh 981220 Rewrote iterators to gain higher performance// hh 981220 Added typename to appropriate return types// hh 981220 Modifed some method signitures to simplified syntax// hh 981220 Added class modifier to several friend declarations// hh 990120 changed name of MSIPL flags// hh 990720 Made iterator comparison methods global friends.// hh 990825 changed void* to const void*// hh 990826 Seperated out calls involving T()// hh 991005 Fixed type-o in deque<void*>::erase// hh 991116 Fixed pointer conversion bug in T* specialization by introducing __convert_iterator// hh 991208 #ifdef'd out oldstart argument name in grow_buf_front for when exceptions are turned off.// hh 000130 Added :: to placement new.// hh 000130 Silenced some conversion warnings in the iterators.// hh 000130 Changed name of std::__cdeque to Metrowerks::cdeque