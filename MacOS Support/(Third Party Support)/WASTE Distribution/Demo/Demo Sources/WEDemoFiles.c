/* *	WASTE Demo Project: *	File Handling * *	Copyright © 1993-2002 Marco Piovanelli *	All Rights Reserved * *	Original C Port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __WEDEMO__#include "WEDemo.h"#endifOSStatus WriteFile	(		const FSRef *				inFolderRef,		CFStringRef					inFileName,		Boolean						inReplacing,		OSType						inFileType,		WEReference					inText,		FSRef *						outFileRef	){	Boolean					safeSave = ( inFileType != kTypeRTFD ) ;	const CFStringRef		kTempFileName = CFSTR ( "WEDemoTemp" ) ;	FSCatalogInfo			catalogInfo ;	FSVolumeRefNum			volume = 0 ;	FSRef					existingFileRef ;	FSRef					fileRef ;	FSRef					tempItemsFolderRef ;	UniCharCount			fileNameLength ;	UniChar					fileName [ 256 ] ;	Boolean					lock = false ;	OSStatus				err ;	BlockZero ( & catalogInfo, sizeof ( catalogInfo ) ) ;	BlockZero ( & existingFileRef, sizeof ( existingFileRef ) ) ;	BlockZero ( & fileRef, sizeof ( fileRef ) ) ;	BlockZero ( & tempItemsFolderRef, sizeof ( tempItemsFolderRef ) ) ;	/* get the reference number of the target volume */	if ( ( err = FSGetObjectVolume ( inFolderRef, & volume ) ) != noErr )	{		goto cleanup ;	}	fileNameLength = CFStringGetLength ( inFileName ) ;	CFStringGetCharacters ( inFileName, CFRangeMake ( 0, fileNameLength ), fileName ) ;	if ( inReplacing )	{		/* the target file already exists */		if ( ( err = FSMakeFSRefUnicode ( inFolderRef, fileNameLength, fileName, kTextEncodingMacRoman, & existingFileRef ) ) != noErr )		{			goto cleanup ;		}		/* get file lock */		if ( ( err = FSGetObjectLock ( & existingFileRef, & lock ) ) != noErr )		{			goto cleanup ;		}		/* if the existing file is locked, we cannot save changes */		err = fLckdErr ;		if ( lock )		{			goto cleanup ;		}		if ( safeSave )		{			/* Perform a "safe save": first write the new contents to a newly created temporary file, */			/* then swap the temporary file and the target file, and finally delete the old file. */			/* If anything goes wrong while writing the new contents, the original file is left untouched. */			/* find the temporary items folder on the file's volume; create it if necessary */			if ( ( err = FSFindFolder ( volume, kTemporaryFolderType, kCreateFolder, & tempItemsFolderRef ) ) != noErr )			{				goto cleanup ;			}			fileNameLength = CFStringGetLength ( kTempFileName ) ;			CFStringGetCharacters ( kTempFileName, CFRangeMake ( 0, fileNameLength ), fileName ) ;			/* create a temporary file */			FSCreateResFile ( & tempItemsFolderRef, fileNameLength, fileName, 0, NULL, & fileRef, NULL ) ;			if ( ( err = ResError ( ) ) != noErr )			{				goto cleanup ;			}		}		else		{			/* Do not perform a "safe save": just overwrite the original file. */			/* If anything goes wrong while writing the new contents, we may lose both the old and new contents. */			fileRef = existingFileRef ;		}	}	else	{		/* the target file doesn't exist yet: create it */		( ( FileInfo * ) & catalogInfo . finderInfo ) -> fileType = inFileType ;		( ( FileInfo * ) & catalogInfo . finderInfo ) -> fileCreator = sigWASTE ;		FSCreateResFile ( inFolderRef, fileNameLength, fileName, kFSCatInfoFinderInfo, & catalogInfo, & fileRef, NULL ) ;		if ( ( err = ResError ( ) ) != noErr )		{			goto cleanup ;		}	}	/* save the text */	if ( ( err = WESave ( 0, 0x7FFFFFFF, & fileRef, inFileType, kTextEncodingMultiRun,		weSaveAddResources | weSaveCompatibilityResources, inText ) ) != noErr )	{		goto cleanup ;	}	if ( inReplacing && safeSave )	{		/* since we were replacing an existing file, let's now swap the original */		/* and the temp file.  let's hear it for safe saves. */		if ( ( err = FSExchangeObjects ( & fileRef, & existingFileRef ) ) != noErr )		{			goto cleanup ;		}		/* can the temp file since we don't need it anymore */		if ( ( err = FSDeleteObject ( & fileRef ) ) != noErr )		{			goto cleanup ;		}		fileRef = existingFileRef ;	}	if ( outFileRef )	{		* outFileRef = fileRef ;	}	/* clear result code */	err = noErr;cleanup :	/* display an alert box if anything went wrong */	if ( err != noErr )	{		ErrorAlert ( err ) ;	}	/* return result code */	return err ;}OSStatus FSGetObjectNameAsCFString ( const FSRef * inObjectRef, CFStringRef * outCFString ){	HFSUniStr255		objectName ;	OSStatus			err ;	* outCFString = NULL ;	/* get object name */	if ( ( err = FSGetCatalogInfo ( inObjectRef, kFSCatInfoNone, NULL, & objectName, NULL, NULL ) ) != noErr )	{		goto cleanup ;	}	/* create the string */	err = memFullErr ;	if ( ( * outCFString = CFStringCreateWithCharacters ( NULL, objectName . unicode, objectName . length ) ) == NULL )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	return err ;}OSStatus FSGetObjectVolume ( const FSRef * inObjectRef, FSVolumeRefNum * outVolumeRefNum ){	FSCatalogInfo		catalogInfo ;	OSStatus			err ;	BlockZero ( & catalogInfo, sizeof ( catalogInfo ) ) ;	err = FSGetCatalogInfo ( inObjectRef, kFSCatInfoVolume, & catalogInfo, NULL, NULL, NULL ) ;	* outVolumeRefNum = catalogInfo . volume ;	return err ;}OSStatus FSGetObjectLock ( const FSRef * inObjectRef, Boolean * outLock ){	FSCatalogInfo		catalogInfo ;	OSStatus			err ;	BlockZero ( & catalogInfo, sizeof ( catalogInfo ) ) ;	err = FSGetCatalogInfo ( inObjectRef, kFSCatInfoNodeFlags, & catalogInfo, NULL, NULL, NULL ) ;	* outLock = ( catalogInfo . nodeFlags & kFSNodeLockedMask ) ;	return err ;}OSStatus FSGetObjectFinderInfo ( const FSRef * inObjectRef, FileInfo * outFinderInfo ){	FSCatalogInfo		catalogInfo ;	OSStatus			err ;	BlockZero ( & catalogInfo, sizeof ( catalogInfo ) ) ;	/* get Finder info for the specified file */	err = FSGetCatalogInfo ( inObjectRef, kFSCatInfoFinderInfo, & catalogInfo, NULL, NULL, NULL ) ;	BlockMoveData ( & catalogInfo . finderInfo, outFinderInfo, sizeof ( FileInfo ) ) ;	return err ;}OSStatus FSSetIsStationery ( const FSRef * inFileRef, Boolean inStationeryFlag ){	FSCatalogInfo		catalogInfo ;	FileInfo *			finderInfo ;	OSStatus			err ;	BlockZero ( & catalogInfo, sizeof ( catalogInfo ) ) ;	finderInfo = ( FileInfo * ) & catalogInfo . finderInfo ;	/* get Finder info for the specified file */	if ( ( err = FSGetCatalogInfo ( inFileRef, kFSCatInfoFinderInfo, & catalogInfo, NULL, NULL, NULL ) ) != noErr )	{		return err ;	}	/* set the stationery bit */	if ( inStationeryFlag )	{		finderInfo -> finderFlags |= kIsStationery ;	}	else	{		finderInfo -> finderFlags &= ~ kIsStationery ;	}	/* reset Finder info */	return FSSetCatalogInfo ( inFileRef, kFSCatInfoFinderInfo, & catalogInfo ) ;}