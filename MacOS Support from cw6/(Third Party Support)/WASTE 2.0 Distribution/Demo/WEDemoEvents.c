/* *	WASTE Demo Project: *	Event Handling * *	Copyright © 1993-2000 Marco Piovanelli *	All Rights Reserved * *	C port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __WEDEMO__#include "WEDemo.h"#endif//	Mac OS #includes#ifndef __APPLEEVENTS__#include <AppleEvents.h>#endif#ifndef __AEREGISTRY__#include <AERegistry.h>#endif#ifndef __DISKINIT__#include <DiskInit.h>#endif#ifndef __TEXTSERVICES__#include <TextServices.h>#endifstatic UInt32		sSleepTime = 0;			// sleep time for WaitNextEvent()static RgnHandle	sMouseRgn = nil;		// mouse region for WaitNextEvent()void AdjustCursor ( Point mouseLoc, RgnHandle mouseRgn ){	Cursor		arrow ;	WindowRef	window ;	// by default, set mouseRgn to the whole QuickDraw coordinate plane,	// so that we never get mouse moved events	SetRectRgn ( mouseRgn, -0x7FFF, -0x7FFF, 0x7FFF, 0x7FFF ) ;#if ! TARGET_API_MAC_CARBON	// give text services a chance to set the cursor shape	// (this call is not needed for Carbon clients)	if ( SetTSMCursor( mouseLoc ) )	{		return ;	}#endif	// if there is a window open, give WEAdjustCursor an opportunity to set the cursor	// WEAdjustCursor intersects mouseRgn (if supplied) with a region within which	// the cursor is to retain its shape	// (if the cursor is outside the view region, this is subtracted from mouseRgn )	if ( ( window = FrontWindow ( ) ) != nil )	{		if ( WEAdjustCursor ( mouseLoc, mouseRgn, GetWindowWE ( window ) ) )		{			return ;		}	}	// set the cursor to the arrow cursor	SetCursor( GetQDGlobalsArrow ( & arrow ) ) ;}void DoMouseDown ( const EventRecord * event ){	WindowRef	window ;	SInt16		partCode ;	// find out where this click when down in	partCode = FindWindow ( event -> where, & window ) ;	// dispatch on partCode	switch ( partCode )	{		case inMenuBar :		{			PrepareMenus ( ) ;			DoMenuChoice ( MenuSelect ( event -> where ), event -> modifiers ) ;			break;		}		case inContent :		{			if ( DoContent ( event -> where, event, window ) )			{				SelectWindow ( window ) ;			}			break;		}		case inDrag :		{			if ( window != FrontWindow ( ) )			{				if ( ( event->modifiers & cmdKey ) == 0 )				{					SelectWindow ( window ) ;				}			}			else if ( IsWindowPathSelectClick ( window, ( EventRecord * ) event ) )			{				DoPathSelect ( window ) ;				break ;			}			DoDrag ( event -> where, window ) ;			break;		}		case inGrow :		{			DoGrow ( event -> where, window ) ;			break;		}		case inGoAway :		{			if ( TrackGoAway ( window, event -> where ) )			{				DoClose ( kNavSaveChangesClosingDocument, savingAsk, window ) ;			}			break ;		}		case inZoomIn :		case inZoomOut :		{			if ( TrackBox ( window, event -> where, partCode ) )			{				DoZoom ( partCode, window ) ;			}			break ;		}		case inProxyIcon:		{			//	in order to start a proxy icon drag, the window must be active			//	and the proxy icon must be enabled			if ( window == FrontWindow ( ) )			{				if ( ! IsWindowModified ( window ) )				{					//	if the mouse isn't held down on the proxy icon for a certain delay,					//	this gesture should be interpreted as an attempt to drag the window					if ( TrackWindowProxyDrag ( window, event->where ) != errUserWantsToDragWindow )					{						break ;					}				}			}			else			{				//	clicking the proxy icon of an inactive window should select				//	the window unless the command key is held down				if ( ( event->modifiers & cmdKey ) == 0 )				{					SelectWindow ( window ) ;				}			}			DoDrag ( event->where, window ) ;			break ;		}#if !TARGET_API_MAC_CARBON		case inSysWindow :		{			SystemClick ( event, window ) ;			break ;		}#endif	}	// switch}void DoKeyDown ( const EventRecord * event ){	SInt16		key ;	Boolean		isCmdKey ;	// extract character code from event message	key = ( event -> message & charCodeMask );	// is this a command+key combo?	isCmdKey = ( ( event -> modifiers & cmdKey ) != 0 );	// map function keys to the equivalent command+key combos	// note that all fuction keys generate the same code, i.e. 0x10	if ( key == 0x10 )	{		isCmdKey = true ;		switch ( ( event -> message & keyCodeMask ) >> 8 )		{			case keyF1:			{				key = 'z' ;				break ;			}			case keyF2:			{				key = 'x' ;				break ;			}			case keyF3:			{				key = 'c' ;				break ;			}			case keyF4:			{				key = 'v' ;				break ;			}			default:			{				key = 0 ;				break ;			}		}	// switch	}	// if	// command + printable character combos are routed to MenuEvent( )	// but be sure to pass command + arrow key combos to WEKey( )	if ( isCmdKey && ( key >= 0x20 ) )	{		PrepareMenus ( );		DoMenuChoice ( MenuEvent ( event ), event->modifiers ) ;	}	else	{		DoKey ( key, event ) ;	}}void DoDiskEvent ( const EventRecord * event ){#if !TARGET_API_MAC_CARBON	Point dialogCorner ;	if ( ( event -> message >> 16 ) != noErr )	{		SetPt ( & dialogCorner, 112, 80 ) ;		DIBadMount ( dialogCorner, event -> message ) ;	}#else	#pragma unused ( event )#endif}void DoOSEvent ( const EventRecord * event ){	SInt16		osMessage ;	WindowRef	window ;	// extract the OS message field from the event record	osMessage = ( event -> message & osEvtMessageMask ) >> 24 ;	// dispatch on osMessage	switch ( osMessage )	{		case suspendResumeMessage:		{			if ( ( window = FrontWindow( ) ) != nil )			{				DoActivate( (event->message & resumeFlag) != 0, window );			}			break;		}		case mouseMovedMessage:		{			// nothing			break;		}	}}void DoHighLevelEvent ( const EventRecord * event ){	AEProcessAppleEvent ( event ) ;}void DoIdleEvent ( const EventRecord * event ){#pragma unused (event)	WindowRef window ;	sSleepTime = 0x7FFFFFFF ;	//	assume we can sleep forever	if ( ( window = FrontWindow ( ) ) != nil )	{		DoIdle ( & sSleepTime, window ) ;	}}void DoWindowEvent ( const EventRecord * event ){	WindowRef window;	// the message field of the event record contains the window reference	window = (WindowRef) event->message;	// make sure this window is an application window; check the windowKind field	if ( GetWindowKind( window ) != userKind )	{		return;	}	switch ( event->what )	{		case updateEvt:		{			DoUpdate( window );			break;		}		case activateEvt:		{			DoActivate( ( event->modifiers & activeFlag) != 0, window );			break;		}	}}void ProcessEvent ( void ){	EventRecord		event ;	Boolean			gotEvent ;	gotEvent = WaitNextEvent ( everyEvent, & event, sSleepTime, sMouseRgn ) ;#if ! TARGET_API_MAC_CARBON	// give text services a chance to intercept this event	// if TSMEvent( ) handles the event, it will set event.what to nullEvent	// this call is not needed for Carbon clients	TSMEvent ( & event ) ;#endif	// adjust cursor shape and set mouse region	// (we assume event.where is the current mouse position in global coordinates	// if event.what <= osEvt; high-level events store the event ID there)	if ( event.what <= osEvt )	{		AdjustCursor ( event.where, sMouseRgn ) ;	}	// dispatch on event.what	switch ( event.what )	{		case nullEvent:		{			DoIdleEvent ( & event ) ;			break ;		}		case mouseDown:		{			DoMouseDown ( & event) ;			break ;		}		case keyDown:		case autoKey:		{			DoKeyDown ( & event ) ;			break ;		}		case updateEvt:		case activateEvt:		{			DoWindowEvent ( & event ) ;			break ;		}		case diskEvt:		{			DoDiskEvent ( & event ) ;			break ;		}		case osEvt:		{			DoOSEvent ( & event ) ;			break;		}		case kHighLevelEvent:		{			DoHighLevelEvent ( & event ) ;			break;		}	}	// switch	if ( gotEvent )	{		sSleepTime = 0 ;  // force early idle after non-idle event	}}OSStatus GotRequiredParams( const AppleEvent *ae ){	DescType	actualType;	Size		actualSize;	OSStatus	err;	err = AEGetAttributePtr( ae, keyMissedKeywordAttr, typeWildCard, &actualType, nil, 0, &actualSize );	return	( err == errAEDescNotFound ) ? noErr :			( err == noErr ) ? errAEParamMissed : err;}static pascal OSErr	HandleOpenDocument ( const AppleEvent * ae, AppleEvent * reply, UInt32 refCon ){#pragma unused ( reply )	AEDescList		docList ;	AEKeyword		keyword ;	DescType		actualType ;	Size			actualSize ;	SInt32			docCount ;	SInt32			docIndex ;	FSSpec			fileSpec ;	WindowRef		window = nil ;	OSStatus		err ;	InitDesc ( & docList ) ;	// extract direct parameter from the Apple event	if ( ( err = AEGetParamDesc ( ae, keyDirectObject, typeAEList, & docList ) ) != noErr )	{		goto cleanup ;	}	// perform the recommended check for additional required parameters	if ( ( err = GotRequiredParams ( ae ) ) != noErr )	{		goto cleanup ;	}	// count the items in the list of aliases	if ( ( err = AECountItems ( & docList, & docCount ) ) != noErr )	{		goto cleanup ;	}	for ( docIndex = 1; docIndex <= docCount; docIndex ++ )	{		//	coerce the nth alias to a file system specification record		if ( ( err = AEGetNthPtr ( & docList, docIndex, typeFSS, & keyword, & actualType,				& fileSpec, sizeof ( fileSpec ), & actualSize ) ) != noErr )		{			goto cleanup ;		}		//	open the specified file		if ( ( err = CreateWindow ( & fileSpec, & window ) ) != noErr )		{			goto cleanup ;		}		if ( refCon == kDoPrint )		{			//	print it			if ( ( err = DoPrint ( window ) ) != noErr )			{				goto cleanup ;			}		}	}cleanup:	AEDisposeDesc ( & docList ) ;	return err ;}static pascal OSErr	HandleOpenApplication ( const AppleEvent * ae, AppleEvent *reply, UInt32 refCon ){#pragma unused ( reply, refCon )	OSStatus	err ;	// perform the recommended check for additional required parameters	if ( ( err = GotRequiredParams ( ae ) ) != noErr )	{		goto cleanup ;	}	// create a new window from scratch	err = CreateWindow ( nil, nil ) ;cleanup :	return err ;}static pascal OSErr	HandleQuitApplication ( const AppleEvent *ae, AppleEvent *reply, UInt32 refCon ){#pragma unused (reply, refCon)	AEKeyword		optKey;	DescType		actualType;	Size			actualSize;	SavingOption	saving;	OSStatus		err;	// default saving option is savingAsk;	saving = savingAsk;	// extract optional save options	if ( ( err = AEGetParamPtr( ae, keyAESaveOptions, typeEnumerated, &actualType, &optKey, sizeof( optKey ), &actualSize ) ) == noErr )	{		if ( optKey == kAEYes )		{			saving = savingYes;		}		else if (optKey == kAENo )		{			saving = savingNo;		}		else if ( optKey != kAEAsk )		{			err = paramErr;	// for want of a better code			goto cleanup;		}	}	// perform the recommended check for additional required parameters	if ( ( err = GotRequiredParams ( ae ) ) != noErr )		goto cleanup;	// actually do the quit stuff	err = DoQuit( saving );cleanup:	return err;}OSStatus InstallEventHandlers ( void ){	OSStatus	err;	// allocate space for the mouse region	sMouseRgn = NewRgn( );	// install AppleEvent handlers for the Required Suite	if ( ( err = AEInstallEventHandler( kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc( HandleOpenApplication ), 0, false ) ) != noErr )	{		goto cleanup;	}	if ( ( err = AEInstallEventHandler ( kCoreEventClass, kAEReopenApplication, NewAEEventHandlerProc( HandleOpenApplication ), 0, false ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEInstallEventHandler( kCoreEventClass, kAEOpenDocuments, NewAEEventHandlerProc( HandleOpenDocument ), kDoOpen, false ) ) != noErr )	{		goto cleanup;	}	if ( ( err = AEInstallEventHandler( kCoreEventClass, kAEPrintDocuments, NewAEEventHandlerProc( HandleOpenDocument ), kDoPrint, false ) ) != noErr )	{		goto cleanup;	}	if ( ( err = AEInstallEventHandler( kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc( HandleQuitApplication ), 0, false ) ) != noErr )	{		goto cleanup;	}	// install Apple event handlers for a subset of the Core suite	if ( ( err = InstallCoreHandlers( ) ) != noErr )		goto cleanup;	// install Apple event handlers for inline input	if ( ( err = WEInstallTSMHandlers( ) ) != noErr )		goto cleanup;cleanup:	return err;}