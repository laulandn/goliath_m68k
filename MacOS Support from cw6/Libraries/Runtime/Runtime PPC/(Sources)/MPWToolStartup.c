/* *	MPWToolStartup.c	-	Default init/startup/termination routines for Metrowerks C++ (PowerPC) * *	Copyright © 1993-2000 Metrowerks, Inc. All Rights Reserved. * */#include <NMWException.h>#include <Quickdraw.h>#include <SegLoad.h>#include <setjmp.h>#include <stdlib.h>	/*	external data	*/extern char __code_start__[];				/*	(defined by linker)	*/extern char	__code_end__[];					/*	(defined by linker)	*/extern char __data_start__[];				/*	(defined by linker)	*/extern char __data_end__[];					/*	(defined by linker)	*/extern char __exception_table_start__[];	/*	(defined by linker)	*/extern char __exception_table_end__[];		/*	(defined by linker)	*/	/*	public data		*/int	StandAlone;char **ArgV;						/*	pascal support for IntEnv glue	*/char **_EnvP;						/*	pascal support for IntEnv glue	*/long ArgC;							/*	pascal support for IntEnv glue	*/	/*	prototypes	*/#ifdef __cplusplusextern "C" {#endifint main(long argc, char **argv, char **envp);void __sinit(void);int __start(void);#ifdef __cplusplus}#endif/* *	__RTOC	-	return the TOC pointer for our code fragment * */static asm char *__RTOC(void){		mr		r3,RTOC	#if !defined(__MWERKS__)			blr	#endif}/* *	__start	-	Default startup routine for Metrowerks C++ (PowerPC) MPW Tools (C and C++) * *	This startup is experimental and has not been thoroughly tested. * *	This routine should be specified as the PEF main routine in the container *	for any monolithic MPW Tool (uses only the normal toolbox shared libs).  *	You should not have an initialize or terminate entry point with this runtime lib. * *	1.	Set up a jmp_buf (exported from StdCLib) for exit() to jump to *	2.	Call all static initializers--these might call exit() *	3.	Set up default values for 'argc' and 'argv' and call main() *	4.	Execute any atexit() routines (via your calling exit()) *	5.	Destroy all static objects *	6.	Execute any cleanup code, e.g. close open files, console window, etc. in *		the event you didn't call exit yourself *	7.	Terminate the MPW Tool * *	This version of the runtime uses only the required entry points in StdCLib *	and uses the Plauger ANSI libs for all other ANSI functionality. * */int __start(void){	int 			fragmentID;	extern 	Boolean _InitStdCLib(void);	extern  int		*StdCLib_StandAlone;	extern 	void 	__exit(void);	extern	int		*__NubAt3Ptr;	extern	void	_BreakPoint(void);	extern	int		*__C_phasePtr;	extern	int		*_exit_statusPtr;	extern	jmp_buf	*__target_for_exitPtr;#pragma options align=mac68k	extern	struct {				short	unknown;				long	ArgC;				char	**ArgV;				char	**EnvP;			} *_IntEnvPtr;#pragma options align=reset	//	register this code fragment with the Exception Handling mechanism	fragmentID = __register_fragment(__code_start__, __code_end__,									__data_start__, __data_end__,									__exception_table_start__, __exception_table_end__,									__RTOC());	if (!_InitStdCLib ()) {		return 1;	}	StandAlone = *StdCLib_StandAlone;	ArgC = _IntEnvPtr->ArgC;	ArgV = _IntEnvPtr->ArgV;	_EnvP = _IntEnvPtr->EnvP;	*_exit_statusPtr = 1;			if (*__NubAt3Ptr != 0) {		_BreakPoint();	}		*__C_phasePtr = 2;		if (setjmp(*__target_for_exitPtr) == 0) {	//	set up jmp_buf for exit()		if (atexit(&__exit)) {			exit(1);		}		if (atexit(&__destroy_global_chain)) {			exit(1);		}		__sinit();					//	call all static initializers		*_exit_statusPtr = main(_IntEnvPtr->ArgC, _IntEnvPtr->ArgV, _IntEnvPtr->EnvP);		exit(*_exit_statusPtr);		// this will jump to __target_for_exitPtr	}	//	unregister this code fragment with the Exception Handling mechanism	__unregister_fragment(fragmentID);	return(*_exit_statusPtr);}