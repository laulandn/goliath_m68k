// ===========================================================================//	LMacTCPTCPEndpoint.cp		PowerPlant 2.1		й1996-2000 Metrowerks Inc.// ===========================================================================// MacTCP version of a TCP endpoint. An instance of this class will normally be// created for you by use of UNetworkFactory.#include <LMacTCPTCPEndpoint.h>#if PP_Target_Carbon		// MacTCP not supported. Remove this file from Carbon targets	#error "Carbon does not support MacTCP"#endif#include <UMacTCPSupport.h>#include <UNetworkFactory.h>#include <LMacTCPTCPSendQueue.h>#include <LMacTCPListenQueue.h>PP_Begin_Namespace_PowerPlant#define		TCP_NONEVENT	0	//A TCP "non-event"... This is used to hide								// some internal differences between how								// OT and MacTCP map notification events.// === Static Members ===TCPNotifyUPP LMacTCPTCPEndpoint::sTCPNotifyUPP = NewTCPNotifyProc(Int_TCPNotifyProc);// ===========================================================================#pragma mark === LMacTCPTCPEndpoint ===// ---------------------------------------------------------------------------//		е LMacTCPTCPEndpoint()// ---------------------------------------------------------------------------//	ConstructorLMacTCPTCPEndpoint::LMacTCPTCPEndpoint(UInt32		inReceiveBufferSize){	UMacTCPSupport::OpenMacTCPDriver();	mReceiveBufferSize = inReceiveBufferSize;	if (mReceiveBufferSize == 0)		mReceiveBufferSize = MacTCP_RcvBuffer;	mTCPStream = nil;	mEndpointState = T_UNBND;	mAckSends = false;	mReceivedDisconnect = 0;	mSharedPool = LSharedMemoryPool::GetSharedPool();	mSharedPool->AddPoolUser(this);	mReceiveBuffer = nil;	mLocalAddress = nil;	mRemoteAddress = nil;	mMessageQueue = nil;	try {		mReceiveBuffer = ::NewPtr((SInt32) mReceiveBufferSize);		ThrowIfMemFail_(mReceiveBuffer);		mLocalAddress = new LInternetAddress(0,0);		mRemoteAddress = new LInternetAddress(0,0);		mMessageQueue = new LNetMessageQueue(*this);	} catch (...) {		if (mReceiveBuffer) {			::DisposePtr(mReceiveBuffer);			mReceiveBuffer = nil;		}		delete mLocalAddress;		mLocalAddress = nil;		delete mRemoteAddress;		mLocalAddress = nil;		delete mMessageQueue;		mMessageQueue = nil;		throw;	//Rethrow after deleting objects.	}	mSendQueue = nil;	mListenQueue = nil;}// ---------------------------------------------------------------------------//		е ~LMacTCPTCPEndpoint// ---------------------------------------------------------------------------//	DestructorLMacTCPTCPEndpoint::~LMacTCPTCPEndpoint(){	try {		if (mEndpointState == T_DATAXFER) {			AbortiveDisconnect();		}	} catch(...) {	}	if (mTCPStream) {		//Release the stream		TCPiopb releaseParam;		releaseParam.ioCompletion = nil;		releaseParam.ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();		releaseParam.tcpStream = mTCPStream;		releaseParam.csCode = TCPRelease;		OSErr err = ::PBControlSync((ParmBlkPtr)&releaseParam);		if(err) {			SignalPStr_("\p ~LMacTCPTCPEndpoint: Attempt to release stream failed within destructor. You should restart.");			// If we get here, the machine is probably hosed. A destructor			// cannot be stopped, so we have to swallow the error.			// MacTCP apparently failed to disconnect the endpoint or release the stream			// and may keep dangling pointers to the program's data structures			// and code. This will almost certainly cause the machine to			// crash at some later time.		}		//Delete receive buffer pointer... Do this here since mReceiveBuffer may have		//	changed during AcceptIncoming().		if (releaseParam.csParam.create.rcvBuff == mReceiveBuffer)			mReceiveBuffer = nil;		::DisposePtr(releaseParam.csParam.create.rcvBuff);		mTCPStream = nil;	}	delete mLocalAddress;	delete mRemoteAddress;	if (mReceiveBuffer)		::DisposePtr(mReceiveBuffer);	if (mSendQueue) {		mSendQueue->KillQueue();		mSendQueue = nil;	}	//Need to delete mMessageQueue before removing memory pool!	delete mMessageQueue;	LActiveEndpointQueueElem*	p;	TInterruptSafeListIterator<LActiveEndpointQueueElem*>	iter(mActiveListens);	while (iter.Next(p)) {		delete p;	}	if (mListenQueue) {		delete mListenQueue;		mListenQueue = nil;	}	//Probably always want to RemovePoolUser last since other objects may	//	have dependance on the memory pool and the memory pool might	//	delete itself when we do this.	mSharedPool->RemovePoolUser(this);}// ---------------------------------------------------------------------------//		е AbortThreadOperation// ---------------------------------------------------------------------------// Abort the pending operation on the thread indicatedvoidLMacTCPTCPEndpoint::AbortThreadOperation(LThread * inThread){	StMacTCPOperation * theOperation = (StMacTCPOperation *)StAsyncOperation::GetThreadOperation(inThread);	if (theOperation) {		theOperation->mTCPParamBlock->mOperation = nil;		theOperation->AbortOperation();	}}// ===========================================================================#pragma mark -#pragma mark ее local address configuration// ---------------------------------------------------------------------------//		е Bind// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::Bind(	LInternetAddress&		inLocalAddress,	UInt32					inListenQueueSize,	Boolean					/* inReusePort */){	if (mEndpointState != T_UNBND) {		Throw_(kOTOutStateErr);	}	//If we are reusing the endpoint and we have an old listen queue, kill it.	if (mListenQueue) {		delete mListenQueue;		mListenQueue = nil;	}	//Get/Set the local IP address if necessary	if (mLocalAddress->GetIPAddress() == 0) {		//GetLocalAddress called here to ensure we have one		LInternetAddress* tempAddress = GetLocalAddress();		delete tempAddress;	}	//Set the local port	mLocalAddress->SetHostPort(inLocalAddress.GetHostPort());	if (inListenQueueSize > 0)	{		if (inListenQueueSize > 10) //don't wonk MacTCP			inListenQueueSize = 10;		mListenQueue = new LMacTCPListenQueue(inListenQueueSize, *this);	}	mEndpointState = T_IDLE;}// ---------------------------------------------------------------------------//		е Unbind// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::Unbind(){	if (mEndpointState != T_IDLE) {		Throw_(kOTOutStateErr);	}	StMacTCPOperation operation(TCPRelease, mTCPStream);	STCPParamBlock& operationPB = operation.GetParamBlock();	if (mTCPStream)		operation.Run();	if (mListenQueue) {		delete mListenQueue;		mListenQueue = nil;	}	mLocalAddress->SetHostPort(0);	mEndpointState = T_UNBND;	mTCPStream = nil;}// ---------------------------------------------------------------------------//		е GetLocalAddress// ---------------------------------------------------------------------------LInternetAddress*LMacTCPTCPEndpoint::GetLocalAddress(){	if ((mLocalAddress->GetIPAddress() == 0) || (mLocalAddress->GetHostPort() == 0)) {		if (mListenQueue) {			mListenQueue->GetALocalAddress(*mLocalAddress);		} else {			LInternetMapper * theMapper = UNetworkFactory::CreateInternetMapper();			LInternetAddress* tempAddress;			try {				tempAddress = theMapper->GetLocalAddress();				mLocalAddress->SetIPAddress(tempAddress->GetIPAddress());			} catch(...) {			}			delete theMapper;			delete tempAddress;		}	}	return new LInternetAddress(*mLocalAddress);}// ===========================================================================#pragma mark -#pragma mark ее connection establishment// ---------------------------------------------------------------------------//		е Connect// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::Connect(	LInternetAddress&	inRemoteAddress,	UInt32				inTimeoutSeconds){	if (inTimeoutSeconds == 0)		inTimeoutSeconds = Timeout_None;	mReceivedDisconnect = 0;	// Attempt a connection.	UInt32 remoteAddress = inRemoteAddress.GetIPAddress();	UInt16 remotePort = inRemoteAddress.GetHostPort();	// First, make sure a stream exists. Create it if not.	if (!mTCPStream) {		CreateTCPStream();	}	// Now, attempt to open the connection.	StMacTCPOperation operation(TCPActiveOpen, mTCPStream);	STCPParamBlock& operationPB = operation.GetParamBlock();	operationPB.csParam.open.ulpTimeoutValue = (SInt8) ((inTimeoutSeconds == Timeout_None) ? 0 : (SInt8)inTimeoutSeconds);	operationPB.csParam.open.ulpTimeoutAction = (SInt8) ((inTimeoutSeconds == Timeout_None) ? 0 : 1);	operationPB.csParam.open.validityFlags = (SInt8) ((inTimeoutSeconds == Timeout_None) ? 0 : 0xC0);	operationPB.csParam.open.commandTimeoutValue = 0;	operationPB.csParam.open.remoteHost = remoteAddress;	operationPB.csParam.open.remotePort = remotePort;	operationPB.csParam.open.localHost = 0;	operationPB.csParam.open.localPort = mLocalAddress->GetHostPort();	operationPB.csParam.open.tosFlags = 0;	operationPB.csParam.open.precedence = 0;	operationPB.csParam.open.dontFrag = 0;	operationPB.csParam.open.timeToLive = 0;	operationPB.csParam.open.security = 0;	operationPB.csParam.open.optionCnt = 0;	operation.Run();	// Open succeeded. Pull remote host information out of param block.	mLocalAddress->SetIPAddress(operationPB.csParam.open.localHost);	mLocalAddress->SetHostPort(operationPB.csParam.open.localPort);	mRemoteAddress->SetIPAddress(operationPB.csParam.open.remoteHost);	mRemoteAddress->SetHostPort(operationPB.csParam.open.remotePort);	mEndpointState = T_DATAXFER;}// ---------------------------------------------------------------------------//		е Disconnect// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::Disconnect(){	AbortiveDisconnect();}// ---------------------------------------------------------------------------//		е SendDisconnect// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::SendDisconnect(){	if (mReceivedDisconnect != 0) {		AbortiveDisconnect();		return;	}	switch (mEndpointState) {		case T_INCON:		case T_OUTCON:			if (mTCPStream != nil)				break;			// else				// fall thru;		case T_UNINIT:		case T_UNBND:		case T_IDLE:			Throw_(kOTOutStateErr);			return;		case T_OUTREL:			Throw_(kOTOutStateErr);			return;	}	if (!mAckSends && mSendQueue) {		while(mSendQueue->IsBusy())			LThread::Yield();	}	mEndpointState = T_OUTREL;	if (mSendQueue) {		mSendQueue->KillQueue();		mSendQueue = nil;	}	StMacTCPOperation operation(TCPClose, mTCPStream);	STCPParamBlock& operationPB = operation.GetParamBlock();	operationPB.csParam.close.ulpTimeoutValue = 0;	operationPB.csParam.close.ulpTimeoutAction = 0;	operationPB.csParam.close.validityFlags = 0;	//NOTE: When AsyncRun completes this TCPClose returns a TCP_NONEVENT	//		code that does not propagate out of the endpoint.	//		When the remote machine issues its own close	//		you will then get a T_ORDREL. This is done to simmulate	//		how OT handles this situation.	operation.AsyncRun(this, TCP_NONEVENT);}// ---------------------------------------------------------------------------//		е AbortiveDisconnect// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::AbortiveDisconnect(){	if (mSendQueue) {		mSendQueue->KillQueue();		mSendQueue = nil;	}	StMacTCPOperation operation(TCPAbort, mTCPStream);	STCPParamBlock& operationPB = operation.GetParamBlock();	operationPB.csParam.close.ulpTimeoutValue = 0;	operationPB.csParam.close.ulpTimeoutAction = 0;	operationPB.csParam.close.validityFlags = 0;	mEndpointState = T_OUTREL;	operation.Run();	mEndpointState = T_IDLE;}// ---------------------------------------------------------------------------//		е AcceptRemoteDisconnect// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::AcceptRemoteDisconnect(){	//Do nothing here and let the user call Disconnect() when done sending	// This for compatability with OT.}// ---------------------------------------------------------------------------//		е GetRemoteHostAddress// ---------------------------------------------------------------------------LInternetAddress*LMacTCPTCPEndpoint::GetRemoteHostAddress(){	return new LInternetAddress(*mRemoteAddress);}// ---------------------------------------------------------------------------//		е Listen// ---------------------------------------------------------------------------//	Listen to an incoming T_LISTEN event.//	For compatability with OT interfaces... Doesn't do anything for us here since//	we pulled the pBlock when we sent the T_Listen event.voidLMacTCPTCPEndpoint::Listen(){}// ---------------------------------------------------------------------------//		е AcceptIncoming// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::AcceptIncoming(LTCPEndpoint* 	inEndpoint){	if (inEndpoint == nil)		inEndpoint = this;	LMacTCPTCPEndpoint * inMacTCPEndpoint = (LMacTCPTCPEndpoint *)inEndpoint;	StMacTCPListenOperation * listenOp = mListenQueue->GetCompletedOperation();	ThrowIfNil_(listenOp);	STCPParamBlock listenCall = listenOp->GetParamBlock();	LInternetAddress address(*mLocalAddress);	if (inMacTCPEndpoint != this)		inMacTCPEndpoint->Bind(address);	inMacTCPEndpoint->mTCPStream = listenCall.tcpStream;	//Delete the receive buffer already allocated to the endpoint...	//	 it will be using the one associated with the connection stream	::DisposePtr(inMacTCPEndpoint->mReceiveBuffer);	ThrowIfMemError_();	inMacTCPEndpoint->mReceiveBuffer = listenOp->GetBuffer();	//Set remote address in new endpoint	inMacTCPEndpoint->mRemoteAddress->SetIPAddress(listenCall.csParam.open.remoteHost);	inMacTCPEndpoint->mRemoteAddress->SetHostPort(listenCall.csParam.open.remotePort);	//Set endpoint state for new endpoint	inMacTCPEndpoint->mEndpointState = T_DATAXFER;	//Push operation back onto the queue for reuse.	mListenQueue->RecycleFreeOperation(listenOp);	//Start another listener to replace the one we just used	if (inMacTCPEndpoint != this)		mListenQueue->StartListener();	//Add the new endpoint to our list of active endpoints	//LActiveEndpointQueueElem object created in mempool since it might	//	be deleted at interrupt time	mActiveListens.Append(new(*mSharedPool) LActiveEndpointQueueElem(			listenCall.tcpStream,			inMacTCPEndpoint));	//Dont Send T_ACCEPTCOMPLETE message to "main" endpoint	//	Since we eat this on the OT side, we don't send it here.	//	This message can be assumed if the routine completes without an exception	//mMessageQueue->Append(new(*mSharedPool) LNetMessage(T_ACCEPTCOMPLETE, kOTNoError, this));	//Send T_PASSCON message to "responding" endpoint... possibly the same as "main" endpoint	inMacTCPEndpoint->mMessageQueue->Append(new(*(inMacTCPEndpoint->mSharedPool))												LNetMessage(T_PASSCON, kOTNoError, this));}// ---------------------------------------------------------------------------//		е RejectIncoming// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::RejectIncoming(){	OSErr err;	StMacTCPListenOperation * listenOp = mListenQueue->GetCompletedOperation();	ThrowIfNil_(listenOp);	STCPParamBlock listenCall = listenOp->GetParamBlock();	listenCall.csCode = TCPStatus;	err = ::PBControlSync((ParmBlkPtr)&listenCall);	listenCall.csCode = TCPAbort;	err = ::PBControlSync((ParmBlkPtr)&listenCall);	listenCall.csCode = TCPRelease;	err = ::PBControlSync((ParmBlkPtr)&listenCall);	mListenQueue->RecycleFreeOperation(listenOp);}// ===========================================================================#pragma mark -#pragma mark ее data transfer// ---------------------------------------------------------------------------//		е SendData// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::SendData(		void*					inData,		UInt32					inDataSize,		Boolean					inExpedited,		UInt32					inTimeoutSeconds){	if (inDataSize > 65535) {		Throw_(TranslateMacTCPError(invalidLength));		return;	}	if (inTimeoutSeconds == 0)		inTimeoutSeconds = Timeout_None;	if (IsAckingSends() || IsQueuingSends()) {		if (!mSendQueue) {			mSendQueue = new LMacTCPTCPSendQueue(this);			mSendQueue->Resume();		}		char * tempData = (char*)inData;		if (!IsAckingSends()) {			// If we are just queuing the data then			// make a copy that we will delete after it's sent			tempData = new char[inDataSize];			::BlockMoveData(inData, tempData, (SInt32) inDataSize);		}		LMacTCPSendData * sendData = new LMacTCPSendData(tempData, inDataSize, inExpedited);		//Note: mSendQueue->Append() may block the thread if there is a		//		large amount of data already waiting. This is equivalent to the OT side		//		T_GODATA situation in LOpenTptTCPEndpoint::SendData()		mSendQueue->Append(sendData);	} else {		wdsEntry				WDS[2];		StMacTCPOperation operation(TCPSend, mTCPStream);		STCPParamBlock& operationPB = operation.GetParamBlock();		operationPB.csParam.send.ulpTimeoutValue = (SInt8) ((inTimeoutSeconds == Timeout_None) ? 0 : (SInt8)inTimeoutSeconds);		operationPB.csParam.send.ulpTimeoutAction = (SInt8) ((inTimeoutSeconds == Timeout_None) ? 0 : 1);		operationPB.csParam.send.validityFlags = (SInt8) ((inTimeoutSeconds == Timeout_None) ? 0 : 0xC0);		operationPB.csParam.send.pushFlag = 0;		operationPB.csParam.send.urgentFlag = inExpedited;		operationPB.csParam.send.wdsPtr = (char*)WDS;		WDS[0].length = (UInt16) inDataSize;		WDS[0].ptr = (char*)inData;		WDS[1].length = 0;		operation.Run();	}}// ---------------------------------------------------------------------------//		е ReceiveData// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::ReceiveData(		void*					outDataBuffer,		UInt32&					ioDataSize,		Boolean&				outExpedited,		UInt32					inTimeoutSeconds){	if (inTimeoutSeconds == 0)		inTimeoutSeconds = Timeout_None;	switch (mEndpointState) {		case T_DATAXFER:		case T_INREL:		case T_OUTREL:			break;		default:			Throw_(kOTOutStateErr);			return;	}	if (ioDataSize > 65535)		ioDataSize = 65535;	StMacTCPOperation operation(TCPRcv, mTCPStream);	STCPParamBlock& operationPB = operation.GetParamBlock();	operationPB.csParam.receive.commandTimeoutValue =				 (SInt8) ((inTimeoutSeconds == Timeout_None) ? 0 : (SInt8)inTimeoutSeconds);	operationPB.csParam.receive.rcvBuff = (char*)outDataBuffer;	operationPB.csParam.receive.rcvBuffLen = (UInt16) ioDataSize;	try {		operation.Run();	}	catch (const LException& inErr) {		Throw_ (TranslateMacTCPError(inErr.GetErrorCode()));	}	catch (ExceptionCode inErr) {		Throw_ (TranslateMacTCPError(inErr));	}	ioDataSize = operationPB.csParam.receive.rcvBuffLen;	outExpedited = operationPB.csParam.receive.urgentFlag;}// ---------------------------------------------------------------------------//		е GetAmountUnread// ---------------------------------------------------------------------------UInt32LMacTCPTCPEndpoint::GetAmountUnread(){	StMacTCPOperation operation(TCPStatus, mTCPStream);	STCPParamBlock& operationPB = operation.GetParamBlock();	operation.Run();	return operationPB.csParam.status.amtUnreadData;}// ===========================================================================#pragma mark -#pragma mark ее acknowledgement of sent data// ---------------------------------------------------------------------------//		е AckSends// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::AckSends(){	if (mSendQueue && mSendQueue->IsBusy()) {		Throw_(kOTOutStateErr);	}	mAckSends = true;}// ---------------------------------------------------------------------------//		е DontAckSends// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::DontAckSends(){	if (mSendQueue && mSendQueue->IsBusy()) {		Throw_(kOTOutStateErr);	}	mAckSends = false;}// ---------------------------------------------------------------------------//		е IsAckingSends// ---------------------------------------------------------------------------BooleanLMacTCPTCPEndpoint::IsAckingSends(){	return mAckSends;}// ===========================================================================#pragma mark -#pragma mark ее implementation details// ---------------------------------------------------------------------------//		е CreateTCPStream// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::CreateTCPStream(){	StMacTCPOperation operation(TCPCreate, mTCPStream);	STCPParamBlock& operationPB = operation.GetParamBlock();	operationPB.csParam.create.rcvBuff = mReceiveBuffer;	operationPB.csParam.create.rcvBuffLen = mReceiveBufferSize;	operationPB.csParam.create.notifyProc = LMacTCPTCPEndpoint::sTCPNotifyUPP;	operationPB.csParam.create.userDataPtr = (char*)this;	operation.Run();	mTCPStream = operationPB.tcpStream;}// ---------------------------------------------------------------------------//		е TranslateMacTCPError// ---------------------------------------------------------------------------//	Translate known MacTCP error codes to equivalent Open Transport//	error codes.ResultTLMacTCPTCPEndpoint::TranslateMacTCPError(	ResultT inError){	switch (inError) {		case  commandTimeout:			return Timeout_Error;			break;		case  connectionTerminated:		case  connectionDoesntExist:			return Disconnect_Error;			break;		case  connectionClosing:			return OrderlyDisconnect_Error;			break;		default:			return inError;			break;	}}// ---------------------------------------------------------------------------//		е DoCleanup// ---------------------------------------------------------------------------voidLMacTCPTCPEndpoint::DoCleanup(){	delete this;}// ---------------------------------------------------------------------------//		е Int_HandleAsyncEvent// ---------------------------------------------------------------------------//	Called by NotifyProc to handle notifications for this endpoint.//	You will be notified via a Broadcast at primary task time of the event if necessary.//	Warning: This routine will probably be called at interrupt time.voidLMacTCPTCPEndpoint::Int_HandleAsyncEvent(	UInt16		inEventCode,	UInt16		inTermReason,	ICMPReport*	inIcmpMsg,	StreamPtr	inStreamPtr){	try {		//If the stream does not match ours then look for a match...		//	will only happen with endpoints that are "listening"		if (inStreamPtr != mTCPStream)		{			LActiveEndpointQueueElem*	nextElem;			TInterruptSafeListIterator<LActiveEndpointQueueElem*>	iter(mActiveListens);			while (iter.Next(nextElem))			{				if (nextElem->mTCPStream == inStreamPtr)				{					nextElem->mEndpoint->Int_HandleAsyncEvent(inEventCode, inTermReason, inIcmpMsg, inStreamPtr);					// If this is a close then delete it from our list					if (inEventCode == TCPClosing)					{						delete nextElem;					}					return;				}			}		}		else		{			switch (inEventCode) {				case TCPClosing:					mReceivedDisconnect = inEventCode;					if (mEndpointState != T_OUTREL)	//If we are OUTREL then don't change						mEndpointState = T_INREL;					mMessageQueue->Append(new(*mSharedPool) LNetMessage(T_ORDREL, noErr, this));					break;				case TCPTerminate:					mEndpointState = T_IDLE;					mMessageQueue->Append(new(*mSharedPool) LNetMessage(T_DISCONNECTCOMPLETE, noErr, this));					break;				case TCPDataArrival:					mMessageQueue->Append(new(*mSharedPool) LDataArrived(T_DATA, noErr, nil, 0, nil, false, this));					break;				//Presently unused/unrecognized by these classes				case TCPULPTimeout:				case TCPUrgent:				case TCPICMPReceived:					break;				//Just swallow these "Non-Events"...				//	 This mechanism used to hide procedural notification differences between OT and MacTCP				case TCP_NONEVENT:					break;			}		}	} catch(...) {	}}// ---------------------------------------------------------------------------//		е Int_TCPNotifyProc	[static]// ---------------------------------------------------------------------------//	The MacTCP asynchronous notification routine (callback).//	Warning: Will probably be called at interrupt time#pragma profile offpascal voidLMacTCPTCPEndpoint::Int_TCPNotifyProc(	StreamPtr		inStreamPtr,	UInt16			inEventCode,	Ptr				inUserPtr,	UInt16			inTermReason,	ICMPReport*		inIcmpMsg){	LMacTCPTCPEndpoint* theTCPEndpoint = (LMacTCPTCPEndpoint*) inUserPtr;	StSetupGlobals globals(*theTCPEndpoint);	theTCPEndpoint->Int_HandleAsyncEvent(inEventCode, inTermReason, inIcmpMsg, inStreamPtr);}#pragma profile reset// ===========================================================================#pragma mark -LActiveEndpointQueueElem::LActiveEndpointQueueElem(StreamPtr inStream, LMacTCPTCPEndpoint* inEndpoint){	mTCPStream = inStream;	mEndpoint = inEndpoint;}LActiveEndpointQueueElem::~LActiveEndpointQueueElem(){}PP_End_Namespace_PowerPlant