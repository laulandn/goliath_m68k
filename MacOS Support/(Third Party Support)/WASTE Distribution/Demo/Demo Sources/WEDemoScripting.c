/* *	WASTE Demo Project: *	Minimal Scripting Support & Other Miscellaneous Apple Event Stuff * *	Copyright © 1993-2002 Marco Piovanelli *	All Rights Reserved * *	Original C Port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> *//* *	Portions of this file are based on public domain code written by: *	Ed Lai, Apple Computer Inc. */#ifndef __WEDEMO__#include "WEDemo.h"#endifenum{	kMaxPropertyLevel	=	2} ;typedef DescType PropertyArray [ kMaxPropertyLevel ] ;OSStatus GetAEDescDataAsHandle ( const AEDesc * inDesc, Handle * outData ){	Size		dataSize ;	Handle		dataHandle ;	OSStatus	err ;	* outData = NULL ;	/* do nothing if inDesc is a null descriptor */	if ( ( inDesc->descriptorType == typeNull ) || ( inDesc->dataHandle == NULL ) )	{		return noErr ;	}	/* get data size */	dataSize = AEGetDescDataSize ( inDesc ) ;	/* allocate a handle this size */	dataHandle = NewHandle ( dataSize ) ;	if ( ( err = MemError ( ) ) != noErr )	{		goto cleanup ;	}	/* fill the handle */	HLock ( dataHandle ) ;	err = AEGetDescData ( inDesc, *dataHandle, dataSize ) ;	HUnlock ( dataHandle ) ;	* outData = dataHandle ;cleanup :	if ( err != noErr )	{		ForgetHandle ( outData ) ;	}	/* return error code */	return err ;}static Boolean PropertyOf ( const AERecord * inRecord, SInt16 * outPropertyLevel, PropertyArray outProperties ){	AERecord			objectSpecifier ;	DescType			desiredClass ;	AEKeyword			keyForm ;	DescType			propertyTag ;	DescType			actualType ;	Size				actualSize ;	Boolean				retVal = false ;	AEInitializeDescInline ( & objectSpecifier ) ;	/* extract object specifier from specified record */	/* (if inRecord is an Apple event, extract its direct object parameter) */	if ( AEGetParamDesc ( inRecord, ( * outPropertyLevel == 0 ) ? keyDirectObject : keyAEContainer, typeAERecord, & objectSpecifier ) != noErr )	{		goto cleanup ;	}	/* extract desired class */	if ( AEGetParamPtr ( & objectSpecifier, keyAEDesiredClass, typeType, & actualType, & desiredClass, sizeof ( desiredClass ), & actualSize ) != noErr )	{		goto cleanup ;	}	/* extract key form */	if ( AEGetParamPtr ( & objectSpecifier, keyAEKeyForm, typeEnumerated, & actualType, & keyForm, sizeof ( keyForm ), & actualSize ) != noErr )	{		goto cleanup ;	}	/* does this object specifier specify a property? */	if ( ( desiredClass != cProperty ) || ( keyForm != formPropertyID ) )	{		goto cleanup ;	}	/* which property does this object specifier specify? */	if ( AEGetParamPtr ( & objectSpecifier, keyAEKeyData, typeType, & actualType, & propertyTag, sizeof ( propertyTag ), & actualSize ) != noErr )	{		goto cleanup ;	}	/* bump property level and save property tag into property array */	outProperties [ ( * outPropertyLevel ) ++ ] = propertyTag ;	/* property of what? */	if ( AESizeOfParam ( & objectSpecifier, keyAEContainer, & actualType, & actualSize ) == noErr )	{		if ( actualType == typeNull )		{			/* property of application (i.e., null container): we are done */			retVal = true ;		}		else if ( ( actualType == typeObjectSpecifier ) && ( * outPropertyLevel < kMaxPropertyLevel ) )		{			/* property of another object, so do a recursive call */			/* unless we have already reached max recursion depth */			retVal = PropertyOf ( & objectSpecifier, outPropertyLevel, outProperties ) ;		}	}cleanup :	AEDisposeDesc ( & objectSpecifier ) ;	return retVal ;}OSStatus GetContentsOfSelection ( DescType inRequestedType, AEDesc * outDesc, WEReference inText ){	Handle		dataHandle = NULL ;	OSStatus	err;	/* allocate a handle to hold the contents data */	dataHandle = NewHandle ( 0 ) ;	if ( ( err = MemError ( ) ) != noErr )	{		goto cleanup ;	}	/* get the text for the specified range */	if ( ( err = WEStreamRange ( kCurrentSelection, kCurrentSelection, inRequestedType, kNilOptions, dataHandle, inText ) ) != noErr )	{		goto cleanup ;	}	/* create the AE descriptor */	HLock ( dataHandle ) ;	err = AECreateDesc ( inRequestedType, * dataHandle, GetHandleSize ( dataHandle ), outDesc ) ;	HUnlock ( dataHandle ) ;	if ( err != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup:	ForgetHandle ( & dataHandle ) ;	/* return result code */	return err ;}OSStatus SetContentsOfSelection ( const AEDesc * inDesc, WEReference inText ){	TextEncoding	textEncoding = kTextEncodingMultiRun ;	ItemCount		flavorCount = 0 ;	FlavorType		flavorTypes [ 1 ] = { kTypeStyles } ;	Handle			flavorHandles [ 1 ] = { NULL } ;	Handle			textHandle = NULL ;	AEDesc			textDesc ;	AEDesc			stylesDesc ;	AEDesc			recordDesc ;	OSStatus		err ;	AEInitializeDescInline ( & textDesc ) ;	AEInitializeDescInline ( & stylesDesc ) ;	AEInitializeDescInline ( & recordDesc ) ;	/* we expect inDesc type to be one of utxt, TEXT or STXT */	switch ( inDesc -> descriptorType )	{		case typeUnicodeText :		{			if ( ( err = GetAEDescDataAsHandle ( inDesc, & textHandle ) ) != noErr )			{				goto cleanup ;			}			textEncoding = kTextEncodingUnicodeDefault ;			break ;		}		case typeChar :		{			if ( ( err = GetAEDescDataAsHandle ( inDesc, & textHandle ) ) != noErr )			{				goto cleanup ;			}			break ;		}		case typeStyledText :		{			/* coerce the styled text descriptor to an Apple event record */			if ( ( err = AECoerceDesc ( inDesc, typeAERecord, & recordDesc ) ) != noErr )			{				goto cleanup ;			}			/* extract text + styles from the record */			if ( ( err = AEGetParamDesc ( & recordDesc, keyAEText, typeChar, & textDesc ) ) != noErr )			{				goto cleanup ;			}			if ( ( err = AEGetParamDesc ( & recordDesc, keyAEStyles, typeScrapStyles, & stylesDesc ) ) != noErr )			{				goto cleanup ;			}			/* copy descriptor data into handles */			if ( ( err = GetAEDescDataAsHandle ( & textDesc, & textHandle ) ) != noErr )			{				goto cleanup ;			}			if ( ( err = GetAEDescDataAsHandle ( & stylesDesc, & flavorHandles [ 0 ] ) ) != noErr )			{				goto cleanup ;			}			flavorCount ++ ;			break ;		}	}	/* replace the selection with the given text */	HLock ( textHandle ) ;	err = WEPut ( kCurrentSelection, kCurrentSelection, * textHandle, GetHandleSize ( textHandle ), textEncoding, kNilOptions, flavorCount, flavorTypes, flavorHandles, inText ) ;	HUnlock ( textHandle ) ;	/* clear result code */	err = noErr ;cleanup :	AEDisposeDesc ( & recordDesc ) ;	AEDisposeDesc ( & textDesc ) ;	AEDisposeDesc ( & stylesDesc ) ;	ForgetHandle ( & textHandle ) ;	ForgetHandle ( & flavorHandles [ 0 ] ) ;	return err ;}static pascal OSErr HandleGetData ( const AppleEvent * inAE, AppleEvent * outReply, SInt32 inHandlerRefCon ){#pragma unused ( inHandlerRefCon )	WEReference			text = NULL ;	AEDesc				textDesc ;	SInt16				propertyLevel = 0 ;	PropertyArray		properties ;	FlavorType			requestedType ;	DescType			actualType ;	Size				actualSize ;	OSStatus			err ;	AEInitializeDescInline ( & textDesc ) ;	/* the only Apple event object we recognize is "contents of selection" */	err = errAENoSuchObject ;	if ( ! PropertyOf ( inAE, & propertyLevel, properties ) ||		 ( propertyLevel != 2 ) ||		 ( properties [ 0 ] != pContents ) ||		 ( properties [ 1 ] != pSelection ) )	{		goto cleanup ;	}	/* extract the optional parameter keyAERequestedType, if present */	/* The Apple Event Registry says this parameter can be a list */	/* of type tags, but in most cases it is just a single tag, as we assume here. */	if ( AEGetParamPtr ( inAE, keyAERequestedType, typeType, & actualType, & requestedType, sizeof ( requestedType ), & actualSize ) != noErr )	{		requestedType = kTypeText ;		/* return raw TEXT by default */	}	/* make sure there is a document window in front */	err = errAENoUserSelection ;	if ( ( text = GetWindowText ( GetFrontWindowOfClass ( kDocumentWindowClass, false ) ) ) == NULL )	{		goto cleanup ;	}	/* create an Apple event descriptor for the selected text */	if ( ( err = GetContentsOfSelection ( requestedType, & textDesc, text ) ) != noErr )	{		goto cleanup ;	}	/* put the text descriptor into the reply event */	if ( ( err = AEPutParamDesc ( outReply, keyDirectObject, & textDesc ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup:	AEDisposeDesc ( & textDesc ) ;	return err ;}static pascal OSErr HandleSetData ( const AppleEvent * inAE, AppleEvent * outReply, SInt32 inHandlerRefCon ){#pragma unused ( outReply, inHandlerRefCon )	WEReference			text = NULL ;	AEDesc				textDesc ;	SInt16				propertyLevel = 0 ;	PropertyArray		properties ;	OSStatus			err ;	AEInitializeDescInline ( & textDesc ) ;	/* the only Apple event object we recognize is "contents of selection" */	err = errAENoSuchObject ;	if ( ! PropertyOf ( inAE, & propertyLevel, properties ) ||		 ( propertyLevel != 2 ) ||		 ( properties [ 0 ] != pContents ) ||		 ( properties [ 1 ] != pSelection ) )	{		goto cleanup ;	}	/* make sure there is a document window in front */	err = errAENoUserSelection ;	if ( ( text = GetWindowText ( GetFrontWindowOfClass ( kDocumentWindowClass, false ) ) ) == NULL )	{		goto cleanup ;	}	/* extract the required keyAEData parameter */	if ( ( err = AEGetParamDesc ( inAE, keyAEData, typeWildCard, & textDesc ) ) != noErr )	{		goto cleanup ;	}	/* set the contents of the selection */	if ( ( err = SetContentsOfSelection ( & textDesc, text ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	AEDisposeDesc ( & textDesc ) ;	return err ;}OSStatus InstallCoreHandlers ( void ){	OSStatus err ;	if ( ( err = AEInstallEventHandler ( kAECoreSuite, kAEGetData, NewAEEventHandlerUPP ( HandleGetData ), 0L, false ) ) != noErr )	{		return err ;	}	if ( ( err = AEInstallEventHandler ( kAECoreSuite, kAESetData, NewAEEventHandlerUPP ( HandleSetData ), 0L, false ) ) != noErr )	{		return err ;	}	return noErr ;}OSStatus FindProcess	(		OSType					inProcessType,		OSType					inProcessSignature,		ProcessSerialNumber *	outPSN	){	ProcessSerialNumber		psn ;	ProcessInfoRec			info ;	/* start at beginning of process list */	psn . lowLongOfPSN = kNoProcess ;	psn . highLongOfPSN = kNoProcess ;	/* init process info record */	BlockZero ( & info, sizeof ( info ) ) ;	info . processInfoLength = sizeof ( info ) ;	/* walk the process list, looking for the given creator */	while (	( GetNextProcess ( & psn ) == noErr ) &&			( GetProcessInformation ( & psn, & info ) == noErr ) )	{		if ( info . processSignature == inProcessSignature )		{			if ( ( inProcessType == typeWildCard ) || ( inProcessType == info . processType ) )			{				if ( outPSN )				{					* outPSN = psn ;				}				return noErr ;			}		}	}	return procNotFound ;}OSStatus CreatePSNBasedAppleEvent	(		const ProcessSerialNumber *		inTargetPSN,		AEEventClass					inEventClass,		AEEventID						inEventID,		AppleEvent *					outAE	){	AEAddressDesc	targetAddress ;	OSStatus		err ;	AEInitializeDescInline ( outAE ) ;	AEInitializeDescInline ( & targetAddress ) ;	/* create an address descriptor for the target application based on the PSN */	if ( ( err = AECreateDesc ( typeProcessSerialNumber, inTargetPSN,		sizeof ( * inTargetPSN ), & targetAddress ) ) != noErr )	{		goto cleanup ;	}	/* create the Apple event */	if ( ( err = AECreateAppleEvent ( inEventClass, inEventID, & targetAddress,		kAutoGenerateReturnID, kAnyTransactionID, outAE ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	AEDisposeDesc ( & targetAddress ) ;	/* return result code */	return err ;}OSStatus CreateObjectSpecifier	(		const AEDesc *		inContainerDesc,		DescType			inDesiredClass,		AEKeyword			inKeyForm,		const AEDesc *		inKeyData,		AEDesc *			outObjectSpecifier	){	AEDesc			recordDesc ;	OSStatus		err ;	AEInitializeDescInline ( & recordDesc ) ;	/* create a record */	if ( ( err = AECreateList ( NULL, 0, true, & recordDesc ) ) != noErr )	{		goto cleanup ;	}	/* add container field */	if ( ( err = AEPutParamDesc ( & recordDesc, keyAEContainer, inContainerDesc ) ) != noErr )	{		goto cleanup ;	}	/* add desired class field */	if ( ( err = AEPutParamPtr ( & recordDesc, keyAEDesiredClass, typeType,		& inDesiredClass, sizeof ( inDesiredClass ) ) ) != noErr )	{		goto cleanup ;	}	/* add key form field */	if ( ( err = AEPutParamPtr ( & recordDesc, keyAEKeyForm, typeEnumerated,		& inKeyForm, sizeof ( inKeyForm ) ) ) != noErr )	{		goto cleanup ;	}	/* add key data field */	if ( ( err = AEPutParamDesc ( & recordDesc, keyAEKeyData, inKeyData ) ) != noErr )	{		goto cleanup ;	}	/* coerce the AE record to typeObjectSpecifier */	if ( ( err = AECoerceDesc ( & recordDesc, typeObjectSpecifier, outObjectSpecifier ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	AEDisposeDesc ( & recordDesc ) ;	/* return result code */	return err ;}OSStatus CreatePropertySpecifier	(		const AEDesc *		inContainerSpec,		AEKeyword			inPropertyTag,		AEDesc *			outPropertySpecifier	){	AEDesc			propertyDesc ;	OSStatus		err ;	AEInitializeDescInline ( & propertyDesc ) ;	/* create property descriptor */	if ( ( err = AECreateDesc ( typeType, & inPropertyTag, sizeof ( inPropertyTag ), & propertyDesc ) ) != noErr )	{		goto cleanup ;	}	/* create object specifier */	if ( ( err = CreateObjectSpecifier ( inContainerSpec, cProperty,		formPropertyID, & propertyDesc, outPropertySpecifier ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	AEDisposeDesc ( & propertyDesc ) ;	/* return result code */	return err ;}OSStatus CreateFinderObjectSpecifier	(		const FSRef *		inObjectRef,		AEDesc *			outSpecifier	){	Handle			alias = NULL ;	AEDesc			nullDesc ;	AEDesc			aliasDesc ;	OSStatus		err ;	AEInitializeDescInline ( outSpecifier ) ;	AEInitializeDescInline ( & nullDesc ) ;	AEInitializeDescInline ( & aliasDesc ) ;	/* make an alias for the given Finder object */	if ( ( err = FSNewAliasMinimal ( inObjectRef, ( AliasHandle * ) & alias ) ) != noErr )	{		goto cleanup ;	}	/* create an alias descriptor */	HLock ( alias ) ;	err = AECreateDesc ( typeAlias, * alias, GetHandleSize ( alias ), & aliasDesc ) ;	HUnlock ( alias ) ;	if ( err != noErr )	{		goto cleanup ;	}	/* make an object specifier for the thing */	if ( ( err = CreateObjectSpecifier ( & nullDesc, typeWildCard, formAlias, & aliasDesc, outSpecifier ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	ForgetHandle ( & alias ) ;	AEDisposeDesc ( & aliasDesc ) ;	return err ;}OSStatus SendGetDataEvent	(		const ProcessSerialNumber *		inTargetPSN,		const AEDesc *					inObjectSpec,		DescType						inRequestedType,		AEDesc *						outResult	){	AppleEvent		ae ;		/* the "get data" event */	AppleEvent		reply ;		/* the reply event */	OSStatus		err ;	AEInitializeDescInline ( & ae ) ;	AEInitializeDescInline ( & reply ) ;	/* create a "get data" Apple event for the specified process */	if ( ( err = CreatePSNBasedAppleEvent ( inTargetPSN, kAECoreSuite, kAEGetData, & ae ) ) != noErr )	{		goto cleanup ;	}	/* put the given specifier into the direct parameter of the event */	if ( ( err = AEPutParamDesc ( & ae, keyDirectObject, inObjectSpec ) ) != noErr )	{		goto cleanup ;	}	/* add the optional keyAERequestedType parameter to the event (unless we don't care) */	if ( inRequestedType != typeWildCard )	{		if ( ( err = AEPutParamPtr ( & ae, keyAERequestedType, typeType, & inRequestedType, sizeof ( inRequestedType ) ) ) != noErr )		{			goto cleanup ;		}	}	/* send the event and wait for the reply */	if ( ( err = AESend ( & ae, & reply, kAEWaitReply | kAENeverInteract, kAENormalPriority, kAEDefaultTimeout, NULL, NULL ) ) != noErr )	{		goto cleanup ;	}	/* extract direct parameter from the reply */	if ( ( err = AEGetParamDesc ( & reply, keyDirectObject, inRequestedType, outResult ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup:	AEDisposeDesc ( & ae ) ;	AEDisposeDesc ( & reply ) ;	return err ;}OSStatus FSGetObjectIconRect	(		const FSRef *		inObjectRef,		Rect *				outIconRect	){	ProcessSerialNumber		finderPSN ;			/* the Finder's process serial number */	AEDesc					thingSpec ;			/* specifier for inObjectRef */	AEDesc					containerSpec ;		/* specifier for "container of inObjectRef" */	AEDesc					windowSpec ;		/* specifier for "window of container of inObjectRef" */	AEDesc					windowBoundsSpec ;	/* specifier for "bounds of window of container of inObjectRef" */	AEDesc					iconBoundsSpec ;	/* specifier for "bounds of inObjectRef" */	AEDesc					result ;	Rect					windowBounds ;	FSVolumeRefNum			volume ;	FSRef					desktopRef ;	FSRef					parentRef ;	OSStatus				err ;	AEInitializeDescInline ( & thingSpec ) ;	AEInitializeDescInline ( & containerSpec ) ;	AEInitializeDescInline ( & windowSpec ) ;	AEInitializeDescInline ( & windowBoundsSpec ) ;	AEInitializeDescInline ( & iconBoundsSpec )  ;	AEInitializeDescInline ( & result ) ;	/* get the Finder's process serial number */	if ( ( err = FindProcess ( FOUR_CHAR_CODE ( 'FNDR' ), FOUR_CHAR_CODE ( 'MACS' ), & finderPSN ) ) != noErr )	{		goto cleanup ;	}	/* make an object specifier for the given Finder object */	if ( ( err = CreateFinderObjectSpecifier ( inObjectRef, & thingSpec ) ) != noErr )	{		goto cleanup ;	}	/* make an object specifier for "container of" object */	if ( ( err = CreatePropertySpecifier ( & thingSpec, pContainer, & containerSpec ) ) != noErr )	{		goto cleanup ;	}	/* make an object specifier for "window of container of" object */	if ( ( err = CreatePropertySpecifier ( & containerSpec, pWindow, & windowSpec ) ) != noErr )	{		goto cleanup ;	}	/* make an object specifier for "bounds of window of container of" object */	if ( ( err = CreatePropertySpecifier ( & windowSpec, pBounds, & windowBoundsSpec ) ) != noErr )	{		goto cleanup ;	}	/* get bounds of object's enclosing window, in global coordinates */	if ( ( err = SendGetDataEvent ( & finderPSN, & windowBoundsSpec, typeQDRectangle, & result ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEGetDescData ( & result, & windowBounds, sizeof ( windowBounds ) ) ) != noErr )	{		goto cleanup ;	}	AEDisposeDesc ( & result ) ;	/* make an object specifier for "bounds of" object */	if ( ( err = CreatePropertySpecifier ( & thingSpec, pBounds, & iconBoundsSpec ) ) != noErr )	{		goto cleanup ;	}	/* get bounds of object, relative to the enclosing window */	if ( ( err = SendGetDataEvent ( & finderPSN, & iconBoundsSpec, typeQDRectangle, & result ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEGetDescData ( & result, outIconRect, sizeof ( * outIconRect ) ) ) != noErr )	{		goto cleanup ;	}	AEDisposeDesc ( & result ) ;	/* calculate object's rectangle, in global coordinates */	OffsetRect ( outIconRect, windowBounds . left, windowBounds . top ) ;	/* SPECIAL CASE: check if the object is on the desktop */	/* get FSRef of desktop folder */	if ( ( err = FSGetObjectVolume ( inObjectRef, & volume ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = FSFindFolder ( volume, kDesktopFolderType, kDontCreateFolder, & desktopRef ) ) != noErr )	{		goto cleanup ;	}	/* get FSRef of enclosing folder */	if ( ( err = FSGetCatalogInfo ( inObjectRef, kFSCatInfoNone, NULL, NULL, NULL, & parentRef ) ) != noErr )	{		goto cleanup ;	}	/* same folder? */	if ( FSCompareFSRefs ( & desktopRef, & parentRef ) == noErr )	{		/* the object is on the desktop, so the rectangle returned by the Finder is 20 pixels below the actual icon */		OffsetRect ( outIconRect, 0, -20 ) ;	}	/* clear result code */	err = noErr ;cleanup :	AEDisposeDesc ( & thingSpec ) ;	AEDisposeDesc ( & containerSpec ) ;	AEDisposeDesc ( & windowSpec ) ;	AEDisposeDesc ( & windowBoundsSpec ) ;	AEDisposeDesc ( & iconBoundsSpec ) ;	AEDisposeDesc ( & result ) ;	return err ;}