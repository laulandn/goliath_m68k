// ===========================================================================//	UAnimateColorCursor.cp		PowerPlant 2.1		©1997-1999 Metrowerks Inc.// ===========================================================================//	Original Author: John C. Daub////	A set of utility classes to handle COLOR cursor animation (e.g. spinning//	cursors).#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <UAnimateColorCursor.h>#include <UCursor.h>#include <UColorCursor.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <TArrayIterator.h>PP_Begin_Namespace_PowerPlant#pragma mark === UAnimateColorCursor ===//----------------------------------------------------------------------------//	¥ UAnimateColorCursor//----------------------------------------------------------------------------// Basic class for animating a COLOR cursor ('crsr'). Implements things// pretty much the same way as UAnimateCursor, but with of course// obvious differences due to handling color cursors. One additional// difference is that 'crsr's cannot work with 'acur' resources... so// we need a different way to specify what ResIDT's of the 'crsr's to// use.//----------------------------------------------------------------------------//	¥ UAnimateColorCursor						[public]//----------------------------------------------------------------------------//	Parameterized constructor////	inFirstCrsrID is the ResIDT of the first 'crsr' resource to use.//	We then obtain crsr's sequentially for inNumCrsrs.UAnimateColorCursor::UAnimateColorCursor(	ResIDT		inFirstCrsrID,	UInt16		inNumCrsrs,	UInt32		inTickInterval,	UInt32		inInitialDelay ){	mFirstCrsrID = inFirstCrsrID;	mNumCrsrs = inNumCrsrs;	mTickInterval = inTickInterval;	mInitialDelay = inInitialDelay;	mCursorTable = new TArray<CCrsrHandle>;	ThrowIfNil_(mCursorTable);	InitAnimCursor();}//----------------------------------------------------------------------------//	¥ ~UAnimateColorCursor						[public, virtual]//----------------------------------------------------------------------------//	DestructorUAnimateColorCursor::~UAnimateColorCursor(){	Suspend();	if ( mCursorTable != nil ) {		CCrsrHandle theCursor;		TArrayIterator<CCrsrHandle> iterator(*mCursorTable);		while ( iterator.Next(theCursor) ) {			::DisposeCCursor(theCursor);		}		delete mCursorTable;		mCursorTable = nil;	}}//----------------------------------------------------------------------------//	¥ InitAnimCursor							[protected, virtual]//----------------------------------------------------------------------------//	(Almost) private initializervoidUAnimateColorCursor::InitAnimCursor(){	// load up all the cursors	CCrsrHandle theCursor;	for ( SInt16 i = mFirstCrsrID; i < (mFirstCrsrID + mNumCrsrs); ++i ) {		// get the cursor		theCursor = ::GetCCursor(i);		ThrowIfResFail_(theCursor);		// insert it into our table		mCursorTable->InsertItemsAt(1, LArray::index_Last, theCursor);	}	// get ready to go...	::MacShowCursor();	mLastTick = ::TickCount();	mStartTick = mLastTick;	mNextFrameIndex = 1;	// and you call Resume() to actually start animating}//----------------------------------------------------------------------------//	¥ Tick										[public, virtual]//----------------------------------------------------------------------------// Call this to "animate" to the next framevoidUAnimateColorCursor::Tick(){	// time to tick?	UInt32 theTick = ::TickCount();	if ( ((theTick < (mInitialDelay + mStartTick))) ||		(theTick < (mLastTick + mTickInterval)) )		return; // sure isn't.	// get the cursor	CCrsrHandle theCursorH;	mCursorTable->FetchItemAt( mNextFrameIndex, theCursorH );	// set the cursor	::SetCCursor( theCursorH );	// and get ready to display the next cursor	if ( mNextFrameIndex >= mNumCrsrs ) {		mNextFrameIndex = 1;	} else {		mNextFrameIndex += 1;	}	mLastTick = ::TickCount();}//----------------------------------------------------------------------------//	¥ Suspend									[public, virtual]//----------------------------------------------------------------------------//	Stops the cursor from animating. Doesn't destroy it, just temporarily//	suspends animation.voidUAnimateColorCursor::Suspend(	ResIDT		inNewCursorID ){	// set the cursor to something	UColorCursor::SetTheCursor( inNewCursorID );	UCursor::SetInAnimatedCursor(false);}//----------------------------------------------------------------------------//	¥ Resume							[public, virtual]//----------------------------------------------------------------------------//	If you stopped the animation (via Suspend), call this to resume//	animation. Also, when the UAnimateCursor object is first created,//	it does not start animating immediately. You must call this routine//	to start the animation.voidUAnimateColorCursor::Resume(){	// reset everything	Reset();	UCursor::SetInAnimatedCursor(true);}//----------------------------------------------------------------------------//	¥ Reset									[public, virtual]//----------------------------------------------------------------------------//	Reset back to initial valuesvoidUAnimateColorCursor::Reset(){	mLastTick = ::TickCount();	mNextFrameIndex = 1;}#pragma mark === UPeriodicalColorCursor ===//----------------------------------------------------------------------------//	¥ UPeriodicalColorCursor//----------------------------------------------------------------------------//	This is an automated instance of UAnimateColorCursor. Instead of you//	"ticking" on your own, this object will handle it itself via//	PowerPlant's periodical mechanisms. You can utilize this as either//	a repeater or idler.//----------------------------------------------------------------------------//	¥ UPeriodicalColorCursor					[public]//----------------------------------------------------------------------------//	Parameterized constructor.////	Takes the same input parameters as the associated UAnimateColorCursor,//	but also a Boolean if this should be a repeater or idler (is repeater//	by default).UPeriodicalColorCursor::UPeriodicalColorCursor(	ResIDT		inFirstCrsrID,	UInt16		inNumCrsrs,	UInt32		inTickInterval,	UInt32		inInitialDelay,	Boolean		inIsRepeater )		: UAnimateColorCursor(	inFirstCrsrID,								inNumCrsrs,								inTickInterval,								inInitialDelay ){	mIsRepeater = inIsRepeater;}//----------------------------------------------------------------------------//	¥ ~UPeriodicalColorCursor					[public, virtual]//----------------------------------------------------------------------------//	DestructorUPeriodicalColorCursor::~UPeriodicalColorCursor(){	// nothing}//----------------------------------------------------------------------------//	¥ Suspend									[public, virtual]//----------------------------------------------------------------------------//	Call this to temporarily stop the cursor animationvoidUPeriodicalColorCursor::Suspend(	ResIDT	inNewCursorID ){	if ( mIsRepeater ) {		StopRepeating();	} else {		StopIdling();	}	UAnimateColorCursor::Suspend( inNewCursorID );}//----------------------------------------------------------------------------//	¥ Resume									[public, virtual]//----------------------------------------------------------------------------//	Call this to restart cursor animation (after a call to Suspend), and to//	start cursor animation the first time after creating the object.voidUPeriodicalColorCursor::Resume(){	UAnimateColorCursor::Resume();	if ( mIsRepeater ) {		StartRepeating();	} else {		StartIdling();	}}//----------------------------------------------------------------------------//	¥ SpendTime									[protected, virtual]//----------------------------------------------------------------------------//	Using the LPeriodical mechanisms, this is what automates the cursor//	animation.voidUPeriodicalColorCursor::SpendTime(	const EventRecord&	/* inMacEvent */){	Tick();}PP_End_Namespace_PowerPlant