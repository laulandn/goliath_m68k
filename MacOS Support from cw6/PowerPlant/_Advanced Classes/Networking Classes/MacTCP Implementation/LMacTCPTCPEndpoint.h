// ===========================================================================//	LMacTCPTCPEndpoint.h		PowerPlant 2.1		©1996-2000 Metrowerks Inc.// ===========================================================================#ifndef _H_LMacTCPTCPEndpoint#define _H_LMacTCPTCPEndpoint#pragma once#include <LTCPEndpoint.h>#include <LCleanupTask.h>#include <UCallbackUtils.h>#include <LSharedMemoryPool.h>#include <UNetworkMessages.h>#include <LNetMessageQueue.h>#include <MacTCP.h>#if PP_Uses_Pragma_Import	#pragma import on#endifPP_Begin_Namespace_PowerPlantenum { MacTCP_RcvBuffer = 16384 };class LMacTCPTCPSendQueue;class LMacTCPListenQueue;class LActiveEndpointQueueElem;// ===========================================================================//		¥ LMacTCPTCPEndpoint// ===========================================================================//	An implementation of LTCPEndpoint that communicates with MacTCP.//	We recommend that you do not make a subclass of this class.class LMacTCPTCPEndpoint :		public LTCPEndpoint,								public LGlobalsContext,								public LCleanupTask{public:							LMacTCPTCPEndpoint(UInt32		inReceiveBufferSize = MacTCP_RcvBuffer);	virtual					~LMacTCPTCPEndpoint();	//Basic Endpoint Operations	virtual void				Bind(										LInternetAddress&		inLocalAddress,										UInt32					inListenQueueSize = 0,										Boolean					inReusePort = true);	virtual void				Unbind();	//Basic TCP Endpoint Operations	virtual void				Connect(										LInternetAddress&		inRemoteAddress,										UInt32					inTimeoutSeconds = Timeout_None);	virtual void				SendDisconnect();	virtual void				Disconnect();	virtual void				AbortiveDisconnect();	virtual void				AcceptRemoteDisconnect();		// passive connections (servers)	virtual void				Listen();	virtual void				AcceptIncoming(LTCPEndpoint* 	inEndpoint);	virtual void				RejectIncoming();		// sending data	virtual void				SendData(										void*					inData,										UInt32					inDataSize,										Boolean					inExpedited = false,										UInt32					inTimeoutSeconds = Timeout_None);		// receiving data	virtual void				ReceiveData(										void*					outDataBuffer,										UInt32&					ioDataSize,										Boolean&				outExpedited,										UInt32					inTimeoutSeconds = Timeout_None);		// receive configuration	virtual UInt32				GetAmountUnread();		// Accessors	virtual EEndpointState		GetState()									{ return (EEndpointState) mEndpointState; }	virtual void				AckSends();	virtual void				DontAckSends();	virtual Boolean				IsAckingSends();	virtual LInternetAddress*	GetLocalAddress();	virtual LInternetAddress*	GetRemoteHostAddress();	virtual void				AbortThreadOperation(LThread * inThread);protected:	void					DoCleanup();	ResultT					TranslateMacTCPError(ResultT inError);	void					CreateTCPStream();	void					Int_HandleAsyncEvent(										UInt16		inEventCode,										UInt16		inTermReason,										ICMPReport*	inIcmpMsg,										StreamPtr	inStreamPtr);	static pascal void		Int_TCPNotifyProc(										StreamPtr		inStreamPtr,										UInt16			inEventCode,										Ptr				inUserPtr,										UInt16			inTermReason,										ICMPReport*		inIcmpMsg);	StreamPtr				mTCPStream;			// pointer to MacTCP stream object	Ptr						mReceiveBuffer;	UInt32					mReceiveBufferSize;	LInternetAddress *		mLocalAddress;	LInternetAddress *		mRemoteAddress;	LNetMessageQueue *		mMessageQueue;	LSharedMemoryPool * 	mSharedPool;	LMacTCPTCPSendQueue *	mSendQueue;	LMacTCPListenQueue *	mListenQueue;	TInterruptSafeList<LActiveEndpointQueueElem*>	mActiveListens;	Boolean					mAckSends;	UInt16					mEndpointState;	UInt16					mReceivedDisconnect;private:	static TCPNotifyUPP		sTCPNotifyUPP;	friend class LMacTCPTCPSendQueue;	friend class LMacTCPListenQueue;	friend class StMacTCPOperation;};// ===========================================================================//		¥ LActiveEndpointQueueElem// ===========================================================================//	Implementation detail. Do not use this structure.class LActiveEndpointQueueElem :	public LInterruptSafeListMember,									public LRMPObject{public:		 				LActiveEndpointQueueElem(StreamPtr inStream, LMacTCPTCPEndpoint* inEndpoint);	virtual				~LActiveEndpointQueueElem() ;	StreamPtr				mTCPStream;		// the stream	LMacTCPTCPEndpoint*		mEndpoint;		// ...and it's endpoint};PP_End_Namespace_PowerPlant#if PP_Uses_Pragma_Import	#pragma import reset#endif#endif