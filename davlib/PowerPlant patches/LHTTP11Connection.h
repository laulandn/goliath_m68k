/*	LHTTP11Connection.h	Copyright (C) 2000 i-drive.com (email: opensource@mail.idrive.com)	This library is free software; you can redistribute it and/or	modify it under the terms of version 2.1 the GNU Lesser General	Public License as published by the Free Software Foundation.	This library is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU	Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public	License along with this library; if not, write to the Free Software	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA*/// ===========================================================================////   Portions of this file are derived from the file LHTTPConnection.h//   by Metrowerks, and are Copyrighted (C) 1996-1999 Metrowerks Inc.//// ===========================================================================/*	LHTTP11Connection is based on LHTTPConnection, and adds the following functionality:		* Persistent connections, with no unnecessary disconnections	* HTTP 1.1 protocol	* support for secure connections via OpenSSL	* To support the above, endpoints may be handled outside the class	* Some cookie support	* support for non-standard methods and extensions	* parse reply to extract headers	* supports cancelling a transaction	* supports redirects, with external caching of redirected connections		bug fixes:	* Remove extra CRLF in SendCommandWithReply()	* Correct adjusting of completedBytes in progress message		Message (handled by LHTTP11Message):	* add Host Tag	* add Cookie tag*/#pragma once#include <LHTTPConnection.h>#include <LMutexSemaphore.h>#include <LCookie.h>#include <string>#include <map>#if PP_Uses_Pragma_Import	#pragma import on#endifPP_Begin_Namespace_PowerPlantextern const SInt16 kHTTPSPort;class LHTTP11Connection : public LHTTPConnection {public:// Methods							LHTTP11Connection (											LThread& 		inThread,											LTCPEndpoint *	inEndPoint = nil,											LCookieList  *  inOutCookieList = nil,											bool			inSecure = false );													virtual void			ResetMembers (void);		virtual void 			Connect(											const PP_STD::string&	inRemoteHost,											SInt16					inRemotePort = 0);	virtual void 			Connect(											ConstStr255Param		inRemoteHost,											SInt16					inRemotePort = 0);		virtual void			Get(									const PP_STD::string&	inRemoteHost,									const PP_STD::string&	inRequest,									LHTTPMessage&			inMessage,									LHTTPResponse&			outResponse,									SInt16					inRemotePort = kHTTPPort);		virtual void			Head(									const PP_STD::string&	inRemoteHost,									const PP_STD::string&	inRequest,									LHTTPMessage&			inMessage,									LHTTPResponse&			outResponse,									SInt16					inRemotePort = kHTTPPort);	virtual void			Post(									const PP_STD::string&	inRemoteHost,									const PP_STD::string&	inRequest,									LHTTPMessage&			inMessage,									LHTTPResponse&			outResponse,									SInt16					inRemotePort = kHTTPPort);	virtual void			Put(									const PP_STD::string&	inRemoteHost,									const PP_STD::string&	inRequest,									LHTTPMessage&			inMessage,									LHTTPResponse&			outResponse,									SInt16					inRemotePort = kHTTPPort);										virtual void			Get(									ConstStr255Param	inRemoteHost,									ConstStr255Param	inRequest,									LHTTPMessage&		inMessage,									LHTTPResponse&		outResponse,									SInt16				inRemotePort = kHTTPPort);		virtual void			Head(									ConstStr255Param	inRemoteHost,									ConstStr255Param	inRequest,									LHTTPMessage&		inMessage,									LHTTPResponse&		outResponse,									SInt16				inRemotePort = kHTTPPort);	virtual void			Post(									ConstStr255Param	inRemoteHost,									ConstStr255Param	inRequest,									LHTTPMessage&		inMessage,									LHTTPResponse&		outResponse,									SInt16				inRemotePort = kHTTPPort);	virtual void			Put(									ConstStr255Param	inRemoteHost,									ConstStr255Param	inRequest,									LHTTPMessage&		inMessage,									LHTTPResponse&		outResponse,									SInt16				inRemotePort = kHTTPPort);	void					SetCancelFlag (const bool *wasCancelled = NULL) {mWasCanceled = wasCancelled;}	static void				SetLoggingStream(									FSSpec *			logStream);			bool			GetWasClosed() {return mWasClosed;};	protected:											// Variables	static const char* 		kHTTP11Version;	static const char* 		kFieldTransferEncoding;	static const char* 		kChunkedTransferEncoding;	virtual void			DoHTTPMethod (											EHTTPMethod				inMethod,											const PP_STD::string&	inRemoteHost,											const PP_STD::string&	inRequest,											LHTTPMessage&			inMessage,											LHTTPResponse&			outResponse,											SInt16					inRemotePort);		virtual void			DoHTTPMethod (											EHTTPMethod			inMethod,											ConstStr255Param	inRemoteHost,											ConstStr255Param	inRequest,											LHTTPMessage&		inMessage,											LHTTPResponse&		outResponse,											SInt16				inRemotePort);		virtual void			DoHTTPMethod (											const char*				inMethod,											const PP_STD::string&	inRemoteHost,											const PP_STD::string&	inRequest,											LHTTPMessage&			inMessage,											LHTTPResponse&			outResponse,											SInt16					inRemotePort);	virtual void			DoHTTPMethod (											const char*				inMethod,											const PP_STD::string&	inRemoteHost,											const PP_STD::string&	inRequest,											LHTTPMessage&			inMessage,											LHTTPResponse&			outResponse,											SInt16					inRemotePort,											SProgressMessage		*progress);	virtual void			SendCommandWithReply (											const char * inString,											LHTTPMessage& inMessage,											LHTTPResponse& outResponse,											SProgressMessage&	inProgressMsg);												virtual void			WaitResponse( LHTTPResponse& outResponse,											SProgressMessage&	inProgressMsg);			void			ReadBuffered( std::string&			inBuffer,											LDynamicBuffer&		target,											UInt32				requested,											SProgressMessage&	inProgressMsg);													UInt32				ReadUntilMatch( std::string& 		inBuffer,											const char* 		inMatch);	virtual void			SendData(									const char*			inData,									UInt32				totalSize,									SProgressMessage&	inProgressMsg);										virtual void			SendData(									LDynamicBuffer *	inBuffer,									SProgressMessage&	inProgressMsg);												void			LogHTTPRequest(											LDynamicBuffer& message,											LHTTPResponse& response);												virtual bool			MethodMayRedirect (const char *inMethod);bool					WasCancelled (void) const {return mWasCanceled ? *mWasCanceled : false;}		LCookieList				*mCookieList;	std::string				mHost;	bool					mHasExternalEndpoint;	const bool*				mWasCanceled;	bool					mIsSecure;	bool					mNoContent;	// Logging	static LStream*			mLoggingStream;	static LMutexSemaphore  mLoggingAccess;	bool					mWasClosed;};PP_End_Namespace_PowerPlant#if PP_Uses_Pragma_Import	#pragma import reset#endif