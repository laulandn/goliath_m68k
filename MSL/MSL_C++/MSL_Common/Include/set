/*  Metrowerks Standard Library  *//*  $Date: 2000/06/09 19:26:18 $  *  $Revision: 1.9.6.3 $  *  $NoKeywords: $  * *		Portions Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//** **  set       // hh 971223 Changed filename from set.h to set **/#ifndef _SET#define _SET#include <mslconfig>#include <tree>#include <functional>#ifndef RC_INVOKED#pragma options align=native#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#if _MSL_FORCE_ENUMS_ALWAYS_INT		#pragma enumsalwaysint on	#else		#pragma enumsalwaysint off	#endif#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT		#pragma bool on	#else		#pragma bool off	#endif#endif#ifndef _MSL_NO_CPP_NAMESPACE	namespace std {#endif// settemplate <class Key, class Compare = less<Key>, class Allocator = allocator<Key> >class set{public:	//  types:	typedef Key                                   key_type;	typedef Key                                   value_type;	typedef Compare                               key_compare;	typedef Compare                               value_compare;	typedef Allocator                             allocator_type;	typedef typename Allocator::reference         reference;	typedef typename Allocator::const_reference   const_reference;	class                                         iterator;	class                                         const_iterator;	typedef typename Allocator::size_type         size_type;	typedef typename Allocator::difference_type   difference_type;	typedef typename Allocator::pointer           pointer;	typedef typename Allocator::const_pointer     const_pointer;	typedef _STD::reverse_iterator<iterator>       reverse_iterator;	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;private:	struct v_compare		: public binary_function<value_type, value_type, bool>	{		v_compare() {}		v_compare(Compare c) : comp(c) {}		bool operator()(const value_type& x, const value_type& y) const		{			return comp(x, y);		}		Compare comp;	};	typedef __tree<value_type, v_compare, allocator_type> tree_type;public:	struct debug_view	{		debug_view* left_;		debug_view* right_;		debug_view* parent_;		value_type data_;	};	friend class iterator;	class iterator		: public _STD::iterator<bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>	{	public:		iterator() {}		const_reference operator * () const {return *i_;}		const_pointer operator -> () const {return i_.operator->();}		iterator& operator ++ () {++i_; return *this;}		iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}		iterator& operator -- () {--i_; return *this;}		iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}		bool operator ==(const iterator& rhs) const {return i_ == rhs.i_;}		bool operator ==(const const_iterator& rhs) const {return const_iterator(*this) == rhs;}		bool operator !=(const iterator& rhs) const {return i_ != rhs.i_;}		bool operator !=(const const_iterator& rhs) const {return  const_iterator(*this) != rhs;}	private:		tree_type::iterator i_;		iterator(const tree_type::iterator& i) : i_(i) {}		operator tree_type::iterator() const {return i_;}		friend class set;		friend class set::const_iterator;	};	friend class const_iterator;	class const_iterator		: public _STD::iterator<bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>	{	public:		const_iterator() {}		const_iterator(const set::iterator& i) : i_(i) {}		const_reference operator * () const {return *i_;}		const_pointer operator -> () const {return i_.operator->();}		const_iterator& operator ++ () {++i_; return *this;}		const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}		const_iterator& operator -- () {--i_; return *this;}		const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}		bool operator ==(const const_iterator& rhs) const {return i_ == rhs.i_;}		bool operator ==(const set::iterator& rhs) const {return *this == const_iterator(rhs);}		bool operator !=(const const_iterator& rhs) const {return i_ != rhs.i_;}		bool operator !=(const set::iterator& rhs) const {return *this != const_iterator(rhs);}	private:		tree_type::const_iterator i_;		const_iterator(const tree_type::const_iterator& i) : i_(i) {}		operator tree_type::const_iterator() const {return i_;}		friend class set;		friend class set::iterator;	};	//  construct/copy/destroy:	         set();	explicit set(const Compare& comp);	         set(const Compare& comp, const Allocator& a);	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <class InputIterator>			inline			set(InputIterator first, InputIterator last)				: tree_(first, last, false, v_compare(), allocator_type())			{			}		template <class InputIterator>			inline			set(InputIterator first, InputIterator last, const Compare& comp)				: tree_(first, last, false, v_compare(comp), allocator_type())			{			}		template <class InputIterator>			inline			set(InputIterator first, InputIterator last, const Compare& comp,				const Allocator& a)				: tree_(first, last, false, v_compare(comp), a)			{			}	#else		set(const_iterator first, const_iterator last, const Compare& comp = Compare(),			const Allocator& a = Allocator());		set(const value_type* first, const value_type* last, const Compare& comp = Compare(),			const Allocator& a = Allocator());	#endif	allocator_type get_allocator() const;	//  iterators:	iterator               begin();	const_iterator         begin() const;	iterator               end();	const_iterator         end() const;	reverse_iterator       rbegin();	const_reverse_iterator rbegin() const;	reverse_iterator       rend();	const_reverse_iterator rend() const;	//  capacity:	bool          empty() const;	size_type     size() const;	size_type     max_size() const;	//  modifiers:	pair<iterator,bool> insert(const value_type& x);	iterator            insert(iterator position, const value_type& x);	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <class InputIterator>			inline			void insert(InputIterator first, InputIterator last)			{				tree_.insert_one(first, last);			}	#else		void insert(const_iterator first, const_iterator last);		void insert(const value_type* first, const value_type* last);	#endif	void      erase(iterator position);	size_type erase(const key_type& x);	void      erase(iterator first, iterator last);	void swap(set<Key,Compare,Allocator>& x);	void clear();	//  observers:	key_compare   key_comp() const;	value_compare value_comp() const;	//  set operations:	iterator  find(const key_type& x) const;	size_type count(const key_type& x) const;	iterator  lower_bound(const key_type& x) const;	iterator  upper_bound(const key_type& x) const;	pair<iterator,iterator> equal_range(const key_type& x) const;private:	tree_type tree_;};template <class Key, class Compare, class Allocator>booloperator==(const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator< (const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator!=(const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator> (const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator>=(const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator<=(const set<Key,Compare,Allocator>& x, const set<Key,Compare,Allocator>& y);//  specialized algorithms:template <class Key, class Compare, class Allocator>voidswap(set<Key,Compare,Allocator>& x, set<Key,Compare,Allocator>& y);// multisettemplate <class Key, class Compare = less<Key>, class Allocator = allocator<Key> >class multiset{public:	//  types:	typedef Key                                   key_type;	typedef Key                                   value_type;	typedef Compare                               key_compare;	typedef Compare                               value_compare;	typedef Allocator                             allocator_type;	typedef typename Allocator::reference         reference;	typedef typename Allocator::const_reference   const_reference;	class                                         iterator;	class                                         const_iterator;	typedef typename Allocator::size_type         size_type;	typedef typename Allocator::difference_type   difference_type;	typedef typename Allocator::pointer           pointer;	typedef typename Allocator::const_pointer     const_pointer;	typedef _STD::reverse_iterator<iterator>       reverse_iterator;	typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;private:	struct v_compare		: public binary_function<value_type, value_type, bool>	{		v_compare() {}		v_compare(Compare c) : comp(c) {}		bool operator()(const value_type& x, const value_type& y) const		{			return comp(x, y);		}		Compare comp;	};	typedef __tree<value_type, v_compare, allocator_type> tree_type;public:	struct debug_view	{		debug_view* left_;		debug_view* right_;		debug_view* parent_;		value_type data_;	};	friend class iterator;	class iterator		: public _STD::iterator<bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>	{	public:		iterator() {}		const_reference operator * () const {return *i_;}		const_pointer operator -> () const {return i_.operator->();}		iterator& operator ++ () {++i_; return *this;}		iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}		iterator& operator -- () {--i_; return *this;}		iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}		bool operator ==(const iterator& rhs) const {return i_ == rhs.i_;}		bool operator ==(const const_iterator& rhs) const {return const_iterator(*this) == rhs;}		bool operator !=(const iterator& rhs) const {return i_ != rhs.i_;}		bool operator !=(const const_iterator& rhs) const {return const_iterator(*this) != rhs;}	private:		tree_type::iterator i_;		iterator(const tree_type::iterator& i) : i_(i) {}		operator tree_type::iterator() const {return i_;}		friend class multiset;		friend class multiset::const_iterator;	};	friend class const_iterator;	class const_iterator		: public _STD::iterator<bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>	{	public:		const_iterator() {}		const_iterator(const multiset::iterator& i) : i_(i) {}		const_reference operator * () const {return *i_;}		const_pointer operator -> () const {return i_.operator->();}		const_iterator& operator ++ () {++i_; return *this;}		const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}		const_iterator& operator -- () {--i_; return *this;}		const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}		bool operator ==(const const_iterator& rhs) const {return i_ == rhs.i_;}		bool operator ==(const multiset::iterator& rhs) const {return *this == const_iterator(rhs);}		bool operator !=(const const_iterator& rhs) const {return i_ != rhs.i_;}		bool operator !=(const multiset::iterator& rhs) const {return *this != const_iterator(rhs);}	private:		tree_type::const_iterator i_;		const_iterator(const tree_type::const_iterator& i) : i_(i) {}		operator tree_type::const_iterator() const {return i_;}		friend class multiset;	};	//  construct/copy/destroy:	         multiset();	explicit multiset(const Compare& comp);	         multiset(const Compare& comp, const Allocator& a);	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <class InputIterator>			inline			multiset(InputIterator first, InputIterator last)				: tree_(first, last, true, v_compare(), allocator_type())			{			}		template <class InputIterator>			inline			multiset(InputIterator first, InputIterator last, const Compare& comp)				: tree_(first, last, true, v_compare(comp), allocator_type())			{			}		template <class InputIterator>			inline			multiset(InputIterator first, InputIterator last, const Compare& comp,				const Allocator& a)				: tree_(first, last, true, v_compare(comp), a)			{			}	#else		multiset(const_iterator first, const_iterator last, const Compare& comp = Compare(),			const Allocator& a = Allocator());		multiset(const value_type* first, const value_type* last, const Compare& comp = Compare(),			const Allocator& a = Allocator());	#endif	allocator_type get_allocator() const;	//  iterators:	iterator               begin();	const_iterator         begin() const;	iterator               end();	const_iterator         end() const;	reverse_iterator       rbegin();	const_reverse_iterator rbegin() const;	reverse_iterator       rend();	const_reverse_iterator rend() const;	//  capacity:	bool          empty() const;	size_type     size() const;	size_type     max_size() const;	//  modifiers:	iterator insert(const value_type& x);	iterator insert(iterator position, const value_type& x);	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <class InputIterator>			inline			void insert(InputIterator first, InputIterator last)			{				tree_.insert_multi(first, last);			}	#else		void insert(const_iterator first, const_iterator last);		void insert(const value_type* first, const value_type* last);	#endif	void      erase(iterator position);	size_type erase(const key_type& x);	void      erase(iterator first, iterator last);	void swap(multiset<Key,Compare,Allocator>& x);	void clear();	//  observers:	key_compare   key_comp() const;	value_compare value_comp() const;	//  set operations:	iterator  find(const key_type& x) const;	size_type count(const key_type& x) const;	iterator  lower_bound(const key_type& x) const;	iterator  upper_bound(const key_type& x) const;	pair<iterator,iterator> equal_range(const key_type& x) const;private:	tree_type tree_;};template <class Key, class Compare, class Allocator>booloperator==(const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator< (const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator!=(const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator> (const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator>=(const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);template <class Key, class Compare, class Allocator>booloperator<=(const multiset<Key,Compare,Allocator>& x, const multiset<Key,Compare,Allocator>& y);//  specialized algorithms:template <class Key, class Compare, class Allocator>voidswap(multiset<Key,Compare,Allocator>& x, multiset<Key,Compare,Allocator>& y);// set implementationtemplate <class Key, class Compare, class Allocator>inlineset<Key, Compare, Allocator>::set()	: tree_(v_compare(), allocator_type()){}template <class Key, class Compare, class Allocator>inlineset<Key, Compare, Allocator>::set(const Compare& comp)	: tree_(v_compare(comp), allocator_type()){}template <class Key, class Compare, class Allocator>inlineset<Key, Compare, Allocator>::set(const Compare& comp, const Allocator& a)	: tree_(v_compare(comp), a){}#ifdef _MSL_NO_MEMBER_TEMPLATE	template <class Key, class Compare, class Allocator>	inline	set<Key, Compare, Allocator>::set(const_iterator first, const_iterator last,		const Compare& comp, const Allocator& a)		: tree_(first, last, false, comp, a)	{	}	template <class Key, class Compare, class Allocator>	inline	set<Key, Compare, Allocator>::set(const value_type* first, const value_type* last,		const Compare& comp, const Allocator& a)		: tree_(first, last, false, comp, a)	{	}#endiftemplate <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::allocator_typeset<Key, Compare, Allocator>::get_allocator() const{	return tree_.get_allocator();}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::iteratorset<Key, Compare, Allocator>::begin(){	return tree_.begin();}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::const_iteratorset<Key, Compare, Allocator>::begin() const{	return tree_.begin();}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::iteratorset<Key, Compare, Allocator>::end(){	return tree_.end();}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::const_iteratorset<Key, Compare, Allocator>::end() const{	return tree_.end();}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::reverse_iteratorset<Key, Compare, Allocator>::rbegin(){	return reverse_iterator(end());}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::const_reverse_iteratorset<Key, Compare, Allocator>::rbegin() const{	return const_reverse_iterator(end());}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::reverse_iteratorset<Key, Compare, Allocator>::rend(){	return reverse_iterator(begin());}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::const_reverse_iteratorset<Key, Compare, Allocator>::rend() const{	return const_reverse_iterator(begin());}template <class Key, class Compare, class Allocator>inlineboolset<Key, Compare, Allocator>::empty() const{	return tree_.empty();}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::size_typeset<Key, Compare, Allocator>::size() const{	return tree_.size();}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::size_typeset<Key, Compare, Allocator>::max_size() const{	return tree_.max_size();}template <class Key, class Compare, class Allocator>inlinepair<set<Key, Compare, Allocator>::iterator, bool>set<Key, Compare, Allocator>::insert(const value_type& x){	pair<tree_type::iterator, bool> result = tree_.insert_one(x);	return pair<iterator, bool>(result.first, result.second);}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::iteratorset<Key, Compare, Allocator>::insert(iterator position, const value_type& x){	return tree_.insert_one(position, x);}#ifdef _MSL_NO_MEMBER_TEMPLATE	template <class Key, class Compare, class Allocator>	inline	void	set<Key, Compare, Allocator>::insert(const_iterator first, const_iterator last)	{		tree_.insert_one(first, last);	}	template <class Key, class Compare, class Allocator>	inline	void	set<Key, Compare, Allocator>::insert(const value_type* first, const value_type* last)	{		tree_.insert_one(first, last);	}#endiftemplate <class Key, class Compare, class Allocator>inlinevoidset<Key, Compare, Allocator>::erase(iterator position){	tree_.erase(position);}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::size_typeset<Key, Compare, Allocator>::erase(const key_type& x){	return tree_.erase_one(x);}template <class Key, class Compare, class Allocator>inlinevoidset<Key, Compare, Allocator>::erase(iterator first, iterator last){	tree_.erase(first, last);}template <class Key, class Compare, class Allocator>inlinevoidset<Key, Compare, Allocator>::swap(set<Key,Compare,Allocator>& x){	tree_.swap(x.tree_);}template <class Key, class Compare, class Allocator>inlinevoidset<Key, Compare, Allocator>::clear(){	tree_.clear();}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::key_compareset<Key, Compare, Allocator>::key_comp() const{	return tree_.value_comp().comp;}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::value_compareset<Key, Compare, Allocator>::value_comp() const{	return tree_.value_comp().comp;}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::iteratorset<Key, Compare, Allocator>::find(const key_type& x) const{	return const_cast<tree_type&>(tree_).find(x);}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::size_typeset<Key, Compare, Allocator>::count(const key_type& x) const{	return tree_.count_one(x);}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::iteratorset<Key, Compare, Allocator>::lower_bound(const key_type& x) const{	return const_cast<tree_type&>(tree_).lower_bound(x);}template <class Key, class Compare, class Allocator>inlinetypename set<Key, Compare, Allocator>::iteratorset<Key, Compare, Allocator>::upper_bound(const key_type& x) const{	return const_cast<tree_type&>(tree_).upper_bound(x);}template <class Key, class Compare, class Allocator>inlinepair<set<Key, Compare, Allocator>::iterator, set<Key, Compare, Allocator>::iterator>set<Key, Compare, Allocator>::equal_range(const key_type& x) const{	pair<tree_type::iterator, tree_type::iterator> result =		const_cast<tree_type&>(tree_).equal_range(x);	return pair<iterator, iterator>(result.first, result.second);}template <class Key, class Compare, class Allocator>inlinebooloperator==(const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y){	return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());}template <class Key, class Compare, class Allocator>inlinebooloperator!=(const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y){	return !(x == y);}template <class Key, class Compare, class Allocator>inlinebooloperator< (const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y){	return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}template <class Key, class Compare, class Allocator>inlinebooloperator> (const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y){	return y < x;}template <class Key, class Compare, class Allocator>inlinebooloperator>=(const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y){	return !(x < y);}template <class Key, class Compare, class Allocator>inlinebooloperator<=(const set<Key, Compare, Allocator>& x, const set<Key, Compare, Allocator>& y){	return !(y < x);}template <class Key, class Compare, class Allocator>inlinevoidswap(set<Key, Compare, Allocator>& x, set<Key, Compare, Allocator>& y){	x.swap(y);}// multiset implementationtemplate <class Key, class Compare, class Allocator>inlinemultiset<Key, Compare, Allocator>::multiset()	: tree_(v_compare(), allocator_type()){}template <class Key, class Compare, class Allocator>inlinemultiset<Key, Compare, Allocator>::multiset(const Compare& comp)	: tree_(v_compare(comp), allocator_type()){}template <class Key, class Compare, class Allocator>inlinemultiset<Key, Compare, Allocator>::multiset(const Compare& comp, const Allocator& a)	: tree_(v_compare(comp), a){}#ifdef _MSL_NO_MEMBER_TEMPLATE	template <class Key, class Compare, class Allocator>	inline	multiset<Key, Compare, Allocator>::multiset(const_iterator first, const_iterator last,		const Compare& comp, const Allocator& a)		: tree_(first, last, true, comp, a)	{	}	template <class Key, class Compare, class Allocator>	inline	multiset<Key, Compare, Allocator>::multiset(const value_type* first, const value_type* last,		const Compare& comp, const Allocator& a)		: tree_(first, last, true, comp, a)	{	}#endiftemplate <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::allocator_typemultiset<Key, Compare, Allocator>::get_allocator() const{	return tree_.get_allocator();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::iteratormultiset<Key, Compare, Allocator>::begin(){	return tree_.begin();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::const_iteratormultiset<Key, Compare, Allocator>::begin() const{	return tree_.begin();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::iteratormultiset<Key, Compare, Allocator>::end(){	return tree_.end();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::const_iteratormultiset<Key, Compare, Allocator>::end() const{	return tree_.end();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::reverse_iteratormultiset<Key, Compare, Allocator>::rbegin(){	return reverse_iterator(end());}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::const_reverse_iteratormultiset<Key, Compare, Allocator>::rbegin() const{	return const_reverse_iterator(end());}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::reverse_iteratormultiset<Key, Compare, Allocator>::rend(){	return reverse_iterator(begin());}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::const_reverse_iteratormultiset<Key, Compare, Allocator>::rend() const{	return const_reverse_iterator(begin());}template <class Key, class Compare, class Allocator>inlineboolmultiset<Key, Compare, Allocator>::empty() const{	return tree_.empty();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::size_typemultiset<Key, Compare, Allocator>::size() const{	return tree_.size();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::size_typemultiset<Key, Compare, Allocator>::max_size() const{	return tree_.max_size();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::iteratormultiset<Key, Compare, Allocator>::insert(const value_type& x){	return tree_.insert_multi(x);}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::iteratormultiset<Key, Compare, Allocator>::insert(iterator position, const value_type& x){	return tree_.insert_multi(position, x);}#ifdef _MSL_NO_MEMBER_TEMPLATE	template <class Key, class Compare, class Allocator>	inline	void	multiset<Key, Compare, Allocator>::insert(const_iterator first, const_iterator last)	{		tree_.insert_multi(first, last);	}	template <class Key, class Compare, class Allocator>	inline	void	multiset<Key, Compare, Allocator>::insert(const value_type* first, const value_type* last)	{		tree_.insert_multi(first, last);	}#endiftemplate <class Key, class Compare, class Allocator>inlinevoidmultiset<Key, Compare, Allocator>::erase(iterator position){	tree_.erase(position);}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::size_typemultiset<Key, Compare, Allocator>::erase(const key_type& x){	return tree_.erase_multi(x);}template <class Key, class Compare, class Allocator>inlinevoidmultiset<Key, Compare, Allocator>::erase(iterator first, iterator last){	tree_.erase(first, last);}template <class Key, class Compare, class Allocator>inlinevoidmultiset<Key, Compare, Allocator>::swap(multiset<Key,Compare,Allocator>& x){	tree_.swap(x.tree_);}template <class Key, class Compare, class Allocator>inlinevoidmultiset<Key, Compare, Allocator>::clear(){	tree_.clear();}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::key_comparemultiset<Key, Compare, Allocator>::key_comp() const{	return tree_.value_comp().comp;}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::value_comparemultiset<Key, Compare, Allocator>::value_comp() const{	return tree_.value_comp().comp;}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::iteratormultiset<Key, Compare, Allocator>::find(const key_type& x) const{	return const_cast<tree_type&>(tree_).find(x);}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::size_typemultiset<Key, Compare, Allocator>::count(const key_type& x) const{	return tree_.count_multi(x);}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::iteratormultiset<Key, Compare, Allocator>::lower_bound(const key_type& x) const{	return const_cast<tree_type&>(tree_).lower_bound(x);}template <class Key, class Compare, class Allocator>inlinetypename multiset<Key, Compare, Allocator>::iteratormultiset<Key, Compare, Allocator>::upper_bound(const key_type& x) const{	return const_cast<tree_type&>(tree_).upper_bound(x);}template <class Key, class Compare, class Allocator>inlinepair<multiset<Key, Compare, Allocator>::iterator, multiset<Key, Compare, Allocator>::iterator>multiset<Key, Compare, Allocator>::equal_range(const key_type& x) const{	pair<tree_type::iterator, tree_type::iterator> result =		const_cast<tree_type&>(tree_).equal_range(x);	return pair<iterator, iterator>(result.first, result.second);}template <class Key, class Compare, class Allocator>inlinebooloperator==(const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y){	return x.size() == y.size() && equal(x.begin(), x.end(), y.begin());}template <class Key, class Compare, class Allocator>inlinebooloperator!=(const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y){	return !(x == y);}template <class Key, class Compare, class Allocator>inlinebooloperator< (const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y){	return lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}template <class Key, class Compare, class Allocator>inlinebooloperator> (const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y){	return y < x;}template <class Key, class Compare, class Allocator>inlinebooloperator>=(const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y){	return !(x < y);}template <class Key, class Compare, class Allocator>inlinebooloperator<=(const multiset<Key, Compare, Allocator>& x, const multiset<Key, Compare, Allocator>& y){	return !(y < x);}template <class Key, class Compare, class Allocator>inlinevoidswap(multiset<Key, Compare, Allocator>& x, multiset<Key, Compare, Allocator>& y){	x.swap(y);}#ifndef _MSL_NO_CPP_NAMESPACE	} // namespace std#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#pragma enumsalwaysint reset#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#pragma bool reset#endif#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endif#pragma options align=reset#endif // RC_INVOKED#endif // _SET// hh 971220 fixed MOD_INCLUDE// hh 971223 Changed filename from set.h to set// hh 971223 Made include guards standard// hh 971223 added alignment wrapper// hh 971230 added RC_INVOKED wrapper// DWA 980305 changed iterator to const_iterator in multiset constructor, hh 980311 checked// hh 981130 Rewrote// hh 991120 Added wrapper around compare function so that empty member optimization can still//           be used in case it is a function pointer.// hh 000130 Renamed from tree.h to tree// hh 000130 Got rid of default arguments involving references