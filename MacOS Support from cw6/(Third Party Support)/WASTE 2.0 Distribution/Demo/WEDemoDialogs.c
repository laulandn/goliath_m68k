/* *	WASTE Demo Project: *	Dialog Utilities * *	Copyright © 1993-2000 Marco Piovanelli *	All Rights Reserved * *	C port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> *///	WASTE Demo #includes#ifndef __WEDEMO__#include "WEDemo.h"#endif//	Mac OS #includes#ifndef __DIALOGS__#include <Dialogs.h>#endif#ifndef __TEXTUTILS__#include <TextUtils.h>#endifstatic pascal Boolean MyStandardDialogFilter( DialogRef dialog, EventRecord *event, SInt16 *item ){	GrafPtr				savePort;	ModalFilterUPP		stdFilter = nil;	Boolean				retval = false;	// set up the port	GetPort( &savePort );	SetPortDialogPort( dialog );	// 	intercept window events directed to windows behind the dialog	if ( ( event->what == updateEvt ) || ( event->what == activateEvt ) )	{		if ( ((WindowRef) event->message) != GetDialogWindow( dialog ) )		{			DoWindowEvent( event );		}	}	// is the default item a pushbutton?	if ( GetDialogItemType( dialog, GetDialogDefaultItem( dialog ) ) == kButtonDialogItem )	{		// yes, so tell the Dialog Manager to care about its outline		SetDialogDefaultItem( dialog, GetDialogDefaultItem( dialog ));	}	// this is something not in the original WASTE Demo App, but in the work that I've done	// on my own projects, I've found it useful and helpful.	// let's also make sure the cancel button can be handled...now, the cancel button	// should be dialog item #2.  So, we get dialog item #2, check if it's a button.	// if it fills these 2 criteria, it's cancel.  Even if the default item and the	// cancel item are the same, still let them both be set this way so whatever keyboard	// keys sthe user presses will be handled properly	// pass the number "2" to GetDialogItemType...don't check for the cancel item (cause tho	// cancel is defined as 2, we're not looking for cancel, we're looking for dialog item #2	// this is just more readable code.	// remember, this assumes that your cancel item will be item #2 (or at least the item	// that you want to use for cancelling is #2), and that there are at least 2 items in	// the dialog to begin with!	if ( GetDialogItemType( dialog, kStdCancelItemIndex ) == kButtonDialogItem )	{		SetDialogCancelItem( dialog, kStdCancelItemIndex );	}	//	call the standard Dialog Manager filter procedure	if ( ( GetStdFilterProc( & stdFilter ) == noErr ) && ( stdFilter != nil ) )	{		retval = CallModalFilterProc( stdFilter, dialog, event, item );	}	//	restore the port	SetPort( savePort );	return retval;}ModalFilterUPP GetMyStandardDialogFilter ( void ){	static ModalFilterUPP sFilterUPP = nil;	if ( sFilterUPP == nil )	{		sFilterUPP = NewModalFilterProc ( MyStandardDialogFilter ) ;	}	return sFilterUPP;}SInt16 GetDialogItemType( DialogRef dialog, SInt16 item ){	SInt16		itemType;	Handle		itemHandle;	Rect		itemRect;	GetDialogItem( dialog, item, &itemType, &itemHandle, &itemRect );	return itemType;}Handle GetDialogItemHandle( DialogRef dialog, SInt16 item ){	SInt16		itemType;	Handle		itemHandle;	Rect		itemRect;	GetDialogItem( dialog, item, &itemType, &itemHandle, &itemRect );	return itemHandle;}void GetDialogItemRect( DialogRef dialog, SInt16 item, Rect *itemRect ){	SInt16		itemType;	Handle		itemHandle;	GetDialogItem( dialog, item, &itemType, &itemHandle, itemRect );}void SetDialogItemProc( DialogRef dialog, SInt16 item, UserItemUPP proc ){	SInt16		itemType;	Handle		itemHandle;	Rect		itemRect;	GetDialogItem( dialog, item, &itemType, &itemHandle, &itemRect );	if ( ( itemType & 0x007F) == userItem )	{		SetDialogItem( dialog, item, itemType, (Handle) proc, &itemRect );	}}void FlashButton( DialogRef dialog, SInt16 item ){	ControlRef	button;	UInt32			finalTicks ;	button = (ControlRef) GetDialogItemHandle( dialog, item );	HiliteControl( button, kControlButtonPart );	Delay( 8, &finalTicks );	HiliteControl( button, kControlNoPart );}void GetEditFieldString ( DialogRef dialog, SInt16 item, Str255 string ){	GetDialogItemText ( GetDialogItemHandle ( dialog, item ), string ) ;}void SetEditFieldString ( DialogRef dialog, SInt16 item, ConstStr255Param string ){	SetDialogItemText ( GetDialogItemHandle ( dialog, item ), string ) ;}void ReplaceParam ( Str255 ioTarget, ConstStr255Param inParam, SInt16 inIndex ){	StringHandle	hCopy = NewString ( ioTarget ) ;	Size			len ;	int				offset ;	inIndex += '^0' ;	for ( offset = 1 ; offset >= 0 ; )	{		offset = Munger ( ( Handle ) hCopy, offset, & inIndex, sizeof ( inIndex ),						& inParam [ 1 ], StrLength ( inParam ) ) ;		len = GetHandleSize ( ( Handle ) hCopy ) - 1 ;		if ( len > 255 )		{			break ;		}		( * hCopy ) [ 0 ] = len ;		BlockMoveData ( * hCopy, ioTarget, StrLength ( * hCopy ) + 1 ) ;	}	DisposeHandle ( ( Handle ) hCopy ) ;}void NumToVersionString ( UInt32 inVersion, Str15 outVersionString ){	static unsigned char	stages [ 3 ] = { 'd', 'a', 'b' } ;	unsigned char *			p = outVersionString ;	int						stage ;	//	special case: a zero version means "version not available"	if ( inVersion == 0 )	{		* ++ p = 'n' ;		* ++ p = '/' ;		* ++ p = 'a' ;	}	else	{		//	major revision		if ( inVersion & 0xF0000000 )		{			* ++ p = ( ( inVersion & 0xF0000000 ) >> 28 ) + '0' ;		}		* ++ p = ( ( inVersion & 0x0F000000 ) >> 24 ) + '0' ;		//	add a dot		* ++ p = '.' ;		//	minor revision		* ++ p = ( ( inVersion & 0x00F00000 ) >> 20 ) + '0' ;		if ( inVersion & 0x000F0000 )		{			* ++ p = '.' ;			* ++ p = ( ( inVersion & 0x000F0000 ) >> 16 ) + '0' ;		}		//	stage		stage = ( ( inVersion & 0x0000FF00 ) >> 13 ) - 1 ;		if ( stage < 3 )		{			* ++ p = stages [ stage ] ;		//	pre-release (development, alpha or beta)			//	revision level (this is a vanilla unsigned integer, it is NOT coded as BCD)			inVersion &= 0x000000FF ;			if ( inVersion / 100 )			{				* ++ p = ( inVersion / 100 ) + '0' ;			}			inVersion %= 100 ;			if ( inVersion / 10 )			{				* ++ p = ( inVersion / 10 ) + '0' ;			}			inVersion %= 10 ;			* ++ p = inVersion + '0' ;		}	}	//	compute length byte	* outVersionString = ( p - outVersionString ) ;}void ErrorAlert ( OSStatus err ){	Cursor		arrow ;	Str255		errString ;	NumToString ( err, errString ) ;	ParamText ( errString, nil, nil, nil ) ;	SetCursor ( GetQDGlobalsArrow ( & arrow ) ) ;	Alert ( kAlertGenError, GetMyStandardDialogFilter ( ) ) ;}