// ===========================================================================//	LCFString.cp				PowerPlant 2.1			 ©2000 Metrowerks Inc.// ===========================================================================#include <LCFString.h>// ---------------------------------------------------------------------------//	¥ LCFString								Default Constructor		  [public]// ---------------------------------------------------------------------------//	Create a mutable CFString////	inMaxLength of zero means an unlimited lengthLCFString::LCFString(	CFIndex			inMaxLength,	CFAllocatorRef	inAllocator){	mMutableStringRef = ::CFStringCreateMutable(inAllocator, inMaxLength);	if (mMutableStringRef == nil) {		// throw std::bad_alloc	}	SetTypeRef(mMutableStringRef);	mMaxLength = inMaxLength;}// ---------------------------------------------------------------------------//	¥ LCFString								Constructor				  [public]// ---------------------------------------------------------------------------//	Create an immutable CFString from a Pascal StringLCFString::LCFString(	ConstStringPtr		inPString,	CFStringEncoding	inEncoding,	CFAllocatorRef		inAllocator){	CFStringRef	ref = ::CFStringCreateWithPascalString(							inAllocator, inPString, inEncoding);	if (ref == nil) {		// throw std::bad_alloc	}	SetTypeRef(ref);	mMutableStringRef = nil;	mMaxLength = GetLength();}// ---------------------------------------------------------------------------//	¥ LCFString								Constructor				  [public]// ---------------------------------------------------------------------------//	Create an immutable CFString from a C StringLCFString::LCFString(	const char*			inCString,	CFStringEncoding	inEncoding,	CFAllocatorRef		inAllocator){	CFStringRef	ref = ::CFStringCreateWithCString(							inAllocator, inCString, inEncoding);	if (ref == nil) {		// throw std::bad_alloc	}	SetTypeRef(ref);	mMutableStringRef = nil;	mMaxLength = GetLength();}// ---------------------------------------------------------------------------//	¥ LCFString								Constructor				  [public]// ---------------------------------------------------------------------------//	Create an immutable LCFString from an existing CFString////	This object retains the CFString. Caller should release it if necessary.LCFString::LCFString(	CFStringRef	inStringRef)	: LCFObject(inStringRef){	mMutableStringRef = nil;	mMaxLength = GetLength();}// ---------------------------------------------------------------------------//	¥ LCFString								Constructor				  [public]// ---------------------------------------------------------------------------//	Create a mutable LCFString from an existing mutable CFString////	This object retains the CFString. Caller should release it if necessary.LCFString::LCFString(	CFMutableStringRef	inStringRef)	: LCFObject(inStringRef){	mMutableStringRef = inStringRef;	mMaxLength = 0;		// ??? No way to get this info}// ---------------------------------------------------------------------------//	¥ LCFString								Copy Constructor		  [public]// ---------------------------------------------------------------------------LCFString::LCFString(	const LCFString&	inSource){	if (inSource.mMutableStringRef != nil) {		mMutableStringRef = ::CFStringCreateMutableCopy(								inSource.GetAllocator(),								inSource.mMaxLength,								inSource.mMutableStringRef);		if (mMutableStringRef == nil) {			// throw std::bad_alloc		}	} else {		CFStringRef	ref = ::CFStringCreateCopy(								inSource.GetAllocator(),								inSource.GetTypeRef());		if (ref == nil) {			// throw std::bad_alloc		}		SetTypeRef(ref);		mMutableStringRef = nil;	}	mMaxLength = inSource.mMaxLength;}// ---------------------------------------------------------------------------//	operator =								Assignment Operator		  [public]// ---------------------------------------------------------------------------LCFString&LCFString::operator = (	const LCFString&	inSource){	LCFString	theCopy(inSource);		// Make stack-based copy	CFStringRef			copyRef			= theCopy.GetTypeRef();	CFMutableStringRef	copyMutableRef	= theCopy.mMutableStringRef;	CFIndex				copyMaxLength	= theCopy.mMaxLength;										// Copy didn't throw. Swap values										// of "this" string with the copy	theCopy.SetTypeRef( GetTypeRef() );	theCopy.mMutableStringRef	= mMutableStringRef;	theCopy.mMaxLength			= mMaxLength;	SetTypeRef(copyRef);	mMutableStringRef	= copyMutableRef;	mMaxLength			= copyMaxLength;										// Now "this" object is a copy of										// the source. theCopy holds "this"										// object's original data, which will										// be destroyed by the destructor										// for the stack-based theCopy object.	return *this;}// ---------------------------------------------------------------------------//	¥ ~LCFString							Destructor				  [public]// ---------------------------------------------------------------------------LCFString::~LCFString(){}// ---------------------------------------------------------------------------//	¥ Append														  [public]// ---------------------------------------------------------------------------voidLCFString::Append(	CFStringRef	inString){	if (mMutableStringRef != nil) {		::CFStringAppend(mMutableStringRef, inString);	} else {		// Error	}}// ---------------------------------------------------------------------------//	¥ Append														  [public]// ---------------------------------------------------------------------------voidLCFString::Append(	const UniChar*	inChars,	CFIndex			inNumChars){	if (mMutableStringRef != nil) {		::CFStringAppendCharacters(mMutableStringRef, inChars, inNumChars);	} else {		// Error	}}// ---------------------------------------------------------------------------//	¥ Append														  [public]// ---------------------------------------------------------------------------voidLCFString::Append(	ConstStringPtr		inPString,	CFStringEncoding	inEncoding){	if (mMutableStringRef != nil) {		::CFStringAppendPascalString(mMutableStringRef, inPString, inEncoding);	} else {		// Error	}}// ---------------------------------------------------------------------------//	¥ Append														  [public]// ---------------------------------------------------------------------------voidLCFString::Append(	const char*			inCString,	CFStringEncoding	inEncoding){	if (mMutableStringRef != nil) {		::CFStringAppendCString(mMutableStringRef, inCString, inEncoding);	} else {		// Error	}}// ---------------------------------------------------------------------------//	¥ Insert														  [public]// ---------------------------------------------------------------------------voidLCFString::Insert(	CFIndex		inLocation,	CFStringRef	inString){	if (mMutableStringRef != nil) {		::CFStringInsert(mMutableStringRef, inLocation, inString);	} else {		// Error	}}// ---------------------------------------------------------------------------//	¥ Delete														  [public]// ---------------------------------------------------------------------------voidLCFString::Delete(	CFRange		inRange){	if (mMutableStringRef != nil) {		::CFStringDelete(mMutableStringRef, inRange);	} else {		// Error	}}// ---------------------------------------------------------------------------//	¥ Replace														  [public]// ---------------------------------------------------------------------------voidLCFString::Replace(	CFRange			inRange,	CFStringRef		inReplacementStr){	if (mMutableStringRef != nil) {		::CFStringReplace(mMutableStringRef, inRange, inReplacementStr);	} else {		// Error	}}// ---------------------------------------------------------------------------//	¥ ReplaceAll													  [public]// ---------------------------------------------------------------------------voidLCFString::ReplaceAll(	CFStringRef		inReplacementStr){	if (mMutableStringRef != nil) {		::CFStringReplaceAll(mMutableStringRef, inReplacementStr);	} else {		// Error	}}