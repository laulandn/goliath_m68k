/* *	WASTE Demo Project: *	Printing * *	Copyright © 1993-2002 Marco Piovanelli *	All Rights Reserved * *	Original C Port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> *//* WASTE Demo #includes */#include "WEDemo.h"static void ValidateMargins	(		const Rect *		inPaperRect,		/* paper rectangle */		const Rect *		inMaxPageRect,		/* maximum printable area */		PageMarginRec *		ioMargins			/* page margins */	){	const Fixed			kMinPageWidth = ( 36 << 16 ) ;		/* half inch */	const Fixed			kMinPageHeight = ( 36 << 16 ) ;		/* half inch */	PageMarginRec		minMargins ;	PageMarginRec		maxMargins ;	/* find the narrowest possible margins allowed by the specified print record */	minMargins.left = ( inMaxPageRect->left - inPaperRect->left ) << 16 ;	minMargins.right = ( inPaperRect->right - inMaxPageRect->right ) << 16 ;	minMargins.top = ( inMaxPageRect->top - inPaperRect->top ) << 16 ;	minMargins.bottom = ( inPaperRect->bottom - inMaxPageRect->bottom ) << 16 ;	/* and the widest possible margins */	maxMargins.left = ( ( ( inPaperRect->right - inPaperRect->left ) << 16 ) - kMinPageWidth ) / 2 ;	maxMargins.top = ( ( ( inPaperRect->bottom - inPaperRect->top ) << 16 ) - kMinPageHeight ) / 2 ;	maxMargins.right = maxMargins.left ;	maxMargins.bottom = maxMargins.top ;	/* make sure the margins aren't too wide or too narrow */	if ( ioMargins->top < minMargins.top )	{		ioMargins->top = minMargins.top ;	}	else if ( ioMargins->top > maxMargins.top )	{		ioMargins->top = maxMargins.top ;	}	if ( ioMargins->bottom < minMargins.bottom )	{		ioMargins->bottom = minMargins.bottom ;	}	else if ( ioMargins->bottom > maxMargins.bottom )	{		ioMargins->bottom = maxMargins.bottom ;	}	if ( ioMargins->left < minMargins.left )	{		ioMargins->left = minMargins.left ;	}	else if ( ioMargins->left > maxMargins.left )	{		ioMargins->left = maxMargins.left ;	}	if ( ioMargins->right < minMargins.right )	{		ioMargins->right = minMargins.right ;	}	else if ( ioMargins->right > maxMargins.right )	{		ioMargins->right = maxMargins.right ;	}}static void CalculatePageRect	(		const Rect *				inPaperRect,		const PageMarginRec *		inPageMargins,		Rect *						outPageRect	){	Rect marginRect ;	/* get page margins rounded to nearest integral values */	marginRect.left = FixRound ( inPageMargins->left ) ;	marginRect.top = FixRound ( inPageMargins->top ) ;	marginRect.right = FixRound ( inPageMargins->right ) ;	marginRect.bottom = FixRound ( inPageMargins->bottom ) ;	/* calculate page rect (the destination rectangle for printing) */	/* based on the paper rect and page margins */	/* all values are expressed in integral PostScript points (1/72 inch) */	outPageRect->left = ( inPaperRect->left + marginRect.left ) ;	outPageRect->top = ( inPaperRect->top + marginRect.top ) ;	outPageRect->right = outPageRect->left + ( ( inPaperRect->right - inPaperRect->left ) - ( marginRect.left + marginRect.right ) ) ;	outPageRect->bottom = outPageRect-> top + ( ( inPaperRect->bottom - inPaperRect->top ) - ( marginRect.top + marginRect.bottom ) ) ;}static void PMRectToRect ( const PMRect * inPMRect, Rect * outRect ){	outRect->left = inPMRect->left ;	outRect->top = inPMRect->top ;	outRect->right = inPMRect->right ;	outRect->bottom = inPMRect->bottom ;}static pascal void PageSetupSheetDone ( PMPrintSession inPrintSession, WindowRef inWindow, Boolean inAccepted ){	Document *			document = GetWindowDocument ( inWindow ) ;	Handle				oldFlattenedPageFormat = NULL ;	Handle				newFlattenedPageFormat = NULL ;	/* sanity checks */	if ( ( document == NULL ) ||		 ( document -> printSession == NULL ) ||		 ( document -> printSession != inPrintSession ) ||		 ( document -> pageFormat == NULL ) )	{		return ;	}	if ( inAccepted )	{		/* flatten the page format so we can keep it around */		if ( PMFlattenPageFormat ( document -> pageFormat, & newFlattenedPageFormat ) != noErr )		{			goto cleanup ;		}		/* get rid of the old page format, if any */		if ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & oldFlattenedPageFormat, document -> text ) == noErr )		{			ForgetHandle ( & oldFlattenedPageFormat ) ;		}		/* associate new flattened page format with WASTE instance */		WESetUserInfo ( kPageFormatTag, ( SInt32 ) newFlattenedPageFormat, document -> text ) ;	}cleanup :	/* release objects */	PMRelease ( document -> pageFormat ) ;	document -> pageFormat = NULL ;	PMRelease ( document -> printSession ) ;	document -> printSession = NULL ;}OSStatus DoPageSetup ( Document * inDocument ){	static PMSheetDoneUPP	sheetDoneUPP = NULL ;	Handle					flattenedPageFormat = NULL ;	Boolean					usingSheets = false ;	Boolean					accepted = false ;	OSStatus				err ;	/* create sheet done UPP the first time through */	if ( ! sheetDoneUPP )	{		sheetDoneUPP = NewPMSheetDoneUPP ( PageSetupSheetDone ) ;	}	/* sanity check: do nothing if another print session is already associated with this document */	if ( inDocument -> printSession )	{		err = kPMObjectInUse ;		goto cleanup ;	}	/* begin a print session */	if ( ( err = PMCreateSession ( & inDocument -> printSession ) ) != noErr )	{		goto cleanup ;	}	/* use sheets if available */	if ( ( err = PMSessionUseSheets ( inDocument -> printSession, inDocument -> window, sheetDoneUPP ) ) == noErr )	{		usingSheets = true ;	}	else if ( err != kPMNotImplemented )	{		goto cleanup ;	}	/* get the PMPageFormat object associated with our WASTE instance, if any */	if ( ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & flattenedPageFormat, inDocument -> text ) == noErr ) && ( flattenedPageFormat != NULL ) )	{		/* pre-existing flattened page format data: unflatten it */		if ( ( err = PMUnflattenPageFormat ( flattenedPageFormat, & inDocument -> pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	else	{		/* no pre-existing page format: create one */		if ( ( err = PMCreatePageFormat ( & inDocument -> pageFormat ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = PMSessionDefaultPageFormat ( inDocument -> printSession, inDocument -> pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	/* display the page setup dialog */	if ( ( err = PMSessionPageSetupDialog ( inDocument -> printSession, inDocument -> pageFormat, & accepted ) ) != noErr )	{		goto cleanup ;	}	/* if we're not using sheets, manually call the sheet done function */	if ( ! usingSheets )	{		PageSetupSheetDone ( inDocument -> printSession, inDocument -> window, accepted ) ;	}	/* clear result code */	err = noErr ;cleanup :	if ( err != noErr )	{		/* release the page format */		if ( inDocument -> pageFormat )		{			PMRelease ( inDocument -> pageFormat ) ;			inDocument -> pageFormat = NULL ;		}		/* close the print session */		if ( inDocument -> printSession )		{			PMRelease ( inDocument -> printSession ) ;			inDocument -> printSession = NULL ;		}	}	/* return result code */	return err ;}static OSStatus PrintText	(		PMPrintSession		inPrintSession,		PMPrintSettings		inPrintSettings,		PMPageFormat		inPageFormat,		PageMarginRec *		ioPageMargins,		WEReference			inText	){	WEPrintOptions			printOptions ;	WEPrintSession			wasteSession = NULL ;	GrafPtr					printPort = NULL ;	PMRect					pmRect ;	Rect					paperRect ;	Rect					printableArea ;	UInt32					firstSelectedPage = 0 ;	UInt32					lastSelectedPage = 0 ;	SInt32					pageIndex ;	SInt32					pageCount ;	OSStatus				err ;	/* get paper rectangle, rounded to nearest integral values */	if ( ( err = PMGetAdjustedPaperRect ( inPageFormat, & pmRect ) ) != noErr )	{		goto cleanup ;	}	PMRectToRect ( & pmRect, & paperRect ) ;	/* get printable page rectangle (actual page rect can't be larger than this) */	if ( ( err = PMGetAdjustedPageRect ( inPageFormat, & pmRect ) ) != noErr )	{		goto cleanup ;	}	PMRectToRect ( & pmRect, & printableArea ) ;	/* validate page margins */	ValidateMargins ( & paperRect, & printableArea, ioPageMargins ) ;	/* zero out the print options record (this is important for future compatibility!) */	BlockZero ( & printOptions, sizeof ( printOptions ) ) ;	/* calculate page rectangle */	CalculatePageRect ( & paperRect, ioPageMargins, & printOptions . pageRect ) ;	/* copy it to a PMRect for PMBeginPage */	pmRect . left = printOptions . pageRect . left ;	pmRect . top = printOptions . pageRect . top ;	pmRect . right = printOptions . pageRect . right ;	pmRect . bottom = printOptions . pageRect . bottom ;	/* create a WASTE print session */	if ( ( err = WENewPrintSession ( & printOptions, inText, & wasteSession ) ) != noErr )	{		goto cleanup ;	}	/* get page count */	pageCount = WECountPages ( wasteSession ) ;	/* get page range selected by the user */	if ( ( err = PMGetFirstPage ( inPrintSettings, & firstSelectedPage ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = PMGetLastPage ( inPrintSettings, & lastSelectedPage ) ) != noErr )	{		goto cleanup ;	}	/* sanity checks */	if ( lastSelectedPage > pageCount )	{		lastSelectedPage = pageCount ;	}	/* begin document */	if ( ( err = PMSessionBeginDocument ( inPrintSession, inPrintSettings, inPageFormat ) ) != noErr )	{		goto cleanup ;	}	/* WASTE page indices are zero-based, while Printing Manager's are one-based */	firstSelectedPage -= 1 ;	lastSelectedPage -= 1 ;	/* page loop */	for ( pageIndex = firstSelectedPage ; pageIndex <= lastSelectedPage ; pageIndex ++ )	{		/* begin page */		if ( ( err = PMSessionBeginPage ( inPrintSession, inPageFormat, & pmRect ) ) != noErr )		{			goto cleanup ;		}		/* get the QuickDraw graphics port associated with the print context */		if ( ( err = PMSessionGetGraphicsContext ( inPrintSession, kPMGraphicsContextQuickdraw, ( void ** ) & printPort ) ) != noErr )		{			goto cleanup ;		}		/* print this page */		if ( ( err = WEPrintPage ( pageIndex, printPort, NULL, wasteSession ) ) != noErr )		{			goto cleanup ;		}		/* end page */		if ( ( err = PMSessionEndPage ( inPrintSession ) ) != noErr )		{			goto cleanup ;		}	}	/* end document */	if ( ( err = PMSessionEndDocument ( inPrintSession ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	/* clean up */	if ( wasteSession )	{		WEDisposePrintSession ( wasteSession ) ;		wasteSession = NULL ;	}	/* return result code */	return err ;}static pascal void PrintSheetDone ( PMPrintSession inPrintSession, WindowRef inWindow, Boolean inAccepted ){	Document *				document = GetWindowDocument ( inWindow ) ;	PageMarginRecHandle		hPageMargins = NULL ;	PageMarginRec			pageMargins ;	/* sanity checks */	if ( ( document == NULL ) ||		 ( document -> printSession == NULL ) ||		 ( document -> printSession != inPrintSession ) ||		 ( document -> pageFormat == NULL ) ||		 ( document -> printSettings == NULL ) )	{		return ;	}	/* get the page margins record associated with our WASTE instance */	if ( WEGetUserInfo ( kPageMarginsTag, ( SInt32 * ) & hPageMargins, document -> text ) == noErr )	{		pageMargins = ** hPageMargins ;		if ( inAccepted )		{			PrintText ( document -> printSession, document -> printSettings, document -> pageFormat, & pageMargins, document -> text ) ;		}	}	/* release objects */	PMRelease ( document -> pageFormat ) ;	document -> pageFormat = NULL ;	PMRelease ( document -> printSettings ) ;	document -> printSettings = NULL ;	PMRelease ( document -> printSession ) ;	document -> printSession = NULL ;}OSStatus DoPrint ( Document * inDocument ){	static PMSheetDoneUPP	sheetDoneUPP = NULL ;	Handle					flattenedPageFormat = NULL ;	PMPrintSession			printSession = NULL ;	PMPageFormat			pageFormat = NULL ;	PMPrintSettings			printSettings = NULL ;	Boolean					usingSheets = false ;	Boolean					accepted = false ;	OSStatus				err ;	/* create sheet done UPP the first time through */	if ( ! sheetDoneUPP )	{		sheetDoneUPP = NewPMSheetDoneUPP ( PrintSheetDone ) ;	}	/* sanity check: do nothing if another print session is already associated with this document */	if ( inDocument -> printSession )	{		err = kPMObjectInUse ;		goto cleanup ;	}	/* start a new print session */	if ( ( err = PMCreateSession ( & inDocument -> printSession ) ) != noErr )	{		goto cleanup ;	}	/* use sheets if available */	if ( ( err = PMSessionUseSheets ( inDocument -> printSession, inDocument -> window, sheetDoneUPP ) ) == noErr )	{		usingSheets = true ;	}	else if ( err != kPMNotImplemented )	{		goto cleanup ;	}	/* get the PMPageFormat object associated with our WASTE instance, if any */	if ( ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & flattenedPageFormat, inDocument -> text ) == noErr ) &&		 ( flattenedPageFormat != NULL ) )	{		/* pre-existing flattened page format data: unflatten it */		if ( ( err = PMUnflattenPageFormat ( flattenedPageFormat, & inDocument -> pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	else	{		/* no pre-existing page format: create one */		if ( ( err = PMCreatePageFormat ( & inDocument -> pageFormat ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = PMSessionDefaultPageFormat ( inDocument -> printSession, inDocument -> pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	/* create a print settings object */	if ( ( err = PMCreatePrintSettings ( & inDocument -> printSettings ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = PMSessionDefaultPrintSettings ( inDocument -> printSession, inDocument -> printSettings ) ) != noErr )	{		goto cleanup ;	}	/* display the print dialog */	if ( ( err = PMSessionPrintDialog ( inDocument -> printSession, inDocument -> printSettings, inDocument -> pageFormat, & accepted ) ) != noErr )	{		goto cleanup ;	}	/* if we're not using sheets, manually call the sheet done function */	if ( ! usingSheets )	{		PrintSheetDone ( inDocument -> printSession, inDocument -> window, accepted ) ;	}	/* clear result code */	err = noErr ;cleanup :	/* clean up */	if ( err != noErr )	{		if ( inDocument -> printSettings )		{			PMRelease ( inDocument -> printSettings ) ;			inDocument -> printSettings = NULL ;		}		if ( inDocument -> pageFormat )		{			PMRelease ( inDocument -> pageFormat ) ;			inDocument -> pageFormat = NULL ;		}		if ( inDocument -> printSession )		{			PMRelease ( inDocument -> printSession ) ;			inDocument -> printSession = NULL ;		}	}	/* return result code */	return err ;}