/*  Metrowerks Standard Library  *//*  $Date: 2000/05/18 20:06:45 $  *  $Revision: 1.6.6.1.6.2 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//* *		Thread.c */#include <cstdlib>#if defined(_MWMT)/* #define _MWMT   the macro _MWMT is defined by the VC++ IDE whenever you link with                the multithreaded runtime.  This enables the prototypes for begin/                endthreadex.  Our IDE doesn't do this so we do it here.  The customer                needs to also have this in their prefix file when including process.h                mf-- 052798             */#define WIN32_LEAN_AND_MEAN#include <windows.h>#include <process.h>	// for _beginthread, _beginthreadex, _endthread, and						// _endthreadex declarations#include "ThreadLocalData.h"static unsigned long WINAPI _ThreadStart(void  *lpThreadParameter);static unsigned long WINAPI _ThreadStartEx(void  *lpThreadParameter);// An internal structure used to pass information from _beginthreadex to// _ThreadStart.typedef struct {	LPVOID mCodeAddress;	// address of either an unsigned (__stdcall *)(void*) 							// or an unsigned (__cdecl *) (void*)	HANDLE mThreadHandle;	LPVOID mParameter;} _ThreadCreationInfo;static unsigned long begin_thread_implementation (        void *inSecurity,        unsigned inStacksize,        void *inCodeAddress,        void *inParameter,        unsigned int inCreationFlags,        unsigned int *inThreadID,		unsigned long __stdcall (*inStartCode)(void*)        )		{	HANDLE threadHandle;	_ThreadCreationInfo * theThreadCreationInfo = 			(_ThreadCreationInfo *)(malloc(sizeof(_ThreadCreationInfo)));		if (!theThreadCreationInfo) {		return 0;	}		theThreadCreationInfo->mCodeAddress = inCodeAddress;				theThreadCreationInfo->mParameter = inParameter;					threadHandle = CreateThread(		inSecurity,								// lpThreadAttributes		inStacksize,							// dwStackSize		inStartCode,							// lpStartAddress		theThreadCreationInfo,					// lpParameter		inCreationFlags | CREATE_SUSPENDED,		// dwCreationFlags		(LPDWORD)inThreadID						// lpThreadId	);	// pass the thread handle value through the special parameter	theThreadCreationInfo->mThreadHandle = threadHandle;		// resume the thread now if the original caller didn't specify that	// it should be suspended	if (!(inCreationFlags & CREATE_SUSPENDED))	{		ResumeThread(threadHandle);	}		return (unsigned long) threadHandle;}unsigned long __cdecl _beginthreadex (        void *inSecurity,        unsigned int inStacksize,        unsigned int (__stdcall *inCodeAddress) (void*) ,        void *inParameter,        unsigned int inCreationFlags,        unsigned int *inThreadID        )		{	return begin_thread_implementation(		inSecurity,		inStacksize,		(void *)inCodeAddress,		inParameter,		inCreationFlags,		inThreadID,		_ThreadStartEx);}VOID __cdecl _endthreadex(UINT inReturnCode){	_DisposeThreadData();		ExitThread(inReturnCode);}unsigned long __cdecl _beginthread(		void (__cdecl *inCodeAddress)(void *),		unsigned int inStackSize,		void *inParameter		){	unsigned int threadID;	return begin_thread_implementation(		NULL,		inStackSize,		(void *)inCodeAddress,		inParameter,		0,		&threadID,		_ThreadStart);}VOID __cdecl _endthread(void){	CloseHandle(_GetThreadLocalData()->thread_handle);	_DisposeThreadData();		ExitThread(0);}// This is the function _beginthreadex uses as the starting address of all// new threads. This does some thread initialization and then calls the // user's code.static unsigned long WINAPI _ThreadStartEx(void *inParameter){	_ThreadCreationInfo * theThreadCreationInfo = (_ThreadCreationInfo *)inParameter;	HANDLE threadHandle = theThreadCreationInfo->mThreadHandle;	LPVOID theUserParameter = theThreadCreationInfo->mParameter;	unsigned int (__stdcall *theUserCode)(void *) = theThreadCreationInfo->mCodeAddress;			// This block was malloc'ed by _beginthreadex and should be free'd here.	free(theThreadCreationInfo);		_InitializeThreadData(threadHandle);		// if the user returns without ending itself, end the thread here	_endthreadex((*theUserCode)(theUserParameter));	return 0;  /* 990827 vss */}// This is the function _beginthread uses as the starting address of all// new threads. This does some thread initialization and then calls the // user's code.static unsigned long WINAPI _ThreadStart(void *inParameter){	_ThreadCreationInfo * theThreadCreationInfo = (_ThreadCreationInfo *)inParameter;	HANDLE threadHandle = theThreadCreationInfo->mThreadHandle;	LPVOID theUserParameter = theThreadCreationInfo->mParameter;	void (__cdecl *theUserCode)(void *) = theThreadCreationInfo->mCodeAddress;		// This block was malloc'ed by _beginthreadex and should be free'd here.	free(theThreadCreationInfo);		_InitializeThreadData(threadHandle);		// if the user returns without ending itself, end the thread here	(*theUserCode)(theUserParameter);	_endthread();	return 0;  /* 990827 vss */}#endif/* Change History:   031098 blc --  made _ThreadStart call _endthreadex if thread returns without exiting   020398  mf --  made _beginthreadex/_endthreadex compatible with microsoft's api.  This                   eliminates the need for process.h in the MSL headers   980313 rjk --  removed syntax error in call to _endthreadex.   980527 mf  --  _begin/endthreadex follow the prototypes in process.h   990301 mf  --  wrapped file w/#if defined(_MWMT) to prevent compilation into single threaded                  lib.   990308 blc --  moved check of _MT to after include of stdlib.h so we could                  correctly pick up the defintion of _MT from ansi_prefix.win32.h   990317 blc --  revised to support _beginthread/_endthread   990827 vss     Added return 0 to _ThreadStart and _ThreadStartEx   000515 cc 	  Fixed #include*/                  