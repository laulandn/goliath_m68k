// ===========================================================================//	LMacTCPUDPSendQueue.cp		PowerPlant 2.1		©1996-1999 Metrowerks Inc.// ===========================================================================////	Queues data for asynchronous style data sending for MacTCP. Used primarily//	for OT style acked data transfers which are not native to MacTCP.#include <LMacTCPUDPSendQueue.h>#if PP_Target_Carbon		// MacTCP not supported. Remove this file from Carbon targets	#error "Carbon does not support MacTCP"#endifPP_Begin_Namespace_PowerPlant// ===========================================================================#pragma mark === LMacTCPUDPSendQueue ===// ---------------------------------------------------------------------------//		¥ LMacTCPUDPSendQueue// ---------------------------------------------------------------------------//	ConstructorLMacTCPUDPSendQueue::LMacTCPUDPSendQueue(						LMacTCPUDPEndpoint * inEndpoint)	: LSendQueue(inEndpoint){	mMacTCPUDPEndpoint = inEndpoint;	mOperation = new StMacTCPUDPSendOperation(this, mMacTCPUDPEndpoint->mUDPStream);}// ---------------------------------------------------------------------------//		¥ LMacTCPUDPSendQueue// ---------------------------------------------------------------------------//	DestructorLMacTCPUDPSendQueue::~LMacTCPUDPSendQueue(){	delete mOperation;	if (!mEndpointDead)		mMacTCPUDPEndpoint->mSendQueue = nil;}// ---------------------------------------------------------------------------//		¥ NotifyRelease// ---------------------------------------------------------------------------//	Returns the size of the pending data in the queuevoidLMacTCPUDPSendQueue::NotifyRelease(LSendData* inData){	mMacTCPUDPEndpoint->mMessageQueue->Append(new(*(mMacTCPUDPEndpoint->mSharedPool))		LMemoryReleasedMsg(T_MEMORYRELEASED, kOTNoError, inData->mData, inData->mDataSize, mMacTCPUDPEndpoint));}// ---------------------------------------------------------------------------//		¥ Int_InternalSend// ---------------------------------------------------------------------------//	Sends are chained via the completion routine//	NOTE: This routine *might* be called at interrupt timevoidLMacTCPUDPSendQueue::Int_InternalSend(){	if (mEndpointDead)		return;	mBusy = true;	switch (mMacTCPUDPEndpoint->GetState()) {		case T_IDLE:			break;		default:			return;	}	mOperation->SetStream(mMacTCPUDPEndpoint->mUDPStream);	SUDPParamBlock& operationPB = mOperation->GetParamBlock();	TInterruptSafeListIterator<LSendData*> iter(mWaitingQueue);	LSendData* p;	if (iter.Next(p)) {		LMacTCPUDPSendData* data = (LMacTCPUDPSendData*) p;		//Remove from waiting queue		if (!mWaitingQueue.Remove(p))			return;		//Append to pending queue		mPendingQueue.Append(p);		operationPB.csParam.send.remoteHost = data->mRemoteHost.GetIPAddress();		operationPB.csParam.send.remotePort = data->mRemoteHost.GetHostPort();		operationPB.csParam.send.wdsPtr = (char*)mWDS;		operationPB.csParam.send.reserved = 0;		mWDS[0].length = (UInt16) data->mDataSize;		mWDS[0].ptr = (char*)data->mData;		mWDS[1].length = 0;		mOperation->Int_AsyncRun();		//resume the thread if blocked and memory restrictions lifted		if (mThread) {			if (WaitingDataSize() < GetBlockingDataSize()) {				LThread::ThreadAsynchronousResume(mThread);				mThread = nil;			}		}	}}// ===========================================================================#pragma mark -#pragma mark === StMacTCPUDPSendOperation ===// ---------------------------------------------------------------------------//		¥ Constructor// ---------------------------------------------------------------------------StMacTCPUDPSendOperation::StMacTCPUDPSendOperation(								LMacTCPUDPSendQueue * inSendQueue,								StreamPtr	inStreamPtr)	: StMacTCPUDPOperation(UDPWrite, inStreamPtr){	mMacTCPSendQueue = inSendQueue;}// ---------------------------------------------------------------------------//		¥ Destructor// ---------------------------------------------------------------------------StMacTCPUDPSendOperation::~StMacTCPUDPSendOperation(){}// ---------------------------------------------------------------------------//		¥ SetStream// ---------------------------------------------------------------------------voidStMacTCPUDPSendOperation::SetStream(StreamPtr	inStreamPtr){	mUDPParamBlock->udpStream = inStreamPtr;}// ---------------------------------------------------------------------------//		¥ AsyncResume// ---------------------------------------------------------------------------//	NOTE: This routine *might* be called at interrupt timevoidStMacTCPUDPSendOperation::Int_AsyncResume(OSStatus	inResult){	mResult = inResult;	mMacTCPSendQueue->Int_SendComplete();}// ---------------------------------------------------------------------------//		¥ AbortOperation// ---------------------------------------------------------------------------voidStMacTCPUDPSendOperation::AbortOperation(){	Int_AsyncResume(Abort_Error);}// ---------------------------------------------------------------------------//		¥ Int_AsyncRun// ---------------------------------------------------------------------------// Attempt the operation. Check for immediate failure. This Run does not block a thread//	NOTE: This routine *might* be called at interrupt timevoidStMacTCPUDPSendOperation::Int_AsyncRun(){	mUDPParamBlock->csCode = UDPWrite;	mUDPParamBlock->ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();	mUDPParamBlock->ioCompletion = GetCompletionProc();	OSErr result = ::PBControlAsync((ParmBlkPtr)mUDPParamBlock);	if (result)		::DebugStr("\p StMacTCPUDPSendOperation::Int_AsyncRun - PBControlAsync failed");}PP_End_Namespace_PowerPlant