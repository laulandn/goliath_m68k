/* =========================================================================== *	PKCSUtils.cpp * *  This file is part of the DAVLib package *  Copyright (C) 1999-2002  Thomas Bednarzär * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com */#ifndef __PKCSUtils_h__#include "PKCSUtils.h"#endif#include "openssl/ssl.h"#include "openssl/err.h"#include "OpenSSLCWrappers.h"bool GetBMPStringVal(PKCS12 *p12, const char *pass, int passlen, int inBagID, int inAttrId, std::wstring& outData);bool GetBMPStringVal(PKCS12 *p12, const char *pass, int passlen, int inBagID, int inAttrId, std::wstring& outData) {	STACK *asafes, *bags;	int i, bagnid;	PKCS7 *p7;	if (!( asafes = UnpackPKCS12AuthSafes (p12))) 		return false;	for (i = 0; i < sk_num (asafes); i++) {		p7 = (PKCS7 *) sk_value (asafes, i);		bagnid = OBJ_obj2nid (p7->type);		if (bagnid == NID_pkcs7_data) {			bags = UnpackP7Data(p7);		} else if (bagnid == NID_pkcs7_encrypted) {			bags = UnpackEncryptedP7Data(p7, (char*)pass, passlen);		} else continue;		if (!bags) 			return false;				for (int i = 0; i < sk_num (bags); i++) {			PKCS12_SAFEBAG *safeBag =(PKCS12_SAFEBAG*)sk_value (bags, i);			if (M_PKCS12_bag_type(safeBag) == inBagID) {				ASN1_TYPE *atype;				if (!(atype = PKCS12_get_attr(safeBag, inAttrId))) 					continue;				if (atype->type != V_ASN1_BMPSTRING)					break;				outData.assign(reinterpret_cast<std::wstring::value_type*>(atype->value.bmpstring->data),							static_cast<unsigned long>(atype->value.bmpstring->length/2));			    FreeBags(bags);			    return true;			}		}		FreeBags(bags);	}	return false;}bool GetFriendlyName(PKCS12 *p12, const char *pass, int passlen, std::wstring& outFriendlyName) {	STACK *asafes, *bags;	int i, bagnid;	PKCS7 *p7;	if (!( asafes = UnpackPKCS12AuthSafes (p12))) 		return false;	for (i = 0; i < sk_num (asafes); i++) {		p7 = (PKCS7 *) sk_value (asafes, i);		bagnid = OBJ_obj2nid (p7->type);		if (bagnid == NID_pkcs7_data) {			bags = UnpackP7Data(p7);		} else if (bagnid == NID_pkcs7_encrypted) {			bags = UnpackEncryptedP7Data(p7, (char*)pass, passlen);		} else continue;		if (!bags) 			return false;				for (int i = 0; i < sk_num (bags); i++) {			PKCS12_SAFEBAG *safeBag =(PKCS12_SAFEBAG*)sk_value (bags, i);			if (M_PKCS12_bag_type(safeBag) == NID_certBag) {				ASN1_TYPE *atype;				if (!(atype = PKCS12_get_attr(safeBag, NID_friendlyName))) 					continue;				if (atype->type != V_ASN1_BMPSTRING)					break;				outFriendlyName.assign(reinterpret_cast<std::wstring::value_type*>(atype->value.bmpstring->data),							static_cast<unsigned long>(atype->value.bmpstring->length/2));			    FreeBags(bags);			    return true;			}		}		FreeBags(bags);	}	return false;}static void hex_prin(unsigned char *buf, int len, std::string& out){	int i;	char tmp[1];	for (i = 0; i < len; i++) {		sprintf(tmp, "%02X ", buf[i]);		out+=tmp;			}}bool GetLocalKeyID(PKCS12 *p12, const char *pass, int passlen, std::string& outLocalKeyId) {	STACK *asafes, *bags;	int i, bagnid;	PKCS7 *p7;	if (!( asafes = UnpackPKCS12AuthSafes (p12))) 		return false;	for (i = 0; i < sk_num (asafes); i++) {		p7 = (PKCS7 *) sk_value (asafes, i);		bagnid = OBJ_obj2nid (p7->type);		if (bagnid == NID_pkcs7_data) {			bags = UnpackP7Data(p7);		} else if (bagnid == NID_pkcs7_encrypted) {			bags = UnpackEncryptedP7Data(p7, (char*)pass, passlen);		} else continue;		if (!bags) 			return false;				for (int i = 0; i < sk_num (bags); i++) {			PKCS12_SAFEBAG *safeBag =(PKCS12_SAFEBAG*)sk_value (bags, i);			if (M_PKCS12_bag_type(safeBag) == NID_certBag) {				ASN1_TYPE *atype;				if (!(atype = PKCS12_get_attr(safeBag, NID_localKeyID))) 					continue;				if (atype->type != V_ASN1_OCTET_STRING)					break;				hex_prin(atype->value.bit_string->data, atype->value.bit_string->length, outLocalKeyId);			    FreeBags(bags);			    return true;			}		}		FreeBags(bags);	}	return false;}bool DumpAttrs(PKCS12 *p12, const char *pass, int passlen, std::map<std::string, std::string>& outKeyValMap) {	STACK *asafes, *bags;	int i, bagnid, attr_nid;	PKCS7 *p7;	char *value;	char buf[80];	X509_ATTRIBUTE *attr;	ASN1_TYPE *av;	if (!( asafes = UnpackPKCS12AuthSafes (p12))) 		return false;	for (i = 0; i < sk_num (asafes); i++) {		p7 = (PKCS7 *) sk_value (asafes, i);		bagnid = OBJ_obj2nid (p7->type);		if (bagnid == NID_pkcs7_data) {			bags = UnpackP7Data(p7);		} else if (bagnid == NID_pkcs7_encrypted) {			bags = UnpackEncryptedP7Data(p7, (char*)pass, passlen);		} else continue;		if (!bags) 			return false;				for (int i = 0; i < sk_num (bags); i++) {			PKCS12_SAFEBAG *safeBag = (PKCS12_SAFEBAG*)sk_value (bags, i);			STACK_OF(X509_ATTRIBUTE) *attrlst = safeBag->attrib;			if ((!attrlst) || (!sk_X509_ATTRIBUTE_num(attrlst))) {				continue;			}			for(i = 0; i < sk_X509_ATTRIBUTE_num(attrlst); i++) {				attr = sk_X509_ATTRIBUTE_value(attrlst, i);				attr_nid = OBJ_obj2nid(attr->object);								std::string name, val;				bool haveVal = false;								if(attr_nid == NID_undef) {					int len = i2t_ASN1_OBJECT(&buf[0],80, attr->object);					name.append(&buf[0], (unsigned long)len);				} else {					name = OBJ_nid2ln(attr_nid);				}								if(sk_ASN1_TYPE_num(attr->value.set)) {					av = sk_ASN1_TYPE_value(attr->value.set, 0);					switch(av->type) {						case V_ASN1_BMPSTRING:        					value = uni2asc(av->value.bmpstring->data,                                	       av->value.bmpstring->length);							val = value;							free(value);							haveVal = true;						break;						case V_ASN1_OCTET_STRING:							hex_prin(av->value.bit_string->data, av->value.bit_string->length, val);							haveVal = true;						break;						case V_ASN1_BIT_STRING:							hex_prin(av->value.octet_string->data, av->value.octet_string->length, val);							haveVal = true;						break;					}				} 				if (haveVal) {					outKeyValMap[name] = val;				}			}		}		FreeBags(bags);	}	return false;}