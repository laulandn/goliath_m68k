/* =========================================================================== *	CDAVTranscodeUtils.cpp			    * *  This file is part of the DAVLib package *  Copyright (C) 1999-2002  Thomas Bednarzär * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com */#ifndef __CDAVTRANSCODEUTILS_H__#include "CDAVTranscodeUtils.h"#endif#include "ConvertUTF.h"#include <memory>#include <vector>#include <MacErrors.h>#include <Script.h>std::auto_ptr<CDAVTranscodeUtils>	mTranscodeContext;// ---------------------------------------------------------------------------//		¥ GetTranscoderContext// ---------------------------------------------------------------------------//CDAVTranscodeUtils*	CDAVTranscodeUtils::GetTranscoderContext() {	CDAVTranscodeUtils* ctx = mTranscodeContext.get();	if (!ctx) {		mTranscodeContext = std::auto_ptr<CDAVTranscodeUtils>(new CDAVTranscodeUtils());		ctx = mTranscodeContext.get();	}	return ctx;}// ---------------------------------------------------------------------------//		¥ CDAVTranscodeUtils// ---------------------------------------------------------------------------//CDAVTranscodeUtils::CDAVTranscodeUtils() {}// ---------------------------------------------------------------------------//		¥ ~CDAVTranscodeUtils// ---------------------------------------------------------------------------//CDAVTranscodeUtils::~CDAVTranscodeUtils() {	UnicodeToTextPairList::iterator iter;	for (iter = mUnicodeToTextMappings.begin(); iter != mUnicodeToTextMappings.end(); ++iter) {		::DisposeUnicodeToTextInfo(&(*iter).second);	}		TextToUnicodePairList::iterator iter2;	for (iter2 = mTextToUnicodeMappings.begin(); iter2 != mTextToUnicodeMappings.end(); ++iter2) {		::DisposeTextToUnicodeInfo(&(*iter2).second);	}}// ---------------------------------------------------------------------------//		¥ TranscodeUTF8ToSystemScript// ---------------------------------------------------------------------------//std::string CDAVTranscodeUtils::TranscodeUTF8ToSystemScript(const std::string& inUTF8Str) {	CDAVTranscodeUtils* tCtx = GetTranscoderContext();		std::wstring utf16Str = UTF8to16(inUTF8Str);	UnicodeToTextInfo utti = tCtx->GetUnicodeToTextInfoForEncoding(GetScriptManagerVariable(smKeyScript));	std::vector<char> outputBuf(inUTF8Str.size());	ByteCount processBytes = 0; 	ByteCount outLen = 0; 	OSStatus err = ::ConvertFromUnicodeToText(utti, utf16Str.length()*sizeof(std::wstring::value_type), (const unsigned short*)utf16Str.c_str(),							kUnicodeUseFallbacksMask | kUnicodeLooseMappingsMask,							0, NULL, NULL, NULL,							outputBuf.size(), &processBytes, &outLen,  							(LogicalAddress)&outputBuf[0]);	if (err == noErr || err == kTECUsedFallbacksStatus) {		return std::string( reinterpret_cast<char*>(&outputBuf[0]), outLen );	}	return std::string();}// ---------------------------------------------------------------------------//		¥ TranscodeSystemScriptToUTF8// ---------------------------------------------------------------------------//std::string CDAVTranscodeUtils::TranscodeSystemScriptToUTF8(const std::string& inSysScriptStr) {	CDAVTranscodeUtils* tCtx = GetTranscoderContext();	TextToUnicodeInfo ttui = tCtx->GetTextToUnicodeInfoForEncoding(GetScriptManagerVariable(smKeyScript));	std::vector<UniChar> outputBuf(inSysScriptStr.size());	ByteCount processBytes = 0; 	ByteCount outLen = 0;	OSStatus err = 0;	err = ::ConvertFromTextToUnicode(ttui, inSysScriptStr.length()*sizeof(std::string::value_type), 							(ConstLogicalAddress)inSysScriptStr.c_str(),							kUnicodeUseFallbacksMask | kUnicodeLooseMappingsMask,							0, NULL, NULL, NULL,							outputBuf.size()*sizeof(UniChar), &processBytes, &outLen,  							&outputBuf[0]);	if (err == noErr || err == kTECUsedFallbacksStatus) {		std::wstring utf16str( reinterpret_cast<std::wstring::value_type*>(&outputBuf[0]), outLen/sizeof(UniChar));		return UTF16to8(utf16str);	}	return std::string();}// ---------------------------------------------------------------------------//		¥ GetUnicodeToTextInfoForEncoding// ---------------------------------------------------------------------------//UnicodeToTextInfo CDAVTranscodeUtils::GetUnicodeToTextInfoForEncoding(TextEncoding inEncoding) {	UnicodeToTextPairList::iterator iter;	for (iter = mUnicodeToTextMappings.begin(); iter != mUnicodeToTextMappings.end(); ++iter) {		if (inEncoding == (*iter).first)			return ((*iter).second);	}	UnicodeToTextInfo theInfo;	UnicodeMapping theMapping;	theMapping.unicodeEncoding = kTextEncodingUnicodeDefault;	theMapping.otherEncoding = inEncoding;	theMapping.mappingVersion = kUnicodeUseLatestMapping;		::CreateUnicodeToTextInfo(&theMapping, &theInfo);	mUnicodeToTextMappings.push_back(std::pair<TextEncoding, UnicodeToTextInfo>(inEncoding, theInfo));		return theInfo;}// ---------------------------------------------------------------------------//		¥ GetTextToUnicodeInfoForEnciding// ---------------------------------------------------------------------------//TextToUnicodeInfo CDAVTranscodeUtils::GetTextToUnicodeInfoForEncoding(TextEncoding inEncoding) {	TextToUnicodePairList::iterator iter;	for (iter = mTextToUnicodeMappings.begin(); iter != mTextToUnicodeMappings.end(); ++iter) {		if (inEncoding == (*iter).first)			return ((*iter).second);	}	TextToUnicodeInfo theInfo;	UnicodeMapping theMapping;	theMapping.unicodeEncoding = kTextEncodingUnicodeDefault;	theMapping.otherEncoding = inEncoding;	theMapping.mappingVersion = kUnicodeUseLatestMapping;		::CreateTextToUnicodeInfo(&theMapping, &theInfo);	mTextToUnicodeMappings.push_back(std::pair<TextEncoding, TextToUnicodeInfo>(inEncoding, theInfo));		return theInfo;}// ---------------------------------------------------------------------------//		¥ UTF8to16// ---------------------------------------------------------------------------//std::wstring CDAVTranscodeUtils::UTF8to16(const std::string& utf8) {	if (! utf8.empty()) {		std::vector<std::wstring::value_type> utf16(utf8.size());				UTF16* targetstart = (unsigned short*)&utf16[0];		UTF16* origstart = targetstart;		const UTF8* srcstart = reinterpret_cast<const unsigned char*>(utf8.c_str());		ConvertUTF8toUTF16( &srcstart, 							reinterpret_cast<const unsigned char*>(utf8.c_str() + utf8.size()), 							&targetstart, 							(unsigned short*)&utf16[0] + utf16.size(), 							lenientConversion );		int strSize = targetstart - origstart; 		return std::wstring( &utf16[0], strSize); 	} else { 		return std::wstring(); 	}}// ---------------------------------------------------------------------------------//		¥ UTF16to8// ---------------------------------------------------------------------------------//std::string CDAVTranscodeUtils::UTF16to8(const std::wstring& uni_string) {	// worst case, every character ends up being 4 blips.	if (! uni_string.empty() ) {		std::vector<unsigned char> utf8(uni_string.size() * 4);		UTF8* targetstart = &utf8[0];		UTF8* origstart = targetstart;		const UTF16* srcstart = (const unsigned short*)uni_string.c_str();		ConvertUTF16toUTF8( &srcstart,							(const unsigned short*)uni_string.c_str() + uni_string.size(),							&targetstart,							&utf8[0] + utf8.size(),							lenientConversion );		int strSize = targetstart - origstart;		return std::string( reinterpret_cast<char*>(&utf8[0]), strSize );	} else {		return std::string();	}}