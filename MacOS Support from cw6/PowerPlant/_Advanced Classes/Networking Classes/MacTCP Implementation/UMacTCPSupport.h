// ===========================================================================//	UMacTCPSupport.h			PowerPlant 2.1		©1996-2000 Metrowerks Inc.// ===========================================================================#ifndef _H_UMacTCPSupport#define _H_UMacTCPSupport#pragma once#include <UNetworking.h>#include <PP_Types.h>#include <Devices.h>#include <MacTCP.h>#include <LCleanupTask.h>#include <AddressXlation.h>#include <UCallbackUtils.h>#include <LPeriodical.h>#if PP_Uses_Pragma_Import	#pragma import on#endifPP_Begin_Namespace_PowerPlantclass LReentrantMemoryPool;class LMacTCP_CloseResolver;#pragma mark UMacTCPSupport// ===========================================================================//		¥ UMacTCPSupport// ===========================================================================//	Helpers for MacTCP classes. Keeps global reference to MacTCP//	driver and DNS code segment.class UMacTCPSupport {public:	static Boolean				HasMacTCP();	static SInt16				GetMacTCPRefNum();	static void					OpenMacTCPDriver();private:	static SInt16					sMacTCPRefNum;	static LMacTCP_CloseResolver*	sCloseResolverTask;	friend class LMacTCPInetMapper;};#pragma mark StMacTCPOperation// ===========================================================================//		¥ STCPParamBlock// ===========================================================================//	Extended param block for use by our completion routines.class StMacTCPOperation;class LTCPParamBlockDeleteQueue;class LMacTCPTCPEndpoint;struct STCPParamBlock : public TCPiopb,						public LInterruptSafeListMember {	StMacTCPOperation * mOperation;	LMacTCPTCPEndpoint	*	mEndpoint;	UInt16				mEventCode;};// ===========================================================================//		¥ StMacTCPOperation// ===========================================================================class StMacTCPOperation :	public StAsyncOperation,							public LGlobalsContext {public:							StMacTCPOperation(									SInt16		inOperationCode,									StreamPtr	inStreamPtr);							~StMacTCPOperation();	void					Run();	void					AsyncRun(	LMacTCPTCPEndpoint*	inEndpoint,										UInt16				inEventCode);	inline STCPParamBlock&	GetParamBlock()									{ return *mTCPParamBlock; }	inline TCPIOCompletionUPP GetCompletionProc()									{ return sMacTCPCompletionProc; }	static void				NewTCPParamBlockDeleteQueue();	static void				DeleteTCPParamBlockDeleteQueue();protected:#if TARGET_RT_MAC_CFM	static void				Int_TCPCompletionProc(									STCPParamBlock*	inParamBlock);#else	static void				Int_TCPCompletionProc(									STCPParamBlock*	inParamBlock : __A0);#endif	STCPParamBlock *		mTCPParamBlock;				// parameter blockprivate:	static TCPIOCompletionUPP	sMacTCPCompletionProc;	static LTCPParamBlockDeleteQueue *	sTCPParamBlockDeleteQueue;	friend class LMacTCPTCPEndpoint;	friend class StMacTCPUDPOperation;};#pragma mark LMacTCPDNSOperationclass LDNSOperationDeleteQueue;// ===========================================================================//		¥ LMacTCPDNSOperation// ===========================================================================class LMacTCPDNSOperation :	public StAsyncOperation,								public LGlobalsContext,								public LInterruptSafeListMember {public:							LMacTCPDNSOperation();	virtual					~LMacTCPDNSOperation();	inline ResultUPP		 GetResultProc()									{ return sMacTCPDNSCompletionProc; }	void					WaitForCompletion();	static void				NewDNSOperationDeleteQueue();	static void				DeleteDNSOperationDeleteQueue();protected:	static pascal void		Int_DNSCompletionProc(									hostInfo*	inHostInfoPtr,									Ptr			inUserDataPtr);	static pascal void		Int_DNSCompletionProc2(									returnRec*	inReturnRecPtr,									Ptr			inUserDataPtr);private:	LOperationListMember *	mOperationListMem;	static ResultUPP		sMacTCPDNSCompletionProc;	static UInt16			sMacTCPDNSPendingOperations;	static LDNSOperationDeleteQueue *	sDNSOperationDeleteQueue;	friend class LMacTCP_CloseResolver;};// ===========================================================================#pragma mark StMacTCPUDPOperationclass LMacTCPUDPEndpoint;// ===========================================================================//		¥ SUDPParamBlock// ===========================================================================//	Extended param block for use by our completion routines.class StMacTCPUDPOperation;class LUDPParamBlockDeleteQueue;struct SUDPParamBlock : public UDPiopb,						public LInterruptSafeListMember {	StMacTCPUDPOperation *	mOperation;	LMacTCPUDPEndpoint	*	mEndpoint;};// ===========================================================================//		¥ StMacTCPUDPOperation// ===========================================================================class StMacTCPUDPOperation :	public StAsyncOperation,								public LGlobalsContext {public:							StMacTCPUDPOperation(									SInt16		inOperationCode,									StreamPtr	inStreamPtr);							~StMacTCPUDPOperation();	void					Run();	inline SUDPParamBlock&	GetParamBlock()									{ return *mUDPParamBlock; }	inline UDPIOCompletionUPP GetCompletionProc()									{ return sMacTCPUDPCompletionProc; }	static void				NewUDPParamBlockDeleteQueue();	static void				DeleteUDPParamBlockDeleteQueue();protected:#if TARGET_RT_MAC_CFM	static void				Int_UDPCompletionProc(									SUDPParamBlock*	inParamBlock);#else	static void				Int_UDPCompletionProc(									SUDPParamBlock*	inParamBlock : __A0);#endif	SUDPParamBlock *		mUDPParamBlock;				// parameter blockprivate:	static UDPIOCompletionUPP	sMacTCPUDPCompletionProc;	static LUDPParamBlockDeleteQueue *	sUDPParamBlockDeleteQueue;	friend class LMacTCPUDPEndpoint;	friend class StMacTCPOperation;};// ===========================================================================#pragma mark LMacTCP_CloseResolverclass LMacTCP_CloseResolver : public LCleanupTask {public:							LMacTCP_CloseResolver();	virtual					~LMacTCP_CloseResolver();protected:	virtual void			DoCleanup();	friend class UMacTCPSupport;	friend class LMacTCP_CloseResolver;};// ===========================================================================#pragma mark LTCPParamBlockDeleteQueueclass LTCPParamBlockDeleteQueue :	public LPeriodical,									public LInterruptSafeList{public:				LTCPParamBlockDeleteQueue();	virtual		~LTCPParamBlockDeleteQueue();	void		SpendTime(const EventRecord& inMacEvent);};// ===========================================================================#pragma mark LUDPParamBlockDeleteQueueclass LUDPParamBlockDeleteQueue :	public LPeriodical,									public LInterruptSafeList{public:				LUDPParamBlockDeleteQueue();	virtual		~LUDPParamBlockDeleteQueue();	void		SpendTime(const EventRecord& /* inMacEvent */);};// ===========================================================================#pragma mark LDNSOperationDeleteQueueclass LDNSOperationDeleteQueue :	public LPeriodical,									public LInterruptSafeList{public:				LDNSOperationDeleteQueue();	virtual		~LDNSOperationDeleteQueue();	void		SpendTime(const EventRecord	& /* inMacEvent */);};PP_End_Namespace_PowerPlant#if PP_Uses_Pragma_Import	#pragma import reset#endif#endif