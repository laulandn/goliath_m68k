/* *	File:		CFM68K_SegLoader.c *				©1993-1995 metrowerks Inc. All rights reserved *	Author:		Berardino E. Baratta * *	Content:	Segment loader routine for flat model CFM68K RSEG applications ... * */#include <Assembler.h>#include <CodeFragments.h>#include <Errors.h>#include <Resources.h>/* typedefs taken from linker's structures */typedef struct CFM68KCODEHeader {	//	header of a CFM68K CODE resource	short	version;				//	header version number (FFFD)	short	reserved1;				//	reserved space (set to zero)	long	jtoffset;				//	a5 offset to first jump table entry	long	jtentries;				//	number of jump table entries	long	xvoffset;				//	a5 offset to first xvector entry	long	xventries;				//	number of xvector entries	long	reserved2[5];			//	reserved space (set to zero)	char	code[];					//	the code} CFM68KCODEHeader;/* local prototypes */asm void __segloader(void);/* *	Segment loader routine.  This routine is what the XVector tables are initialized with *	and is the first routine called by CFM.  This version is special in that it can only *	be used with our single segment version.  For this version, CODE 1 is the only CODE *	resource, and we will never allow people to unload/load it, it is preloaded and locked. *	Our LoadSeg/UnloadSeg patches don't really do anything, they just return for a CFM world *	and pass through to the original calls for a segmented world. * *	safe data registers:		d0,d1,d2	volatile registers *	safe address registers:		a0,a1,a2	a0,a1 are volatile registers *	 */asm void __segloader(void){	movea.l		(a1), a5	link		a6, #0xfff8	movem.l		a2/a5, -(sp)					/* check to see that we're in a real CFM68K A5 world */	cmpi.w		#0xfffd, 0x2a(a5)	bne			__loaderror__	/* is this the first time through? */	lea			__firsttime__, a0	cmpi.l		#0, (a0)	bne			__loadxvectors__	/* remind ourselves that we've already patched LoadSeg/UnloadSeg */	move.l		#1, (a0)										/* a0 contains the address of __firsttime__ */__loadxvectors__:	/* load CODE (1) to get A5 offset to xvector table and # of xvectors info */	move.l		#1, -(sp)	move.l		#'CODE', -(sp)	cfmcall		GetResource	movea.l		-12(a6), a5										/* restore our A5 */	move.l		d0, a2											/* save a copy of the Handle's address */	move.l		d0, -(sp)										/* CFM68K applications return pointers in d0 */	tst.b		0x0bb2											/* test SegHiEnable byte */	beq.s		__lockinplace_	cfmcall		HLockHi											/* lock the handle high in the heap */	bra.s		__restoreA5____lockinplace_:	cfmcall		HLock											/* lock the handle in current place in the heap */__restoreA5__:	movea.l		-12(a6), a5										/* restore our A5 */	movea.l		(a2), a0										/* store pointer to CODE(1) */	cmpi.w		#0xfffd, struct(CFM68KCODEHeader.version)(a0)	/* check version number */	bne			__loaderror__	move.l		struct(CFM68KCODEHeader.xventries)(a0), d1		/* d3 stores # of xvectors in table */	move.l		struct(CFM68KCODEHeader.xvoffset)(a0), d0		/* d0 stores offset to xvector table */	add.l		#0x20, d0										/* compensate for 32 bytes of reserved space */	movea.l		a5, a1											/* put a5's address into a1 */	add.l		d0, a1											/* make a1 point at first xvector */	/* now d1 = #xvectors, a1 = first xvector, a0 = CODE start */	/* loop through all xvectors (d1) and setup each XVector */	bra			__doneyet____patchxvector__:	move.l		a0, (a1)										/* loop CODE start into final address */	move.l		0x8(a1), d0										/* get function's offset in CODE resource */	add.l		d0, (a1)										/* add it to the CODE start */	add.l		#12, a1											/* go on to the next xvector */__doneyet__:													/* are we done yet? */	tst.l		d1	dbeq		d1, __patchxvector__	__loopdone__:	/* cleanup the stack, patch the return address and return */	movem.l		(a7)+, a2	unlk		a6	subq.l		#8, (a7)										/* fixup return address to point to cfm call to main */	rts	/* storage area */__firsttime__:	dc.l		0x00000000										/* storage for knowing if this is the first time through */	/* LoadSeg patch routine */__LoadSeg__:	/* NOT YET IMPLEMENTED */	rts	/* UnloadSeg patch routine */__UnloadSeg__:	/* NOT YET IMPLEMENTED */	rts	/* error cases */__loaderror__:	moveq	#dsLoadErr,d0	_SysError	_ExitToShell												/* needed? */	rts}/* *	Dummy initialization routine, needed to get around a possible bug in CFM68K *	where not having an init routine, when generating a flat data fork based PEF *	application, would crash after calling the main routine. */pascal OSErr __dummy_init_routine(CFragInitBlock *theInitBlock);pascal OSErr __dummy_init_routine(CFragInitBlock *theInitBlock){#pragma unused (theInitBlock)	return noErr;}