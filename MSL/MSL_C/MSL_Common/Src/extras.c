#include <extras.h>#include <ctime>#if !(__dest_os == __mac_os && __MC68K__)#include <cwchar>   /*  cc 051100 */#include <cwctype>  /*  cc 051100 */#include <csignal>#include <cctype>	/*  cc 051100 */#include <cerrno>	/*  cc 051100 */#include <cstring>  /*  cc 051100 */#include <cstdlib>	/*  cc 051100 */#include "ansi_files.h"/* *	long __myraise(long signal); *	raise a signal (note that it is not int size dependant) *//* made __myraise into an inline to avoid function call *//*long __myraise(long signal){	return (raise(signal));}	*/	/* *	long tell(int fildes) *		Return the current on disk position. *//* made tell into an inline to avoid function call *//* made _wtoi into an inline to avoid function call *//*int _wtoi (const wchar_t *str){	return watoi (str);}*//* * lowercase all characters in str */wchar_t *_wcslwr (wchar_t *str){	wchar_t *saved = str;	while (*str)	{		*str = towlower (*str);		str++;	}  	return saved;}/* * uppercase all characters in str */wchar_t *_wcsupr (wchar_t *str){	wchar_t *saved = str;	while (*str)	{		*str = towupper (*str);		str++;	}  	return saved;}/* * copy str into newly malloc'd storage, return pointer to space */  /* made _wcsdup into an inline to avoid function call *//*wchar_t *_wcsdup (const wchar_t *str){	wchar_t * rval = (wchar_t *)malloc((wcslen(str)+1) * sizeof (wchar_t));		if (rval) {		wcscpy(rval, str);	}		return rval;}*//* * case-insensitive compare of s1, s2 */int _wcsicmp(const wchar_t *s1, const wchar_t *s2){    wchar_t c1, c2;    while (1)    {    	c1 = towlower(*s1++);    	c2 = towlower(*s2++);        if (c1 < c2) return -1;        if (c1 > c2) return 1;        if (c1 == 0) return 0;    }}/* * case-insensitive compare of s1, s2, stopping after n characters */int _wcsnicmp(const wchar_t *s1, const wchar_t *s2, size_t n){    int i;    wchar_t c1, c2;    for (i=0; i<n; i++)    {        c1 = towlower(*s1++);        c2 = towlower(*s2++);        if (c1 < c2) return -1;        if (c1 > c2) return 1;        if (!c1) return 0;    }    return 0;}/* * reverse order of characters in str */wchar_t * _wcsrev(wchar_t *str){	int SmallIndex = 0;	int BigIndex = wcslen(str) - 1;		while (SmallIndex < BigIndex) {		wchar_t Temp = str[SmallIndex];				str[SmallIndex] = str[BigIndex];		str[BigIndex] = Temp;				SmallIndex++;		BigIndex--;	}		return str;}/* * set all characters of str to wc */wchar_t *_wcsset(wchar_t *str, wchar_t wc){	wchar_t *saved = str;	while (*str)	{		*str++ = wc;	}  	return saved;}/* * set characters of str to wc, up to max of n characters */wchar_t *_wcsnset(wchar_t *str, wchar_t wc, size_t n){	wchar_t *saved = str;	while (*str && n--)	{		*str = wc;	}  	return saved;}/* return pointer to first character in s1 that isn't in s2 */wchar_t *_wcsspnp(const wchar_t *s1, const wchar_t *s2){	const wchar_t *set;	while (*s1)	{		for (set = s2; *set; set++)		{			if (*s1 != *(set++))			{				return (wchar_t *)s1;			}		}		s1++;	}		return NULL;}char * _strlwr (char *string){	char *s = string;		while (*s)	{		*s = tolower (*s);		s++;	}	return string;}/* Convert unsigned integer to a string */char * _ultoa(unsigned long val, char *str, int radix) {	unsigned long theNum = val;	int StrIndex = 0;	do 	{		int CurDigit = theNum % radix;		if (CurDigit > 9)			str[StrIndex++] = CurDigit + 'A' - 10;		else			str[StrIndex++] = CurDigit + '0';				theNum /= radix;	} while (theNum);			str[StrIndex++] = 0;		/* Now reverse the string.*/	_strrev(str);			return str;}/* Convert a value as a g format */char *_gcvt(double value, int digits, char *buffer){    sprintf(buffer, "%.*g", digits, value);    return buffer;}/* return unused heap memory */int _heapmin(void){    errno = ENOSYS;    return -1;}/* Compare lexigraphically two strings */int _stricmp(const char *s1, const char *s2){    char c1, c2;    while (1)    {    	c1 = tolower(*s1++);    	c2 = tolower(*s2++);        if (c1 < c2) return -1;        if (c1 > c2) return 1;        if (c1 == 0) return 0;    }}/* Compare lexigraphically two strings up to a max length */int _strnicmp(const char *s1, const char *s2, int n){    int i;    char c1, c2;    for (i=0; i<n; i++)    {        c1 = tolower(*s1++);        c2 = tolower(*s2++);        if (c1 < c2) return -1;        if (c1 > c2) return 1;        if (!c1) return 0;    }    return 0;}wchar_t * _wstrrev(wchar_t * str){	int SmallIndex = 0;	int BigIndex = wcslen(str) - 1;		while (SmallIndex < BigIndex) {		wchar_t Temp = str[SmallIndex];				str[SmallIndex] = str[BigIndex];		str[BigIndex] = Temp;				SmallIndex++;		BigIndex--;	}		return str;}/* Uppercase a string */char *_strupr(char *str){    while (*str)    {        *str = toupper(*str);        str++;    }    return str;}/* Get the date in a string */char *_strdate(char *str){    time_t timer;        time(&timer);    strftime(str, 10, "%m/%d/%y", localtime(&timer));    return str;}/* Set characters of string to character */char * _strset(char *str, int c){	char *save = str;	while (*str)	{		*str++ = c;	}		return save;} /* Set first n characters of string to character */char * _strnset(char *str, int c, size_t n){	char *save = str;	while (n && *str)	{		*(str++) = c;		n--;	}	return save;}/* return pointer to first character in s1 that isn't in s2 */char *_strspnp(char *s1, const char *s2){	while (*s1)	{		const char *set = s2;		while (*set)		{			if (*s1 != *(set++))			{				return s1;			}		}		s1++;	}		return NULL;}/* Convert integer to string */char * _itoa(int val, char *str, int radix) {	char IsNegative = 0;	int theNum = val;	unsigned int theUNum;							/* mm 000209 */	int StrIndex = 0;	if (val < 0)									/* mm 000209 */	{												/* mm 000209 */		theUNum    = -val;							/* mm 000209 */		IsNegative = 1;								/* mm 000209 */	}												/* mm 000209 */	else											/* mm 000209 */		theUNum = val;								/* mm 000209 */	do 													{														int CurDigit = theUNum % radix;				/* mm 000209 */		if (CurDigit > 9)										str[StrIndex++] = CurDigit + 'A' - 10;			else													str[StrIndex++] = CurDigit + '0';				theUNum /= radix;							/* mm 000209 */	} while (theUNum);								/* mm 000209 */		if (IsNegative) 		str[StrIndex++] = '-';	str[StrIndex++] = 0;	/* Now reverse the string.  */	_strrev(str);	return str;}wchar_t* _itow(int val, wchar_t *str, int radix) {	char IsNegative = 0;	int theNum = val;	unsigned int theUNum;							/* mm 000209 */	int StrIndex = 0;	if (val < 0)									/* mm 000209 */	{												/* mm 000209 */		theUNum    = -val;							/* mm 000209 */		IsNegative = 1;								/* mm 000209 */	}												/* mm 000209 */	else											/* mm 000209 */		theUNum = val;								/* mm 000209 */	do 													{														int CurDigit = theUNum % radix;				/* mm 000209 */		if (CurDigit > 9)			str[StrIndex++] = CurDigit + L'A' - 10;		else			str[StrIndex++] = CurDigit + L'0';		theUNum /= radix;							/* mm 000209 */	} while (theUNum);								/* mm 000209 */	if (IsNegative) 		str[StrIndex++] = '-';	str[StrIndex++] = 0;		/* Now reverse the string.*/	_wstrrev(str);	return str;}/* reverse a string in place */char * _strrev(char * str){	int SmallIndex = 0;	int BigIndex = strlen(str) - 1;		while (SmallIndex < BigIndex) {		char Temp = str[SmallIndex];				str[SmallIndex] = str[BigIndex];		str[BigIndex] = Temp;				SmallIndex++;		BigIndex--;	}		return str;}/* put together a path */void _makepath(char *path, const char *drive, const char *dir, const char *fname, const char *ext){    char ch;        path[0] = 0;    if (drive && drive[0])    {        strncat(path, drive, _MAX_PATH);        if (path[strlen(path)-1] != ':')        {            strncat(path, ":", _MAX_PATH-strlen(path));        }    }    if (dir && dir[0])    {        strncat(path, dir, _MAX_PATH-strlen(path));        ch = path[strlen(path)-1];        if (ch != '\\' && ch != '/')        {            strncat(path, "\\", _MAX_PATH-strlen(path));        }    }    if (fname && fname[0])    {        strncat(path, fname, _MAX_PATH-strlen(path));    }    if (ext && ext[0])    {        if (ext[0] != '.')        {            strncat(path, ".", _MAX_PATH-strlen(path));        }        strncat(path, ext, _MAX_PATH-strlen(path));    }}/* _splitpath takes a path and returns pointers to each of the * components of the path. */void _splitpath (const char *path, char *drive, char *dir, char *fname, 	char *ext){	const char *end, *dir_end_fwd, *dir_end_back;	/* first, check for drive letter in string... we should find a colon	 * in the second character position if its included. */	if (path [1] == ':')	{		if (drive)		{			drive [0] = path [0];			drive [1] = ':';			drive [2] = '\0';		}		path += 2;		/* increment current position to beyond						 * drive letter */	}	else if (drive != NULL)	/* if no drive, make empty */		strcpy (drive, "");	/* to find the directory, look for the last slash character */  	dir_end_back = strrchr (path, '\\');	dir_end_fwd = strrchr (path, '/');	/* use the one farthest to the end as the delimiter */	if (dir_end_fwd && dir_end_back)		end = (dir_end_fwd > dir_end_back ? dir_end_fwd : dir_end_back);	else if (dir_end_fwd)		end = dir_end_fwd;	else		end = dir_end_back;  	if (end == NULL)		/* if no dir, zero out path */	{		if (dir != NULL)			strcpy (dir, "");	}	else			/* we have a directory */	{		if (dir != NULL)	/* do we need to copy it? */		{			memcpy (dir, path, end - path + 1);			dir [end - path + 1] = '\0';		}		path = end + 1;		/* next search starts after dir */	}	/* now, we are at the filename... to isolate this, find the last	 * period, everything up to this is filename, everything after is	 * extension */	end = strrchr (path, '.');	if (end == NULL)		/* no extension */	{		end = path + strlen (path); /* set to end of string */	}	if (fname != NULL)	{		memcpy (fname, path, end - path);		fname [end - path] = '\0';	}	if (ext != NULL)		strcpy (ext, end);}/* made _strdup into an inline to avoid function call *//* char *_strdup(const char *str)		{			char * rval = (char *)malloc(strlen(str)+1);						if (rval) {				strcpy(rval, str);			}						return rval;		}*//*     Change record *     000510  cc made __myraise an inline in unix.h *     000511  cc moved common source from extras.win32.c  *     000511  cc added <cwchar>, <cwctype> */ #endif