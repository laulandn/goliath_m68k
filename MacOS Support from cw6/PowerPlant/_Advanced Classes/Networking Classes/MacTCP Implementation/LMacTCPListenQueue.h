// ===========================================================================//	LMacTCPListenQueue.h		PowerPlant 2.1		©1996-2000 Metrowerks Inc.// ===========================================================================//	IMPLEMENTATION DETAILS of MacTCP classes. DO NOT USE THESE CLASSES DIRECTLY!#ifndef _H_LMacTCPListenQueue#define _H_LMacTCPListenQueue#pragma once#include <LInterruptSafeList.h>#include <LReentrantMemoryPool.h>#include <UMacTCPSupport.h>#include <LMacTCPTCPEndpoint.h>#include <MacTCP.h>#if PP_Uses_Pragma_Import	#pragma import on#endifPP_Begin_Namespace_PowerPlant#define kBufferSize 128	// should be way more than we needclass StMacTCPListenOperation;class LListenQueueElem;// ===========================================================================#pragma mark === LMacTCPListenQueue ===// ===========================================================================//		¥ LMacTCPListenQueue// ===========================================================================//	Implementation detail. Do not use this class directly.class LMacTCPListenQueue{public:							LMacTCPListenQueue(UInt32 inListenQueueSize,												LMacTCPTCPEndpoint& inEndpoint);	virtual					~LMacTCPListenQueue();	void				StartListener();	StMacTCPListenOperation*		GetUnusedOperation();	void				StoreCompletedOperation(LListenQueueElem * newElem);	StMacTCPListenOperation*		GetCompletedOperation();	void				RecycleFreeOperation(StMacTCPListenOperation* inOperation);	void				GetALocalAddress(LInternetAddress& outAddress);protected:	void				AllocateMoreOperations();	void				Int_IncomingConnection(StMacTCPListenOperation * inOperation);	TInterruptSafeList<LListenQueueElem*>	mFreeList;	TInterruptSafeList<LListenQueueElem*>	mCompletedList;	TInterruptSafeList<LListenQueueElem*>	mRunningList;	StMacTCPListenOperation*	mOperationPool[kBufferSize];	SInt32						mOperationCount;	SInt32						mFree;	SInt32						mCompleted;	LMacTCPTCPEndpoint *		mEndpoint;	StMacTCPListenOperation*	mOperation;	friend class LMacTCPTCPEndpoint;	friend class StMacTCPListenOperation;};// ===========================================================================#pragma mark -#pragma mark === StMacTCPListenOperation ===class StMacTCPListenOperation : public StMacTCPOperation{public:							StMacTCPListenOperation(										LMacTCPListenQueue * inSendQueue,										StreamPtr	inStreamPtr = nil);							~StMacTCPListenOperation();	virtual void			SetStream(StreamPtr	inStreamPtr);	virtual void			SetBuffer(Ptr inRcvBuff);	virtual Ptr				GetBuffer()							{ return mReceiveBuffer; }	virtual void			Int_AsyncResume(OSStatus	inResult);	virtual void			AbortOperation();	virtual void 			AsyncRun();protected:	LMacTCPListenQueue *	mMacTCPListenQueue;	Ptr						mReceiveBuffer;	friend class LMacTCPListenQueue;};// ===========================================================================#pragma mark -#pragma mark === LListenQueueElem ===// ===========================================================================//		¥ LListenQueueElem// ===========================================================================//	Implementation detail. Do not use this structure.class LListenQueueElem : public LRMPObject, public LInterruptSafeListMember {public:	inline 				LListenQueueElem(StMacTCPListenOperation* inOperation)							{ mOperation = inOperation; }	StMacTCPListenOperation*		mOperation;	friend class LReentrantMemoryPool;};PP_End_Namespace_PowerPlant#if PP_Uses_Pragma_Import	#pragma import reset#endif#endif