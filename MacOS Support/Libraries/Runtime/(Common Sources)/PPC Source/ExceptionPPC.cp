////	ExceptionPPC.cp		-	Exception Handling Runtime Support for CodeWarriorª (PowerPC)////  Copyright © 1995-2002 Metrowerks Corporation.  All rights reserved.//////	POWERPC STACK FRAME FORMAT////	The PowerPC runtime architecture uses a grow-down stack with a single stack//	pointer at the low address end. The stack has the following organization://	////	LOW ADDRESSES	|						|//					|						|//					|-----------------------|//					|	GPR save area		|//					|-----------------------|	Can be used by frameless leaf routines//					|	FPR save area		|//	Callee's SP   =>|-----------------------|//					|		Callee's		|//					|	  linkage area		|//					|-----------------------|//					|		Callee's		|	Storage for parameters passed to//					|	parameter area		|	routines called by callee//					|-----------------------|//					|		Callee's		|//					|	local variables		|//					|-----------------------|//					|	alignment gap 1		|//					|-----------------------|//					|	GPR save area		|	Storage for nonvolatile GPRs used by callee//					|-----------------------|//					|	alignment gap 2		|//					|-----------------------|//					|	FPR save area		|	Storage for nonvolatile FPRs used by callee//	Caller's SP   =>|-----------------------|//					|		Caller's		|//					|	  linkage area		|//					|-----------------------|//					|		Caller's		|	Storage for parameters passed to//					|	parameter area		|	callee//					|-----------------------|//					|		Caller's		|//					|	local variables		|//					|-----------------------|//					|						|//	HIGH ADDRESSES	|						|//////	where the "linkage area" looks like this://////					|-----------------------|//				0	| Stack Frame Back Link	|	Pointer to caller's frame//					|-----------------------|//				4	|		Saved CR		|	Our CR (saved by routines we call)//					|-----------------------|//				8	|		Saved LR		|	Our LR (saved by routines we call)//					|-----------------------|//				12	|		(Reserved)		|//					|-----------------------|//				16	|		(Reserved)		|//					|-----------------------|//				20	|	Saved TOC Pointer	|	Our TOC (saved by cross-TOC glue)//					|-----------------------|//////	To unwind the stack, we start with a return address and SP for the routine which//	threw the exception. The next return address can be found by following the//	back-link at 0(SP) and accessing the saved LR in that frame.////	Restoring registers is slightly more tricky. If 'saved_CR' is true, we restore//	the CR from the callers linkage area. For saved GPRs and FPRs we start with//	the callers SP; the <n> saved FPRs will be at <callers SP> - (8 * <n>) and the//	<m> saved GPRs will be the (<m> * 4) words ending at at <callers SP> - (8 * <n>)//	adjusted so that the last word ends on a 16-byte boundary. (See below)//////#define EX_DEBUG	1#if defined(EX_DEBUG) && EX_DEBUG	#include <stdio.h>#endif#define __NOSTRING__	//	do not include <string>#if __MACH__	extern "C"	{		#include <mach-o/loader.h>		#include <mach-o/getsect.h>				#if !_MSL_USING_MW_C_HEADERS			#include <string.h>		#endif	}		#if _MSL_USING_MW_C_HEADERS		#include <string.h>	#endif#endif#include <stdlib.h>#include <CPlusLib.h>#include <exception.h>#include <ExceptionPPC.h>#include <NMWException.h>		 // ra 990322 changed form "" to <>// JWW - Define to 1 for a runtime library which will work on both AltiVec and non-AltiVec machines#define GENERIC_RUNTIME_MODEL 1// JWW - Define to 1 to get a dynamic list of fragments instead of a static number of slots#define DYNAMIC_FRAGMENT_REGISTRATION_TABLE 1#if 1	#define INLINE inline				//	inline for shipping code#else	#define INLINE static				//	static for debugging#endif#if __ALTIVEC__	// JWW - For the generic case, always switch on AltiVec.  For the processor-specific case,	// test __VEC__ to see if the AltiVec programming model is turned on or not.	#if GENERIC_RUNTIME_MODEL || __VEC__		#pragma scheduling altivec		#pragma altivec_model on		#pragma options align=power				union MWEVector128 {			__vector unsigned long	vul;			unsigned long 			l[4];			unsigned short 			s[8];			unsigned char 			c[16];		};		typedef union MWEVector128 MWEVector128;	#endif#else	// JWW - If the compiler cannot generate AltiVec, then GENERIC_RUNTIME_MODEL must not be on	#if GENERIC_RUNTIME_MODEL		#error The compiler cannot generate AltiVec code necessary for a generic runtime model	#endif#endif//	typedefstypedef struct ThrowContext {#if __VEC__	MWEVector128 VR[32];					//  VR0-VR31 (not all are saved/restored)	MWEVector128 vscr;	unsigned long vrsave;#endif	double		FPR[32];					//	FPR0-FPR31	(not all are saved/restored)	long		GPR[32];					//	GPR0-GPR31	(not all are saved/restored)	long		CR;							//	CR0-CR7	char*		SP;							//	stack pointer during unwind (used for linkage)	char*		FP;							//	frame pointer during unwind (used for locals)	char*		throwSP;					//	stack pointer at throw	char*		returnaddr;					//	return address	char*		throwtype;					//	throw type argument (0L: rethrow: throw; )	void*		location;					//	location argument (0L: rethrow: throw; )	void*		dtor;						//	dtor argument	CatchInfo	*catchinfo;					//	pointer to rethrow CatchInfo (or 0L)	}	ThrowContext;typedef ThrowContext* ThrowContextPtr;typedef struct MWExceptionInfo {	ExceptionTable*	exception_record;		//	pointer to exception table (small or large)	char*			current_function;		//	pointer to current function	char*			action_pointer;			//	pointer to action#if !__MACH__	/* I am not clear on where I need to use these in the Mach-O case */	/* especially since I am using absolute addresses */	char*			code_section;			//	base of code section for fragment containing table	char*			data_section;			//	base of data section for fragment containing table	char*			TOC;					//	TOC pointer for fragment containing table#endif}	MWExceptionInfo;#if __MACH__enum {	kFragmentSorted	= 0x00000001,	kFragmentLoaded = 0x00000002};#endiftypedef struct FragmentInfo {	ExceptionTableIndex*	exception_start;	//	start of exception table index for fragment	ExceptionTableIndex*	exception_end;		//	end of exception table index for fragment	char*					code_start;			//	start of code section for fragment	char*					code_end;			//	end of code section for fragment#if __MACH__	int						flags;#else	char*					data_start;			//	start of data section for fragment	char*					data_end;			//	end of data section for fragment	char*					TOC;				//	TOC pointer for fragment#endif} FragmentInfo;typedef struct ActionIterator {	MWExceptionInfo	info;					//	pointer to exception record	char*			current_SP;				//	current stack pointer	char*			current_FP;				//	current frame pointer (SP or R31)	long			current_R31;			//	current R31}	ActionIterator;#if __VEC__#pragma options align=reset#endif#define	MAXFRAGMENTS	32					//	maximum # of code fragments we can register#if DYNAMIC_FRAGMENT_REGISTRATION_TABLE	#if __MACH__		// JWW - The system calloc is used to allocate new fragment slots dynamically		#include <stdlib.h>	#else		// JWW - MacMemory is used to allocate new fragment slots dynamically		#include <MacMemory.h>		#include <CodeFragments.h>	#endif		typedef struct FragmentInfoBlock {		FragmentInfo fragmentinfo[MAXFRAGMENTS];		struct FragmentInfoBlock *nextfragmentblock;	} FragmentInfoBlock;	static FragmentInfoBlock *fragmentinfohead;	static FragmentInfo *lastusedfragment;#else	static FragmentInfo fragmentinfo[MAXFRAGMENTS];#endif#if GENERIC_RUNTIME_MODEL	#if __MACH__		// JWW - sysctl is used to determine if the machine has a vector processing unit		#include <sys/sysctl.h>	#else		// JWW - Gestalt is used to determine if the machine has a vector processing unit		#include <CodeFragments.h>		#include <Gestalt.h>		#include <OSUtils.h>	#endif		static bool isvelocitytestdone = false;	static bool hasvelocityengine = false;#else	#if __VEC__		#define hasvelocityengine true	#else		#define hasvelocityengine false	#endif#endiftypedef void (*DeleteFunc)(void *);#if __MACH__extern "C"{	#include <mach-o/getsect.h>	#include <mach-o/dyld.h>/* I can't find a system routine which does this so I am doing it my self */static const struct segment_command *getsegbynamefromheader(const mach_header *header, const char *seg_name){	const struct load_command *lc;	int	n_cmds = header->ncmds;	int cmd;		/* load commands start after the header */	lc = (const struct load_command *) (&header[1]);		for (cmd = 0; cmd < n_cmds; cmd++) {		if (lc->cmd == LC_SEGMENT) {			const struct segment_command *sc = (const struct segment_command *) lc;			if (!strncmp(seg_name,sc->segname,sizeof(sc->segname))) {				return sc;			}		}		lc = (const struct load_command *) (((const char *)lc)+lc->cmdsize);	}		#if defined(EX_DEBUG) && EX_DEBUG			printf("EXCEPTION ERROR: Could not find segment \"%16s\"\n", seg_name);	#endif		return NULL;}}static int insert_macho_fragment(FragmentInfo *f_in);static void mark_unloaded_macho_fragments(void);static void release_unloaded_macho_fragments(void);static void __reinitialize_metrowerks_exceptions(void){	const struct section *eti_sect;	const struct segment_command *seg_text;	const struct mach_header *mh;	unsigned long i;	unsigned long n;	unsigned long vm_addr_slide;	FragmentInfo f;		/* mark all unloaded */	mark_unloaded_macho_fragments();	/* register all loaded images */	n = _dyld_image_count();	for (i = 0; i < n; i++)	{		mh = _dyld_get_image_header(i);		if (mh)		{			vm_addr_slide = _dyld_get_image_vmaddr_slide(i);			eti_sect = getsectbynamefromheader(mh,"__DATA","__mwexceptionidx");			if (eti_sect) {								f.exception_start=(ExceptionTableIndex *)(eti_sect->addr + vm_addr_slide);				f.exception_end=(ExceptionTableIndex *)(eti_sect->addr + vm_addr_slide + eti_sect->size);				seg_text = getsegbynamefromheader(mh, "__TEXT");				f.code_start=(char *) seg_text->vmaddr + vm_addr_slide;				f.code_end=f.code_start + seg_text->vmsize;				f.flags = kFragmentLoaded;				/* insert it if not already present */				insert_macho_fragment(&f);			}		}	}		release_unloaded_macho_fragments();	return;}/************************************************************************//* Purpose..: Register a code fragment and its exception tables			*//* Input....: pointer to start of fragments code section				*//* Input....: pointer to end   of fragments code section				*//* Input....: pointer to start of fragments data section				*//* Input....: pointer to end   of fragments data section				*//* Input....: pointer to start of fragments exception table index		*//* Input....: pointer to end   of fragments exception table index		*//* Input....: RTOC for fragment											*//* Return...: unique ID for __ex_unregister_fragment					*//************************************************************************/#if DYNAMIC_FRAGMENT_REGISTRATION_TABLEstatic void mark_unloaded_macho_fragments(void){	FragmentInfoBlock *nextfragment;	FragmentInfoBlock *lastfragment;	FragmentInfo *f;	int i;		nextfragment = fragmentinfohead;	while (nextfragment != NULL)	{		//	find a free entry in the mach header table		for(i=0,f=nextfragment->fragmentinfo;i<MAXFRAGMENTS;++i,++f) {			/* clear loaded flag */			f->flags &= ~kFragmentLoaded;		}		lastfragment = nextfragment;		nextfragment = nextfragment->nextfragmentblock;	}}static void release_unloaded_macho_fragments(void){	FragmentInfoBlock *nextfragment;	FragmentInfoBlock *lastfragment;	FragmentInfo *f;	int i;		nextfragment = fragmentinfohead;	while (nextfragment != NULL)	{		//	find a free entry in the mach header table		for(i=0,f=nextfragment->fragmentinfo;i<MAXFRAGMENTS;++i,++f) {			if ((f->flags & kFragmentLoaded) == 0) {				f->code_start = 0;			}		}		lastfragment = nextfragment;		nextfragment = nextfragment->nextfragmentblock;	}}static int insert_macho_fragment(FragmentInfo *f_in){	FragmentInfoBlock *nextfragment;	FragmentInfoBlock *lastfragment;	FragmentInfo *f;	FragmentInfo *free_f;	int i;	int id;	int	free_id;		if (f_in == NULL) return(-1);		free_f = 0;	id = 0;	lastfragment = NULL;	nextfragment = fragmentinfohead;		while (nextfragment != NULL)	{		//	find a free entry in the mach header table		for(i=0,f=nextfragment->fragmentinfo;i<MAXFRAGMENTS;++i,++f,++id) {			if (f->exception_start == f_in->exception_start			&& f->exception_end == f_in->exception_end) {				f->flags |= kFragmentLoaded;				return id;			}			if(f->code_start==0) {				free_f = f;				free_id = id;			}		}		lastfragment = nextfragment;		nextfragment = nextfragment->nextfragmentblock;	}		if (free_f != 0) {		*free_f = *f_in;		free_f->flags |= kFragmentLoaded;		return(free_id);	}	//	ran out of registration slots so create a new block (calloc zeros the memory)	nextfragment = (FragmentInfoBlock *) calloc(sizeof(FragmentInfoBlock), 1);	if (nextfragment != NULL)	{		//	link in the new block to the end of the list		if (lastfragment == NULL)			fragmentinfohead = nextfragment;		else			lastfragment->nextfragmentblock = nextfragment;				//	fill in first mach header table entry in the new block		f = nextfragment->fragmentinfo;		*f = *f_in;		f->flags |= kFragmentLoaded;		return(id);	}		//	couldn't register the mach header	return(-1);}#elsestatic void mark_unloaded_macho_fragments(void){	const struct section *eti_sect;	const struct section *sect;	const struct segment_command *seg_text;	FragmentInfo *f;	int i;		for(i=0,f=fragmentinfo;i<MAXFRAGMENTS;++i,++f) {		f->flags &= ~kFragmentLoaded;	}}static void release_unloaded_macho_fragments(void){	const struct section *eti_sect;	const struct section *sect;	const struct segment_command *seg_text;	FragmentInfo *f;	int i;		for(i=0,f=fragmentinfo;i<MAXFRAGMENTS;++i,++f) {		if ((f->flags & kFragmentLoaded)==0) {			f->code_start = 0;		}	}}static int insert_macho_fragment(FragmentInfo *f_in){	const struct section *eti_sect;	const struct section *sect;	const struct segment_command *seg_text;	FragmentInfo *f;	int i;		if (!header) return(0);	//	find a free entry in the mach header table	for(i=0,f=fragmentinfo;i<MAXFRAGMENTS;++i,++f) {		if (f->exception_start == f_in->exception_start		&& f->exception_end == f_in->exception_end) {			f->flags |= kFragmentLoaded;			return(i);		}		if(f->code_start==0) {			*f = *f_in;			f->flags |= kFragmentLoaded;			return(i);		}	}	//	couldn't register the mach header	return(-1);}#endif /* DYNAMIC_FRAGMENT_REGISTRATION_TABLE */__declspec(private_extern) int __register_mach_header(const struct mach_header *header, unsigned long vmaddr_slide){	const struct section *eti_sect;	const struct segment_command *seg_text;	FragmentInfo f;		if (!header) return(0);	//	find a free entry in the mach header table	eti_sect = getsectbynamefromheader(header,"__DATA","__mwexceptionidx");	if (eti_sect) {		f.exception_start=(ExceptionTableIndex *)(eti_sect->addr + vmaddr_slide);		f.exception_end=(ExceptionTableIndex *)(eti_sect->addr + vmaddr_slide + eti_sect->size);		seg_text = getsegbynamefromheader(header, "__TEXT");		f.code_start=(char *) seg_text->vmaddr + vmaddr_slide;		f.code_end=f.code_start + seg_text->vmsize;		f.flags = kFragmentLoaded;		return insert_macho_fragment(&f);	}	//	couldn't register the mach header	return(-1);}__declspec(private_extern) int __register_mach_sorted(char *code_start, char *code_end,						char *exception_start, char *exception_end){	FragmentInfo f;		f.exception_start=(ExceptionTableIndex*)exception_start;	f.exception_end=(ExceptionTableIndex*)exception_end;	f.code_start=code_start;	f.code_end=code_end;	f.flags = kFragmentLoaded|kFragmentSorted;	return insert_macho_fragment(&f);}/************************************************************************//* Purpose..: Un-register a code fragment and its exception tables		*//* Input....: unique ID assigned in __ex_register_fragment				*//* Return...: ---														*//************************************************************************/#if DYNAMIC_FRAGMENT_REGISTRATION_TABLE__declspec(private_extern) void __unregister_mach_header(int fragmentID){	FragmentInfoBlock *nextfragment;	FragmentInfoBlock *lastfragment;	FragmentInfo *f;	int i;		if (fragmentID >= 0 && fragmentinfohead != NULL)	{		lastfragment = NULL;		nextfragment = fragmentinfohead;				// find the mach header block containing the fragmentID		while (fragmentID >= MAXFRAGMENTS && nextfragment != NULL)		{			lastfragment = nextfragment;			nextfragment = nextfragment->nextfragmentblock;			fragmentID -= MAXFRAGMENTS;		}				if(nextfragment != NULL)		{			// remove the mach header entry from the table			f = &nextfragment->fragmentinfo[fragmentID];			f->code_start=0; f->code_end=0;			f->exception_start=0; f->exception_end=0;						// clear the last used mach header if it is the one being unregistered			if (lastusedfragment == f)				lastusedfragment = NULL;						if (nextfragment->nextfragmentblock != NULL)				return;		// if entry is not in the last block, don't try to deallocate.							// this keeps the fragment IDs valid since an intermediate block							// may become empty, but a later block may contain a valid entry.							// if the intermediate block were deleted, the ID number of the							// later entry would be off by a factor of MAXFRAGMENTS.			else			{				// deallocate empty end blocks if possible				while (nextfragment != NULL)				{					// find out if the mach header block contains a single valid fragment entry					for(i=0,f=nextfragment->fragmentinfo;i<MAXFRAGMENTS;++i,++f)						if(f->code_start!=0)							return;	// valid mach header table entry exists - don't deallocate anymore										// the mach header table is empty - unlink it and deallocate it from the system					if (lastfragment == NULL)						fragmentinfohead = nextfragment->nextfragmentblock;					else						lastfragment->nextfragmentblock = nextfragment->nextfragmentblock;										free(nextfragment);										// find the new last block					lastfragment = NULL;					nextfragment = fragmentinfohead;					while ((nextfragment != NULL) && (nextfragment->nextfragmentblock != NULL))					{						lastfragment = nextfragment;						nextfragment = nextfragment->nextfragmentblock;					}				}			}		}	}}#else__declspec(private_extern) void __unregister_mach_header(int fragmentID){	FragmentInfo *f;		if(fragmentID>=0 && fragmentID<MAXFRAGMENTS)	{		f = &fragmentinfo[fragmentID];		f->code_start=0;		f->code_end=0;		f->exception_start=0;		f->exception_end=0;		f->flags=0;	}}#endif /* DYNAMIC_FRAGMENT_REGISTRATION_TABLE */#else	// JWW - The previous code is Mach-O, the following code is PEF/************************************************************************//* Purpose..: Register a code fragment and its exception tables			*//* Input....: pointer to start of fragments code section				*//* Input....: pointer to end   of fragments code section				*//* Input....: pointer to start of fragments data section				*//* Input....: pointer to end   of fragments data section				*//* Input....: pointer to start of fragments exception table index		*//* Input....: pointer to end   of fragments exception table index		*//* Input....: RTOC for fragment											*//* Return...: unique ID for __ex_unregister_fragment					*//************************************************************************/#if DYNAMIC_FRAGMENT_REGISTRATION_TABLEint __register_fragment(char *code_start, char *code_end,						char *data_start, char *data_end,						char *exception_start, char *exception_end,						char *TOC){	FragmentInfoBlock *nextfragment;	FragmentInfoBlock *lastfragment;	FragmentInfo *f;	int i;	int id;		#if GENERIC_RUNTIME_MODEL	// JWW - Check to see if the processor has AltiVec or not, but only do the test once	if (!isvelocitytestdone)	{		OSErr theErr;		long theResult;				isvelocitytestdone = true;				if ((Ptr) Gestalt != (Ptr) kUnresolvedCFragSymbolAddress)		{			theErr = Gestalt(gestaltPowerPCProcessorFeatures, &theResult);						if ((theErr == noErr) && (theResult & (1 << gestaltPowerPCHasVectorInstructions)))				hasvelocityengine = true;		}	}	#endif		id = 0;	lastfragment = NULL;	nextfragment = fragmentinfohead;		while (nextfragment != NULL)	{		//	find a free entry in the fragment table		for(i=0,f=nextfragment->fragmentinfo;i<MAXFRAGMENTS;++i,++f,++id) if(f->code_start==0)		{			f->code_start=code_start;			f->code_end=code_end;			f->data_start=data_start;			f->data_end=data_end;			f->exception_start=(ExceptionTableIndex *)exception_start;			f->exception_end=(ExceptionTableIndex *)exception_end;			f->TOC=TOC;			return(id);		}				lastfragment = nextfragment;		nextfragment = nextfragment->nextfragmentblock;	}		//	ran out of registration slots so create a new block	if ((Ptr) NewPtrClear != (Ptr) kUnresolvedCFragSymbolAddress)	{		nextfragment = (FragmentInfoBlock *) NewPtrClear(sizeof(FragmentInfoBlock));		if (nextfragment != NULL)		{			//	link in the new block to the end of the list			if (lastfragment == NULL)				fragmentinfohead = nextfragment;			else				lastfragment->nextfragmentblock = nextfragment;						//	fill in first fragment table entry in the new block			f = nextfragment->fragmentinfo;			f->code_start=code_start;			f->code_end=code_end;			f->data_start=data_start;			f->data_end=data_end;			f->exception_start=(ExceptionTableIndex *)exception_start;			f->exception_end=(ExceptionTableIndex *)exception_end;			f->TOC=TOC;			return(id);		}	}		//	couldn't register the fragment	return(-1);}#elseint __register_fragment(char *code_start, char *code_end,						char *data_start, char *data_end,						char *exception_start, char *exception_end,						char *TOC){	FragmentInfo *f;	int i;		#if GENERIC_RUNTIME_MODEL	// JWW - Check to see if the processor has AltiVec or not, but only do the test once	if (!isvelocitytestdone)	{		OSErr theErr;		long theResult;				isvelocitytestdone = true;				if ((Ptr) Gestalt != (Ptr) kUnresolvedCFragSymbolAddress)		{			theErr = Gestalt(gestaltPowerPCProcessorFeatures, &theResult);						if ((theErr == noErr) && (theResult & (1 << gestaltPowerPCHasVectorInstructions)))				hasvelocityengine = true;		}	}	#endif		//	find a free entry in the fragment table	for(i=0,f=fragmentinfo;i<MAXFRAGMENTS;++i,++f) if(f->code_start==0)	{		f->code_start=code_start;		f->code_end=code_end;		f->data_start=data_start;		f->data_end=data_end;		f->exception_start=(ExceptionTableIndex *)exception_start;		f->exception_end=(ExceptionTableIndex *)exception_end;		f->TOC=TOC;		return(i);	}	//	couldn't register the fragment	return(-1);}#endif /* DYNAMIC_FRAGMENT_REGISTRATION_TABLE *//************************************************************************//* Purpose..: Un-register a code fragment and its exception tables		*//* Input....: unique ID assigned in __ex_register_fragment				*//* Return...: ---														*//************************************************************************/#if DYNAMIC_FRAGMENT_REGISTRATION_TABLEvoid __unregister_fragment(int fragmentID){	FragmentInfoBlock *nextfragment;	FragmentInfoBlock *lastfragment;	FragmentInfo *f;	int i;		if (fragmentID >= 0 && fragmentinfohead != NULL)	{		lastfragment = NULL;		nextfragment = fragmentinfohead;				// find the fragment block containing the fragmentID		while (fragmentID >= MAXFRAGMENTS && nextfragment != NULL)		{			lastfragment = nextfragment;			nextfragment = nextfragment->nextfragmentblock;			fragmentID -= MAXFRAGMENTS;		}				if(nextfragment != NULL)		{			// remove the fragment entry from the table			f = &nextfragment->fragmentinfo[fragmentID];			f->code_start=0; f->code_end=0;			f->data_start=0; f->data_end=0;			f->exception_start=0; f->exception_end=0;			f->TOC=0;						// clear the last used fragment if it is the one being unregistered			if (lastusedfragment == f)				lastusedfragment = NULL;						if (nextfragment->nextfragmentblock != NULL)				return;		// if entry is not in the last block, don't try to deallocate.							// this keeps the fragment IDs valid since an intermediate block							// may become empty, but a later block may contain a valid entry.							// if the intermediate block were deleted, the ID number of the							// later entry would be off by a factor of MAXFRAGMENTS.			else			{				// deallocate empty end blocks if possible				while (nextfragment != NULL)				{					// find out if the fragment block contains a single valid fragment entry					for(i=0,f=nextfragment->fragmentinfo;i<MAXFRAGMENTS;++i,++f)						if(f->code_start!=0)							return;	// valid fragment table entry exists - don't deallocate anymore										// the fragment table is empty - unlink it and deallocate it from the system					if (lastfragment == NULL)						fragmentinfohead = nextfragment->nextfragmentblock;					else						lastfragment->nextfragmentblock = nextfragment->nextfragmentblock;										DisposePtr((Ptr) nextfragment);										// find the new last block					lastfragment = NULL;					nextfragment = fragmentinfohead;					while ((nextfragment != NULL) && (nextfragment->nextfragmentblock != NULL))					{						lastfragment = nextfragment;						nextfragment = nextfragment->nextfragmentblock;					}				}			}		}	}}#elsevoid __unregister_fragment(int fragmentID){	FragmentInfo *f;		if(fragmentID>=0 && fragmentID<MAXFRAGMENTS)	{		f = &fragmentinfo[fragmentID];		f->code_start=0; f->code_end=0;		f->data_start=0; f->data_end=0;		f->exception_start=0; f->exception_end=0;		f->TOC=0;	}}#endif /* DYNAMIC_FRAGMENT_REGISTRATION_TABLE */#endif /* __MACH__ *//************************************************************************//* Purpose..: Get an exception fragment record pointer					*//* Input....: pointer to return address									*//* Return...: pointer to FragmentInfo struct 							*//************************************************************************/#if DYNAMIC_FRAGMENT_REGISTRATION_TABLEstatic FragmentInfo *ExPPC_FindExceptionFragment(char *returnaddr){	FragmentInfoBlock *nextfragment;	FragmentInfo *f;	int i;		if (lastusedfragment != NULL)	{		if (returnaddr>=lastusedfragment->code_start && returnaddr<lastusedfragment->code_end) {			return(lastusedfragment);		}	}		nextfragment = fragmentinfohead;	while (nextfragment != NULL)	{		for(i=0,f=nextfragment->fragmentinfo;i<MAXFRAGMENTS;++i,++f) if(f->code_start!=0)		{			if(returnaddr>=f->code_start && returnaddr<f->code_end)			{				lastusedfragment = f;				return(f);			}		}				nextfragment = nextfragment->nextfragmentblock;	}	#if __MACH__	/* if we failed, reinitialize and try again - lazy binding may present new unexpected headers */	__reinitialize_metrowerks_exceptions();		if (lastusedfragment != NULL)	{		if (returnaddr>=lastusedfragment->code_start && returnaddr<lastusedfragment->code_end) {			return(lastusedfragment);		}	}		nextfragment = fragmentinfohead;	while (nextfragment != NULL)	{		for(i=0,f=nextfragment->fragmentinfo;i<MAXFRAGMENTS;++i,++f) if(f->code_start!=0)		{			if(returnaddr>=f->code_start && returnaddr<f->code_end)			{				lastusedfragment = f;				return(f);			}		}				nextfragment = nextfragment->nextfragmentblock;	}#endif		return(0);}#elsestatic FragmentInfo *ExPPC_FindExceptionFragment(char *returnaddr){	FragmentInfo *f;	int i;		for(i=0,f=fragmentinfo;i<MAXFRAGMENTS;++i,++f) if(f->code_start!=0)	{		if(returnaddr>=f->code_start && returnaddr<f->code_end) return(f);	}	#if __MACH__	/* if we failed, reinitialize and try again - lazy binding may present new unexpected headers */	__reinitialize_metrowerks_exceptions();		for(i=0,f=fragmentinfo;i<MAXFRAGMENTS;++i,++f) if(f->code_start!=0)	{		if(returnaddr>=f->code_start && returnaddr<f->code_end) return(f);	}#endif		return(0);}#endif/************************************************************************//* Purpose..: Get a exception record pointer							*//* Input....: pointer to return address									*//* Input....: pointer to MWExceptionInfo struct for result				*//* Return...: ---														*//************************************************************************/static void ExPPC_FindExceptionRecord(char *returnaddr,MWExceptionInfo *info){	FragmentInfo *fragment;	ExceptionTableIndex *exceptionindex,*p;	unsigned long returnoffset;	long i,m,n;	#if defined(EX_DEBUG) && EX_DEBUG			printf("EXCEPTION MSG: trying to find return address 0x%08x\n", returnaddr);	#endif	//	so far we haven't found anything	info->exception_record=0;	info->action_pointer=0;		//	find the exception table for the fragment containing 'returnaddr'	if ((fragment=ExPPC_FindExceptionFragment(returnaddr))==0) 	{		#if defined(EX_DEBUG) && EX_DEBUG					printf("\tFRAGEMENT NOT FOUND\n");				#endif		return;	}	#if defined(EX_DEBUG) && EX_DEBUG			printf("\tfragment found\n");		printf("\tcode_start = 0x%08x\n", fragment->code_start);		printf("\tcode_end = 0x%08x\n", fragment->code_end);		printf("\texception_start = 0x%08x\n", fragment->exception_start);		printf("\texception_end = 0x%08x\n", fragment->exception_end);		printf("\n");		#endif#if !__MACH__	info->code_section=fragment->code_start;	info->data_section=fragment->data_start;	info->TOC=fragment->TOC;#endif	exceptionindex=fragment->exception_start;#if __MACH__	if (fragment->flags & kFragmentSorted) {		/* binary search */				i = 0;		n = fragment->exception_end-fragment->exception_start;		while (1) {			if(i>n) return;			m=(i+n)/2;			p=&exceptionindex[m];			if(returnaddr<(char *)p->functionaddr) {				n=m-1;			} else if(returnaddr>(char *)p->functionaddr+p->functionsize) {				i=m+1;			}			else break;		}		info->current_function=(char *) p->functionaddr;	} else {		/* not sorted linear search */		info->current_function = 0;		for(p = &exceptionindex[0]; p < fragment->exception_end; p++)		{			/* for Mach functionaddr is function address */			if ((returnaddr >= (char *) p->functionaddr)			&& (returnaddr < ((char *) p->functionaddr)+p->functionsize))			{				info->current_function=(char *) p->functionaddr;				break;			}		}		if (!info->current_function) {			#if defined(EX_DEBUG) && EX_DEBUG				printf("\tRECORD NOT FOUND\n");						#endif			return;		}	}	#if defined(EX_DEBUG) && EX_DEBUG		printf("\trecord found\n");		printf("\tindex = %d\n", p - &exceptionindex[0]);		printf("\tfunction = 0x%08x\n", info->current_function);		printf("\n");	#endif		if (p->directstore)	{		info->exception_record=(ExceptionTable *)(&p->exceptionaddr);	}	else	{		/* for Mach exceptionaddr is real address */		info->exception_record=(ExceptionTable *) p->exceptionaddr;	}		//	find the set of actions to perform for an exception thrown from 'returnaddr'	returnoffset=(unsigned long) returnaddr - (unsigned long) p->functionaddr;#else		//	binary-search the exception table index for a function containing 'returnaddr'	returnoffset=returnaddr-fragment->code_start;	for(i=0,n=fragment->exception_end-fragment->exception_start;;)	{		if(i>n) return;		p=&exceptionindex[m=(i+n)/2];		if(returnoffset<p->functionoffset) n=m-1;		else if(returnoffset>p->functionoffset+p->functionsize) i=m+1;		else break;	}	info->current_function=fragment->code_start+p->functionoffset;	info->exception_record=p->directstore?(ExceptionTable *)(&p->exceptionoffset)										:(ExceptionTable *)(fragment->data_start+p->exceptionoffset);	//	find the set of actions to perform for an exception thrown from 'returnaddr'	returnoffset-=(unsigned long) p->functionoffset;	#endif	if (info->exception_record->largetable)	{		ExceptionTableLarge *etl = (ExceptionTableLarge *) info->exception_record;		ExceptionRangeLarge *erl; 				for( erl = etl->largeranges; erl->start != 0; erl++ )		{			unsigned long range_end = erl->start + (erl->size * 4);		// large range is 256K (64K * 4) ... (+4?)						if ( erl->start <= returnoffset && range_end >= returnoffset )			{				info->action_pointer = (char *) etl + erl->action; 				break;			}		}	}	else	{#if __VEC__		ExceptionTableSmall *ets 		= (ExceptionTableSmall *) 		info->exception_record;		ExceptionTableSmallVector *etsv = (ExceptionTableSmallVector *) info->exception_record;		ExceptionRangeSmall *ers;		if ( info->exception_record->hasaltivec ) {			for( ers = etsv->smallranges; ers->start != 0; ers++ ) {				if( ers->start <= returnoffset && ers->end >= returnoffset) {					info->action_pointer = (char *) etsv + ers->action; 					break;				}			}		}		else {			for( ers = ets->smallranges; ers->start != 0; ers++ ) {				if( ers->start <= returnoffset && ers->end >= returnoffset) {					info->action_pointer = (char *) ets + ers->action; 					break;				}			}		}#else		ExceptionTableSmall *ets = (ExceptionTableSmall *) info->exception_record;		ExceptionRangeSmall *ers;		for( ers = ets->smallranges; ers->start != 0; ers++ )		{			if( ers->start <= returnoffset && ers->end >= returnoffset)			{				info->action_pointer = (char *) ets + ers->action; 				break;			}		}#endif	}}/************************************************************************//* Purpose..: Find R31 saved in given stack frame						*//* Input....: pointer to throw context									*//* Input....: pointer to topmost exception record						*//* Return...: pointer to return PC										*//************************************************************************/static long ExPPC_PopR31(char *SP,MWExceptionInfo *info){	double *FPR_save_area;	long *GPR_save_area;	int saved_GPRs, saved_FPRs;	//	find saved FPRs	saved_FPRs=info->exception_record->savedFPRs;	FPR_save_area=(double *)(SP-saved_FPRs*8);    //  find saved GPRs    saved_GPRs=info->exception_record->savedGPRs;    GPR_save_area=(long *)FPR_save_area;    if(saved_FPRs&1) GPR_save_area-=2;  // 8-byte gap if # saved FPRs is odd	//	return saved R31	return(GPR_save_area[-1]);	//	R31 is last register saved, has highest address}/************************************************************************//* Purpose..: Return current exception action type						*//* Input....: pointer to ActionIterator									*//* Return...: action type												*//************************************************************************/static exaction_type ExPPC_CurrentAction(const ActionIterator *iter){	if(iter->info.action_pointer==0) return EXACTION_ENDOFLIST;	return ((ex_destroylocal *)iter->info.action_pointer)->action&EXACTION_MASK;}/************************************************************************//* Purpose..: Move to next action in Exception Table					*//* Input....: pointer to ActionIterator									*//* Return...: next action type											*//************************************************************************/static exaction_type ExPPC_NextAction(ActionIterator *iter){	exaction_type	action;	for(;;)	{		if(	iter->info.action_pointer==0		||	((action=((ex_destroylocal *)iter->info.action_pointer)->action)&EXACTION_ENDBIT)!=0 )		{	//	end of action list: find next exception record			char *return_addr, *callers_SP;						//	get LR saved in linkage area of caller			callers_SP=*(char **)iter->current_SP;			if(iter->info.exception_record->savedGPRs) iter->current_R31=ExPPC_PopR31(callers_SP,&iter->info);			return_addr=*(char **)(callers_SP+8);			ExPPC_FindExceptionRecord(return_addr,&iter->info);			if(iter->info.exception_record==0) terminate();	//	cannot find matching exception record			//	pop down to caller's stack frame			iter->current_SP=callers_SP;			iter->current_FP=(iter->info.exception_record->hasframeptr)?(char *)iter->current_R31:iter->current_SP;			if(iter->info.action_pointer==0) continue;		//	no actions		}		else		{			switch(action)			{			case EXACTION_DESTROYLOCAL:				iter->info.action_pointer+=sizeof(ex_destroylocal); break;			case EXACTION_DESTROYLOCALCOND:				iter->info.action_pointer+=sizeof(ex_destroylocalcond); break;			case EXACTION_DESTROYLOCALPOINTER:				iter->info.action_pointer+=sizeof(ex_destroylocalpointer); break;			case EXACTION_DESTROYLOCALARRAY:				iter->info.action_pointer+=sizeof(ex_destroylocalarray); break;			case EXACTION_DESTROYBASE:			case EXACTION_DESTROYMEMBER:				iter->info.action_pointer+=sizeof(ex_destroymember); break;			case EXACTION_DESTROYMEMBERCOND:				iter->info.action_pointer+=sizeof(ex_destroymembercond); break;			case EXACTION_DESTROYMEMBERARRAY:				iter->info.action_pointer+=sizeof(ex_destroymemberarray); break;			case EXACTION_DELETEPOINTER:				iter->info.action_pointer+=sizeof(ex_deletepointer); break;			case EXACTION_DELETEPOINTERCOND:				iter->info.action_pointer+=sizeof(ex_deletepointercond); break;			case EXACTION_CATCHBLOCK:				iter->info.action_pointer+=sizeof(ex_catchblock); break;#if __MACH__			case EXACTION_CATCHBLOCK_32:				iter->info.action_pointer+=sizeof(ex_catchblock_32); break;#endif			case EXACTION_ACTIVECATCHBLOCK:				iter->info.action_pointer+=sizeof(ex_activecatchblock); break;			case EXACTION_SPECIFICATION:				iter->info.action_pointer+=sizeof(ex_specification)+((ex_specification *)iter->info.action_pointer)->specs*sizeof(void *); break;			default:				terminate();	//	error			}		}		action=((ex_destroylocal *)iter->info.action_pointer)->action&EXACTION_MASK;		if(action==EXACTION_BRANCH)		{	//	skip to target action--we never return EXACTION_BRANCH to caller!			iter->info.action_pointer=((char *)iter->info.exception_record)+((ex_branch *)iter->info.action_pointer)->target;			action=((ex_destroylocal *)iter->info.action_pointer)->action&EXACTION_MASK;		}		return action;	}}/************************************************************************//* Purpose..: Restore registers											*//* Input....: pointer to throw context									*//* Input....: pointer to topmost exception record						*//* Return...: pointer to return PC										*//************************************************************************/static char *ExPPC_PopStackFrame(ThrowContext *context,MWExceptionInfo *info){	char *SP, *callers_SP;	double *FPR_save_area;	long *GPR_save_area;	int saved_GPRs, saved_FPRs;#if __VEC__	MWEVector128 *VR_save_area;	int saved_VRs;#endif	int i, j;		//	obtain current and callers frame pointers	SP=context->SP; callers_SP=*(char **)SP;	//	restore saved FPRs	saved_FPRs=info->exception_record->savedFPRs;	FPR_save_area=(double *)(callers_SP-saved_FPRs*8);	for(i=32-saved_FPRs, j=0;i<32;++i,++j) context->FPR[i]=FPR_save_area[j];    //  restore saved GPRs    saved_GPRs=info->exception_record->savedGPRs;    GPR_save_area=(long *)FPR_save_area;    if(saved_FPRs&1) GPR_save_area-=2;  // 8-byte gap if # saved FPRs is odd    GPR_save_area-=saved_GPRs;    for(i=32-saved_GPRs, j=0;i<32;++i,++j) context->GPR[i]=GPR_save_area[j];#if __VEC__	//	restore saved VRs	if ( info->exception_record->hasaltivec )	{		ExceptionTableSmallVector *etsv = (ExceptionTableSmallVector *) info->exception_record;		int vrsavesize 					= etsv->hasvrsave ? sizeof(long) : 0;		saved_VRs						= etsv->savedVRs;		VR_save_area	=	(MWEVector128 *) GPR_save_area;		VR_save_area	-=	vrsavesize;		VR_save_area	-= 	saved_VRs;				VR_save_area	=  (MWEVector128 *) ( (unsigned int) VR_save_area & 0xFFFFFFF0 );		// align to 16-byte boundary		for(i=32-saved_VRs, j=0;i<32;++i,++j)		{			context->VR[i].l[0] = VR_save_area[j].l[0];			context->VR[i].l[1] = VR_save_area[j].l[1];			context->VR[i].l[2] = VR_save_area[j].l[2];			context->VR[i].l[3] = VR_save_area[j].l[3];		}	}#endif		//	restore saved CR	if(info->exception_record->savedCR) context->CR=*(long *)(callers_SP+4);		//	restore saved SP (back link)	context->SP=callers_SP;		//	return new return_addr	return(*(char **)(callers_SP+8));}/************************************************************************//* Purpose..: Unwind ex_destroylocal struct								*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroylocal struct							*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyLocal(ThrowContext *context,const ex_destroylocal *ex){	DTORCALL_COMPLETE(ex->dtor,context->FP+ex->local);}/************************************************************************//* Purpose..: Unwind ex_destroylocal_32 struct							*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroylocal_32 struct							*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyLocal_32(ThrowContext *context,const ex_destroylocal_32 *ex){	DTORCALL_COMPLETE(ex->dtor,context->FP+ex->local);}/*#pragma mark --- turned inlining off#pragma dont_inline on*//************************************************************************//* Purpose..: Unwind ex_destroylocalcond struct							*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroylocalcond struct						*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyLocalCond(ThrowContext *context,const ex_destroylocalcond *ex){	int cond = ex->regcond	? (local_cond_type) context->GPR[ex->cond]							: *(local_cond_type *)(context->FP+ex->cond);	if(cond) DTORCALL_COMPLETE(ex->dtor,context->FP+ex->local);}/************************************************************************//* Purpose..: Unwind ex_destroylocalcond_32 struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroylocalcond_32 struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyLocalCond_32(ThrowContext *context,const ex_destroylocalcond_32 *ex){	int cond = ex->regcond	? (local_cond_type) context->GPR[ex->cond]							: *(local_cond_type *)(context->FP+ex->cond);	if(cond) DTORCALL_COMPLETE(ex->dtor,context->FP+ex->local);}/************************************************************************//* Purpose..: Unwind ex_destroylocalpointer struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroylocalpointer struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyLocalPointer(ThrowContext *context,const ex_destroylocalpointer *ex){	void *pointer = ex->regpointer	? (void *) context->GPR[ex->pointer]									: *(void **)(context->FP+ex->pointer);	DTORCALL_COMPLETE(ex->dtor,pointer);}/************************************************************************//* Purpose..: Unwind ex_destroylocalpointer_32 struct					*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroylocalpointer_32 struct				*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyLocalPointer_32(ThrowContext *context,const ex_destroylocalpointer_32 *ex){	void *pointer = ex->regpointer	? (void *) context->GPR[ex->pointer]									: *(void **)(context->FP+ex->pointer);	DTORCALL_COMPLETE(ex->dtor,pointer);}/************************************************************************//* Purpose..: Unwind ex_destroylocalarray struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroylocalarray struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyLocalArray(ThrowContext *context,const ex_destroylocalarray *ex){	char *ptr	= context->FP+ex->localarray;	long n		= ex->elements;	long size	= ex->element_size;	for(ptr=ptr+size*n; n>0; n--)	{		ptr-=size; DTORCALL_COMPLETE(ex->dtor,ptr);	}}/************************************************************************//* Purpose..: Unwind ex_destroylocalarray_32 struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroylocalarray_32 struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyLocalArray_32(ThrowContext *context,const ex_destroylocalarray_32 *ex){	char *ptr	= context->FP+ex->localarray;	long n		= ex->elements;	long size	= ex->element_size;	for(ptr=ptr+size*n; n>0; n--)	{		ptr-=size; DTORCALL_COMPLETE(ex->dtor,ptr);	}}/************************************************************************//* Purpose..: Unwind ex_destroymember struct							*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroymember struct						*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyMember(ThrowContext *context,const ex_destroymember *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	DTORCALL_COMPLETE(ex->dtor,objectptr+ex->offset);}/************************************************************************//* Purpose..: Unwind ex_destroymember_32 struct							*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroymember_32 struct						*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyMember_32(ThrowContext *context,const ex_destroymember_32 *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	DTORCALL_COMPLETE(ex->dtor,objectptr+ex->offset);}/************************************************************************//* Purpose..: Unwind ex_destroymember struct							*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroymember struct						*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyBase(ThrowContext *context,const ex_destroymember *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	DTORCALL_PARTIAL(ex->dtor,objectptr+ex->offset);}/************************************************************************//* Purpose..: Unwind ex_destroymember_32 struct							*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroymember_32 struct						*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyBase_32(ThrowContext *context,const ex_destroymember_32 *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	DTORCALL_PARTIAL(ex->dtor,objectptr+ex->offset);}/************************************************************************//* Purpose..: Unwind ex_destroymembercond struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroymembercond struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyMemberCond(ThrowContext *context,const ex_destroymembercond *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	int cond = ex->regcond	? (vbase_ctor_arg_type) context->GPR[ex->cond]							: *(vbase_ctor_arg_type *)(context->FP+ex->cond);	if(cond) DTORCALL_PARTIAL(ex->dtor,objectptr+ex->offset);}/************************************************************************//* Purpose..: Unwind ex_destroymembercond_32 struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroymembercond_32 struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyMemberCond_32(ThrowContext *context,const ex_destroymembercond_32 *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	int cond = ex->regcond	? (vbase_ctor_arg_type) context->GPR[ex->cond]							: *(vbase_ctor_arg_type *)(context->FP+ex->cond);	if(cond) DTORCALL_PARTIAL(ex->dtor,objectptr+ex->offset);}/************************************************************************//* Purpose..: Unwind ex_destroymemberarray struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroymemberarray struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyMemberArray(ThrowContext *context,const ex_destroymemberarray *ex){	char *ptr	= ex->regpointer	? (char *) context->GPR[ex->objectptr]									: *(char **)(context->FP+ex->objectptr);	long n		= ex->elements;	long size	= ex->element_size;	// msw 11/28/97 -	Bug fix.	ptr += ex->offset;	for(ptr=ptr+size*n; n>0; n--)	{		ptr-=size; DTORCALL_COMPLETE(ex->dtor,ptr);	}}/************************************************************************//* Purpose..: Unwind ex_destroymemberarray_32 struct					*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_destroymemberarray_32 struct				*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DestroyMemberArray_32(ThrowContext *context,const ex_destroymemberarray_32 *ex){	char *ptr	= ex->regpointer	? (char *) context->GPR[ex->objectptr]									: *(char **)(context->FP+ex->objectptr);	long n		= ex->elements;	long size	= ex->element_size;	// msw 11/28/97 -	Bug fix.	ptr += ex->offset;	for(ptr=ptr+size*n; n>0; n--)	{		ptr-=size; DTORCALL_COMPLETE(ex->dtor,ptr);	}}/************************************************************************//* Purpose..: Unwind ex_deletepointer struct							*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_deletepointer struct						*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DeletePointer(ThrowContext *context,const ex_deletepointer *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	((DeleteFunc) ex->deletefunc)(objectptr);}/************************************************************************//* Purpose..: Unwind ex_deletepointer_32 struct							*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_deletepointer_32 struct						*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DeletePointer_32(ThrowContext *context,const ex_deletepointer_32 *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	((DeleteFunc) ex->deletefunc)(objectptr);}/************************************************************************//* Purpose..: Unwind ex_deletepointercond struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_deletepointercond struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DeletePointerCond(ThrowContext *context,const ex_deletepointercond *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	int cond = ex->regcond	? (local_cond_type) context->GPR[ex->cond]							: *(local_cond_type *)(context->FP+ex->cond);	if(cond) ((DeleteFunc) ex->deletefunc)(objectptr);}/************************************************************************//* Purpose..: Unwind ex_deletepointercond_32 struct						*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to throw context									*//* Input....: pointer to ex_deletepointercond_32 struct					*//* Return...: ---														*//************************************************************************/INLINE void ExPPC_DeletePointerCond_32(ThrowContext *context,const ex_deletepointercond_32 *ex){	char *objectptr = ex->regpointer	? (char *) context->GPR[ex->objectptr]										: *(char **)(context->FP+ex->objectptr);	int cond = ex->regcond	? (local_cond_type) context->GPR[ex->cond]							: *(local_cond_type *)(context->FP+ex->cond);	if(cond) ((DeleteFunc) ex->deletefunc)(objectptr);}/*#pragma mark --- turned inlining back on#pragma dont_inline reset*//************************************************************************//* Purpose..: Unwind stack												*//* Input....: pointer to throw context									*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to topmost action									*//* Input....: pointer to catcher										*//* Return...: ---														*//************************************************************************/static void ExPPC_UnwindStack(ThrowContext *context,MWExceptionInfo *info,void *catcher){	exaction_type	action;#pragma exception_terminate		//	this will prevent exception exits during unwindind	for(;;)	{		if(info->action_pointer==0)		{			char *return_addr;				return_addr=ExPPC_PopStackFrame(context,info);			ExPPC_FindExceptionRecord(return_addr,info);			if(info->exception_record==0) terminate();		//	cannot find matching exception record			context->FP=(info->exception_record->hasframeptr)?(char *)context->GPR[31]:context->SP;			continue;		}		action=((ex_destroylocal *)info->action_pointer)->action;		switch(action&EXACTION_MASK)		{		case EXACTION_BRANCH:			info->action_pointer=((char *)info->exception_record)+((ex_branch *)info->action_pointer)->target;			break;				case EXACTION_DESTROYLOCAL:			ExPPC_DestroyLocal(context,(ex_destroylocal *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroylocal);			break;		case EXACTION_DESTROYLOCAL_32:			ExPPC_DestroyLocal_32(context,(ex_destroylocal_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroylocal_32);			break;		case EXACTION_DESTROYLOCALCOND:			ExPPC_DestroyLocalCond(context,(ex_destroylocalcond *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroylocalcond);			break;		case EXACTION_DESTROYLOCALCOND_32:			ExPPC_DestroyLocalCond_32(context,(ex_destroylocalcond_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroylocalcond_32);			break;		case EXACTION_DESTROYLOCALPOINTER:			ExPPC_DestroyLocalPointer(context,(ex_destroylocalpointer *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroylocalpointer);			break;		case EXACTION_DESTROYLOCALPOINTER_32:			ExPPC_DestroyLocalPointer_32(context,(ex_destroylocalpointer_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroylocalpointer_32);			break;		case EXACTION_DESTROYLOCALARRAY:			ExPPC_DestroyLocalArray(context,(ex_destroylocalarray *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroylocalarray);			break;		case EXACTION_DESTROYLOCALARRAY_32:			ExPPC_DestroyLocalArray_32(context,(ex_destroylocalarray_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroylocalarray_32);			break;		case EXACTION_DESTROYBASE:			ExPPC_DestroyBase(context,(ex_destroymember *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroymember);			break;		case EXACTION_DESTROYBASE_32:			ExPPC_DestroyBase_32(context,(ex_destroymember_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroymember_32);			break;		case EXACTION_DESTROYMEMBER:			ExPPC_DestroyMember(context,(ex_destroymember *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroymember);			break;		case EXACTION_DESTROYMEMBER_32:			ExPPC_DestroyMember_32(context,(ex_destroymember_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroymember_32);			break;		case EXACTION_DESTROYMEMBERCOND:			ExPPC_DestroyMemberCond(context,(ex_destroymembercond *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroymembercond);			break;		case EXACTION_DESTROYMEMBERCOND_32:			ExPPC_DestroyMemberCond_32(context,(ex_destroymembercond_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroymembercond_32);			break;		case EXACTION_DESTROYMEMBERARRAY:			ExPPC_DestroyMemberArray(context,(ex_destroymemberarray *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroymemberarray);			break;		case EXACTION_DESTROYMEMBERARRAY_32:			ExPPC_DestroyMemberArray_32(context,(ex_destroymemberarray_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_destroymemberarray_32);			break;		case EXACTION_DELETEPOINTER:			ExPPC_DeletePointer(context,(ex_deletepointer *)info->action_pointer);			info->action_pointer+=sizeof(ex_deletepointer);			break;		case EXACTION_DELETEPOINTER_32:			ExPPC_DeletePointer_32(context,(ex_deletepointer_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_deletepointer_32);			break;		case EXACTION_DELETEPOINTERCOND:			ExPPC_DeletePointerCond(context,(ex_deletepointercond *)info->action_pointer);			info->action_pointer+=sizeof(ex_deletepointercond);			break;		case EXACTION_DELETEPOINTERCOND_32:			ExPPC_DeletePointerCond_32(context,(ex_deletepointercond_32 *)info->action_pointer);			info->action_pointer+=sizeof(ex_deletepointercond_32);			break;		case EXACTION_CATCHBLOCK:			if(catcher==(void *)info->action_pointer) {				//	finished unwinding				return;			}			info->action_pointer+=sizeof(ex_catchblock);			break;#if __MACH__		case EXACTION_CATCHBLOCK_32:			if(catcher==(void *)info->action_pointer) {				//	finished unwinding				return;			}			info->action_pointer+=sizeof(ex_catchblock_32);			break;#endif		case EXACTION_ACTIVECATCHBLOCK:			{				CatchInfo		*catchinfo;				catchinfo=(CatchInfo *)(context->FP+((ex_activecatchblock *)info->action_pointer)->cinfo_ref);            	if ( catchinfo->dtor )           		{                	if ( context->location == catchinfo->location )                	{                    	context->dtor = catchinfo->dtor;                	}                	else                	{                    	DTORCALL_COMPLETE(catchinfo->dtor,catchinfo->location);                	}           		}				info->action_pointer+=sizeof(ex_activecatchblock);			}			break;		case EXACTION_ACTIVECATCHBLOCK_32:			{				CatchInfo		*catchinfo;				catchinfo=(CatchInfo *)(context->FP+((ex_activecatchblock_32 *)info->action_pointer)->cinfo_ref);            	if ( catchinfo->dtor )           		{                	if ( context->location == catchinfo->location )                	{                    	context->dtor = catchinfo->dtor;                	}                	else                	{                    	DTORCALL_COMPLETE(catchinfo->dtor,catchinfo->location);                	}           		}				info->action_pointer+=sizeof(ex_activecatchblock_32);			}			break;		case EXACTION_SPECIFICATION:			if(catcher==(void *)info->action_pointer) {				//	finished unwinding				return;			}			info->action_pointer+=sizeof(ex_specification)+((ex_specification *)info->action_pointer)->specs*sizeof(void *);			break;		default:			terminate();			//	error		}				if(action&EXACTION_ENDBIT) {			info->action_pointer=0;		}	}}/************************************************************************//* Purpose..: Check if an exception is in a specification list			*//* Input....: pointer to exception type string							*//* Input....: pointer to specification list								*//* Return...: ---														*//************************************************************************/static int ExPPC_IsInSpecification(char *extype,ex_specification *spec){	long i,offset;	for(i=0; i<spec->specs; i++)	{		if(__throw_catch_compare(extype,spec->spec[i],&offset)) {			return 1;		}	}	return 0;}/************************************************************************//* Purpose..: Unexpected handler										*//* Input....: pointer to throw context									*//* Return...: --- (this function will never return)						*//************************************************************************/extern void __unexpected(CatchInfo* catchinfo){		ex_specification *unexp=(ex_specification *)catchinfo->stacktop;#pragma exception_magic	try {		unexpected();	}	catch(...)	{	//	unexpected throws an exception => check if the exception matches the specification		if(ExPPC_IsInSpecification((char *)((CatchInfo *)&__exception_magic)->typeinfo,unexp))		{	//	new exception is in specification list => rethrow			throw;		}		if(ExPPC_IsInSpecification("!bad_exception!!",unexp))		{	//	"bad_exception" is in specification list => throw bad_exception()			throw bad_exception();		}		if(ExPPC_IsInSpecification("!std::bad_exception!!",unexp))		{	//	"bad_exception" is in specification list => throw bad_exception()			throw bad_exception();		}		//	cannot handle exception => terminate();	}	terminate();}/************************************************************************//* Purpose..: Restore registers and branch to catcher					*//* Input....: pointer to throw context									*//* Input....: destination RTOC											*//* Input....: destination PC											*//* Return...: ---														*//************************************************************************/static asm void ExPPC_LongJump(register ThrowContext *context, register void *newRTOC, register void *newPC, register bool hasaltivec){#if !GENERIC_RUNTIME_MODEL	#pragma unused(hasaltivec)#endif#if __ALTIVEC__		nofralloc#endif		mr			r8,newPC	#if !__MACH__		mr			RTOC,newRTOC		//	restore RTOC#endif		lwz			r0,context->CR		//	restore CR		mtcrf		255,r0#if GENERIC_RUNTIME_MODEL		// JWW - Test for need to restore AltiVec registers		or. hasaltivec,hasaltivec,hasaltivec		beq __skipaltivec_1#endif#if __VEC__		lwz			r5,context->vrsave			bcl			20,31,__setLR		// set LR to address of setLR				__setLR:			oris	 	r5,r5,0x8000		// indicate vr0 also in-use		mtvrsave 	r5		clrlwi		r5,r5,20			// clear left 20 bits		cntlzw		r5,r5				// find first nonvolatile VR used		slwi		r5,r5,3				// multiply by 8 for index past __longjmpv20		mflr		r7				addi		r7,r7,__longjmpv20 - __setLR - (20 * 8)		add			r7,r7,r5		mtctr		r7		bctr								// jump to index past __longjmpv20		__longjmpv20:				la			r31,context->VR[20]		lvx			vr20,r0,r31		la			r31,context->VR[21]		lvx			vr21,r0,r31		la			r31,context->VR[22]		lvx			vr22,r0,r31		la			r31,context->VR[23]		lvx			vr23,r0,r31		la			r31,context->VR[24]		lvx			vr24,r0,r31		la			r31,context->VR[25]		lvx			vr25,r0,r31		la			r31,context->VR[26]		lvx			vr26,r0,r31		la			r31,context->VR[27]		lvx			vr27,r0,r31		la			r31,context->VR[28]		lvx			vr28,r0,r31		la			r31,context->VR[29]		lvx			vr29,r0,r31		la			r31,context->VR[30]		lvx			vr30,r0,r31		la			r31,context->VR[31]		lvx			vr31,r0,r31#endif__skipaltivec_1:		//	restore R13-R31		lmw			r13,context->GPR[13]		//	restore FP14-FP31		lfd			fp14,context->FPR[14]		lfd			fp15,context->FPR[15]		lfd			fp16,context->FPR[16]		lfd			fp17,context->FPR[17]		lfd			fp18,context->FPR[18]		lfd			fp19,context->FPR[19]		lfd			fp20,context->FPR[20]		lfd			fp21,context->FPR[21]		lfd			fp22,context->FPR[22]		lfd			fp23,context->FPR[23]		lfd			fp24,context->FPR[24]		lfd			fp25,context->FPR[25]		lfd			fp26,context->FPR[26]		lfd			fp27,context->FPR[27]		lfd			fp28,context->FPR[28]		lfd			fp29,context->FPR[29]		lfd			fp30,context->FPR[30]		lfd			fp31,context->FPR[31]				mtlr		r8						//	restore PC (LR)#if GENERIC_RUNTIME_MODEL		// JWW - Test for need to restore AltiVec registers		or. hasaltivec,hasaltivec,hasaltivec		beq __skipaltivec_2#endif#if __VEC__		la			r5,context->vscr		lvewx		vr0,r0,r5				// load 32 bits into lo 32 bits of v0		mtvscr		vr0				lwz			r5,context->vrsave		// restore vrsave, remove usage of bit 0		mtvrsave 	r5#endif__skipaltivec_2:		//	restore SP to stack top at throw: discards exception-handling frames		//	but not exception temporaries		lwz			SP,context->throwSP		//	move stack frame back-link from catcher's linkage area to new top of		//	stack; this effectively pops all intermediate frames.		lwz			r3,context->SP		lwz			r3,0(r3)		stw			r3,0(SP)		//	jump to exception handler		blr}/************************************************************************//* Purpose..: Handle unexpected exception								*//* Input....: pointer to throw context									*//* Input....: pointer to topmost MWExceptionInfo struct					*//* Input....: pointer to specification record							*//* Return...: ---														*//************************************************************************/static void ExPPC_HandleUnexpected(ThrowContext *context,MWExceptionInfo *info,ex_specification *unexp){	CatchInfo	*catchinfo;#pragma exception_terminate		//	this will prevent exception exits during unwinding	ExPPC_UnwindStack(context,info,unexp);	//	unwind stack to failing specification	//	initialize catch info struct	catchinfo=(CatchInfo *)(context->FP+unexp->cinfo_ref);	catchinfo->location		= context->location;	catchinfo->typeinfo		= context->throwtype;	catchinfo->dtor			= context->dtor;	catchinfo->stacktop		= unexp;		//	the __unexpected will never call __end_catch											//	so we can resue this field	//	jump to exception handler#if __MACH__	ExPPC_LongJump(context,0,info->current_function+unexp->pcoffset,hasvelocityengine);#else	ExPPC_LongJump(context,info->TOC,info->current_function+unexp->pcoffset,hasvelocityengine);#endif}/************************************************************************//* Purpose..: Throw (rethrow) current exception							*//* Input....: pointer to throw context									*//* Return...: ---														*//************************************************************************/static void ExPPC_ThrowHandler(ThrowContext *context){	ActionIterator	iter;	MWExceptionInfo	info;	exaction_type	action;	CatchInfo		*catchinfo;	long			offset;	//	find first ExceptionRecord		ExPPC_FindExceptionRecord(context->returnaddr, &info);	if(info.exception_record==0) terminate();	//	cannot find matching exception record	context->FP=(info.exception_record->hasframeptr)?(char *)context->GPR[31]:context->SP;	if(context->throwtype==0)	{	//	rethrow, find most recent exception		iter.info		= info;		iter.current_SP	= context->SP;		iter.current_FP	= context->FP;		iter.current_R31 = context->GPR[31];		for(action=ExPPC_CurrentAction(&iter);; action=ExPPC_NextAction(&iter))		{			switch(action)			{			case EXACTION_ACTIVECATCHBLOCK:				break;				case EXACTION_ENDOFLIST:			case EXACTION_DESTROYLOCAL:			case EXACTION_DESTROYLOCALCOND:			case EXACTION_DESTROYLOCALPOINTER:			case EXACTION_DESTROYLOCALARRAY:			case EXACTION_DESTROYBASE:			case EXACTION_DESTROYMEMBER:			case EXACTION_DESTROYMEMBERCOND:			case EXACTION_DESTROYMEMBERARRAY:			case EXACTION_DELETEPOINTER:			case EXACTION_DELETEPOINTERCOND:			case EXACTION_CATCHBLOCK:#if __MACH__			case EXACTION_CATCHBLOCK_32:#endif			case EXACTION_SPECIFICATION:				continue;			case EXACTION_TERMINATE:			default:				terminate();			//	cannot find find most recent exception			}			break;		}		catchinfo=(CatchInfo *)(iter.current_FP+((ex_activecatchblock *)iter.info.action_pointer)->cinfo_ref);		context->throwtype	= (char *)catchinfo->typeinfo;		context->location	= catchinfo->location;		context->dtor		= 0;		// original active catch block is still responsible for destruction		context->catchinfo	= catchinfo;	}	else context->catchinfo=0L;	//	find matching exception handler	iter.info		= info;	iter.current_SP	= context->SP;	iter.current_FP	= context->FP;	iter.current_R31 = context->GPR[31];	for(action=ExPPC_CurrentAction(&iter);; action=ExPPC_NextAction(&iter))	{		switch(action)		{#if __MACH__		case EXACTION_CATCHBLOCK_32:			if(__throw_catch_compare(context->throwtype,((ex_catchblock_32 *)iter.info.action_pointer)->catch_type,&offset))			{				break;			}			continue;#endif		case EXACTION_CATCHBLOCK:			if(__throw_catch_compare(context->throwtype,((ex_catchblock *)iter.info.action_pointer)->catch_type,&offset))			{				break;			}			continue;		case EXACTION_SPECIFICATION:			if(!ExPPC_IsInSpecification(context->throwtype,(ex_specification *)iter.info.action_pointer))			{	//	unexpected specification				ExPPC_HandleUnexpected(context,&info,(ex_specification *)iter.info.action_pointer);				//	we will never return from this function call			}			continue;		case EXACTION_ENDOFLIST:		case EXACTION_DESTROYLOCAL:		case EXACTION_DESTROYLOCALCOND:		case EXACTION_DESTROYLOCALPOINTER:		case EXACTION_DESTROYLOCALARRAY:		case EXACTION_DESTROYBASE:		case EXACTION_DESTROYMEMBER:		case EXACTION_DESTROYMEMBERCOND:		case EXACTION_DESTROYMEMBERARRAY:		case EXACTION_DELETEPOINTER:		case EXACTION_DELETEPOINTERCOND:		case EXACTION_ACTIVECATCHBLOCK:			continue;		case EXACTION_TERMINATE:		default:			#if defined(EX_DEBUG) && EX_DEBUG				printf("EXCEPTION ERROR: throw not caught\n");			#endif			terminate();			//	cannot find matching catch block		}		break;	}	//	we have found a matching catch block#if __MACH__	if (action == EXACTION_CATCHBLOCK_32) {		ex_catchblock_32	*catchblock_32;		catchblock_32=(ex_catchblock_32 *)iter.info.action_pointer;		ExPPC_UnwindStack(context,&info,catchblock_32);		//	initialize catch info struct		catchinfo=(CatchInfo *)(context->FP+catchblock_32->cinfo_ref);		catchinfo->location		= context->location;		catchinfo->typeinfo		= context->throwtype;		catchinfo->dtor			= context->dtor;		if(*context->throwtype=='*')		{			//	pointer match (create a pointer copy with adjusted offset)			catchinfo->sublocation	= &catchinfo->pointercopy;			catchinfo->pointercopy	= *(long *)context->location+offset;		}		else		{	//	traditional or class match (directly adjust offset)			catchinfo->sublocation	= (char *)context->location+offset;		}		//	remember eventual stacktop (restored from catchinfo at end of catch block)		//	catchinfo->stacktop = context->SP;	//	saved at try { ... } instead		//	jump to exception handler//#if __MACH__		ExPPC_LongJump(context,0,info.current_function+catchblock_32->catch_pcoffset,hasvelocityengine);//#else//		ExPPC_LongJump(context,info.TOC,info.current_function+catchblock->catch_pcoffset,hasvelocityengine);//#endif	}	else#endif	{		ex_catchblock	*catchblock;		catchblock=(ex_catchblock *)iter.info.action_pointer;		ExPPC_UnwindStack(context,&info,catchblock);		//	initialize catch info struct		catchinfo=(CatchInfo *)(context->FP+catchblock->cinfo_ref);		catchinfo->location		= context->location;		catchinfo->typeinfo		= context->throwtype;		catchinfo->dtor			= context->dtor;		if(*context->throwtype=='*')		{	//	pointer match (create a pointer copy with adjusted offset)			catchinfo->sublocation	= &catchinfo->pointercopy;			catchinfo->pointercopy	= *(long *)context->location+offset;		}		else		{	//	traditional or class match (directly adjust offset)			catchinfo->sublocation	= (char *)context->location+offset;		}		//	remember eventual stacktop (restored from catchinfo at end of catch block)	//	catchinfo->stacktop = context->SP;	//	saved at try { ... } instead		//	jump to exception handler#if __MACH__		ExPPC_LongJump(context,0,info.current_function+catchblock->catch_pcoffset,hasvelocityengine);#else		ExPPC_LongJump(context,info.TOC,info.current_function+catchblock->catch_pcoffset,hasvelocityengine);#endif	}}#if GENERIC_RUNTIME_MODEL// JWW - Turn __throw into a dispatcher for __throw_vec or __throw_normalvoid __throw_vec(char *throwtype, void *location, void *dtor);void __throw_normal(char *throwtype, void *location, void *dtor);void __throw(char *throwtype, void *location, void *dtor){	#if defined(EX_DEBUG) && EX_DEBUG			printf("EXCEPTION MSG: throw, type=%s location=0x%08x, dtor=0x%08x\n", throwtype, location, dtor);	#endif	#if GENERIC_RUNTIME_MODEL && __MACH__	// JWW - Check to see if the processor has AltiVec or not, but only do the test once	if (!isvelocitytestdone)	{		int mib[2];		size_t len;		int hasvectorunit;				mib[0] = CTL_HW;		mib[1] = HW_VECTORUNIT;		len = sizeof(hasvectorunit);		if (sysctl(mib, 2, &hasvectorunit, &len, NULL, 0) == 0)		{			if (hasvectorunit != 0)				hasvelocityengine = true;		}	}	#endif		if (hasvelocityengine)		__throw_vec(throwtype, location, dtor);	else		__throw_normal(throwtype, location, dtor);}#endif// JWW - If using the generic runtime model, always include code for the AltiVec version of// __throw, but call it __throw_vec instead.  If using the processor specific runtime, test// __VEC__ to see if the AltiVec __throw should be used, and if so just call it __throw.#if GENERIC_RUNTIME_MODEL || __VEC__#pragma altivec_vrsave off/************************************************************************//* Purpose..: Throw (rethrow) current exception							*//* Input....: pointer to throw type (0L: rethrow)						*//* Input....: pointer to complete throw object (0L: rethrow)			*//* Input....: pointer to throw object destructor (0L: no destructor		*//* Return...: ---														*//************************************************************************/#if GENERIC_RUNTIME_MODELasm void __throw_vec(char *throwtype, void *location, void *dtor)#elseasm void __throw(char *throwtype, void *location, void *dtor)#endif{		ThrowContext 	throwcontext;					nofralloc						// user is responsible for stack frame//// PROLOGUE//		mflr		r0		mr			r11,r30				// save high 2 nonvolatiles in r11 and r12		stw			r31,-4(sp)		mr			r12,r31		stw			r30,-8(sp)		stw			r0,8(sp)		stw			r3,24(sp)		stw			r4,28(sp)		mr			r30,sp				// save callerSP in r30		stw			r5,32(sp)		clrrwi		sp,sp,4				// clear the right 4 bits to 16-byte align new frame										// frame size calculated by:										// sizeof(ThrowContext) 										// + 24 bytes for linkage area 										// + 8 for 16-byte alignment										// + 32 for parameter area size												stwu		r30,-(sizeof(ThrowContext) + 32 + 24 + 8) (SP)//// MAIN FUNCTION BODY//		addi		r31,sp,64			// offset of throwcontext calculated by:										// SP + 24 bytes for linkage area + 8 for 16-byte alignment										//    + 32 for parameter area size				stmw		r13,ThrowContext.GPR[13](r31)		stw			r11,ThrowContext.GPR[30](r31)	// restore register state as it was on entry to this routine		stw			r12,ThrowContext.GPR[31](r31)				mfvrsave 	r5		stw			r5,ThrowContext.vrsave(r31)		bcl			20,31,__setLR		// set LR to address of setLR				__setLR:			stw			r5,ThrowContext.vrsave(r31)		clrlwi		r5,r5,20			// clear left 20 bits		cntlzw		r5,r5				// find first nonvolatile VR used		slwi		r5,r5,3				// multiply by 8 for index past __setjmpv20		mflr		r4				addi		r4,r4,__setjmpv20 - __setLR	- (20 * 8)		add			r4,r4,r5		mtctr		r4				bctr							// jump to index past __setjmpv20		__setjmpv20:				li 			r3,ThrowContext.VR[20]		stvx		vr20,r3,r31		li 			r3,ThrowContext.VR[21]		stvx		vr21,r3,r31		li 			r3,ThrowContext.VR[22]		stvx		vr22,r3,r31		li 			r3,ThrowContext.VR[23]		stvx		vr23,r3,r31		li 			r3,ThrowContext.VR[24]		stvx		vr24,r3,r31		li 			r3,ThrowContext.VR[25]		stvx		vr25,r3,r31		li 			r3,ThrowContext.VR[26]		stvx		vr26,r3,r31		li 			r3,ThrowContext.VR[27]		stvx		vr27,r3,r31		li 			r3,ThrowContext.VR[28]		stvx		vr28,r3,r31		li 			r3,ThrowContext.VR[29]		stvx		vr29,r3,r31		li 			r3,ThrowContext.VR[30]		stvx		vr30,r3,r31		li 			r3,ThrowContext.VR[31]		stvx		vr31,r3,r31		mfvrsave 	r6		oris	 	r6,r6,0x8000		// indicate vr0 in-use		mtvrsave 	r6		mfvscr		vr0					// mfvscr is context-synchronizing, so this will take many cycles		la 			r5,ThrowContext.vscr(r31)		stvewx		vr0,r0,r5			// store 32 bits out of lo 32 bits of v0		li			r5,0x0000			// indicate that no vector registers are being used now		mtvrsave	r5					// This is OK because we just saved the non-volatile set and exercised our right										// to trash all the volatile vector registers		//	save FPRs so we can restore them during stack unwind		stfd		fp14,ThrowContext.FPR[14](r31)		stfd		fp15,ThrowContext.FPR[15](r31)		stfd		fp16,ThrowContext.FPR[16](r31)		stfd		fp17,ThrowContext.FPR[17](r31)		stfd		fp18,ThrowContext.FPR[18](r31)		stfd		fp19,ThrowContext.FPR[19](r31)		stfd		fp20,ThrowContext.FPR[20](r31)		stfd		fp21,ThrowContext.FPR[21](r31)		stfd		fp22,ThrowContext.FPR[22](r31)		stfd		fp23,ThrowContext.FPR[23](r31)		stfd		fp24,ThrowContext.FPR[24](r31)		stfd		fp25,ThrowContext.FPR[25](r31)		stfd		fp26,ThrowContext.FPR[26](r31)		stfd		fp27,ThrowContext.FPR[27](r31)		stfd		fp28,ThrowContext.FPR[28](r31)		stfd		fp29,ThrowContext.FPR[29](r31)		stfd		fp30,ThrowContext.FPR[30](r31)		stfd		fp31,ThrowContext.FPR[31](r31)		//	save CR so we can restore it during stack unwind		mfcr		r3		stw			r3,ThrowContext.CR(r31);		//	tcp->SP = tcp->throwSP = <stack pointer of caller>;		//	tcp->returnaddr = <return address into caller>;		lwz			r3,0(sp)		lwz			r4,8(r3)		stw			r3,ThrowContext.SP(r31);		stw			r3,ThrowContext.throwSP(r31);		stw			r4,ThrowContext.returnaddr(r31);		//	tcp->throwtype = throwtype;		lwz			r3,throwtype(r30)	// using callerSP		stw			r3,ThrowContext.throwtype(r31)		//	tcp->location = location;		lwz			r3,location(r30)	// using callerSP		stw			r3,ThrowContext.location(r31)		//	tcp->dtor = dtor;		lwz			r3,dtor(r30)		// using callerSP		stw			r3,ThrowContext.dtor(r31)		//	call __ex_throwhandler(&throwcontext);		mr			r3,r31		bl			ExPPC_ThrowHandler		nop//// EPILOGUE//				lwz			r0,8(r30)			// fetch old LR from linkage area		mr			sp,r30				// restore caller's SP from nonvolatile r30		mtlr		r0					// restore LR so we can return		lwz			r31,-4(sp)			// restore nonvolatile r30 and r31 callerSP-relative		lwz			r30,-8(sp)		blr}#pragma debug_listing  off#pragma altivec_vrsave on#endif /* GENERIC_RUNTIME_MODEL || __VEC__ */// JWW - If using the generic runtime model, always include code for the regular version of// __throw, but call it __throw_normal instead.  If using the processor specific runtime, test// __VEC__ to see if the regular __throw should be used, and if so just call it __throw.#if GENERIC_RUNTIME_MODEL || !__VEC__/************************************************************************//* Purpose..: Throw (rethrow) current exception							*//* Input....: pointer to throw type (0L: rethrow)						*//* Input....: pointer to complete throw object (0L: rethrow)			*//* Input....: pointer to throw object destructor (0L: no destructor		*//* Return...: ---														*//************************************************************************/#if GENERIC_RUNTIME_MODELasm void __throw_normal(char *throwtype, void *location, void *dtor)#elseasm void __throw(char *throwtype, void *location, void *dtor)#endif{		ThrowContext 	throwcontext;					nofralloc						// user is responsible for stack frame//// PROLOGUE//		mflr		r0		mr			r11,r30				// save high 2 nonvolatiles in r11 and r12		stw			r31,-4(sp)		mr			r12,r31		stw			r30,-8(sp)		stw			r0,8(sp)		stw			r3,24(sp)		stw			r4,28(sp)		mr			r30,sp				// save callerSP in r30		stw			r5,32(sp)		clrrwi		sp,sp,4				// clear the right 4 bits to 16-byte align new frame										// frame size calculated by:										// sizeof(ThrowContext) 										// + 24 bytes for linkage area 										// + 8 for 16-byte alignment										// + 32 for parameter area size												stwu		r30,-(sizeof(ThrowContext) + 32 + 24 + 8) (SP)//// MAIN FUNCTION BODY//		addi		r31,sp,64			// offset of throwcontext calculated by:										// SP + 24 bytes for linkage area + 8 for 16-byte alignment										//    + 32 for parameter area size				//	save GPRs so we can restore them during stack unwind		stmw		r13,ThrowContext.GPR[13](r31)		stw			r11,ThrowContext.GPR[30](r31)	// restore register state as it was on entry to this routine		stw			r12,ThrowContext.GPR[31](r31)				//	save FPRs so we can restore them during stack unwind		stfd		fp14,ThrowContext.FPR[14](r31)		stfd		fp15,ThrowContext.FPR[15](r31)		stfd		fp16,ThrowContext.FPR[16](r31)		stfd		fp17,ThrowContext.FPR[17](r31)		stfd		fp18,ThrowContext.FPR[18](r31)		stfd		fp19,ThrowContext.FPR[19](r31)		stfd		fp20,ThrowContext.FPR[20](r31)		stfd		fp21,ThrowContext.FPR[21](r31)		stfd		fp22,ThrowContext.FPR[22](r31)		stfd		fp23,ThrowContext.FPR[23](r31)		stfd		fp24,ThrowContext.FPR[24](r31)		stfd		fp25,ThrowContext.FPR[25](r31)		stfd		fp26,ThrowContext.FPR[26](r31)		stfd		fp27,ThrowContext.FPR[27](r31)		stfd		fp28,ThrowContext.FPR[28](r31)		stfd		fp29,ThrowContext.FPR[29](r31)		stfd		fp30,ThrowContext.FPR[30](r31)		stfd		fp31,ThrowContext.FPR[31](r31)		//	save CR so we can restore it during stack unwind		mfcr		r3		stw			r3,ThrowContext.CR(r31);		//	tcp->SP = tcp->throwSP = <stack pointer of caller>;		//	tcp->returnaddr = <return address into caller>;		lwz			r3,0(sp)		lwz			r4,8(r3)		stw			r3,ThrowContext.SP(r31);		stw			r3,ThrowContext.throwSP(r31);		stw			r4,ThrowContext.returnaddr(r31);		//	tcp->throwtype = throwtype;		lwz			r3,throwtype(r30)	// using callerSP		stw			r3,ThrowContext.throwtype(r31)		//	tcp->location = location;		lwz			r3,location(r30)	// using callerSP		stw			r3,ThrowContext.location(r31)		//	tcp->dtor = dtor;		lwz			r3,dtor(r30)		// using callerSP		stw			r3,ThrowContext.dtor(r31)		//	call __ex_throwhandler(&throwcontext);		mr			r3,r31		bl			ExPPC_ThrowHandler		nop//// EPILOGUE//				lwz			r0,8(r30)			// fetch old LR from linkage area		mr			sp,r30				// restore caller's SP from nonvolatile r30		mtlr		r0					// restore LR so we can return		lwz			r31,-4(sp)			// restore nonvolatile r30 and r31 callerSP-relative		lwz			r30,-8(sp)		blr}#endif /* GENERIC_RUNTIME_MODEL || !__VEC__ *//************************************************************************//* Purpose..: Deinitialize CatchInfo struct								*//* Input....: pointer to catchinfo struct								*//* Return...: ---														*//************************************************************************/void __end__catch(CatchInfo *catchinfo){	if (catchinfo->location && catchinfo->dtor)		DTORCALL_COMPLETE(catchinfo->dtor,catchinfo->location);}#if __MACH__ && __mwlinker__extern char __code_start__[];				/*	(defined by linker)	*/extern char	__code_end__[];					/*	(defined by linker)	*/extern char __exception_table_start__[];	/*	(defined by linker)	*/extern char __exception_table_end__[];		/*	(defined by linker)	*/static int	fragmentID = 0;static void initialize_macho_file(void){	//	register this code fragment with the Exception Handling mechanism	fragmentID = __register_mach_sorted(__code_start__, __code_end__,									__exception_table_start__, __exception_table_end__);}#pragma CALL_ON_MODULE_BIND initialize_macho_filestatic void terminate_macho_file(void){	__unregister_mach_header(fragmentID);}#pragma CALL_ON_MODULE_TERM terminate_macho_file#endif/* Change record: * JWW 000613 Added DYNAMIC_FRAGMENT_REGISTRATION_TABLE switch to dynamically allocate fragment slots * JWW 010306 Added GENERIC_RUNTIME_MODEL switch to make a library able to run anywhere * JWW 010531 Synchronized Mach-O and PEF runtime code * JWW 010728 Added in Rommel's support code for throwing exceptions with >32K stack frames * JWW 011102 Include string.h outside of the extern "C" block when using MSL headers * BC  020402 Support binary search with new linker */