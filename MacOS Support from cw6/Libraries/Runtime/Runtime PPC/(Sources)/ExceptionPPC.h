////  ExceptionPPC.h	-	C++ Exception Table Format for CodeWarriorª (PowerPC)////  Copyright © 1995-1997 Metrowerks, Inc.  All rights reserved.////#ifndef __EXCEPTIONPPC_H__#define __EXCEPTIONPPC_H__#pragma options align=mac68k//	Exception Table Actionstypedef unsigned char exaction_type;#define EXACTION_ENDBIT					0x80	//	action table end bit#define EXACTION_MASK					0x7F	//	action mask#define	EXACTION_ENDOFLIST				0#define	EXACTION_BRANCH					1typedef struct ex_branch {	exaction_type	action;				//	EXACTION_BRANCH	unsigned char	unused;				//	(reserved for future use)	unsigned short	target;				//	exception-table-relative offset of branch target} ex_branch;#define EXACTION_DESTROYLOCAL			2typedef struct ex_destroylocal {	exaction_type	action;				//	EXACTION_DESTROYLOCAL	unsigned char	unused;				//	(reserved for future use)	short			local;				//	16-bit frame-relative offset to local variable	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocal;#define EXACTION_DESTROYLOCALCOND		3typedef struct ex_destroylocalcond {	exaction_type	action;				//	EXACTION_DESTROYLOCALCOND	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					unused		: 7;	//	(reserved for future use)	short			cond;				//	16-bit frame-relative offset or GPR# of condition flag	short			local;				//	16-bit frame-relative offset to local variable	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalcond;#define EXACTION_DESTROYLOCALPOINTER	4typedef struct ex_destroylocalpointer {	exaction_type	action;				//	EXACTION_DESTROYLOCALPOINTER	unsigned char	regpointer	: 1,	//	1 -> pointer is in a GPR					unused		: 7;	//	(reserved for future use)	short			pointer;			//	16-bit frame-relative offset or GPR# of local pointer	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalpointer;#define EXACTION_DESTROYLOCALARRAY		5typedef struct ex_destroylocalarray {	exaction_type	action;				//	EXACTION_DESTROYLOCALARRAY	unsigned char	unused;				//	(reserved for future use)	short			localarray;			//	16-bit frame-relative offset to local array	unsigned short	elements;			//	number of array elements	unsigned short	element_size;		//	size of one array element	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalarray;#define EXACTION_DESTROYBASE			6#define EXACTION_DESTROYMEMBER			7typedef struct ex_destroymember {	exaction_type	action;				//	EXACTION_DESTROYMEMBER or EXACTION_DESTROYBASE	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymember;#define EXACTION_DESTROYMEMBERCOND		8typedef struct ex_destroymembercond {	exaction_type	action;				//	EXACTION_DESTROYMEMBERCOND	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 6;	//	(reserved for future use)	short			cond;				//	16-bit frame-relative offset or GPR# of condition flag	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymembercond;#define EXACTION_DESTROYMEMBERARRAY		9typedef struct ex_destroymemberarray {	exaction_type	action;				//	EXACTION_DESTROYMEMBERARRAY	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	long			elements;			//	number of array elements	long			element_size;		//	size of one array element	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymemberarray;#define EXACTION_DELETEPOINTER			10typedef struct ex_deletepointer {	exaction_type	action;				//	EXACTION_DELETEPOINTER	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	void*			deletefunc;			//	absolute pointer to TVector of deletefunc} ex_deletepointer;#define EXACTION_DELETEPOINTERCOND		11typedef struct ex_deletepointercond {	exaction_type	action;				//	EXACTION_DELETEPOINTERCOND	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 6;	//	(reserved for future use)	short			cond;				//	16-bit frame-relative offset or GPR# of condition flag	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	void*			deletefunc;			//	absolute pointer to TVector of deletefunc} ex_deletepointercond;#define EXACTION_CATCHBLOCK				12typedef struct ex_catchblock {	exaction_type	action;				//	EXACTION_CATCHBLOCK	unsigned char	unused;				//	(reserved for future use)	char*			catch_type;			//	absolute pointer to catch type info; 0 => catch(...)	unsigned short	catch_pcoffset;		//	16-bit function-relative offset to catch label	short			cinfo_ref;			//	16-bit frame-relative offset to local CatchInfo struct} ex_catchblock;#define EXACTION_ACTIVECATCHBLOCK		13typedef struct ex_activecatchblock {	exaction_type	action;				//	EXACTION_ACTIVECATCHBLOCK	unsigned char	unused;				//	(reserved for future use)	short			cinfo_ref;			//	16-bit frame-relative offset to local CatchInfo struct} ex_activecatchblock;#define EXACTION_TERMINATE				14typedef struct ex_terminate {	exaction_type	action;				//	EXACTION_TERMINATE	unsigned char	unused;				//	(reserved for future use)} ex_terminate;#define EXACTION_SPECIFICATION			15typedef struct ex_specification {	exaction_type	action;				//	EXACTION_SPECIFICATION	unsigned char	unused;				//	(reserved for future use)	unsigned short	specs;				//	number of specializations (0-n)	long			pcoffset;			//	16-bit function-relative offset to catch label	long			cinfo_ref;			//	16-bit frame-relative offset to local CatchInfo struct	char			*spec[];			//	array of absolute pointers to catch type info}	ex_specification;//	Exception Table Rangestypedef struct ExceptionRangeSmall {	unsigned short	start;				//	start of PC range where actions apply	unsigned short	end;				//	end of PC range where actions apply	unsigned short	action;				//	table-relative offset to actions for an} ExceptionRangeSmall;					//	exception thrown in range start..endtypedef struct ExceptionRangeLarge {	unsigned long	start;				//	start of PC range where actions apply	unsigned short	size;				//	size of PC range/4 where actions apply	unsigned short	action;				//	table-relative offset to actions for an} ExceptionRangeLarge;					//	exception thrown in range start..end//	Exception Tables (per-function)typedef struct ExceptionTable {	unsigned short		savedGPRs	: 5,	//	# of saved GPRs (rN-r31)						savedFPRs	: 5,	//	# of saved FPRs (rN-r31)						savedCR		: 1,	//	1 -> saved CR in frame							hasframeptr	: 1,	//	1 -> frame uses R31 as frame pointer						largetable	: 1,	//  (always zero)#if __VEC__						hasaltivec	: 1,	//  next short has altivec info 						reserved	: 2;	//	(reserved for future use)#else						reserved	: 3;	//	(reserved for future use)#endif	ExceptionRangeSmall	ranges[];			//	table of PC ranges and their actions//	unsigned short		end = 0;			//	(marks end of range list)//	unsigned long		actions[];			//	arbitrary action data} ExceptionTable;typedef struct ExceptionTableSmall {	unsigned short		savedGPRs	: 5,	//	# of saved GPRs (rN-r31)						savedFPRs	: 5,	//	# of saved FPRs (rN-r31)						savedCR		: 1,	//	1 -> saved CR in frame							hasframeptr	: 1,	//	1 -> frame uses R31 as frame pointer						largetable	: 1,	//  (always zero)#if __VEC__						hasaltivec	: 1,	//  next short has altivec info 						reserved	: 2;	//	(reserved for future use)#else						reserved	: 3;	//	(reserved for future use)#endif	ExceptionRangeSmall	smallranges[];		//	table of small PC ranges and their actions//	unsigned short		end = 0;			//	(marks end of range list)//	unsigned long		actions[];			//	arbitrary action data} ExceptionTableSmall;#if __VEC__typedef struct ExceptionTableSmallVector {	unsigned short		savedGPRs	: 5,	//	# of saved GPRs (rN-r31)						savedFPRs	: 5,	//	# of saved FPRs (rN-r31)						savedCR		: 1,	//	1 -> saved CR in frame							hasframeptr	: 1,	//	1 -> frame uses R31 as frame pointer						largetable	: 1,	//  (always zero)						hasaltivec	: 1,	//  next short has altivec info 						reserved	: 2;	//	(reserved for future use)	unsigned short		savedVRs	: 5,	//	# of saved GPRs (vrN-vr31)						hasvrsave	: 1,	//  has vrsave available in frame						reservedv	: 10;	//  reserved	ExceptionRangeSmall	smallranges[];		//	table of small PC ranges and their actions//	unsigned short		end = 0;			//	(marks end of range list)//	unsigned long		actions[];			//	arbitrary action data} ExceptionTableSmallVector;#endiftypedef struct ExceptionTableLarge {	unsigned short		savedGPRs	: 5,	//	# of saved GPRs (rN-r31)						savedFPRs	: 5,	//	# of saved FPRs (rN-r31)						savedCR		: 1,	//	1 -> saved CR in frame							hasframeptr	: 1,	//	1 -> frame uses R31 as frame pointer						largetable  : 1,	//  (always 1)#if __VEC__						hasaltivec	: 1,	//  next short has altivec info 						reserved	: 2;	//	(reserved for future use)	unsigned short		savedVRs	: 5,	//	# of saved GPRs (vrN-vr31)						hasvrsave	: 1,	//  has vrsave available in frame						reservedv	: 10;	//  reserved#else						reserved	: 3;	//	(reserved for future use)	unsigned short		unused;				//  reserved (align ranges on 4 byte boundary)#endif	ExceptionRangeLarge	largeranges[];		//	table of large PC ranges and their actions//  unsigned long   	start = 0;			//  (marks end of range list)//	unsigned short		size = 0;			//	(marks end of range list)//	unsigned long		actions[];			//	arbitrary action data} ExceptionTableLarge;//	Exception Table Indices (per-function)typedef struct ExceptionTableIndex {	unsigned long	functionoffset;		//	code-relative address of function	unsigned long	directstore : 1,	//	1 -> 4 byte exception table is in 'exceptionoffset'					functionsize : 31;	//	length of function	unsigned long	exceptionoffset;	//	data-relative address of exception table} ExceptionTableIndex;					//	(or table itself if 'directstore' == 1)#pragma options align=reset#endif