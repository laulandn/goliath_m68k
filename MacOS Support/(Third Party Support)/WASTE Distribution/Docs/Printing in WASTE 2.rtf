{\rtf1\mac{\fonttbl{\f0\fswiss Helvetica;}{\f1\froman Palatino;}{\f2\fmodern Courier;}}{\colortbl\red0\green0\blue0;}{\info{\title Printing in WASTE 2}{\subject WASTE, the WorldScript-aware Styled Text Engine}{\author Marco Piovanelli}}\paperw12240\paperh15840\margl1440\margr1440\margt1440\margb1440{\*\macprintrecord 00030000004800480000000002d80228ffe1ffe202f902460347052803fc00020000004800480000000002d80228000100000064000000010003030300000001270f00010001000000000000000000000000680800190190000000000000000000000000000000000000000000000000000000000000000067726f77000100004000000000000000}\deftab480{\pard\plain\f0\fs72\cf0\qc\sb360\sa480 {\b Printing in WASTE 2\par}}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b What\'d5s New\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 WASTE 1.3 doesn\'d5t have any special support for printing. This doesn\'d5t mean you can\'d5t implement printing with the available APIs, of course, but there are several gotchas you have to watch out for.  Printing text with WASTE involves calculating the number of lines that fit in each page, clipping the view rectangle to an integral number of lines, switching grafports, disabling offscreen drawing, etc.\parWASTE 2 (starting from revision 2.0a7) introduces some new APIs that are meant to streamline printing code in client applications, especially in applications that have simple printing requirements. These new APIs don\'d5t interact directly with the Print Manager, so the print loop is still under your application\'d5s control. They are mainly concerned with calculating page boundaries according to a page rectangle you provide. One advantage of this approach is that these APIs work with both the \'d2classic\'d3 Mac OS Print Manager and with the new Print Manager in Carbon.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b The Print Session Object\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 The new APIs revolve around the concept of {\b print session}.  To print a WASTE document, you create a print session object based on your print record (page format in Carbon).  In your page loop, you call {\f2 WEPrintPage} repeatedly on the session object.  You get rid of the print session when you\'d5re finished.\parThe line and page layout information maintained by the print session object are relative to the page rectangle you specify, and independent of the line layout information maintained by the main WE instance. So, for example, you can service update events on the screen in the middle of your print loop.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b The APIs\par}}{\pard\plain\f0\fs28\cf0\ql\sb240\sa120\brdrb\brdrdot {\b WENewPrintSession\par}}{\pard\plain\f2\fs24\cf0\ql\li480\tx4800 pascal OSErr WENewPrintSession\par  (\par    const WEPrintOptions *\tab inPrintOptions,\par    WEReference\tab inWE,\par    WEPrintSession *\tab outPrintSession\par  );\par{\f0 \par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 This routine creates a new print session object for printing a given WE instance. The {\f2 inPrintOptions} parameter points to a block that specifies printing options: currently, the only meaningful field in this block is the {\b page rectangle}, which represents the printable area in integral points at the standard 72 dpi resolution. Nonetheless, you should zero out the whole block for future compatibility.\par{\f2 WENewPrintSession} calculates line breaks according to the specified page width: these line breaks are kept in a data structure owned by the session object and don't interfere with the existing line layout information. Once line breaks have been calculated, {\f2 WENewPrintSession} goes on to find page breaks. Page breaks are calculated so that lines don\'d5t get split across pages.\par}{\pard\plain\f0\fs28\cf0\ql\sb240\sa120\brdrb\brdrdot {\b WECountPages\par}}{\pard\plain\f2\fs24\cf0\ql\li480\tx4800 pascal SInt32 WECountPages\par  (\par    WEPrintSession\tab inPrintSession\par  );\par{\f0 \par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 This routine returns the number of pages needed to print the whole text according to the layout information associated with the print session.\par}{\pard\plain\f0\fs28\cf0\ql\sb240\sa120\brdrb\brdrdot {\b WEPrintPage\par}}{\pard\plain\f2\fs24\cf0\ql\li480\tx4800 pascal OSErr WEPrintPage\par  (\par    SInt32\tab inPageIndex,\par    GrafPtr\tab inPrintPort,\par    const Rect *\tab inPageRect,\par    WEPrintSession\tab inPrintSession\par  );\par{\f0 \par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 This routine prints a page. It should be called between the Print Manager calls {\f2 PrOpenPage} and {\f2 PrClosePage} (or their Carbon counterparts {\f2 PMBeginPage} and {\f2 PMEndPage}). The {\f2 inPageIndex} parameter must be in the range {\f2 0} to {\f2 WECountPages(inPrintSession) - 1}. You pass the printing graphics port (obtained from {\f2 PrOpenDoc} in the classic Print Manager or {\f2 PMGetGrafPtr} in Carbon) in the {\f2 inPrintPort} parameter.\parThe {\f2 inPageRect} parameter is optional: if you don\'d5t specify a rectangle (and pass {\f2 nil}), {\f2 WEPrintPage} will use the page rectangle originally passed to {\f2 WENewPrintSession}. If you do specify a different page rectangle, it must be the same width as the page rectangle originally passed to {\f2 WENewPrintSession}. A possible use of this parameter is to swap left/right (or top/bottom) margins for even/odd pages.\par}{\pard\plain\f0\fs28\cf0\ql\sb240\sa120\brdrb\brdrdot {\b WEDisposePrintSession\par}}{\pard\plain\f2\fs24\cf0\ql\li480\tx4800 pascal OSErr WEDisposePrintSession\par  (\par    WEPrintSession\tab inPrintSession\par  );\par{\f0 \par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 Call this routine when you\'d5re finished with a print session.\par}}