/* =========================================================================== *	SSLCertificateUtils.cpp			    * *  This file is part of the DAVLib package *  Copyright (C) 1999-2002  Thomas Bednarzär * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com */#ifndef __SSLCertificateUtils_h__#include "SSLCertificateUtils.h"#endif#if DAVLIB_SSL#include <LFileStream.h>#include <UMemoryMgr.h>#include "SSLWrapper.h"#ifndef __CDAVTRANSCODEUTILS_H__#include "CDAVTranscodeUtils.h"#endif// ---------------------------------------------------------------------------------//		¥ ClientCertInfo// ---------------------------------------------------------------------------------//	ClientCertInfo::ClientCertInfo() {}// ---------------------------------------------------------------------------------//		¥ ClientCertInfo// ---------------------------------------------------------------------------------//	ClientCertInfo::ClientCertInfo(const ClientCertInfo& rhs):	mIssuedTo(rhs.mIssuedTo),    mIssuedBy(rhs.mIssuedBy),    mExpirationDate(rhs.mExpirationDate),    mFriendlyName(rhs.mFriendlyName),	    mLocalKeyID(rhs.mLocalKeyID){}// ---------------------------------------------------------------------------//		¥ = ()// ---------------------------------------------------------------------------//	ClientCertInfo&  ClientCertInfo::operator = (const ClientCertInfo& rhs) {   mIssuedTo = rhs.mIssuedTo;   mIssuedBy = rhs.mIssuedBy;   mExpirationDate = rhs.mExpirationDate;   mFriendlyName = rhs.mFriendlyName;	   mLocalKeyID = rhs.mLocalKeyID;   return *this;}// ---------------------------------------------------------------------------------//		¥ ParseCertifcate// ---------------------------------------------------------------------------------//	    ClientCertInfo::ParseStatus ClientCertInfo::ParseCertifcate(const FSSpec& inSpec, const std::string& inPassword, ClientCertInfo& outCertData) {   LFileStream inStream(inSpec);   SInt32 fileSize = 0;   try {      inStream.OpenDataFork( fsRdPerm );      fileSize = inStream.GetLength();   } catch (...) {      return eIOErr;   }      StPointerBlock tempSwap(fileSize);   try {      SInt32 bytesRead = inStream.ReadData(tempSwap, fileSize);   } catch (...) {      return eIOErr;   }   std::wstring friendlyName;   Cssl::CertParseState stat = Cssl::ParseClientCert(tempSwap.Get(), fileSize, inPassword, outCertData.mIssuedTo, outCertData.mIssuedBy, outCertData.mExpirationDate, friendlyName, outCertData.mLocalKeyID);   if (Cssl::eBadPass == stat)      return ClientCertInfo::eBadPass;      else if (Cssl::eBadBata == stat)       return ClientCertInfo::eBadData;   else if (Cssl::eUnknown == stat)      return ClientCertInfo::eUnknownErr;         if (friendlyName.size() > 0) {      outCertData.mFriendlyName = CDAVTranscodeUtils::UTF16to8(friendlyName);   }   return eOK;}#elseClientCertInfo::ParseStatus ClientCertInfo::ParseCertifcate(const FSSpec& inSpec, const std::string& inPassword, ClientCertInfo& outCertData) {   return ClientCertInfo::eUnknownErr;} #endif