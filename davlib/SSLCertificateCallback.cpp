/* =========================================================================== *	SSLCertificateCallback.cpp		    * *  This file is part of the DAVLib package *  Copyright (C) 1999-2002  Thomas Bednarzär * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com */#ifndef __SSLCertificateCallback_h__#include "SSLCertificateCallback.h"#endif#include "SSLWrapper.h"#include <assert.h>#include <string.h>static bool DLSSLCertificateCallback(	void *inUserData,										const std::map<std::string, std::string>& inOwnerInfo,										const std::map<std::string, std::string>& inIssuerInfo,										const std::string& inValidFromDate,										const std::string& inValidToDate,										const std::string& inFingerprint,										bool& outAcceptOnce) {	DAVLibSSLCertificateCallback* cbObj = reinterpret_cast<DAVLibSSLCertificateCallback*>(inUserData);	if (NULL == cbObj) {		assert(0);		return false;	}					return cbObj->OnCertificateReceived(inOwnerInfo, inIssuerInfo, inValidFromDate, inValidToDate, inFingerprint, outAcceptOnce);}static int DLSSLClientCertCallback(void *userdata, std::string& outTheCertData, std::string& outThePrivKey) {	DAVLibClientCertificateCallback* dlUd = reinterpret_cast<DAVLibClientCertificateCallback*>(userdata);	if (NULL == dlUd) {		assert(0);		return 0;	}		if (!dlUd->OnSupplyClientCert(outTheCertData, outThePrivKey))		return 0;	return 1;		}void DAVLibClientCertificateCallback::InstallDAVLibSSLClientCertCallback(DAVLibClientCertificateCallback* inCallback) {	Cssl::InstallClientCertCallback(DLSSLClientCertCallback, inCallback);}void DAVLibSSLCertificateCallback::InstallDAVLibSSLCertCallback(DAVLibSSLCertificateCallback* inCallback) {	Cssl::InstallCertCallback(DLSSLCertificateCallback, inCallback);}	OSErr	FSpGetFullPath(const FSSpec *spec,							   std::string& fullPath);	OSErr	FSpGetFullPath(const FSSpec *spec,							   std::string& fullPath){	OSErr		result;	OSErr		realResult;	FSSpec		tempSpec;	CInfoPBRec	pb;		/* Default to noErr */	realResult = result = noErr;			/* Make a copy of the input FSSpec that can be modified */	BlockMoveData(spec, &tempSpec, sizeof(FSSpec));		if ( result == noErr )	{		if ( tempSpec.parID == fsRtParID )		{			/* The object is a volume */						/* Add a colon to make it a full pathname */			++tempSpec.name[0];			tempSpec.name[tempSpec.name[0]] = ':';						/* We're done */			//result = PtrToHand(&tempSpec.name[1], fullPath, tempSpec.name[0]);			fullPath.append((char*)&tempSpec.name[1], tempSpec.name[0]);		}		else		{			/* The object isn't a volume */						/* Is the object a file or a directory? */			pb.dirInfo.ioNamePtr = tempSpec.name;			pb.dirInfo.ioVRefNum = tempSpec.vRefNum;			pb.dirInfo.ioDrDirID = tempSpec.parID;			pb.dirInfo.ioFDirIndex = 0;			result = PBGetCatInfoSync(&pb);			// Allow file/directory name at end of path to not exist.			realResult = result;			if ( (result == noErr) || (result == fnfErr) )			{				/* if the object is a directory, append a colon so full pathname ends with colon */				if ( (result == noErr) && (pb.hFileInfo.ioFlAttrib & kioFlAttribDirMask) != 0 )				{					++tempSpec.name[0];					tempSpec.name[tempSpec.name[0]] = ':';				}								/* Put the object name in first */				fullPath.append((char*)&tempSpec.name[1], tempSpec.name[0]);				//if ( result == noErr )				{					/* Get the ancestor directory names */					pb.dirInfo.ioNamePtr = tempSpec.name;					pb.dirInfo.ioVRefNum = tempSpec.vRefNum;					pb.dirInfo.ioDrParID = tempSpec.parID;					do	/* loop until we have an error or find the root directory */					{						pb.dirInfo.ioFDirIndex = -1;						pb.dirInfo.ioDrDirID = pb.dirInfo.ioDrParID;						result = PBGetCatInfoSync(&pb);						if ( result == noErr )						{							/* Append colon to directory name */							++tempSpec.name[0];							tempSpec.name[tempSpec.name[0]] = ':';														/* Add directory name to beginning of fullPath */							std::string tmp;							tmp.append((char*)&tempSpec.name[1], tempSpec.name[0]);							fullPath = tmp + fullPath;						}					} while ( (result == noErr) && (pb.dirInfo.ioDrDirID != fsRtDirID) );				}			}		}	}			return ( result );}void DAVLibSSLCertificateCallback::SetCertificateDatabaseFile(FSSpec* inTheSpec) {	std::string path;		// the current SSL interfaces need C-Strings; expose FSSpecs in DAVLib so at least	//  thats doing the right thing and is containing the evil	if (noErr == FSpGetFullPath(inTheSpec, path))		SetCertDBPath(path.c_str());}					