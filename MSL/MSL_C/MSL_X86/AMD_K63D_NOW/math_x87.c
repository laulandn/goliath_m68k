  const short __TO_INFINITY=0x0b7f;   /* mask to change rounding mode to "toward +inf" on 16 bit control word*/  const short __TO_M_INFINITY=0x077f; /* mask to change rounding mode to "toward -inf" on 16 bit control word*/  const short __TRUNC=0x0f7f;         /* mask to change rounding mode to "toward zero" on 16 bit control word*/    const short __SIXTYFOURBITS=0x037f; /* sets precision to "full" or 64 significant bits(full extended format) */  const float __HALF= .5f;  const float __ONE =1.0f;            /* used instead of instruction fld1 */#define _INLINE __declspec(selectany)#include <math.h>#pragma k63d_calls off__declspec(naked) void _reduce(void);__declspec(naked) void _reduce(void){asm{	fldpi			; st=pi st(1)=x	fxch reduce:	fld __HALF	fmul 	fprem	fnstsw ax	    ; 16 bit register	test ax, 0400h	; check for C2 bit	jnz  reduce	fstp st(1)	ret}}#pragma k63d_calls resetdouble cosh(double x){asm {	fld x	fldl2e			; st=log2(e) st(1)=x	fmul st,st(1)		; st=y=x*log2(e) 	fld st			; pushes st into st(1),st(2)=garbage	fst st(2)		; copies I+f to st(2)	frndint			; st=I,st(1)=y will work only for round 				; to nearest or maybe chop	fxch			;; st=I+f  st(1)=I st(2)=I+f	fsub st,st(1)		; st=f st(1)=I  st(2)=y=I+f	fst st(2)	f2xm1	fld1	fadd			; st=2^f st(1)=2^f -1 st(2)=I+f	fscale			; st=2^f*2^I  st(1)=I st(2)=f		fxch st(2)		; st=f st1=I st2=2^f	fchs			; st=-f st1=I st2=2^f	f2xm1	fld1	fadd			; st=2^-f st(1)=I  st(2)=2^f	fxch	fchs	fxch	fscale 	fstp st(1)		; st=2^-y st(1)=2^y st(2)=y	fadd	fld __HALF	fmul    fstp x }    return x;}	double sinh(double x){asm {	fld x	fldl2e			; st=log2(e) st(1)=x 	fmul			; st=y=x*log2(e) st(1)=log2(e) 	fld st			; st=st(1)=y 	frndint			; st=I,st(1)=y will work only for round  				; to nearest or maybe chop 	ftst			; if st=0 i.e. y is small -> we 	fstsw ax		; ftst doesn't set status word 				; flags in the microsoft debugger,  				; so I'm a little suspicious of this working 	sahf 	jnz big_y		;; needn't do a fscale when I=0. 	fstp st			; pop stack(don't need I anymore I=0)	fld st 	; fst st(1)		; st==st(1)=f (need a backup for -f) 	f2xm1 	fxch 	fchs 	f2xm1 	jmp common_sinhbig_y: 	fxch 	fsub st,st(1)		; st=y st(1)=I  o.k. to bash y now		fld st(1)		; st=st(1) st=stold st2=st1old	fxch 	 	fst st(2)		; st=f=y-I st(1)=I st(2)=f 	f2xm1 	fld1 	fadd 	fscale			; st=2^f st(1)=I st(2)=f  	fxch st(2)		; st=f st1=I st2=2^f 	fchs			; st=-f st1=I st2=2^f 	f2xm1 	fld1 	fadd			; st=2^-f st(1)=I  st(2)=2^f 	fxch 	fchs 	fxch 	fscale  	fstp st(1)		; st=2^-y st(1)=2^y st(2)=y 	common_sinh:		fsub 	fld __HALF 	fmul    fstp x }    return x;}	double exp(double x){asm{	fld x		fldl2e		; st=log2(e) st(1)=x	fmul		; st=y=x*log2(e) st(1)=log2(e)				; works only if rounding mode is 0				; TO_nearest or 3 TOWARD_zero(chop)				; the default control word is usually 037fH which				; is RC=0	fld st		; backup I+f	frndint		; st=I st(1)=y*log2(x)	fxch	fsub st,st(1)	; st(1)-st=st=f overwrites st(1)	                ; BUG if x is infinity or very large, this subtraction will	                ; produce a nan from inf-inf, so exp returns a nan in this case.	f2xm1	fld1 	fadd		; st=2^f st(1)=2^f-1 st(2)=I	fscale 	fstp st(1)    fstp x }    return x;   }double cos(double x){asm{	fld x	fcos	fnstsw ax		; 16 bit register	test ax, 0400h		; check for C2 bit	jz  finish    ;; argument reduction stuff	call _reduce	fcosfinish:    fstp x }    return x;   }	double sin(double x){asm{	fld x	fsin	fnstsw ax		; 16 bit register	test ax, 0400h		; check for C2 bit	jz  finish_sin	call _reduce    fsinfinish_sin:		    fstp x }    return x;   }   double tan(double x){asm{	fld x	fptan           ; note st=1, st(1)=tan(x)    fnstsw ax		; 16 bit register	test ax, 0400h	; check for C2 bit	jz finish_tan	;; ARGUMENT reduction stuff	fstp st	call _reduce	fptan	finish_tan:    fstp st    fstp x }    return x;   }   double acos(double x){asm{	fld x	fld st			; st=st(1)=x need to save x	fmul st,st		; st=x^2,st(1)=x	fld1			; st=1,st(1)=x^2,st(2)=x	fsubr			; st=1-x^2,st(1)=x				;      _______	fsqrt			; st=\|1 - x^2 ,st(1)=x	fpatan	fldpi	fld __HALF	fmul			; mult st by st(1) then pop	fsubr			; pops stack(clears st(7)    fstp x }    return x;   }   	   double asin(double x){asm{	fld x	fld st			; st=st(1)=x need to save x	fmul st,st		; st=x^2,st(1)=x	fld1			; st=1,st(1)=x^2,st(2)=x	fsubr			; st=1-x^2,st(1)=x				;      _______	fsqrt			; st=\|x^2 - 1 ,st(1)=x	fpatan    fstp x }    return x;   }   	