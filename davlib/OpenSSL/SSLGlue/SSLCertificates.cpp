/* =========================================================================== *	SSLCertificates.cpp		    * *  This file is part of the DAVLib package *  Copyright (C) 1999-2002  Thomas Bednarzär * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com *//* Portions of this code copyrighted as follows */ /* * Copyright (C) 1999-2000 Tommi Komulainen <Tommi.Komulainen@iki.fi> * Originally under GPL in Mutt, http://www.mutt.org/ *  *     This library is free software; you can redistribute it and/or *     modify it under the terms of the GNU Library General Public *     License as published by the Free Software Foundation; either *     version 2 of the License, or (at your option) any later version. *  *     This library is distributed in the hope that it will be useful, *     but WITHOUT ANY WARRANTY; without even the implied warranty of *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU *     Library General Public License for more details. *  *     You should have received a copy of the GNU Library General Public *     License along with this library; if not, write to the Free *     Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, *     MA 02111-1307, USA */ #include "SSLWrapper.h"#include "openssl/ssl.h"#include "openssl/err.h"#include <string.h>#include <string>#include <map>#include <list>#include "SSLCertificates.h"#define SHORT_STRING 128#if OPENSSL_VERSION_NUMBER >= 0x00904000L#define READ_X509_KEY(fp, key)	PEM_read_X509(fp, key, NULL, NULL)#else#define READ_X509_KEY(fp, key)	PEM_read_X509(fp, key, NULL)#endifconst char* SslCertFile = NULL;std::string sCertFileStore;void SetCertDBPath(const char* inCertDBPath) {	sCertFileStore = inCertDBPath;	SslCertFile = sCertFileStore.c_str();}class X509Holder {	public:		X509Holder(X509* inPeerCert);		X509Holder(const X509Holder& rhs);				virtual ~X509Holder();		X509*	GetX509() {return mX509Ptr;};	private:		X509*	mX509Ptr;};inline X509Holder::X509Holder(X509* inPeerCert) {	mX509Ptr = X509_dup(inPeerCert);}inline X509Holder::X509Holder(const X509Holder& rhs) {	mX509Ptr = X509_dup(rhs.mX509Ptr);}inline X509Holder::~X509Holder() {	if (X509_free)		X509_free(mX509Ptr);}std::list<X509Holder>	sSessionCerts;int check_certificate_by_signer (X509 *peercert){  X509_STORE_CTX xsc;  X509_STORE *ctx;  int pass;  ctx = X509_STORE_new ();  if (ctx == NULL) return 0;  /*  if (option (OPTSSLSYSTEMCERTS) && !X509_STORE_set_default_paths (ctx))  {    //DEBUG (DEBUG_SOCKET, "X509_STORE_set_default_paths failed\n");    X509_STORE_free (ctx);    return 0;  }*/  if (!X509_STORE_load_locations (ctx, SslCertFile, NULL))  {    X509_STORE_free (ctx);    return 0;  }    X509_STORE_CTX_init (&xsc, ctx, peercert, NULL);  pass = (X509_verify_cert (&xsc) > 0);  X509_STORE_CTX_cleanup (&xsc);  X509_STORE_free (ctx);  return pass;}char *x509_get_part (char *line, const char *ndx){  static char ret[SHORT_STRING];  char *c, *c2;  strncpy (ret, "Unknown", sizeof (ret));  c = strstr (line, ndx);  if (c)  {    c += strlen (ndx);    c2 = strchr (c, '/');    if (c2)      *c2 = '\0';    strncpy (ret, c, sizeof (ret));    if (c2)      *c2 = '/';  }  return ret;}int check_certificate_by_digest (X509 *peercert){  unsigned char peermd[EVP_MAX_MD_SIZE];  unsigned int peermdlen;  X509 *cert = NULL;  int pass = 0;  FILE *fp;  /* expiration check */  if (X509_cmp_current_time (X509_get_notBefore (peercert)) >= 0)  {    return 0;  }  if (X509_cmp_current_time (X509_get_notAfter (peercert)) <= 0)  {    return 0;  }  if ((fp = fopen (SslCertFile, "rt")) == NULL)    return 0;  if (!X509_digest (peercert, EVP_sha1(), peermd, &peermdlen))  {    fclose (fp);    return 0;  }    while ((cert = READ_X509_KEY (fp, &cert)) != NULL)  {    unsigned char md[EVP_MAX_MD_SIZE];    unsigned int mdlen;    /* Avoid CPU-intensive digest calculation if the certificates are     * not even remotely equal.     */    if (X509_subject_name_cmp (cert, peercert) != 0 ||		X509_issuer_name_cmp (cert, peercert) != 0)      continue;    if (!X509_digest (cert, EVP_sha1(), md, &mdlen) || peermdlen != mdlen)      continue;        if (memcmp(peermd, md, mdlen) != 0)      continue;    pass = 1;    break;  }  X509_free (cert);  fclose (fp);  return pass;}int check_sessioncertificate_by_digest (X509 *peercert){  unsigned char peermd[EVP_MAX_MD_SIZE];  unsigned int peermdlen;  X509 *scert = NULL;  int pass = 0;  /* expiration check */  if (X509_cmp_current_time (X509_get_notBefore (peercert)) >= 0)  {    return 0;  }  if (X509_cmp_current_time (X509_get_notAfter (peercert)) <= 0)  {    return 0;  }  if (!X509_digest (peercert, EVP_sha1(), peermd, &peermdlen))  {    return 0;  }    std::list<X509Holder>::iterator certiter = sSessionCerts.begin();  while (certiter != sSessionCerts.end()) {  	scert = certiter->GetX509();    unsigned char md[EVP_MAX_MD_SIZE];    unsigned int mdlen;    /* Avoid CPU-intensive digest calculation if the certificates are     * not even remotely equal.     */    if (X509_subject_name_cmp (scert, peercert) != 0 ||		X509_issuer_name_cmp (scert, peercert) != 0)      continue;    if (!X509_digest (scert, EVP_sha1(), md, &mdlen) || peermdlen != mdlen)      continue;        if (memcmp(peermd, md, mdlen) != 0)      continue;    pass = 1;    break;      ++certiter;  }  return pass; }char *asn1time_to_string (ASN1_UTCTIME *tm){  static char buf[64];  BIO *bio;  strncpy (buf, "[invalid date]", sizeof (buf));    bio = BIO_new (BIO_s_mem());  if (bio)  {    if (ASN1_TIME_print (bio, tm))      (void) BIO_read (bio, buf, sizeof (buf));    BIO_free (bio);  }  return buf;}static void x509_fingerprint (char *s, int l, X509 * cert){  unsigned char md[EVP_MAX_MD_SIZE];  unsigned int n;  int j;  if (!X509_digest (cert, EVP_md5 (), md, &n))  {    snprintf (s, (unsigned long)l, "[unable to calculate]");  }  else  {    for (j = 0; j < (int) n; j++)    {      char ch[8];      snprintf (ch, 8, "%02X%s", md[j], (j % 2 ? " " : ""));      strncat (s, ch, (unsigned long)l);    }  }}int ssl_check_certificate (X509 *cert, X509_STORE* ctx){  char *part[] =  {"/CN=", "/Email=", "/O=", "/OU=", "/L=", "/ST=", "/C="};  char buf[SHORT_STRING];  int i;  FILE *fp;  char *name = NULL, *c;  X509_STORE_CTX xsc;  int pass;  X509_STORE_CTX_init (&xsc, ctx, cert, NULL);  pass = (X509_verify_cert (&xsc) > 0);  X509_STORE_CTX_cleanup (&xsc);  if (0 != pass)     return 1;       /* automatic check from user's database */  if (SslCertFile && check_certificate_by_digest (cert))  {    return 1;  }    if (sSessionCerts.size() && check_sessioncertificate_by_digest(cert)) {  	return 1;  }    std::map<std::string, std::string> belongsTo, issuedBy;    name = X509_NAME_oneline (X509_get_subject_name (cert),			    buf, sizeof (buf));  for (i = 0; i < 7; i++) {    c = x509_get_part (name, part[i]);    issuedBy.insert(std::pair<std::string, std::string>(part[i], c));  }  name = X509_NAME_oneline (X509_get_issuer_name (cert),			    buf, sizeof (buf));  for (i = 0; i < 7; i++)  {    c = x509_get_part (name, part[i]);    belongsTo.insert(std::pair<std::string, std::string>(part[i], c));  }  std::string validFrom, validTo, fingerPrint;  validFrom = asn1time_to_string (X509_get_notBefore (cert));  validTo = asn1time_to_string (X509_get_notAfter (cert));    buf[0] = '\0';  x509_fingerprint (buf, sizeof (buf), cert);  fingerPrint += buf;  	SSLCertificateCallback certCB = Cssl::GetCertCallback();	bool once = false, accept = false;		if (certCB)		accept = (*certCB)(Cssl::GetCertCallbackData(), belongsTo, issuedBy, validFrom, validTo, fingerPrint, once);		bool didWrite = false;	if (accept && !once) {		if ((fp = fopen (SslCertFile, "a"))) {	  		if (!PEM_write_X509 (fp, cert)) {	    		//***teb - handle error	    	}	  	fclose (fp);		}	} else if (accept && once) {		sSessionCerts.push_back(X509Holder(cert));	}		return (accept==true);}