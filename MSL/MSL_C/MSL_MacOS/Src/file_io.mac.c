/*  Metrowerks Standard Library  *//*  $Date: 2000/01/12 19:54:41 $  *  $Revision: 1.4.10.1 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. */ /* *	file_io.mac.c *	 *	Routines *	-------- *		__open_file *		__open_temp_file *		__read_file *		__write_file *		__position_file *		__flush_file *		__close_file *		__temp_file_name *		__delete_file *		__rename_file * *		__handle_open *		__handle_reopen * *		__set_idle_proc * * */#include <Errors.h>#include <Files.h>#include <OSUtils.h>#include <Devices.h>#include <string.h>#include "file_io.h"#include "path2fss.h"#include <Aliases.h>#include <stdlib.h>     /* mm 981009 */#include "unix.mac.h"   /*mm-960729*/#define io_result(ioResult) ((ioResult == noErr) ? (int) __no_io_error : (int) __io_error)extern int	__system7present(void);											/* mm 980424 */static void set_file_type(FSSpec * spec, int binary_file){	CInfoPBRec	pb;	OSErr				ioResult;		pb.hFileInfo.ioNamePtr   = spec->name;	pb.hFileInfo.ioVRefNum   = spec->vRefNum;	pb.hFileInfo.ioFDirIndex = 0;	pb.hFileInfo.ioDirID     = spec->parID;		if (!(ioResult = PBGetCatInfoSync(&pb)))	{		pb.hFileInfo.ioFlFndrInfo.fdType    = __gettype(binary_file);     /*mm-960729*/		pb.hFileInfo.ioFlFndrInfo.fdCreator = __getcreator(binary_file);  /*mm-960729*/		pb.hFileInfo.ioDirID                = spec->parID;				ioResult = PBSetCatInfoSync(&pb);	}}typedef struct _temp_file_info temp_file_info;							/* mm 981009 */struct  _temp_file_info{	short		refnum;	FSSpec	spec;	struct _temp_file_info * next_struct;								/* mm 981009 */	struct _temp_file_info * prev_struct;								/* mm 981009 */};static temp_file_info*	temp_info_anchor = NULL;						/* mm 981009 */static temp_file_info * find_temp_info(short refnum){	temp_file_info *	p = temp_info_anchor;							/* mm 981009 */		while(p != NULL)													/* mm 981009 */	{		if (p->refnum == refnum)			return(p);		p = p->next_struct;												/* mm 981009 */	}		return(0);}int	__open_file(const char * name, __file_modes mode, __file_handle * handle){	FSSpec					spec;	OSErr						ioResult;	HParamBlockRec	pb;		ioResult = __path2fss(name, &spec);	if (__system7present())												/* mm 980424 */	{																	/* mm 980424 */		Boolean targetIsFolder, wasAliased;								/* mm 980424 */		ResolveAliasFile(&spec, true, &targetIsFolder, &wasAliased);	/* mm 980424 */	}																	/* mm 980424 */		if (ioResult && (ioResult != fnfErr || mode.open_mode == __must_exist))		return(__io_error);		pb.ioParam.ioNamePtr    = spec.name;	pb.ioParam.ioVRefNum    = spec.vRefNum;	pb.ioParam.ioPermssn    = (mode.io_mode == __read) ? fsRdPerm : fsRdWrPerm;	pb.ioParam.ioMisc       = 0;	pb.fileParam.ioFVersNum = 0;	pb.fileParam.ioDirID    = spec.parID;		if (ioResult)	{		if (!(ioResult = PBHCreateSync(&pb)))		{			set_file_type(&spec, mode.binary_io);			ioResult = PBHOpenDFSync(&pb);  /* HH 10/25/97  was PBHOpenSync */		}	}	else	{		if (!(ioResult = PBHOpenDFSync(&pb)) && mode.open_mode == __create_or_truncate)  		                                  /* HH 10/25/97  was PBHOpenSync */		{			pb.ioParam.ioMisc = 0;						ioResult = PBSetEOFSync((ParmBlkPtr) &pb);						if (ioResult)				PBCloseSync((ParmBlkPtr) &pb);		}	}		if (ioResult)		return(__io_error);		*handle = pb.ioParam.ioRefNum;		return(__no_io_error);}int __open_temp_file(__file_handle * handle){	char					temp_name[L_tmpnam];	temp_file_info *		info;	FSSpec					spec;	int						ioresult;		__temp_file_name(temp_name, &spec);		if (!(info = find_temp_info(0)))	{		if (!(info = malloc(sizeof(temp_file_info))))						/* mm 981009 */			return(__io_error);												/* mm 981009 */		memset((void *)info, 0, sizeof(temp_file_info));					/* mm 981009 */		info->next_struct = temp_info_anchor;								/* mm 981009 */		if (temp_info_anchor != NULL) 										/* mm 000105 */			temp_info_anchor->prev_struct = info;							/* mm 000105 */		temp_info_anchor  = info;											/* mm 981009 */		info->prev_struct = NULL;											/* mm 981009 */	}				ioresult = __open_file(temp_name, __temp_file_mode, handle);		if (ioresult == __no_io_error)	{		info->refnum = *handle;		info->spec   = spec;	}		return(ioresult);}int __read_file(__file_handle handle, unsigned char * buffer, size_t * count, __idle_proc idle_proc){	IOParam	pb;		pb.ioCompletion = 0;	pb.ioRefNum     = handle;	pb.ioBuffer     = (Ptr) buffer;	pb.ioReqCount   = *count;	pb.ioPosMode    = fsAtMark;		if (idle_proc)	{		PBReadAsync((ParmBlkPtr) &pb);				while (pb.ioResult > 0)			(*idle_proc)();	}	else		PBReadSync((ParmBlkPtr) &pb);		*count = pb.ioActCount;		if (pb.ioResult == eofErr)		if (*count != 0)			return(__no_io_error);		else			return(__io_EOF);     /* mm 961031 */		return(io_result(pb.ioResult));}int __write_file(__file_handle handle, unsigned char * buffer, size_t * count, __idle_proc idle_proc){	IOParam	pb;		pb.ioCompletion = 0;	pb.ioRefNum     = handle;	pb.ioBuffer     = (Ptr) buffer;	pb.ioReqCount   = *count;	pb.ioPosMode    = fsAtMark;		if (idle_proc)	{		PBWriteAsync((ParmBlkPtr) &pb);				while (pb.ioResult > 0)			(*idle_proc)();	}	else		PBWriteSync((ParmBlkPtr) &pb);		*count = pb.ioActCount;		return(io_result(pb.ioResult));}/* Begin replacement mm 980612 */int __position_file(__file_handle handle, unsigned long * position, int mode, __idle_proc idle_proc){	IOParam	pb;	long		eof, absPos;		pb.ioCompletion = 0;	pb.ioRefNum     = handle;		if (idle_proc)	{		PBGetEOFAsync((ParmBlkPtr) &pb);				while (pb.ioResult > 0)			(*idle_proc)();	}	else		PBGetEOFSync((ParmBlkPtr) &pb);		if (pb.ioResult != noErr)		return(__io_error);		eof = (long) pb.ioMisc;		switch (mode)	{		case SEEK_END:			absPos = eof + *position;			break;					case SEEK_SET:			absPos = *position;			break;					default:			return(__io_error);	}	if (absPos < 0)		return(__io_error);		if (absPos > eof)	{  	pb.ioMisc = (Ptr) absPos;  			if (idle_proc)		{			PBSetEOFAsync((ParmBlkPtr) &pb);						while (pb.ioResult > 0)				(*idle_proc)();		}		else			PBSetEOFSync((ParmBlkPtr) &pb);	}		if (pb.ioResult != noErr)		return(__io_error);		pb.ioPosMode   = fsFromStart;	pb.ioPosOffset = absPos;		if (idle_proc)	{		PBSetFPosAsync((ParmBlkPtr) &pb);				while (pb.ioResult > 0)			(*idle_proc)();	}	else		PBSetFPosSync((ParmBlkPtr) &pb);	*position = absPos;		return(io_result(pb.ioResult));}/* End replacement mm 980612 */int __close_file(__file_handle handle){	temp_file_info *	info;	temp_file_info *	p;	HParamBlockRec		pb;	OSErr							ioResult;		info = find_temp_info(handle);		pb.ioParam.ioRefNum = handle;		if (!(ioResult = PBCloseSync((ParmBlkPtr) &pb)) && info)	{		pb.ioParam.ioNamePtr = info->spec.name;		pb.ioParam.ioVRefNum = info->spec.vRefNum;		pb.fileParam.ioDirID = info->spec.parID;				ioResult = PBHDeleteSync(&pb);	}		if (info)	{		if (temp_info_anchor == info)								/* mm 981009 */		{															/* mm 981009 */			temp_info_anchor = info->next_struct;					/* mm 981009 */			if (temp_info_anchor != NULL) 							/* mm 000105 */				temp_info_anchor->prev_struct = NULL;				/* mm 981009 */		}															/* mm 981009 */		else														/* mm 981009 */		{															/* mm 981009 */			if ((p = info->next_struct) != NULL)					/* mm 981009 */				p->prev_struct = info->prev_struct;					/* mm 981009 */			(info->prev_struct)->next_struct = info->next_struct;	/* mm 981009 */		}															/* mm 981009 */		free(info);  												/* mm 981009 */	}		return(io_result(ioResult));}void __temp_file_name(char * name_str, void * fsspec){	static unsigned long	counter     = 0x00000000;	char					temp_name[] = "temp00000000";	unsigned long			count;	char *					name_ptr;	int						i, n;	OSErr					ioResult;	FSSpec					spec;		do 	{		count = counter++;				name_ptr = &temp_name[strlen(temp_name)];			for (i = 8; i--;)		{			n = count & 0x0F;						count >>= 4;						if (n < 10)				n += '0';			else				n += 'A' - 10;							*--name_ptr = n;		}			} while (!(ioResult = __path2fss(temp_name, &spec)));		strcpy(name_str, temp_name);		if (fsspec)		* (FSSpec *) fsspec = spec;}int __delete_file(const char * name){	FSSpec					spec;	OSErr						ioResult;	HParamBlockRec	pb;		ioResult = __path2fss(name, &spec);		if (ioResult)		return(__io_error);		pb.ioParam.ioNamePtr    = spec.name;	pb.ioParam.ioVRefNum    = spec.vRefNum;	pb.fileParam.ioFVersNum = 0;	pb.fileParam.ioDirID    = spec.parID;		ioResult = PBHDeleteSync(&pb);		return(io_result(ioResult));}int __rename_file(const char * old_name, const char * new_name){	FSSpec					old_spec, new_spec;	OSErr						ioResult;	HParamBlockRec	pb;		if (((ioResult = __path2fss(old_name, &old_spec)) != 0) && (ioResult != notAFileErr)) /* mm 980416 */		return(__io_error);		if ((ioResult = __path2fss(new_name, &new_spec)) != 0 && ioResult != fnfErr)		return(__io_error);		if (old_spec.vRefNum != new_spec.vRefNum || old_spec.parID != new_spec.parID)		return(__io_error);		if (!ioResult)		return(__io_error);		pb.ioParam.ioNamePtr    = old_spec.name;	pb.ioParam.ioVRefNum    = old_spec.vRefNum;	pb.fileParam.ioFVersNum = 0;	pb.ioParam.ioMisc       = (Ptr) new_spec.name;	pb.fileParam.ioDirID    = old_spec.parID;		return(io_result(PBHRenameSync(&pb)));      }/* Change record *	14-Aug-95 JFH  First code release. *	13-Dec-95 JFH  Changed synch read, write, and seek calls to asynch calls followed by a *								 completion loop that repeatedly calls the file's idle_proc. Although you *								 can theoretically do anything in the idle_proc, the safest (and intended) *								 course is to call YieldToAnyThread(). *  02-Jan-96 JFH  Oops! Didn't get that last one quite right. Now if idle_proc is NULL, call *								 will be made synchronously. Before, if idle_proc was NULL I was skipping the *								 call to idle_proc AND the wait loop. Instead of just fixing, I will make the *								 call synchronously to let various system hacks run (like AppleShare). *	mm 960729      Made it possible for users to set creator and file_type *  mm 960911      Corrected action of fseek to go beyond end of file.  See BR7278 *  mm 961031      Changes for Pascal *  HH 971025  You can use the PBHOpen function to open the data fork of a file.  Because PBHOpen               will also open devices, it's safter to use the PBHOppenDF function instead.  PBHOpenDF               is exactly like the PBHOpen function except that PBHOpenDF allows you to open a file               whose name begins with a period (.). *  mm 980416  Allow the renaming of directories---requires the complementary change made to __path2fss 			   to note that a directory has been found.  MW00456 *  mm 980424	Make fopen resolve aliases if possible.  MW00294 *  mm 980612  Rewrite of __position_file.c to avoid a bug in OS 8's AppleShare client: fix from Jon Hueras *  mm 981009  Change of temp_file_info structure to allow an indefinite number of files. *  mm 000105  Correct backward chain of tem file info's.  IR9908-4158 Thanks to Dieter Kohl */