/* ================================================================================================== * PropListParser.cpp													    *    Goliath - a Finder like application that implements WebDAV *    Copyright (C) 1999-2002  Thomas Bednarz * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com * =========================================================================== */#ifndef __PropListParser_h__#include "PropListParser.h"#endif#include <CXMLParser.h>#include <CDAVLibUtils.h>#include <CDAVRequest.h>#include <LFileStream.h>#include <LDynamicBuffer.h>#include <string.h>#include <stack>using namespace PropListParser;const char* PROPMAPLIST  = "propmap.list";const char* PROPMAP      = "propmap";const char* PROPERTY     = "property";const char* PNAME        = "name";const char* PVALUE       = "value";class PropListXMLParser : public CXMLParser {   public:      PropListXMLParser(PropValMapList& outputList);            virtual void StartElementHandler(const XML_Char *name, const XML_Char **atts);      virtual void EndElementHandler(const XML_Char *name);      virtual void CharacterDataHandler(const XML_Char *s, int len);   protected:      enum eCurrKey {         eNone=0,         ePropMapList,         ePropMap,         eProperty,         ePropName,         ePropVal      };      	eCurrKey	mCurrState;	std::string mCurrProp;	std::string mCurrVal;	PropValMapList&	mOutputList;		std::stack<eCurrKey>	mElemStack;};// ---------------------------------------------------------------------------------//		¥ PropListXMLParser()// ---------------------------------------------------------------------------------//PropListXMLParser::PropListXMLParser(PropValMapList& outputList) :     mCurrState(eNone),   mOutputList(outputList){	mElemStack.push(eNone);}// ---------------------------------------------------------------------------------//		¥ StartElementHandler()// ---------------------------------------------------------------------------------//void PropListXMLParser::StartElementHandler(const XML_Char *elemname, const XML_Char **) {	if (strcmp(elemname, PROPMAPLIST) == 0) {		mCurrState = ePropMapList;	} else if (strcmp(elemname, PROPMAP) == 0) {		mCurrState = ePropMap;		mOutputList.push_back(PropValMap());	} else if (strcmp(elemname, PROPERTY) == 0) {		mCurrState = eProperty;	} else if (strcmp(elemname, PNAME) == 0) {		mCurrState = ePropName;	} else if (strcmp(elemname, PVALUE) == 0) {		mCurrState = ePropVal;	} 	mElemStack.push(mCurrState);}// ---------------------------------------------------------------------------------//		¥ EndElementHandler()// ---------------------------------------------------------------------------------//void PropListXMLParser::EndElementHandler(const XML_Char* elemname) {	if (strcmp(elemname, PROPMAPLIST) == 0) {	} else if (strcmp(elemname, PROPMAP) == 0) {	} else if (strcmp(elemname, PROPERTY) == 0) {	   mOutputList[mOutputList.size()-1].insert(PropValMap::value_type(mCurrProp, mCurrVal));	   mCurrProp.clear();	   mCurrVal.clear();	} else if (strcmp(elemname, PNAME) == 0) {	} else if (strcmp(elemname, PVALUE) == 0) {	} 	mCurrState = mElemStack.top();	mElemStack.pop();}// ---------------------------------------------------------------------------------//		¥ CharacterDataHandler()// ---------------------------------------------------------------------------------//void PropListXMLParser::CharacterDataHandler(const XML_Char *s, int len) {	if (ePropName == mCurrState) {		mCurrProp.append(s, len);	} else if (ePropVal == mCurrState) {		mCurrVal.append(s, len);		}} // ---------------------------------------------------------------------------------//		¥ LoadPropList()// ---------------------------------------------------------------------------------//bool PropListParser::LoadPropList(const FSSpec& inPropListFile, PropValMapList& outPVMList) {   PropListXMLParser propParser(outPVMList);      LFileStream filestream(inPropListFile);   if (!filestream.SpecifierExists())      return false;   filestream.OpenDataFork(fsRdPerm);   XML_Error err = propParser.ParseXMLDocument(filestream);   filestream.CloseDataFork();   if (err != XML_ERROR_NONE)       return false;         return true;}// ---------------------------------------------------------------------------------//		¥ LoadPropList()// ---------------------------------------------------------------------------------//bool PropListParser::SavePropList(const FSSpec& inPropListFile, const PropValMapList& inPVMList) {   LDynamicBuffer dynBuf;   CXMLStringUtils::beginXMLDAVBody(dynBuf);   CXMLStringUtils::startElement(dynBuf, PROPMAPLIST);   dynBuf+="\n";   for (PropValMapList::const_iterator iter = inPVMList.begin(); iter!= inPVMList.end(); ++iter) {      CXMLStringUtils::startElement(dynBuf, PROPMAP);      for (PropValMap::const_iterator piter = (*iter).begin(); piter != (*iter).end(); ++piter) {         CXMLStringUtils::startElement(dynBuf, PROPERTY);         CXMLStringUtils::startElement(dynBuf, PNAME);         dynBuf.ConcatenateBuffer((*piter).first.c_str());            CXMLStringUtils::endElement(dynBuf, PNAME);         CXMLStringUtils::startElement(dynBuf, PVALUE);         dynBuf.ConcatenateBuffer((*piter).second.c_str());                   CXMLStringUtils::endElement(dynBuf, PVALUE);                CXMLStringUtils::endElement(dynBuf, PROPERTY);       	 dynBuf+="\n";      }      CXMLStringUtils::endElement(dynBuf, PROPMAP);      dynBuf+="\n";   }   CXMLStringUtils::endElement(dynBuf, PROPMAPLIST);   LFile outFile(inPropListFile);   return CDAVRequest::DynBufferToFile(&dynBuf, outFile);}