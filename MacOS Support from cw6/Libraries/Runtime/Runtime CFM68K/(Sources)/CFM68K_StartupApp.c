/* *	StartupApp.c		-	init/startup/termination routines for Metrowerks C++ (CFM68K) * *	Copyright © 1995-1997 Metrowerks, Inc. All Rights Reserved. * * *	THEORY OF OPERATION * *	This version of the PPC startup code is intended to be used for multi-fragment *	applications. It is designed to properly support exceptions thrown across fragment *	boundaries, and proper initialization and termination--including construction and *	destruction of static objects--for all fragments that make up the program. * *	The startup file defines 3 entry-points: * *		__start			This must be the Main Entry-Point for the Application. *						__start() calls main(), and then calls exit() *						to terminate the program. * *		__initialize	This must be the Initialization Entry-Point for the Application. *						__initialize() registers the exception-handling info for *						the application, and calls all static initializers. * *		__terminate		This must be the Termination Entry-Point for the Application *						__terminate() unregisters the exception-handling info for the *						shared application before the fragment is unloaded. * *	The new zero-runtime-overhead exception-handling mechanism requires that we *	keep track of all loaded fragments and their code/data section ranges--we *	cannot use the OS data structures to do this--so we must call routines which *	register and unregister the exception-handling info as a fragment is loaded/unloaded. * *	The exit() routine will handle all termination responsibilities in the proper *	order. In particular, it will call all atexit() routines before destroying any *	static objects, and it will clean up the I/O and console packages after *	destroying all static objects. * */#include <CodeFragments.h>#include <Exception68K.h>#include <NMWException.h>#include <stdlib.h>#include <Types.h>	/*	external data	*/extern far segment_map SEGMAPNAME[];	/*	private data	*/static long fragmentID;						/*	ID given to fragment by exception-handling	*/	/*	prototypes	*/#ifdef __cplusplusextern "C" {#endif#pragma internal onvoid __InitCode__(void);#pragma internal resetlong main(long argc, char **argv);pascal OSErr __initialize(const CFragInitBlock *theInitBlock);pascal void __terminate(void);pascal void __start(void);#ifdef __cplusplus}#endifchar *GetA5TOC(void) = 0x200D;			/* move.l a5,d0 *//* *	The linker will replace this dummy routine with a linker generated routine containing *	a list of calls to all our static initialization routines ... * *					MOVEA.L		(A1),A5 *					LINK		A6,#$FFF8 *					BSR.L		__InitCode0__ *					... *					BSR.L		__InitCodeN__ *					UNLK		A6 *					RTS * *	NB: for now this will only work under the single segment model */void __InitCode__(void){}/* *	__initialize	-	Default initialization routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF initialization routine in the container *	for any multi-fragment application. * */pascal OSErr __initialize(const CFragInitBlock *theInitBlock){#pragma unused (theInitBlock)	/* register this code fragment with the Exception Handling mechanism */	fragmentID = __register_fragment(SEGMAPNAME, GetA5TOC());		/* call all static initializers */	__InitCode__();		/* return success to Code Fragment Manager */	return(noErr);}/* *	__start	-	Default startup routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF main routine in the container *	for any monolithic application. * *	We defer all details of proper program termination to the ANSI exit() routine. * */pascal void __start(void){	char *argv = 0;	/* call main(argc, argv) */	main(0L, &argv);		/* call exit() to terminate the program properly--will not return */	exit(0);}/* *	__terminate	-	Default termination routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF termination routine in the container *	for any multi-fragment application. * */pascal void __terminate(void){	/* unregister this code fragment with the Exception Handling mechanism */	__unregister_fragment(fragmentID);}