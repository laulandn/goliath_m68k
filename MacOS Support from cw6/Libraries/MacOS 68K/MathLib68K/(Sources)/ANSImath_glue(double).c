/* *	math.h glue functions (double precision math) ... */#ifndef __FP__	#include <fp.h>#endif/* *	We can't include both fp.h and math.h since their definitions of cos, etc... conflict */#ifdef cplusplusextern "C" {#endifdouble acosd(double x);double asind(double x);double atand(double x);double atan2d(double y, double x);double cosd(double x);double sind(double x);double tand(double x);double coshd(double x);double sinhd(double x);double tanhd(double x);double acoshd(double x);double asinhd(double x);double atanhd(double x);double expd(double x);double frexpd(double value, int *exp);double ldexpd(double x, int exp);double logd(double x);double log10d(double x);double modfd(double value, double *iptr);double exp2d(double x);double expm1d(double x);double log1pd(double x);double log2d(double x);double logbd(double x);double scalbn(double x, int n);double scalbln(double x, long n);double fabsd(double x);double powd(double x, double y);double sqrtd(double x);double hypotd(double x, double y);double erfd(double x);double erfcd(double x);double gammad(double x);double lgammad(double x);double ceild(double x);double floord(double x);double nearbyintd(double x);double rintd(double x);long lrint(double x);long long llrint(double x);double roundd(double x);long lround(double x);long long llround(double x);double truncd(double x);double fmodd(double x, double y);double remainderd(double x, double y);double remquod(double x, double y, int* quo);double copysignd(double x, double y);double fdimd(double x, double y);double fmaxd(double x, double y);double fmind(double x, double y);/*double fma(double x, double y, double z);*/#ifdef cplusplus}#endif/********************************************************************************                            Trigonometric functions                           ********************************************************************************/double acosd(double x){	return (double)acos(x);}double asind(double x){	return (double)asin(x);}double atand(double x){	return (double)atan(x);}double atan2d(double y, double x){	return (double)atan2(y, x);}double cosd(double x){	return (double)cos(x);}double sind(double x){	return (double)sin(x);}double tand(double x){	return (double)tan(x);}/********************************************************************************                              Hyperbolic functions                            ********************************************************************************/double coshd(double x){	return (double)cosh(x);}double sinhd(double x){	return (double)sinh(x);}double tanhd(double x){	return (double)tanh(x);}double acoshd(double x){	return (double)acosh(x);}double asinhd(double x){	return (double)asinh(x);}double atanhd(double x){	return (double)atanh(x);}/********************************************************************************                              Exponential functions                           ********************************************************************************/double expd(double x){	return (double)exp(x);}double frexpd(double value, int *exp){	return (double)frexp(value, exp);}double ldexpd(double x, int exp){	return (double)ldexp(x, exp);}double logd(double x){	return (double)log(x);}double log10d(double x){	return (double)log10(x);}double modfd(double value, double *iptr){	double_t iptrl;	double result = (double)modf(value, &iptrl);	*iptr = (double)iptrl;	return result;}double exp2d(double x){	return (double)exp2(x);}double expm1d(double x){	return (double)expm1(x);}double log1pd(double x){	return (double)log1p(x);}double log2d(double x){	return (double)log2(x);}double logbd(double x){	return (double)logb(x);}double scalbn(double x, int n){	return (double)scalb(x, n);}double scalbln(double x, long n){	return (double)scalb(x, n);}/********************************************************************************                     Power and absolute value functions                       ********************************************************************************/double fabsd(double x){	return (double)fabs(x);}double powd(double x, double y){	return (double)pow(x,y);}double sqrtd(double x){	return (double)sqrt(x);}double hypotd(double x, double y){	return (double)hypot(x, y);}double erfd(double x){	return (double)erf(x);}double erfcd(double x){	return (double)erfc(x);}double gammad(double x){	return (double)gamma(x);}double lgammad(double x){	return (double)lgamma(x);}/********************************************************************************                        Nearest integer functions                             ********************************************************************************/double ceild(double x){	return (double)ceil(x);}double floord(double x){	return (double)floor(x);}double nearbyintd(double x){	return (double)nearbyint(x);}double rintd(double x){	return (double)rint(x);}long lrint(double x){	return rinttol(x);}long long llrint(double x){	return (long long)rint(x);}double roundd(double x){	return (double)round(x);}long lround(double x){	return roundtol(x);}long long llround(double x){	return (long long)round(x);}double truncd(double x){	return (double)trunc(x);}/********************************************************************************                            Remainder functions                               ********************************************************************************/double fmodd(double x, double y){	return (double)fmod(x, y);}double remainderd(double x, double y){	return (double)remainder(x, y);}double remquod(double x, double y, int* quo){	return (double)remquo(x, y, quo);}double copysignd(double x, double y){	return (double)copysign(x, y);}double fdimd(double x, double y){	return (double)fdim(x, y);}double fmaxd(double x, double y){	return (double)fmax(x, y);}double fmind(double x, double y){	return (double)fmin(x, y);}/*double fma(double x, double y, double z){	return (double)((long double)x*y + z);}*/