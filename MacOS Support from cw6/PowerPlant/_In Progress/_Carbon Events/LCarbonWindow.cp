// ===========================================================================//	LCarbonWindow.cp			PowerPlant 2.1		©1993-2000 Metrowerks Inc.// ===========================================================================#ifdef PowerPlant_PCH	#include PowerPlant_PCH#endif#include <LCarbonWindow.h>#include <LModelProperty.h>#include <LStream.h>#include <TArrayIterator.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <UAppleEventsMgr.h>#include <UExtractFromAEDesc.h>#include <UReanimator.h>#include <UWindows.h>#include <UDrawingUtils.h>#include <UDrawingState.h>#include <UEventMgr.h>#include <UEnvironment.h>#include <UAppearance.h>#include <UMemoryMgr.h>#include <UTBAccessors.h>#include <AEPackObject.h>#include <AEObjects.h>#include <AERegistry.h>#include <MacWindows.h>#include <Sound.h>#include <ToolUtils.h>PP_Begin_Namespace_PowerPlant// ---------------------------------------------------------------------------//	Constantsconst DescType	pWindowPosition = FOUR_CHAR_CODE('ppos');const SInt16	length_Big		= 16000;// ---------------------------------------------------------------------------//	Class VariablesTArray<WindowPtr>	LCarbonWindow::sWindowList;// ---------------------------------------------------------------------------//	UPP for Carbon Event HandlerEventHandlerUPP	TEventHandler<LCarbonWindow>::sHandlerUPP;// ---------------------------------------------------------------------------//	¥ CreateWindow											 [static] [public]// ---------------------------------------------------------------------------//	Return a newly created Window object initialized from a PPob resourceLCarbonWindow*LCarbonWindow::CreateWindow(	ResIDT			inWindowID,	LCommander*		inSuperCommander){	SetDefaultCommander(inSuperCommander);	SetDefaultAttachable(nil);		LCarbonWindow	*theWindow = static_cast<LCarbonWindow*>						(UReanimator::ReadObjects(ResType_PPob, inWindowID));	ThrowIfNil_(theWindow);		try {		theWindow->FinishCreate();		if (theWindow->HasAttribute(windAttr_ShowNew)) {			theWindow->Show();		}	}		catch (...) {						// FinishCreate failed. Window is		delete theWindow;				//   in an inconsistent state.		throw;							//   Delete it and rethrow	}		return theWindow;}// ---------------------------------------------------------------------------//	¥ LCarbonWindow								Default Constructor		  [public]// ---------------------------------------------------------------------------LCarbonWindow::LCarbonWindow(){	mMacWindowP			 = nil;	mStandardSize.width  = max_Int16;	mStandardSize.height = max_Int16;	mMoveOnlyUserZoom	 = false;	mAttributes			 = windAttr_Regular;		::MacSetRect(&mMinMaxSize, 0, 0, length_Big, length_Big);	mUserBounds = Rect_0000;	SetModelKind(cWindow);	SetUseSubModelList(true);		mForeColor = Color_Black;	mBackColor = Color_White;		mActiveBackgroundBrush	 = 0;	mInactiveBackgroundBrush = 0;	mActiveTextColor		 = 0;	mInactiveTextColor		 = 0;}// ---------------------------------------------------------------------------//	¥ LCarbonWindow								Constructor				  [public]// ---------------------------------------------------------------------------//	Construct Window from the data in a structLCarbonWindow::LCarbonWindow(	const SWindowInfo&	inWindowInfo){	InitWindow(inWindowInfo);	SetModelKind(cWindow);	SetUseSubModelList(true);		InstallEventHandlers();}// ---------------------------------------------------------------------------//	¥ LCarbonWindow								Constructor				  [public]// ---------------------------------------------------------------------------//	Construct a Window from a WIND Resource with the specified attributes//	and SuperCommanderLCarbonWindow::LCarbonWindow(	ResIDT			inWINDid,	UInt32			inAttributes,	LCommander*		inSuperCommander)		: LCommander(inSuperCommander){	mStandardSize.width  = max_Int16;	mStandardSize.height = max_Int16;	mMoveOnlyUserZoom	 = false;	mAttributes			 = inAttributes;		::MacSetRect(&mMinMaxSize, 0, 0, length_Big, length_Big);	SetModelKind(cWindow);	SetUseSubModelList(true);	MakeMacWindow(inWINDid);	FocusDraw();	::GetForeColor(&mForeColor);	::GetBackColor(&mBackColor);		InstallEventHandlers();}// ---------------------------------------------------------------------------//	¥ LCarbonWindow							Parameterized Constructor [public]// ---------------------------------------------------------------------------LCarbonWindow::LCarbonWindow(	LCommander*		inSuperCommander,	const Rect&		inGlobalBounds,	ConstStringPtr	inTitle,	UInt32			inAttributes,	WindowPtr		inBehind)		: LCommander(inSuperCommander){	mStandardSize.width  = max_Int16;	mStandardSize.height = max_Int16;	mMoveOnlyUserZoom	 = false;	mAttributes			 = inAttributes;		::MacSetRect(&mMinMaxSize, 0, 0, length_Big, length_Big);		mMacWindowP = NewMacWindow(inGlobalBounds, inTitle,								HasAttribute(windAttr_CloseBox),								inBehind);	ThrowIfNil_(mMacWindowP);		sWindowList.AddItem(mMacWindowP);		SetWindowKind(mMacWindowP, PP_Window_Kind);										// Stuff object pointer in refcon	::SetWRefCon(mMacWindowP, (long) this);										// Window Frame and Image are the same									//   as its portRect		Rect	portBounds;	::GetWindowPortBounds(mMacWindowP, &portBounds);		ResizeFrameTo((SInt16) (portBounds.right - portBounds.left),				  (SInt16) (portBounds.bottom - portBounds.top),				  Refresh_No);					  	ResizeImageTo(portBounds.right - portBounds.left,				  portBounds.bottom - portBounds.top,				  Refresh_No);		CalcRevealedRect();										// Initial size and location are the									// "user" state for zooming	CalcPortFrameRect(mUserBounds);		PortToGlobalPoint(topLeft(mUserBounds));	PortToGlobalPoint(botRight(mUserBounds));	mVisible = triState_Off;	mActive = triState_Off;	mEnabled = triState_Off;	if (HasAttribute(windAttr_Enabled)) {		mEnabled = triState_On;	}		FocusDraw();	::GetForeColor(&mForeColor);	::GetBackColor(&mBackColor);	SetModelKind(cWindow);	SetUseSubModelList(true);		mActiveBackgroundBrush	 = 0;	mInactiveBackgroundBrush = 0;	mActiveTextColor		 = 0;	mInactiveTextColor		 = 0;		InstallEventHandlers();}// ---------------------------------------------------------------------------//	¥ LCarbonWindow								Stream Constructor		  [public]// ---------------------------------------------------------------------------LCarbonWindow::LCarbonWindow(	LStream*	inStream){	SWindowInfo	windowInfo;	inStream->ReadData(&windowInfo, sizeof(SWindowInfo));	InitWindow(windowInfo);	SetDefaultView(this);	SetModelKind(cWindow);	SetUseSubModelList(true);		InstallEventHandlers();}// ---------------------------------------------------------------------------//	¥ ~LCarbonWindow								Destructor				  [public]// ---------------------------------------------------------------------------LCarbonWindow::~LCarbonWindow(){	if (mMacWindowP != nil) {										// Hide window to ensure proper										//   ordering of remaining windows		::HideWindow(mMacWindowP);												// Delete subpanes *before* disposing of Toolbox WindowRecord.			// The LView destructor will delete subpanes, but it gets			// called after this destructor (since LCarbonWindow is derived			// from LView). If we dispose of the Toolbox WindowRecord first,			// it causes problems for Panes based on other Toolbox data			// structures, such as standard Controls and TextEdit, that			// store their own reference to a WindowRecord.					DeleteAllSubPanes();										// Forget this WindowPtr		sWindowList.Remove(mMacWindowP);				::DisposeWindow(mMacWindowP);	// Kill Toolbox Window		mMacWindowP = nil;	}}#pragma mark -// ---------------------------------------------------------------------------//	¥ InitWindow// ---------------------------------------------------------------------------//	Private Initializer from data in a structvoidLCarbonWindow::InitWindow(	const SWindowInfo	&inWindowInfo){	mAttributes = inWindowInfo.attributes;									// Set Attribute for Window Layer	EWindAttr	windLayerAttr = windAttr_Regular;	if (inWindowInfo.layer == windLayer_Modal) {		windLayerAttr = windAttr_Modal;	} else if (inWindowInfo.layer == windLayer_Floating) {		windLayerAttr = windAttr_Floating;	}	SetAttribute(windLayerAttr);									// Set Min and Max Window Size	mMinMaxSize.left = inWindowInfo.minimumWidth;	mMinMaxSize.top = inWindowInfo.minimumHeight;	mMinMaxSize.right = inWindowInfo.maximumWidth;	if (mMinMaxSize.right < 0) {		mMinMaxSize.right = length_Big;	}	mMinMaxSize.bottom = inWindowInfo.maximumHeight;	if (mMinMaxSize.bottom < 0) {		mMinMaxSize.bottom = length_Big;	}									// Set Standard Size for Zooming	mStandardSize = inWindowInfo.standardSize;	if (mStandardSize.width < 0) {		mStandardSize.width = max_Int16;	}	if (mStandardSize.height < 0) {		mStandardSize.height = max_Int16;	}	mMoveOnlyUserZoom = false;		SetUserCon(inWindowInfo.userCon);		MakeMacWindow(inWindowInfo.WINDid);	::SetPortWindowPort(mMacWindowP);								// Get current window colors	::GetForeColor(&mForeColor);	::GetBackColor(&mBackColor);		FocusDraw();}// ---------------------------------------------------------------------------//	¥ MakeMacWindow// ---------------------------------------------------------------------------//	Make a new Mac Window from a WIND resource templatevoidLCarbonWindow::MakeMacWindow(	SInt16		inWINDid){	SetPaneID(inWINDid);	mMacWindowP = NewMacWindow(inWINDid, window_InFront);	ThrowIfNil_(mMacWindowP);										// Remember this WindowPtr	sWindowList.AddItem(mMacWindowP);			// Inside Mac says that an Application may set the windowKind		// field of a WindowRecord to any value greater than 8 if		// desired. PowerPlant requires that the windowKind for		// windows associated with a LCarbonWindow object be >= PP_Window_Kind,		// which is a large constant. For such windows, PowerPlant		// stores a pointer to the LCarbonWindow object in the refCon.		// If you wish to use unique kinds for your windows (it's the		// only way to differentiate LCarbonWindow subclasses from just looking		// at a Toolbox WindowRecord), store the kind number in the		// refCon field of the WIND resource.											// Get WIND resource to check refCon	SWINDResourceH	theWIND = (SWINDResourceH) ::GetResource(ResType_MacWindow, inWINDid);	SInt16	kind = (SInt16) (**theWIND).refCon;	if (kind < PP_Window_Kind) {	// Use value from refCon if it is		kind = PP_Window_Kind;		//   greater than our special number	}	SetWindowKind(mMacWindowP, kind);	::ReleaseResource((Handle) theWIND);									// Stuff object pointer in refcon	::SetWRefCon(mMacWindowP, (long) this);										// Window Frame and Image are the same									//   as its portRect		Rect	portBounds;	::GetWindowPortBounds(mMacWindowP, &portBounds);		ResizeFrameTo((SInt16) (portBounds.right - portBounds.left),				  (SInt16) (portBounds.bottom - portBounds.top),				  Refresh_No);					  	ResizeImageTo(portBounds.right - portBounds.left,				  portBounds.bottom - portBounds.top,				  Refresh_No);		CalcRevealedRect();										// Initial size and location are the									// "user" state for zooming	CalcPortFrameRect(mUserBounds);		PortToGlobalPoint(topLeft(mUserBounds));	PortToGlobalPoint(botRight(mUserBounds));	mVisible = triState_Off;	mActive = triState_Off;	mEnabled = triState_Off;	if (HasAttribute(windAttr_Enabled)) {		mEnabled = triState_On;	}		mActiveBackgroundBrush	 = 0;	mInactiveBackgroundBrush = 0;	mActiveTextColor		 = 0;	mInactiveTextColor		 = 0;}WindowPtrLCarbonWindow::NewMacWindow(	const Rect&		inGlobalBounds,	ConstStringPtr	inTitle,	bool			inHasGoAway,	WindowPtr		inBehind){										// Map from PP window layer to										//   Toolbox WindowClass	WindowClass		windClass = kDocumentWindowClass;	if (HasAttribute(windAttr_Modal)) {		windClass = kMovableModalWindowClass;	} else if (HasAttribute(windAttr_Floating)) {		windClass = kFloatingWindowClass;	}			// Set Toolbox WindowAttributes based on PP LWindow atrributes											WindowAttributes	windAttr = kWindowNoAttributes;	windAttr += kWindowStandardHandlerAttribute;											// PP has no option for this, so										//   make all non-modal windows										//   collapsible	if (windClass >= kFloatingWindowClass) {		windAttr = kWindowCollapseBoxAttribute;	}		if (inHasGoAway) {		windAttr += kWindowCloseBoxAttribute;	}		if (HasAttribute(windAttr_Zoomable)) {		windAttr += kWindowFullZoomAttribute;	}		if (HasAttribute(windAttr_Resizable)) {		windAttr += kWindowResizableAttribute;	}											// Now we can create Toolbox window	WindowPtr	windowP;	ThrowIfOSStatus_( ::CreateNewWindow(windClass, windAttr,										&inGlobalBounds, &windowP) );										::SetWTitle(windowP, inTitle);			// On Mac OS 8.6, there seems to be a bug with SendBehind.		// If you call InitWindows, it works. If you call		// InitFloatingWindows, it does nothing.		if (inBehind != window_InFront) {		::SendBehind(windowP, inBehind);	}		return windowP;}WindowPtrLCarbonWindow::NewMacWindow(	ResIDT			inWINDid,	WindowPtr		inBehind){										// Map from PP window layer to										//   Toolbox WindowClass	WindowClass		windClass = kDocumentWindowClass;	if (HasAttribute(windAttr_Modal)) {		windClass = kMovableModalWindowClass;	} else if (HasAttribute(windAttr_Floating)) {		windClass = kFloatingWindowClass;	}			// Set Toolbox WindowAttributes based on PP LWindow atrributes			WindowAttributes	windAttr = kWindowNoAttributes;	windAttr += kWindowStandardHandlerAttribute;																			// PP has no option for this, so										//   make all non-modal windows										//   collapsible	if (windClass >= kFloatingWindowClass) {		windAttr += kWindowCollapseBoxAttribute;	}		if (HasAttribute(windAttr_CloseBox)) {		windAttr += kWindowCloseBoxAttribute;	}		if (HasAttribute(windAttr_Zoomable)) {		windAttr += kWindowFullZoomAttribute;	}		if (HasAttribute(windAttr_Resizable)) {		windAttr += kWindowResizableAttribute;	}			// We need to get the WIND resource to find the:		//		- Side Title option for Floaters		//		- Window Bounds		//		- Window Title		//		- Window Positioning Constant		Handle	theWIND = ::GetResource(ResType_MacWindow, inWINDid);		ThrowIfResFail_(theWIND);		StHandleLocker	lockWIND(theWIND);		SWINDResourceP	theWINDInfo = (SWINDResourceP) *theWIND;											// Side Title option for Floaters	if ( (windClass == kFloatingWindowClass)  &&		 (theWINDInfo->procID & kSideFloaterVariantCode) ) {			windAttr += kWindowSideTitlebarAttribute;	}											// Now we can create Toolbox window	WindowPtr	windowP;	ThrowIfOSStatus_( ::CreateNewWindow(windClass, windAttr,										&theWINDInfo->bounds, &windowP) );																				// Set Window title using title from										//   WIND resource	::SetWTitle(windowP, theWINDInfo->title);			// On Mac OS 8.6, there seems to be a bug with SendBehind.		// If you call InitWindows, it works. If you call		// InitFloatingWindows, it does nothing.		if (inBehind != window_InFront) {		::SendBehind(windowP, inBehind);	}			// The Window Positioning Constant comes after the title. It is		// word aligned.		unsigned char*	posP = theWINDInfo->title + theWINDInfo->title[0] + 1;	if ((theWINDInfo->title[0] & 0x0001) == 0) {		posP += 1;						// Align to 2-byte boundary	}		UInt16	posConstant = *(UInt16*) posP;			// The System 7 Window Positioning Constants and the new Window		// Positioning Methods have different values. So, we must map to		// the new values.			WindowPositionMethod	posMethod = 0;		switch (posConstant) {			case kWindowCenterMainScreen:			posMethod = kWindowCenterOnMainScreen;			break;					case kWindowAlertPositionMainScreen:			posMethod = kWindowAlertPositionOnMainScreen;			break;					case kWindowStaggerMainScreen:			posMethod = kWindowCascadeOnMainScreen;			break;					case kWindowCenterParentWindow:			posMethod = kWindowCenterOnParentWindow;			break;					case kWindowAlertPositionParentWindow:			posMethod = kWindowAlertPositionOnParentWindow;			break;					case kWindowStaggerParentWindow:			posMethod = kWindowCascadeOnParentWindow;			break;					case kWindowCenterParentWindowScreen:			posMethod = kWindowCenterOnParentWindowScreen;			break;					case kWindowAlertPositionParentWindowScreen:			posMethod = kWindowAlertPositionOnParentWindowScreen;			break;					case kWindowStaggerParentWindowScreen:			posMethod = kWindowCascadeOnParentWindowScreen;			break;				}				// Set the window position. The "parent" window is always			// the front window.				if (posMethod != 0) {		::RepositionWindow(windowP, ::FrontWindow(), posMethod);	}				// If there is a 'wctb' resource with the same ID as			// the 'WIND', set the eindow's background color to			// the content color from the color table.		StResource	wctbResource(ResType_WindowColorTable, inWINDid,								Throw_No);		RGBColor	contentColor;								if (UWindows::GetColorTableEntry( (CTabHandle) wctbResource.Get(),									  wContentColor,									  contentColor ) ) {				StGrafPortSaver	savePort;							  		::SetPortWindowPort(windowP);		::RGBBackColor(&contentColor);	}	return windowP;}// ---------------------------------------------------------------------------//	¥ InstallEventHandlers// ---------------------------------------------------------------------------//	Install Carbon Event Handlers////	The handlers are template-based functors. The Toolbox callback calls//	a member function of a LCarbonWindow object.////	The functors are member variables, which get desctructed when the//	window is deleted. Destructing a function uninstalls the event handler//	from the system.voidLCarbonWindow::InstallEventHandlers(){	mUpdateHandler.Install(							::GetWindowEventTarget(mMacWindowP),							kEventClassWindow,							kEventWindowUpdate,							this,						 	&HandleUpdate );								   	mActivateHandler.Install(							::GetWindowEventTarget(mMacWindowP),							kEventClassWindow,							kEventWindowActivated,							this,							&HandleActivate );								   	mDeactivateHandler.Install(							::GetWindowEventTarget(mMacWindowP),							kEventClassWindow,							kEventWindowDeactivated,							this,							&HandleDeactivate );								   	mClickContentHandler.Install(							::GetWindowEventTarget(mMacWindowP),							kEventClassWindow,							kEventWindowClickContentRgn,							this,							&HandleClickContent );								   	mCloseHandler.Install(							::GetWindowEventTarget(mMacWindowP),							kEventClassWindow,							kEventWindowClose,							this,							&HandleClose );}#pragma mark -// ---------------------------------------------------------------------------//	¥ FetchWindowObject												  [static]// ---------------------------------------------------------------------------//	Return the PowerPlant Window object associated with a Mac WindowPtr////	Returns nil if the WindowPtr is not a PowerPlant WindowLCarbonWindow*LCarbonWindow::FetchWindowObject(	WindowPtr	inWindowP){	LCarbonWindow*	ppWindow = nil;									// LCarbonWindow class mainatins a list of									//   all WindowPtr's that we created	if ( (inWindowP != nil)  &&		 sWindowList.ContainsItem(inWindowP) ) {									// Object pointer is in the refCon			ppWindow = (LCarbonWindow*) ::GetWRefCon(inWindowP);	}		return ppWindow;}// ---------------------------------------------------------------------------//	¥ GetMacPort// ---------------------------------------------------------------------------//	Return Toolbox GrafPort associated with a Window objectGrafPtrLCarbonWindow::GetMacPort() const{	return (GrafPtr) GetWindowPort(mMacWindowP);}// ---------------------------------------------------------------------------//	¥ GetMacWindow// ---------------------------------------------------------------------------//	Return Toolbox WindowPtr associated with a Window objectWindowPtrLCarbonWindow::GetMacWindow() const{	return mMacWindowP;}// ---------------------------------------------------------------------------//	¥ GetGlobalBounds// ---------------------------------------------------------------------------//	Pass back the port rectangle of a Window in global coordsvoidLCarbonWindow::GetGlobalBounds(	Rect	&outBounds) const{	CalcPortFrameRect(outBounds);	PortToGlobalPoint(topLeft(outBounds));	PortToGlobalPoint(botRight(outBounds));}// ---------------------------------------------------------------------------//	¥ GetDescriptor// ---------------------------------------------------------------------------//	Return the title of a WindowStringPtrLCarbonWindow::GetDescriptor(	Str255	outDescriptor) const{	::GetWTitle(mMacWindowP, outDescriptor);	return outDescriptor;}// ---------------------------------------------------------------------------//	¥ SetDescriptor// ---------------------------------------------------------------------------//	Set the title of a WindowvoidLCarbonWindow::SetDescriptor(	ConstStringPtr	inDescriptor){	::SetWTitle(mMacWindowP, inDescriptor);}// ---------------------------------------------------------------------------//	¥ IsSelected// ---------------------------------------------------------------------------boolLCarbonWindow::IsSelected() const{	WindowClass	theLayer;	::GetWindowClass(mMacWindowP, &theLayer);		WindowPtr	frontOfLayer = ::GetFrontWindowOfClass(theLayer, true);		return (mMacWindowP == frontOfLayer);}#pragma mark -// ---------------------------------------------------------------------------//	¥ ClickInContent// ---------------------------------------------------------------------------//	Respond to a click in the content region of a WindowvoidLCarbonWindow::ClickInContent(	const EventRecord	&inMacEvent){									// Enabled Windows respond to clicks	Boolean		respondToClick = HasAttribute(windAttr_Enabled);										// Set up our extended event record	SMouseDownEvent		theMouseDown;	theMouseDown.wherePort	 = inMacEvent.where;	GlobalToPortPoint(theMouseDown.wherePort);	theMouseDown.whereLocal	 = theMouseDown.wherePort;	theMouseDown.macEvent	 = inMacEvent;	theMouseDown.delaySelect = false;		if (not IsSelected()) {									// Window is not in front, we might									//   need to select it		bool	doSelect = true;		if (HasAttribute(windAttr_DelaySelect)) {									// Delay selection until after handling									//   the click (called click-through)			theMouseDown.delaySelect = true;			Click(theMouseDown);												// After click-through, we select the									//   Window if the mouse is still down									//   or the mouse up occurred inside									//   this Window.												EventRecord	mouseUpEvent;			if (!::StillDown() && UEventMgr::GetMouseUp(mouseUpEvent)) {									// Check location of mouse up event				WindowPtr	upWindow;				::MacFindWindow(mouseUpEvent.where, &upWindow);				doSelect = (upWindow == mMacWindowP);			}		}				if (doSelect) {				// Selecting a Window brings it to the									//   front of its layer and activates it			Select();			respondToClick = HasAttribute(windAttr_GetSelectClick);		}	}		if (respondToClick) {		if (!theMouseDown.delaySelect) {			Click(theMouseDown);		} else {			sLastPaneClicked = nil;		}	}}#pragma mark -// ---------------------------------------------------------------------------//	¥ HandleUpdate// ---------------------------------------------------------------------------OSStatusLCarbonWindow::HandleUpdate(	EventHandlerCallRef	/* inCallRef */,	EventRef			/* inEventRef */){	UpdatePort();	return noErr;}// ---------------------------------------------------------------------------//	¥ HandleActivate// ---------------------------------------------------------------------------OSStatusLCarbonWindow::HandleActivate(	EventHandlerCallRef	/* inCallRef */,	EventRef			/* inEventRef */){	Activate();	return noErr;}// ---------------------------------------------------------------------------//	¥ HandleDeactivate// ---------------------------------------------------------------------------OSStatusLCarbonWindow::HandleDeactivate(	EventHandlerCallRef	/* inCallRef */,	EventRef			/* inEventRef */){	Deactivate();	return noErr;}// ---------------------------------------------------------------------------//	¥ HandleClickContent// ---------------------------------------------------------------------------OSStatusLCarbonWindow::HandleClickContent(	EventHandlerCallRef	/* inCallRef */,	EventRef			inEventRef){		// $$$ This does not work. Need to figure out how to		// create a Classic mouse down EventRecord from the EventRef	OSStatus		result = eventNotHandledErr;	EventRecord		clickEvent;		if (::ConvertEventRefToEventRecord(inEventRef, &clickEvent)) {			ClickInContent(clickEvent);		result = noErr;	}	return result;}// ---------------------------------------------------------------------------//	¥ HandleClose// ---------------------------------------------------------------------------OSStatusLCarbonWindow::HandleClose(	EventHandlerCallRef	/* inCallRef */,	EventRef			/* inEventRef */){	ProcessCommand(cmd_Close);	return noErr;}#pragma mark -// ---------------------------------------------------------------------------//	¥ UpdatePort// ---------------------------------------------------------------------------//	Redraw invalidated area of the Window////	The Mac WindowPtr maintains an update region that defines the area//	that needs to be redrawn.voidLCarbonWindow::UpdatePort(){								// Quick exit if there's nothing to update#if PP_Target_Carbon	{		StRegion	updateRgn;		::GetWindowRegion(mMacWindowP, kWindowUpdateRgn, updateRgn);				if (::EmptyRgn(updateRgn)) {			return;		}	}	#else	if (::EmptyRgn(((WindowPeek) mMacWindowP)->updateRgn)) {		return;	}	#endif	GrafPtr		originalPort = UQDGlobals::GetCurrentPort();		::SetPortWindowPort(mMacWindowP);	::SetOrigin(0,0);	OutOfFocus(nil);		::BeginUpdate(mMacWindowP);		try {			#if PP_Target_Carbon					StRegion	visRgn;			::GetPortVisibleRegion(GetWindowPort(mMacWindowP), visRgn);			Draw(visRgn);				#else					Draw(mMacWindowP->visRgn);					#endif	}		catch (...) {		SignalStringLiteral_("Drawing exception caught in LCarbonWindow::UpdatePort");	}		::EndUpdate(mMacWindowP);		::MacSetPort(originalPort);	OutOfFocus(nil);}// ---------------------------------------------------------------------------//	¥ EstablishPort// ---------------------------------------------------------------------------//	Make Window the current Port////	Usage Note: If you call this function directly, you should call//		LView::OutOfFocus(nil), since changing the current port may//		invalidate the Focus.BooleanLCarbonWindow::EstablishPort(){	Boolean	portSet = (mMacWindowP != nil);	if (portSet && (UQDGlobals::GetCurrentWindowPort() != mMacWindowP)) {		::SetPortWindowPort(mMacWindowP);	}	return portSet;}// ---------------------------------------------------------------------------//	¥ InvalPortRect// ---------------------------------------------------------------------------voidLCarbonWindow::InvalPortRect(	const Rect	*inRect){	StPortOriginState	portOriginState((GrafPtr) ::GetWindowPort(mMacWindowP));	::SetOrigin(0, 0);#if PP_Target_Carbon	::InvalWindowRect(mMacWindowP, inRect);	#else	::InvalRect(inRect);	#endif}// ---------------------------------------------------------------------------//	¥ InvalPortRgn// ---------------------------------------------------------------------------voidLCarbonWindow::InvalPortRgn(	RgnHandle	inRgnH){	StPortOriginState	portOriginState((GrafPtr) ::GetWindowPort(mMacWindowP));	::SetOrigin(0, 0);#if PP_Target_Carbon	::InvalWindowRgn(mMacWindowP, inRgnH);#else		::InvalRgn(inRgnH);	#endif}// ---------------------------------------------------------------------------//	¥ ValidPortRect// ---------------------------------------------------------------------------voidLCarbonWindow::ValidPortRect(	const Rect	*inRect){	StPortOriginState	portOriginState((GrafPtr) ::GetWindowPort(mMacWindowP));	::SetOrigin(0, 0);#if PP_Target_Carbon	::ValidWindowRect(mMacWindowP, inRect);#else		::ValidRect(inRect);	#endif}// ---------------------------------------------------------------------------//	¥ ValidPortRgn// ---------------------------------------------------------------------------voidLCarbonWindow::ValidPortRgn(	RgnHandle	inRgnH){	StPortOriginState	portOriginState((GrafPtr) ::GetWindowPort(mMacWindowP));	::SetOrigin(0, 0);#if PP_Target_Carbon	::ValidWindowRgn(mMacWindowP, inRgnH);#else		::ValidRgn(inRgnH);	#endif}#pragma mark -// ---------------------------------------------------------------------------//	¥ ResizeFrameBy// ---------------------------------------------------------------------------//	Change the Frame size by the specified amounts////		inWidthDelta and inHeightDelta specify, in pixels, how much larger//		to make the Frame. Positive deltas increase the size, negative deltas//		reduce the size.////	Note that this function only changes the internal Frame size of the//	Window object. To change the actual size (on screen) of the Window,//	call ResizeWindowBy() or ResizeWindowTo().voidLCarbonWindow::ResizeFrameBy(	SInt16		inWidthDelta,	SInt16		inHeightDelta,	Boolean		inRefresh){	Rect	beforeFrame;	CalcPortFrameRect(beforeFrame);		mFrameSize.width  += inWidthDelta;	mFrameSize.height += inHeightDelta;	CalcRevealedRect();	OutOfFocus(this);		if (inRefresh) {				Rect	afterRect;		CalcPortFrameRect(afterRect);				StRegion	beforeRgn(beforeFrame);		StRegion	refreshRgn(afterRect);				refreshRgn -= beforeRgn;				if (HasAttribute(windAttr_SizeBox)) {			Rect	sizeBox = beforeFrame;			sizeBox.left = (SInt16) (sizeBox.right - 15);			sizeBox.top = (SInt16) (sizeBox.bottom - 15);			::RectRgn(beforeRgn, &sizeBox);			::MacUnionRgn(refreshRgn, beforeRgn, refreshRgn);						sizeBox = afterRect;			sizeBox.left = (SInt16) (sizeBox.right - 15);			sizeBox.top = (SInt16) (sizeBox.bottom - 15);			beforeRgn = sizeBox;			refreshRgn += beforeRgn;		}				InvalPortRgn(refreshRgn);	}			TArrayIterator<LPane*> iterator(mSubPanes);	LPane	*theSub;	while (iterator.Next(theSub)) {		theSub->AdaptToSuperFrameSize(inWidthDelta, inHeightDelta, inRefresh);	}}// ---------------------------------------------------------------------------//	¥ Select// ---------------------------------------------------------------------------voidLCarbonWindow::Select(){	if (not IsSelected()) {		SendSelfAE(kAEMiscStandards, kAESelect, ExecuteAE_No);		::SelectWindow(mMacWindowP);	}}#pragma mark -// ---------------------------------------------------------------------------//	¥ Show// ---------------------------------------------------------------------------voidLCarbonWindow::Show(){	if (mVisible == triState_Off) {		mVisible = triState_On;		ShowSelf();		LView::Show();	}}// ---------------------------------------------------------------------------//	¥ ShowSelf// ---------------------------------------------------------------------------voidLCarbonWindow::ShowSelf(){	::MacShowWindow(mMacWindowP);}// ---------------------------------------------------------------------------//	¥ HideSelf// ---------------------------------------------------------------------------voidLCarbonWindow::HideSelf(){	::HideWindow(mMacWindowP);	Deactivate();}// ---------------------------------------------------------------------------//	¥ Activate// ---------------------------------------------------------------------------voidLCarbonWindow::Activate(){	if ( (mActive == triState_Off)  &&  IsVisible() ) {		mActive = triState_On;		ActivateSelf();		LView::Activate();					// Normally the active Window contains the Target. If this			// Window can be the Target, restore the Target to what			// it was when the Window was last active. Don't do this			// if the Window is already on duty (which happens when			// the Window is a Superior of a Window that was just			// deactivated).					if (HasAttribute(windAttr_Targetable) && !IsOnDuty()) {			RestoreTarget();		}	}}// ---------------------------------------------------------------------------//	¥ ActivateSelf// ---------------------------------------------------------------------------voidLCarbonWindow::ActivateSelf(){	if (mActiveBackgroundBrush != 0) {				// With Themes brushes, we must make sure that the window			// content color matches the Theme so that the WDEF can hilite			// the window with the right color			SInt16	bitDepth;		bool	hasColor;		GetDeviceInfo(bitDepth, hasColor);		UAppearance::SetWindowContentBrush(mMacWindowP,								mActiveBackgroundBrush, bitDepth, hasColor);	}	::HiliteWindow(mMacWindowP, true);	DrawSizeBox();}// ---------------------------------------------------------------------------//	¥ Deactivate// ---------------------------------------------------------------------------voidLCarbonWindow::Deactivate(){	LView::Deactivate();		if (IsOnDuty()) {			// Switch target to SuperCommander to prevent an		// inactive Window from containing the Target				ForceTargetSwitch(GetSuperCommander());	}}// ---------------------------------------------------------------------------//	¥ DeactivateSelf// ---------------------------------------------------------------------------voidLCarbonWindow::DeactivateSelf(){	if (mInactiveBackgroundBrush != 0) {				// With Themes brushes, we must make sure that the window			// content color matches the Theme so that the WDEF can hilite			// the window with the right color			SInt16	bitDepth;		bool	hasColor;		GetDeviceInfo(bitDepth, hasColor);		UAppearance::SetWindowContentBrush(mMacWindowP,								mInactiveBackgroundBrush, bitDepth, hasColor);	}	::HiliteWindow(mMacWindowP, false);	DrawSizeBox();}// ---------------------------------------------------------------------------//	¥ Enable// ---------------------------------------------------------------------------voidLCarbonWindow::Enable(){	if (mEnabled == triState_Off) {		mEnabled = triState_On;		EnableSelf();		LView::Enable();	}}#pragma mark -// ---------------------------------------------------------------------------//	¥ AttemptClose// ---------------------------------------------------------------------------//	Try to close a Window as a result of direct user actionvoidLCarbonWindow::AttemptClose(){									// Get approval from SuperCommander	if ((mSuperCommander == nil) || mSuperCommander->AllowSubRemoval(this)) {		 		 							// Send Close AE for recording only		SendSelfAE(kAECoreSuite, kAEClose, ExecuteAE_No);		delete this;	}}// ---------------------------------------------------------------------------//	¥ DoClose// ---------------------------------------------------------------------------//	Close a WindowvoidLCarbonWindow::DoClose(){									// Get approval from SuperCommander	if ((mSuperCommander == nil) || mSuperCommander->AllowSubRemoval(this)) {		delete this;	}}// ---------------------------------------------------------------------------//	¥ DrawSelf// ---------------------------------------------------------------------------voidLCarbonWindow::DrawSelf(){	if (HasAttribute(windAttr_EraseOnUpdate)) {		ApplyForeAndBackColors();				Rect	bounds;		::EraseRect( ::GetWindowPortBounds(mMacWindowP, &bounds) );	}		DrawSizeBox();}// ---------------------------------------------------------------------------//	¥ DrawSizeBox// ---------------------------------------------------------------------------//	Draw standard size box for resizable WindowsvoidLCarbonWindow::DrawSizeBox(){	if (HasAttribute(windAttr_SizeBox)) {				// The Toolbox trap DrawGrowIcon draws the size box in			// the lower right corner of a Window, but it also outlines			// the typical scroll bar areas at the right and bottom of			// a Window. We want this routine to work for Windows that			// don't necessarily have standard scroll bars, so we			// temporarily change the clipping region to draw just the			// size box.			FocusDraw();				Rect	sizeBox;		::GetWindowPortBounds(mMacWindowP, &sizeBox);				sizeBox.left = (SInt16) (sizeBox.right - 15);		sizeBox.top =  (SInt16) (sizeBox.bottom - 15);				StClipRgnState	saveClip(sizeBox);		::DrawGrowIcon(mMacWindowP);	}}#pragma mark -// ---------------------------------------------------------------------------//	¥ ApplyForeAndBackColors// ---------------------------------------------------------------------------//	Set the foreground and background colors of the current port////	The Window or one of its SubPanes must already be focusedvoidLCarbonWindow::ApplyForeAndBackColors() const{	::RGBForeColor(&mForeColor);	ThemeBrush	backBrush = 0;		if (UEnvironment::HasFeature(env_HasAppearance11)) {			backBrush = mInactiveBackgroundBrush;		if (IsActive()) {			backBrush = mActiveBackgroundBrush;		}	}		SInt16	bitDepth;	bool	hasColor;	GetDeviceInfo(bitDepth, hasColor);		if (backBrush != 0) {		::SetThemeBackground(backBrush, bitDepth, hasColor);			} else {							// No background Brush											// Must reset backpat to white since										//   some Themes set it differently		Pattern	whitePat;		::BackPat( UQDGlobals::GetWhitePat(&whitePat) );					// Normally, we will use the background color for			// the Window. However, we use a white background if			// the current Theme is not in color.				RGBColor	backColor = mBackColor;				if ( UEnvironment::HasFeature(env_HasAppearance101)  &&			 not ::IsThemeInColor(bitDepth, hasColor) ) {					backColor = Color_White;		}				::RGBBackColor(&backColor);	}}// ---------------------------------------------------------------------------//	¥ SetForeAndBackColors// ---------------------------------------------------------------------------//	Sprecify the foreground and/or background colors of a Window////	Specify nil for inForeColor and/or inBackColor to leave that//	color trait unchangedvoidLCarbonWindow::SetForeAndBackColors(	const RGBColor	*inForeColor,	const RGBColor	*inBackColor){	if (inForeColor != nil) {		mForeColor = *inForeColor;	}		if (inBackColor != nil) {		mBackColor = *inBackColor;	}}// ---------------------------------------------------------------------------//	¥ GetForeAndBackColors// ---------------------------------------------------------------------------//	Pass back the foreground and/or background colors of a Window////	Pass nil for outForeColor and/or outBackColor to not retrieve that colorvoidLCarbonWindow::GetForeAndBackColors(	RGBColor	*outForeColor,	RGBColor	*outBackColor) const{	if (outForeColor != nil) {		*outForeColor = mForeColor;	}		if (outBackColor != nil) {				// Normally, we will use the background color for			// the Window. However, we use a white background if			// the current Theme is not in color.			SInt16	bitDepth;		bool	hasColor;		GetDeviceInfo(bitDepth, hasColor);				if ( UEnvironment::HasFeature(env_HasAppearance101)  &&			 not ::IsThemeInColor(bitDepth, hasColor) ) {					*outBackColor = Color_White;					} else {			*outBackColor = mBackColor;		}	}}// ---------------------------------------------------------------------------//	¥ SetThemeData// ---------------------------------------------------------------------------voidLCarbonWindow::SetThemeData(	ThemeBrush		inActiveBackBrush,	ThemeBrush		inInactiveBackBrush,	ThemeTextColor	inActiveTextColor,	ThemeTextColor	inInactiveTextColor){	mActiveBackgroundBrush	 = inActiveBackBrush;	mInactiveBackgroundBrush = inInactiveBackBrush;	mActiveTextColor		 = inActiveTextColor;	mInactiveTextColor		 = inInactiveTextColor;}// ---------------------------------------------------------------------------//	¥ GetEmbeddedTextColor// ---------------------------------------------------------------------------//	Pass back the color for drawing text within a WindowvoidLCarbonWindow::GetEmbeddedTextColor(	SInt16		inDepth,	bool		inHasColor,	bool		inIsActive,	RGBColor&	ioColor) const{	ThemeTextColor	color = mInactiveTextColor;	if (inIsActive) {		color = mActiveTextColor;	}		if (color != 0) {		UAppearance::GetThemeTextColor(color, inDepth, inHasColor,										inIsActive, &ioColor);											} else {		LView::GetEmbeddedTextColor(inDepth, inHasColor, inIsActive, ioColor);	}}#pragma mark -// ---------------------------------------------------------------------------//	¥ GlobalToPortPoint// ---------------------------------------------------------------------------//	Convert a point from global (screen) coordinates to a Window's Port//	coordinatesvoidLCarbonWindow::GlobalToPortPoint(	Point	&ioPoint) const{		// Windows have a reference to the pixel image of the main screen--		// portBits for B&W and portPixMap for color windows. The bounds		// of the pixel image specify the alignment of the *local* Window		// coordinates with *global* coordinates:		//		localPt = globalPt + topLeft(imageBounds)		//		// To convert from *local* to *port* coordinates, we offset by		// the top left of the Window's port rectangle:		//		portPt = localPt - topLeft(portRect)		//		// Therefore,		//		portPt = globalPt + topLeft(imageBounds) - topLeft(portRect)		//		// Note: We don't use the Toolbox routine GlobalToLocal because		// that routine depends on the current port and the current port		// origin. To use GlobalToLocal we would have to do the following:		//		GrafPtr savePort;		//		GetPort(&savePort);		//		Point	saveOrigin = topLeft(mMacWindowP->portRect);		//		MacSetPort(mMacWindowP);		//		SetOrigin(0,0);		//		GlobalToLocal(ioPoint);		//		SetOrigin(saveOrigin.h, saveOrigin.v);		//		MacSetPort(savePort);		// The equation above avoids all this saving/setting/restoring		// of the current port and port origin.#if PP_Target_Carbon	Rect	pixBounds;	::GetPixBounds(::GetPortPixMap(::GetWindowPort(mMacWindowP)), &pixBounds);		Rect	portBounds;	::GetWindowPortBounds(mMacWindowP, &portBounds);		ioPoint.h += (pixBounds.left - portBounds.left);	ioPoint.v += (pixBounds.top - portBounds.top);#else									// Assume a B&W Window	Point	localOffset = topLeft(mMacWindowP->portBits.bounds);	if (UDrawingUtils::IsColorGrafPort(mMacWindowP)) {									// Nope, it's a color Window		CGrafPtr	colorPortP = (CGrafPtr) mMacWindowP;		localOffset = topLeft((**(colorPortP->portPixMap)).bounds);	}		ioPoint.h += (SInt16) (localOffset.h - mMacWindowP->portRect.left);	ioPoint.v += (SInt16) (localOffset.v - mMacWindowP->portRect.top);	#endif}// ---------------------------------------------------------------------------//	¥ PortToGlobalPoint// ---------------------------------------------------------------------------//	Convert a point from Port to Global (screen) coordinates//		[see discussion above for GlobalToPortPoint() for comments]voidLCarbonWindow::PortToGlobalPoint(	Point	&ioPoint) const{#if PP_Target_Carbon	Rect	pixBounds;	::GetPixBounds(::GetPortPixMap(::GetWindowPort(mMacWindowP)), &pixBounds);		Rect	portBounds;	::GetWindowPortBounds(mMacWindowP, &portBounds);	ioPoint.h -= (pixBounds.left - portBounds.left);	ioPoint.v -= (pixBounds.top - portBounds.top);#else									// Assume a B&W Window	Point	localOffset = topLeft(mMacWindowP->portBits.bounds);	if (UDrawingUtils::IsColorGrafPort(mMacWindowP)) {									// Nope, it's a color Window		CGrafPtr	colorPortP = (CGrafPtr) mMacWindowP;		localOffset = topLeft((**(colorPortP->portPixMap)).bounds);	}		ioPoint.h -= (SInt16) (localOffset.h - mMacWindowP->portRect.left);	ioPoint.v -= (SInt16) (localOffset.v - mMacWindowP->portRect.top);#endif}// ---------------------------------------------------------------------------//	¥ ExpandSubPane// ---------------------------------------------------------------------------//	Resize a SubPane so that it is the same size as the Window,//	horizontally and/or verticallyvoidLCarbonWindow::ExpandSubPane(	LPane	*inSub,	Boolean	inExpandHoriz,	Boolean	inExpandVert){	SDimension16	subSize;	inSub->GetFrameSize(subSize);	SPoint32		subLocation;	inSub->GetFrameLocation(subLocation);			// SubPane overlaps 1-pixel window border	if (inExpandHoriz) {		subSize.width = (SInt16) (mFrameSize.width + 2);		subLocation.h = -1;	}		if (inExpandVert) {		subSize.height = (SInt16) (mFrameSize.height + 2);		subLocation.v = -1;	}		inSub->PlaceInSuperFrameAt(subLocation.h, subLocation.v, false);	inSub->ResizeFrameTo(subSize.width, subSize.height, false);}// ===========================================================================// ¥ Sending Apple Events								Sending Apple Events ¥// ===========================================================================// ---------------------------------------------------------------------------//	¥ SendAESetPosition// ---------------------------------------------------------------------------//	AppleEvent for moving a Window to a new position////	inPosition is the location for the top left corner of the Window's//		port rectangle, in Global coordinates//	Set inExecuteAE to true to actually move the Window, false to//	just send the event for script recording purposes. You'll use the//	false value when you have already moved the window in response to//	tracking user actions (the Toolbox trap DragWindow move the Window).voidLCarbonWindow::SendAESetPosition(	Point	inPosition,	Boolean	inExecuteAE){	try {		LModelProperty	positionProperty(pWindowPosition, this, false);		positionProperty.SendSetDataAE(typeQDPoint, (Ptr) &inPosition,											sizeof(Point), inExecuteAE);	}		catch (...) {		if (inExecuteAE) {			DoSetPosition(inPosition);		}	}}// ---------------------------------------------------------------------------//	¥ SendAESetBounds// ---------------------------------------------------------------------------//	AppleEvent for changing the size of a Window////	inBounds is the new port rectangle for the Window, in Global coordinates.//	Set inExecuteAE to true to actually resize the Window, false to//	just send the event for script recording purposes.voidLCarbonWindow::SendAESetBounds(	Rect	*inBounds,					// New bounds in global coords	Boolean	inExecuteAE){	try {		LModelProperty	positionProperty(pBounds, this, false);		positionProperty.SendSetDataAE(typeQDRectangle, (Ptr) inBounds,											sizeof(Rect), inExecuteAE);	}		catch (...) {		if (inExecuteAE) {			DoSetBounds(*inBounds);		}	}}// ---------------------------------------------------------------------------//	¥ SendAESetZoom// ---------------------------------------------------------------------------//	AppleEvent for zooming a Window////	This function figures out whether to zoom in or out based on the//	current window size and locationvoidLCarbonWindow::SendAESetZoom(){										// Determine zoom direction	Rect	stdBounds;	Boolean	zoomToStdState = !CalcStandardBounds(stdBounds);	try {		LModelProperty	zoomProperty(pIsZoomed, this, false);		zoomProperty.SendSetDataAE(typeBoolean, (Ptr) &zoomToStdState,											sizeof(Boolean), ExecuteAE_No);	}		catch (...) { }		DoSetZoom(zoomToStdState);}// ---------------------------------------------------------------------------//	¥ ObeyCommand// ---------------------------------------------------------------------------//	Handle a commandBooleanLCarbonWindow::ObeyCommand(	CommandT	inCommand,	void		*ioParam){	Boolean		cmdHandled = true;		switch (inCommand) {				case cmd_Close:			AttemptClose();			break;					default:			cmdHandled = LCommander::ObeyCommand(inCommand, ioParam);			break;	}			return cmdHandled;}// ---------------------------------------------------------------------------//	¥ FindCommandStatus// ---------------------------------------------------------------------------//	Pass back whether a Command is enabled and/or marked (in a Menu)voidLCarbonWindow::FindCommandStatus(	CommandT	inCommand,	Boolean		&outEnabled,	Boolean		&outUsesMark,	UInt16		&outMark,	Str255		outName){	switch (inCommand) {			case cmd_Close:			outEnabled = HasAttribute(windAttr_CloseBox);			break;					default:			LCommander::FindCommandStatus(inCommand, outEnabled,									outUsesMark, outMark, outName);			break;	}}// ===========================================================================// ¥ AppleEvent Object Model Support		 AppleEvent Object Model Support ¥// ===========================================================================#pragma mark -// ---------------------------------------------------------------------------//	¥ MakeSelfSpecifier// ---------------------------------------------------------------------------//	Make an Object Specifier for a WindowvoidLCarbonWindow::MakeSelfSpecifier(	AEDesc&	inSuperSpecifier,	AEDesc&	outSelfSpecifier) const{	if (mSuperModel == nil) {				// For Windows, we often use an "abbreviated" container			// hierarchy where the SuperModel of a Window is null			// rather than being the Application.							DescType		keyForm;		StAEDescriptor	keyData;		OSErr			err;					// Specify by name if the Window's model object name			// is not empty				Str255	name;		GetModelName(name);		if (name[0] != 0) {			keyForm = formName;			keyData.Assign(name);					} else {			// Specify by position in the window list					SInt32	windowIndex = UWindows::FindWindowIndex(mMacWindowP);						keyForm = formAbsolutePosition;			keyData.Assign(windowIndex);		}					err = ::CreateObjSpecifier(	cWindow,									&inSuperSpecifier,									keyForm,									keyData,									false,		// Don't dispose inputs									&outSelfSpecifier);		ThrowIfOSErr_(err);			} else {		LModelObject::MakeSelfSpecifier(inSuperSpecifier, outSelfSpecifier);	}}// ---------------------------------------------------------------------------//	¥ GetAEProperty// ---------------------------------------------------------------------------voidLCarbonWindow::GetAEProperty(	DescType		inProperty,	const AEDesc&	inRequestedType,	AEDesc&			outPropertyDesc) const{	OSErr	err;		switch (inProperty) {			case pName: {					// Window Title			Str255	theName;			::GetWTitle(mMacWindowP, theName);			err = ::AECreateDesc(typeChar, (Ptr) theName + 1,								StrLength(theName), &outPropertyDesc);			break;		}			case pWindowPosition: {		// Top left of Frame in Global coords			Point	thePosition = Point_00;			PortToGlobalPoint(thePosition);			err = ::AECreateDesc(typeQDPoint, (Ptr) &thePosition,								sizeof(Point), &outPropertyDesc);			break;		}					case pBounds: {				// Frame in Global coords			Rect	theBounds;			GetGlobalBounds(theBounds);			err = ::AECreateDesc(typeQDRectangle, (Ptr) &theBounds,								sizeof(Rect), &outPropertyDesc);			break;		}					case pIndex: {				// Front-to-back position index			SInt32	theIndex = UWindows::FindWindowIndex(mMacWindowP);			err = ::AECreateDesc(typeLongInteger, (Ptr) &theIndex,								sizeof(SInt32), &outPropertyDesc);			break;		}					case pIsZoomed: {			// Is Window at Standard state?			Rect	stdBounds;			Boolean	isZoomed = CalcStandardBounds(stdBounds);			err = ::AECreateDesc(typeBoolean, (Ptr) &isZoomed,								sizeof(Boolean), &outPropertyDesc);			break;		}				case pHasCloseBox:			GetAEWindowAttribute(windAttr_CloseBox, outPropertyDesc);			break;					case pHasTitleBar:			GetAEWindowAttribute(windAttr_TitleBar, outPropertyDesc);			break;					case pIsFloating:			GetAEWindowAttribute(windAttr_Floating, outPropertyDesc);			break;					case pIsModal:			GetAEWindowAttribute(windAttr_Modal, outPropertyDesc);			break;					case pIsResizable:			GetAEWindowAttribute(windAttr_Resizable, outPropertyDesc);			break;					case pIsZoomable:			// Can Window be zoomed?			GetAEWindowAttribute(windAttr_Zoomable, outPropertyDesc);			break;					case pVisible: {			Boolean	isVis = IsVisible();			err = ::AECreateDesc(typeBoolean, (Ptr) &isVis,								sizeof(Boolean), &outPropertyDesc);			break;		}					default:			LModelObject::GetAEProperty(inProperty, inRequestedType,											outPropertyDesc);			break;	}}// ---------------------------------------------------------------------------//	¥ SetAEProperty// ---------------------------------------------------------------------------voidLCarbonWindow::SetAEProperty(	DescType		inProperty,	const AEDesc&	inValue,	AEDesc&			outAEReply){	switch (inProperty) {			case pName: {			Str255	theName;			UExtractFromAEDesc::ThePString(inValue, theName);			SetDescriptor(theName);			break;		}			case pWindowPosition: {			Point	thePosition;			UExtractFromAEDesc::ThePoint(inValue, thePosition);			DoSetPosition(thePosition);			break;		}			case pBounds: {			Rect	theBounds;			UExtractFromAEDesc::TheRect(inValue, theBounds);			DoSetBounds(theBounds);			break;		}					case pIsZoomed: {			Boolean	isZoomed;			UExtractFromAEDesc::TheBoolean(inValue, isZoomed);			DoSetZoom(isZoomed);			break;		}					case pVisible: {			Boolean	makeVisible;			UExtractFromAEDesc::TheBoolean(inValue, makeVisible);			if (makeVisible) {				Show();			} else {				Hide();			}			break;		}					default:			LModelObject::SetAEProperty(inProperty, inValue, outAEReply);			break;	}}// ---------------------------------------------------------------------------//	¥ AEPropertyExists// ---------------------------------------------------------------------------boolLCarbonWindow::AEPropertyExists(	DescType	inProperty) const{	bool	exists = false;		switch (inProperty) {			case pName:		case pWindowPosition:		case pBounds:		case pIndex:		case pIsZoomed:		case pHasCloseBox:		case pHasTitleBar:		case pIsFloating:		case pIsModal:		case pIsResizable:		case pIsZoomable:		case pVisible:			exists = true;			break;					default:			exists = LModelObject::AEPropertyExists(inProperty);			break;	}		return exists;}// ---------------------------------------------------------------------------//	¥ GetModelName// ---------------------------------------------------------------------------//	Return the name of a Window as an AppleEvent model objectStringPtrLCarbonWindow::GetModelName(	Str255	outModelName) const{	return GetDescriptor(outModelName);}// ---------------------------------------------------------------------------//	¥ GetAEWindowAttribute// ---------------------------------------------------------------------------voidLCarbonWindow::GetAEWindowAttribute(	EWindAttr	inAttribute,	AEDesc&		outPropertyDesc) const{	Boolean	attrIsSet = HasAttribute(inAttribute);	OSErr	err = ::AECreateDesc(typeBoolean, (Ptr) &attrIsSet,								sizeof(Boolean), &outPropertyDesc);	ThrowIfOSErr_(err);}// ---------------------------------------------------------------------------//	¥ HandleAppleEvent// ---------------------------------------------------------------------------voidLCarbonWindow::HandleAppleEvent(	const AppleEvent	&inAppleEvent,	AppleEvent			&outAEReply,	AEDesc				&outResult,	long				inAENumber){	switch (inAENumber) {			case ae_Close:			DoClose();			break;					case ae_Select:			::SelectWindow(mMacWindowP);			break;					default:			LModelObject::HandleAppleEvent(inAppleEvent, outAEReply,												outResult, inAENumber);			break;	}}// ---------------------------------------------------------------------------//	¥ DoSetPosition// ---------------------------------------------------------------------------//	Change the location of a Window////	The top left corner of the Window's port rectangle is placed at//	inPosition, which is in global coordinatesvoidLCarbonWindow::DoSetPosition(	Point	inPosition)					// Top left in global coords{	::MacMoveWindow(mMacWindowP, inPosition.h, inPosition.v, false);		AdjustUserBounds();}// ---------------------------------------------------------------------------//	¥ AdjustUserBounds// ---------------------------------------------------------------------------//	Adjust the UserBounds for zooming after moving a WindowvoidLCarbonWindow::AdjustUserBounds(){	Rect	stdBounds;		if (CalcStandardBounds(stdBounds)) {				// Window is at the standard state. Don't change the			// size of the user bounds, but offset it so that it			// coincides with the current location of the Window.			Point	offset = Point_00;		PortToGlobalPoint(offset);		offset.h -= mUserBounds.left;		offset.v -= mUserBounds.top;		::MacOffsetRect(&mUserBounds, offset.h, offset.v);			} else {				// Window is not at the standard state. The current			// size and location becomes new user bounds.			CalcPortFrameRect(mUserBounds);		PortToGlobalPoint(topLeft(mUserBounds));		PortToGlobalPoint(botRight(mUserBounds));	}		mMoveOnlyUserZoom = false;}// ---------------------------------------------------------------------------//	¥ MoveWindowTo// ---------------------------------------------------------------------------//	Move the top left corner of the Window's port rect to the specified//	location in Global coordsvoidLCarbonWindow::MoveWindowTo(	SInt16	inHoriz,	SInt16	inVert){	Point	position;	position.h = inHoriz;	position.v = inVert;	DoSetPosition(position);}// ---------------------------------------------------------------------------//	¥ MoveWindowBy// ---------------------------------------------------------------------------//	Move Window's location on screen by the specified number of pixels////	Positive horizontal deltas move Window to the left; negative to the right//	Positive vertical deltas move Window down; negative upvoidLCarbonWindow::MoveWindowBy(	SInt16	inHorizDelta,	SInt16	inVertDelta){	Rect	theBounds;	GetGlobalBounds(theBounds);		Point	position;	position.h = (SInt16) (theBounds.left + inHorizDelta);	position.v = (SInt16) (theBounds.top + inVertDelta);	DoSetPosition(position);}// ---------------------------------------------------------------------------//	¥ CalcStandardBounds// ---------------------------------------------------------------------------//	Calculate the bounds of the Window at standard state and return whether//	it is at standard state. The standard state depends on the screen//	containing the largest area of the Window and the current standard size.////	outStdBounds: Port rectangle of Window at standard size, global coordsBooleanLCarbonWindow::CalcStandardBounds(	Rect&	outStdBounds) const{									// Find GDevice containing largest									//   portion of Window	GDHandle	dominantDevice = UWindows::FindDominantDevice(							UWindows::GetWindowStructureRect(mMacWindowP));	if (dominantDevice == nil) {	// Window is offscreen, so use the									//   main scren		dominantDevice = ::GetMainDevice();	}	Rect		screenRect = (**dominantDevice).gdRect;										// Must compensate for MenuBar on the									//   main screen	if (dominantDevice == ::GetMainDevice()) {		screenRect.top += GetMBarHeight();	}		CalcStandardBoundsForScreen(screenRect, outStdBounds);		Rect		contentRect = UWindows::GetWindowContentRect(mMacWindowP);	return ::MacEqualRect(&outStdBounds, &contentRect);}// ---------------------------------------------------------------------------//	¥ CalcStandardBoundsForScreen// ---------------------------------------------------------------------------//	Calculate the bounds of the Window if it was at a Standard (zoomed out)//	state on a Screen with the specified bounds.////	inScreenBounds: Bounding box of screen in global coordinates//	outStdBounds: Port rectangle of Window at standard size, global coordsvoidLCarbonWindow::CalcStandardBoundsForScreen(	const Rect&	inScreenBounds,	Rect&		outStdBounds) const{									// Structure and Content regions are									//   in global coordinates	Rect	strucRect = UWindows::GetWindowStructureRect(mMacWindowP);	Rect	contRect  = UWindows::GetWindowContentRect(mMacWindowP);										// Structure can be (and usually is)									//   larger than Content	Rect	border;	border.left   = (SInt16) (contRect.left - strucRect.left);	border.right  = (SInt16) (strucRect.right - contRect.right);	border.top    = (SInt16) (contRect.top - strucRect.top);	border.bottom = (SInt16) (strucRect.bottom - contRect.bottom);						 						 			// Don't zoom too close to edge of screen	SInt16	screenWidth  = (SInt16) (inScreenBounds.right - inScreenBounds.left - 4);	SInt16	screenHeight = (SInt16) (inScreenBounds.bottom - inScreenBounds.top - 4);										// Standard dimensions are the minimum									//   of mStandardSize and the size of									//   the screen	SInt16	stdWidth = mStandardSize.width;	if (stdWidth > screenWidth - (border.left + border.right)) {		stdWidth = (SInt16) (screenWidth - (border.left + border.right));	}		SInt16	stdHeight = mStandardSize.height;	if (stdHeight > screenHeight - (border.top + border.bottom)) {		stdHeight = (SInt16) (screenHeight - (border.top + border.bottom));	}									// Standard position is the point closest									//   to the current position at which									//   the Window will be all on screen																		// Move window horizontally so that left									//   or right edge of Struction region is									//   2 pixels from the edge of the screen	SInt16	stdLeft = contRect.left;	if (stdLeft < inScreenBounds.left + border.left + 2) {		stdLeft = (SInt16) (inScreenBounds.left + border.left + 2);	} else if (stdLeft > inScreenBounds.right - stdWidth - border.right - 2) {		stdLeft = (SInt16) (inScreenBounds.right - stdWidth - border.right - 2);	}										// Move window vertically so that top									//   or bottom edge of Struction region is									//   2 pixels from the edge of the screen	SInt16	stdTop = contRect.top;	if (stdTop < inScreenBounds.top + border.top + 2) {		stdTop = (SInt16) (inScreenBounds.top + border.top + 2);	} else if (stdTop > inScreenBounds.bottom - stdHeight - border.bottom - 2) {		stdTop = (SInt16) (inScreenBounds.bottom - stdHeight - border.bottom - 2);	}		outStdBounds.left   = stdLeft;	outStdBounds.right  = (SInt16) (stdLeft + stdWidth);	outStdBounds.top    = stdTop;	outStdBounds.bottom = (SInt16) (stdTop + stdHeight);}// ---------------------------------------------------------------------------//	¥ DoSetZoom// ---------------------------------------------------------------------------//	Zoom window to either the Standard or User statevoidLCarbonWindow::DoSetZoom(	Boolean	inZoomToStdState){	if (!HasAttribute(windAttr_Zoomable)) {		ThrowOSErr_(errAENotModifiable);	}	Rect	currBounds = UWindows::GetWindowContentRect(mMacWindowP);	Rect	zoomBounds;	if (inZoomToStdState) {			// Zoom to Standard state		if (CalcStandardBounds(zoomBounds)) {			return;					// Already at Standard state		}			} else {						// Zoom to User state		zoomBounds = mUserBounds;				if (mMoveOnlyUserZoom) {	// Special case for zooming a Window									//   that is at standard size, but									//   is partially offscreen			zoomBounds.right = (SInt16) (zoomBounds.left +								(currBounds.right - currBounds.left));			zoomBounds.bottom = (SInt16) (zoomBounds.top +								(currBounds.bottom - currBounds.top));		}	}		SInt16	zoomWidth  = (SInt16) (zoomBounds.right - zoomBounds.left);	SInt16	zoomHeight = (SInt16) (zoomBounds.bottom - zoomBounds.top);	mMoveOnlyUserZoom = false;			// To avoid unnecessary redraws, we check to see if the		// current and zoom states are either the same size		// or at the same location			if ( ((currBounds.right - currBounds.left) == zoomWidth) &&		 ((currBounds.bottom - currBounds.top) == zoomHeight) ) {									// Same size, just move		::MacMoveWindow(mMacWindowP, zoomBounds.left, zoomBounds.top, false);		mMoveOnlyUserZoom = true;		} else if (::EqualPt(topLeft(currBounds), topLeft(zoomBounds))) {									// Same location, just resize		::SizeWindow(mMacWindowP, zoomWidth, zoomHeight, false);		ResizeFrameTo(zoomWidth, zoomHeight, true);			} else {						// Different size and location									// Zoom appropriately		FocusDraw();		ApplyForeAndBackColors();				Rect	windowBounds;		::EraseRect( ::GetWindowPortBounds(mMacWindowP, &windowBounds));				if (inZoomToStdState) {			SetWindowStandardState(mMacWindowP, &zoomBounds);			::ZoomWindow(mMacWindowP, inZoomOut, false);		} else {			SetWindowStandardState(mMacWindowP, &currBounds);			SetWindowUserState(mMacWindowP, &zoomBounds);			::ZoomWindow(mMacWindowP, inZoomIn, false);		}				ResizeFrameTo(zoomWidth, zoomHeight, false);	}}// ---------------------------------------------------------------------------//	¥ DoSetBounds// ---------------------------------------------------------------------------//	Change size and location of a Window////	inBounds, in global coords, specifies the new size and location of//	the Window's port rectanglevoidLCarbonWindow::DoSetBounds(	const Rect&		inBounds)			// Bounds in global coords{									// Set size and location of Toolbox									//   WindowRecord	::SizeWindow(mMacWindowP, (SInt16) (inBounds.right - inBounds.left),							  (SInt16) (inBounds.bottom - inBounds.top), false);	::MacMoveWindow(mMacWindowP, inBounds.left, inBounds.top, false);										// Set our Frame	ResizeFrameTo((SInt16) (inBounds.right - inBounds.left),				  (SInt16) (inBounds.bottom - inBounds.top), true);	SDimension16	frameSize;		// For Windows, Image is always the	GetFrameSize(frameSize);		//   same size as its Frame	ResizeImageTo(frameSize.width, frameSize.height, false);										// Changing Bounds establishes a									//   new User state for zooming	CalcPortFrameRect(mUserBounds);	PortToGlobalPoint(topLeft(mUserBounds));	PortToGlobalPoint(botRight(mUserBounds));	mMoveOnlyUserZoom = false;}// ---------------------------------------------------------------------------//	¥ ResizeWindowTo// ---------------------------------------------------------------------------//	Change the size of a Window to the specified width and height (in pixels)voidLCarbonWindow::ResizeWindowTo(	SInt16	inWidth,	SInt16	inHeight){	Rect	theBounds;	GetGlobalBounds(theBounds);		theBounds.right  = (SInt16) (theBounds.left + inWidth);	theBounds.bottom = (SInt16) (theBounds.top + inHeight);	DoSetBounds(theBounds);}// ---------------------------------------------------------------------------//	¥ ResizeWindowBy// ---------------------------------------------------------------------------//	Change the size of a Window by the specified number of pixelsvoidLCarbonWindow::ResizeWindowBy(	SInt16	inWidthDelta,	SInt16	inHeightDelta){	Rect	theBounds;	GetGlobalBounds(theBounds);		theBounds.right += inWidthDelta;	theBounds.bottom += inHeightDelta;	DoSetBounds(theBounds);}// ---------------------------------------------------------------------------//	¥ FindWindowByID// ---------------------------------------------------------------------------//	Return the Window object with the specified Pane ID number////	Loops through all Windows from front to back searching for the first one//	with the specified Pane ID. Note that it's common to use the same//	PPob (and WIND) resource to create multiple windows, all of which have//	the same Pane ID. This function returns the frontmost match, whether it//	is visible or not.////	Returns nil if no match found.LCarbonWindow*LCarbonWindow::FindWindowByID(	PaneIDT		inWindowID){	LCarbonWindow		*foundWindow = nil;	WindowPtr	theWindowP = ::GetWindowList();		while (theWindowP) {		LCarbonWindow *window = FetchWindowObject(theWindowP);		if ((window != nil) && (window->GetPaneID() == inWindowID)) {			foundWindow = window;			break;		}		theWindowP = GetNextWindow(theWindowP);	}		return foundWindow;}#pragma mark -// ===========================================================================// ¥ LWindowThemeAttachment// ===========================================================================LWindowThemeAttachment::LWindowThemeAttachment(	LStream*	inStream)		: LAttachment(inStream){	*inStream >> mActiveBackgroundBrush;	*inStream >> mInactiveBackgroundBrush;	*inStream >> mActiveTextColor;	*inStream >> mInactiveTextColor;		mMessage = msg_FinishCreate;	// We only handle this message}BooleanLWindowThemeAttachment::Execute(	MessageT	inMessage,	void*		ioParam){	Boolean		executeHost = true;		if (inMessage == msg_FinishCreate) {		LCarbonWindow*	window = reinterpret_cast<LCarbonWindow*>(ioParam);			window->SetThemeData(mActiveBackgroundBrush, mInactiveBackgroundBrush,							 mActiveTextColor, mInactiveTextColor);		executeHost = mExecuteHost;		delete this;	}		return executeHost;					 }PP_End_Namespace_PowerPlant