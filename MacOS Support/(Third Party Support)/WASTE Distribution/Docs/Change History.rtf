{\rtf1\mac{\fonttbl{\f0\fswiss Helvetica;}{\f1\froman Palatino;}{\f2\fmodern Courier;}}{\colortbl\red0\green0\blue0;}{\info{\title WASTE 2.1 Change History}{\subject WASTE, the WorldScript-aware Styled Text Engine}{\author Marco Piovanelli}}\paperw11904\paperh16840\margl1152\margr1152\margt1440\margb1440{\*\macprintrecord 000100000048004800000000034a025300000000034a0253ff47034a0253010000000048004800000000034a02530001010000640001000000010002000000017d000001000100000000000000000000000050706466006400000000034a02530000000000000000000000000000000000000000000000004d6f7265000100004000000000000004496e666f417574684000000000000054496e666f4b6579774000000000000000496e666f5375626a4000000000000020496e666f5469746c40000000000000040000006400000018574153544520322e31204368616e676520486973746f72790000002f57415354452c2074686520576f726c645363726970742d4177617265205374796c6564205465787420456e67696e6548000000104d6172636f2050696f76616e656c6c69}\deftab720{\pard\plain\f0\fs60\cf0\qc\sb360\sa480 {\b WASTE 2.1 Change History\par}}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.1a8 (May 2002)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 A new {\b undo notification hook} allows your application to be notified whenever an undo-related event occurs. You declare your callback like this:\par}{\pard\plain\f2\fs24\cf0\qj\fi120 pascal OSErr UndoProc\par\tab (\par\tab \tab SInt16\tab \tab \tab \tab \tab inUndoEvent,\par\tab \tab WEActionReference\tab \tab \tab inAction\par\tab ) ;\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 The {\f2 inUndoEvent} parameter describes what is happening and can take up one of three possible values:\par}{\pard\plain\f2\fs24\cf0\qj\sa120\li720 weUndoNewAction{\f1 \par}}{\pard\plain\f1\fs24\cf0\qj\sa120\li1440 A new action is being pushed onto the internal undo (or redo) stack.  This happens when some undoable action (e.g., typing, inline input, pasting) is occurring and undo is enabled. Also, this event is generated when a non-empty action sequence is closed by a call to {\f2 WEEndAction}.\par}{\pard\plain\f2\fs24\cf0\qj\sa120\li720 weUndoBeginSequence{\f1 \par}}{\pard\plain\f1\fs24\cf0\qj\sa120\li1440 A new action sequence is being opened. This happens when {\f2 WEBeginAction} is called, either explicitly or internally by WASTE (e.g., during a drag-move, which is actually two actions being treated as one).\par}{\pard\plain\f2\fs24\cf0\qj\sa120\li720 weUndoNewSubSequence{\f1 \par}}{\pard\plain\f1\fs24\cf0\qj\sa120\li1440 A new action is being added to the open action sequence. This only happens when an undoable action occurs between {\f2 WEBeginAction} and {\f2 WEEndAction}.\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 The {\f2 inAction} parameter is an opaque reference to the action involved. Some new accessors allow you to extract relevant information from a {\f2 WEActionReference}, like its action kind ({\f2 WEGetActionKind}), whether it\'d5s an undo or a redo action ({\f2 WEActionIsRedo}), and the WASTE instance associated with the action ({\f2 WEGetActionOwner}).\par\'a5 Added a new {\f2 WECopyToScrap} API that gives you more control on the way WASTE performs the familiar copy operation.\par}{\pard\plain\f2\fs24\cf0\qj\fi120 pascal OSStatus WECopyToScrap\par\tab (\par\tab \tab ScrapRef\tab \tab \tab \tab \tab inScrap,\par\tab \tab const ScrapFlavorType *\tab \tab inScrapFlavors,\par\tab \tab OptionBits\tab \tab \tab \tab \tab inCopyOptions,\par\tab \tab WEReference\tab \tab \tab \tab inWE\par\tab ) ;\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \parThe {\f2 inScrap} parameter allows you to specify a scrap other than the global clipboard or pasteboard. You can pass {\f2 NULL} in this parameter to refer to the global scrap. This parameter is not significant in classic (non-Carbon) builds and is always ignored.\parThe {\f2 inScrapFlavors} parameter allows you to specify an optional, zero-terminated array of flavors to be copied. Pass {\f2 NULL} to let WASTE choose the appropriate flavors.\parA parallel {\f2 WEPasteFromScrap} API lets you perform a paste operation from a specified scrap:\par}{\pard\plain\f2\fs24\cf0\qj\fi120 pascal OSStatus WEPasteFromScrap\par\tab (\par\tab \tab ScrapRef\tab \tab \tab \tab \tab inScrap,\par\tab \tab OptionBits\tab \tab \tab \tab \tab inPasteOptions,\par\tab \tab WEReference\tab \tab \tab \tab inWE\par\tab ) ;\par\tab \par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 You can now install an optional {\b busy callback} that is invoked by WASTE at specific intervals during time-consuming operations.\par\'a5 Added a {\f2 WEGetLineWidth} accessor that returns the pixel width of the specified line.\par\'a5 An internal API used to highlight text ranges in response to requests by Text Services Manager input methods has been exposed:\par}{\pard\plain\f2\fs24\cf0\qj\fi120 pascal OSStatus WESetTSMHilite\par\tab (\par\tab \tab SInt32\tab \tab \tab \tab \tab inRangeStart,\par\tab \tab SInt32\tab \tab \tab \tab \tab inRangeEnd,\par\tab \tab WETSMHiliteStyle\tab \tab \tab inTSMHiliteStyle,\par\tab \tab WEReference\tab \tab \tab \tab inWE\par\tab ) ;\par\tab \par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 Valid values for {\f2 inTSMHiliteStyle} parameter are {\f2 kRawText}, {\f2 kSelectedRawText}, {\f2 kConvertedText} and {\f2 kSelectedConvertedText} (defined in {\f2 <AERegistry.h>}), plus more values defined in WASTE.h ({\f2 weRedWigglyUnderline}, etc.) that may be handy for implementing MS Word-style wiggly underlines for misspelled words.\par\'a5 {\b Single-click selection of lines}: When the {\f2 weFLeftMarginClick} feature flag is enabled, a single click to the immediate left of a line selects the whole line. A double click selects the corresponding paragraph. Left margin clicks can be combined with the shift modifier to extend the selection in the usual fashion.  If the {\f2 weFLeftMarginClick} flag is on, and {\f2 WEAdjustCursor} is called for a point to the left of the destination rectangle, the cursor is changed to a northeast-pointing arrow.\par\'a5 {\b BBEdit-style combos for backspace and delete}: option-backspace deletes the word to the left of the cursor, command-backspace deletes to the beginning of the line and command-option-backspace deletes to the beginning of the document.\par\'a5 Added some support for {\b RTFD packages} (RTF documents with external attachments). In particular, {\f2 WELoad} will recognize such packages when asked to guess the file type, and the RTF parser will understand the proprietary NeXTStep keyword used to embed graphics (only TIFF graphics is handled at this time). Also, {\f2 WESave} can now write RTFD packages, saving inline graphics in a way that can be understood by Cocoa applications.\par\'a5 The RTF parser now does a better job at matching font names. In particular, the parser now understands Postscript font names found in RTF files produced by Cocoa applications.\par\'a5 Fixed a problem where WASTE would assume the wrong text encoding for ranges set in some Mac OS X fonts like Hiragino, which have a Quickdraw font family number outside the (now obsolete) Script Manager range for the corresponding script. This problem caused WASTE to return bogus Unicode text for such ranges.\par\'a5 Fixed a subtle cosmetic problem with drawing {\f2 weTagBorderStyleDotted} borders. The gray pattern we used was not aligned to the pen position.\par\'a5 WASTE Demo: added support for mouse wheels, contextual menus and Mac OS X Services.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.1a7 (March 2002)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 {\b Line spacing modes}.\parLine spacing modes allow more control on the way line heights are calculated. Previously, the {\f2 weTagLineSpacing} tag was a {\f2 Fixed} value functioning as a multiplier for the height of lines in a paragraph. A value of {\f2 0.0} (the default) meant natural line height (make the line as tall as the tallest character in it), {\f2 1.0} meant double line height and, more generally, a non-negative value {\f2 X} meant make the line {\f2 (1 + X)*N} pixels tall, where {\f2 N} is the natural line height.\parStarting from WASTE 2.1a7, the attribute getters and setters accept a {\f2 WELineSpacing} structure in their value parameters, defined as follows:\par}{\pard\plain\f2\fs24\cf0\ql\li480 typedef struct WELineSpacing\par\{\par    WESelector      mode ;\par    Fixed           value ;\par\} WELineSpacing ;\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 The {\f2 mode} field can be one of {\f2 weTagLineSpacingRelative}, {\f2 weTagLineSpacingAbsolute} or {\f2 weTagLineSpacingAtLeast}. The relative mode instructs WASTE to treat the {\f2 value} field as it always had in the past, i.e., as the relative multiplier previously described. But when the other two modes are in effect, the {\f2 value} field is interpreted as an absolute (exact) pixel height, expressed in {\f2 Fixed} points as usual.\parFuthermore, when the \'d2at least\'d3 mode is in effect, WASTE will use the {\f2 value} field or the natural line height, whichever is greater, whereas when the \'d2absolute\'d3 mode is specified, WASTE will use the {\f2 value} field even if it\'d5s less than the natural line height, possibly cropping some glyphs in the process.\parThe attribute getters and setters still accept {\f2 Fixed} values for the {\f2 weTagLineSpacing} tag, for compatibility with older versions of WASTE.\par\'a5 The delta between the natural height of a line and the height specified by the line spacing tag is now distributed proportionally between the ascent and descent portions of a line (previously, it was added to the descent portion only).\par\'a5 The RTF I/O module now recognizes and writes a number of paragraph-level keywords controlling pagination and hyphenation.\par\'a5 Modified the implementation of some deprecated APIs ({\f2 WEGetParaInfo}, {\f2 WEGetIndParaInfo}, {\f2 WESetRuler} and {\f2 WEContinuousRuler}) so that they cannot be used to inspect or set any attributes besides those explicitly documented in the public headers.\par\'a5 Fixed a bug where the sequence:\par}{\pard\plain\f2\fs24\cf0\ql\li480 WEBeginAction ( we ) ;\parWEFeatureFlag ( weFUndo, weBitClear, we ) ;\parWEKey ( key, modifiers, we ) ;\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 caused a crash. Thanks to Olivier Destrebecq for reporting this.\par\'a5 Incorporated a fix submitted by Matsumoto Satoshi for an undo-related problem that manifests itself with the ATOK input method for Japanese.\par\'a5 Fixed a bug reported by Yoshio Hirose where the caret would not be positioned correctly in lines with tab characters set in non-Roman fonts.\par\'a5 Fixed a bug in {\f2 WESetAttributes} reported by Peter Hoerster: {\f2 weTagSubscript} was broken.\par\'a5 Fixed a potentially crashing bug in the RTF parser where loading a document containing PNG- or JPEG-encoded pictures could cause a crash with QuickTime 2.5. Thanks to Tomasz Kukielka for pointing out the problem.\par\'a5 Fixed a bug where {\f2 WELoad} was ignoring the {\f2 rangeStart}/{\f2 rangeEnd} parameters when loading RTF files. Thanks to Fabio Peri.\par\'a5 Fixed a bug in WASTELib where the host application would be abruptly terminated if a C++ exception was thrown by the RTF I/O module. This would typically occur when loading a corrupt RTF file.\par\'a5 The \'d2Apple Chancery\'d3 and \'d2Zapf Chancery\'d3 are now classified as {\f2 \\fscript} fonts rather than {\f2 \\fdecor} fonts by the RTF writer.\par\'a5 WASTE.h: added experimental support for framework-style includes.\par\'a5 WASTE Demo: the minimum system requirements are now Mac OS 9.1 + CarbonLib 1.5 for Classic and Mac OS X 10.1 for X.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.1a6 (January 2002)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 {\b Tabs}. Each paragraph can now have its own set of user-defined tabs. Up to 20 tab stops per paragraph can be defined.\parDefault tabs are used in paragraphs that don\'d5t have user-defined tabs, or when a tab character is encountered past the rightmost user-defined tab on a line. Default tabs are placed automatically at integer multiples of the {\b default tab width}, a document-wide value that can be gotten and set using suitable accessors ({\f2 WEGetDefaultTabWidth} and {\f2 WESetDefaultTabWidth}).\parAn automatic tab stop is added at the left indent position if there is a hanging indent, i.e., if the first line indent is negative.\parTab indents are expressed in Fixed points from the left edge of the destination rectangle. Tabs can have different alignments (left, center, right or decimal), although currently only left-aligned tabs are rendered correctly. Tabs can also have leaders, i.e., repeating characters used to fill the blank space.\parUse {\f2 WESetAttributes} or {\f2 WESetOneAttribute} with the {\f2 weTagTabList} selector to apply a tab set to a range.\par\'a5 The built-in \'d4new\'d5 handler for pictures now detects a couple of special picture comments used by equation editors and other programs to specify the equation baseline. To see this code in action, try creating a simple equation in Graphing Calculator, copy it and paste it into the WASTE Demo.\par\'a5 Implemented the all caps, all lowercase and hidden styles.\par\'a5 Added the {\f2 WEGetLineAscent} accessor.\par\'a5 Numerous fixes and enhancements to the RTF I/O module.\par\'a5 The WASTE static libraries no longer need the external symbols {\f2 __shl2i} and {\f2 __shr2u} (defined in the Metrowerks runtime libraries). Thanks to Theo Vosse.\par\'a5 Fixed a potentially crashing bug occurring when activating, deactivating and disposing of a WASTE instance with the {\f2 weFAutoIdle} feature enabled. Thanks to J\'8er\'99me Seydoux of the PowerMail team.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.1a5 (January 2002)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 It is now possible for a \'d4new\'d5 object handler to specify the {\b intrinsic baseline} of an object, i.e., a vertical shift to be applied to the bounding rectangle of the object when it\'d5s drawn. This amount is added to any vertical shift applied with {\f2 WESetAttributes}. The first parameter to the new handler, although declared as a {\f2 Point *} for compatibility with older versions of WASTE, is now actually a pointer to a {\f2 WEObjectPlacement} structure which includes an {\f2 objectBaseline} field. Setting this field to a positive value raises the object above the text baseline, while setting it to a negative amount lowers the object below the baseline.\par\'a5 {\f2 WESave} and {\f2 WELoad} would check for the wrong Gestalt bit ({\f2 gestaltFSSupportsHFSPlusVols} instead of {\f2 gestaltHasHFSPlusAPIs}) and could crash if called on pre-Mac OS 9 system software.\par\'a5 {\f2 WESetAttributes} would incorrectly reject negative tab indents.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.1a4 (December 2001)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 Plenty of new features and bug fixes in this release, and more to come...\par\'a5 New filing APIs allow you to store the contents a single WASTE instance (or a subrange of it) into a file, in one of several file formats, and load them back. These APIs are still in flux and have several known problems that will be addressed in future releases. Please bear with me!\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSStatus WESave\par  (\par    SInt32               inRangeStart,\par    SInt32               inRangeEnd,\par    const FSRef *        inFileRef,\par    OSType               inFileFormat,\par    TextEncoding         inTextEncoding,\par    OptionBits           inSaveOptions,\par    WEReference          inWE\par  );\par{\f1 \par}}{\pard\plain\f2\fs24\cf0\qj\sa120\fi120 WESave{\f1  saves the text range specified by }inRangeStart{\f1  and }inRangeEnd{\f1  to }inFileRef{\f1 , in the format indicated by }inFileFormat{\f1 . Currently, the following file formats are supported: }kTypeText{\f1  (}'TEXT'{\f1 ), }kTypeUnicodeText{\f1  (}'utxt'{\f1 ) and }kTypeRTF{\f1  (}'RTF '{\f1 ).\par}kTypeText{\f1  specifies a classic Macintosh text files (using traditional Mac OS encodings). All formatting attributes and embedded objects will be lost unless you specify }weSaveAddResources{\f1  in the }inSaveOption{\f1  parameter, which causes WASTE to add formatting scraps to the resource fork of the file. Specify }weSaveCompatibilityResources{\f1  in addition to }weSaveAddResources{\f1  to include formatting scraps suitable for applications based on TextEdit and WASTE 1.x. Please keep in mind that the text encoding(s) used in a classic Macintosh text file cannot be reliably inferred unless style information is present.\par}kTypeUnicodeText{\f1  specifies a UTF-16 encoded text file. By default, UTF-16 text is output in big-endian byte order. Specify }weSaveLittleEndian{\f1  in }inSaveOptions{\f1  for little-endian (Intel) byte order. A byte-order mark is always automatically prepended at the beginning of the file.\par}kTypeRTF{\f1  specifies a Rich Text Format file. The flavor of RTF used by WASTE (based on the Microsoft RTF 1.5 specification) supports the full range of character-level and paragraph-level formatting attributes currently understood by WASTE, plus a number of other attributes not currently used by WASTE but useful for roundtripping. It also supports embedded pictures, but not other kinds of embedded objects. This flavor of RTF is currently unsuitable for saving non-Roman text. The RTF option is currently only available in the WASTELib dynamic library, but not in the static libraries.\parThe }inTextEncoding{\f1  parameter is reserved for future use: pass }kTextEncodingUnkown{\f1  for the time being.\par}}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSStatus WELoad\par  (\par    SInt32               inRangeStart,\par    SInt32               inRangeEnd,\par    const FSRef *        inFileRef,\par    OSType *             ioFileFormat,\par    TextEncoding *       ioTextEncoding,\par    OptionBits*          ioLoadOptions,\par    WEReference          inWE\par  );\par\par}{\pard\plain\f2\fs24\cf0\qj\sa120\fi120 WELoad{\f1  loads the contents of a file back into a WASTE instance, replacing the specified text range. The file format here is an input/output parameter. You can pass }typeWildCard{\f1  (}'****'{\f1 ) on input if you want WASTE to figure out the correct file format for you; on output, }WELoad{\f1  will returned the detected format. Or you can specify a real file type on input to force }WELoad{\f1  to interpret the contents of the file in a certain way; for instance, this is useful if you want to open an RTF file as a plain text file to edit the RTF tags manually.\parThe }ioTextEncoding{\f1  and }ioLoadOptions{\f1  parameters are reserved for future use: pass }NULL{\f1  for the time being.\par}WESave{\f1  and }WELoad{\f1  require Mac OS 9.1 or later. I\'d5m investigating a versions of these APIs that will take }FSSpec{\f1 \'d5s and work on older versions of the system software.\par\'a5 A new, Carbon-only }WEProcessHICommand{\f1  is meant to streamline code for handling menus and toolbars.\par}}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSStatus WEProcessHICommand\par  (\par    const HICommand *    inHICommand,\par    WEReference          inWE\par  );\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 It will handle most common editing commands such as undo, redo, cut, copy, paste, clear and select all.\par{\f2 WEProcessHICommand} can also process menu commands that set text attributes, like those generated by a Font menu or an Alignment menu, provided you have set up your menus by associating suitable properties to the menu items. For example, if you have a Text Color menu that you want WASTE to handle, you should associate an {\f2 RGBColor} property to each menu item using {\f2 SetMenuItemProperty}. The creator tag of the property must be {\f2 kWASTECreator} ({\f2 'OEDE'}), and the property tag must match the WASTE attribute tag. Finally, the command ID of the menu item must also match the WASTE tag of the attribute you want to set.\par\'a5 WASTE now features built-in object handlers for the most common object types (currently, just pictures and sounds). A new API allows you to install the built-in handlers for a given type:\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr WEInstallStandardObjectHandlers\par  (\par    FlavorType           inFlavorType,\par    WEReference          inWE\par  );\par{\f1 \par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 Passing {\f2 typeWildCard} ({\f2 '****'}) in {\f2 inFlavorType} installs handlers for all supported object flavors. A corresponding {\f2 WERemoveStandardObjectHandlers} API uninstalls the handlers.\par\'a5 A new Carbon-only feature flag, {\f2 weFAutoIdle}, instructs WASTE to take care of caret blinking and other idle-time chores automatically. If you specify this flag in {\f2 WENew} (or enable it using {\f2 WEFeatureFlag} before the first call to {\f2 WEActivate}), you don\'d5t need to call {\f2 WEIdle} periodically as WASTE installs an event loop timer on your behalf.\par\'a5 Added more flexible APIs for attaching user-defined data to a given WASTE instance: {\f2 WEGetProperty}, {\f2 WESetProperty} and {\f2 WERemoveProperty}. Unlike the existing {\f2 WEGetUserInfo}, {\f2 WESetUserInfo} and {\f2 WERemoveUserInfo}, these APIs allow you to attach chunks of data of any size (not just 4 bytes), and identify the chunks by tag {\b and} creator.\parThese new APIs are implemented through the Collection Manager, so they are only guaranteed to be available in Carbon or in classic Mac OS 8.5 and newer. If you attempt to use them on a system that doesn\'d5t have the Collection Manager, you\'d5ll get an {\f2 unimpErr} result code.\parIn Carbon builds of WASTE, the old {\f2 UserInfo} APIs are now implemented on top of the {\f2 Property} calls. This means that client code expecting a specific error code ({\f2 -50}, or {\f2 weUndefinedSelectorErr}) when the specified user info cannot be found will have to be revised to look for {\f2 -5751}, or {\f2 collectionItemNotFoundErr}.\parAdded similar APIs for embedded objects: {\f2 WEGetObjectProperty}, {\f2 WESetObjectProperty} and {\f2 WERemoveObjectProperty}.\par\'a5 A number of formatting attributes defined in the RTF specification and used in Microsoft Word and many other word processors can now be stored internally by WASTE, including hidden, all caps, small caps, embossed, engraved, double-strikethrough, and several underline styles (word, double, dotted, dashed, thick, wave, etc.). Also, WASTE can now remember tab stops, tab alignments and tab leaders associated with each paragraph.\parAlthough none of the above attributes are currently used in the rendering code, the RTF I/O module takes advantage of this capability to provide better roundtripping of RTF files.\par\'a5 The RTF I/O module will also preserve several pieces of document-wide information often found in RTF documents: title, subject, author, manager, company, category, keywords, comments, operator and the base address for hyperlinks.\par\'a5 Added support for language tags. Language tags are character-level attributes that specifies the language (and optionally, other locale-related hints, such as the geographic region) of a text range. They\'d5re not currently used by WASTE (except for roundtripping of language information in RTF files), but they\'d5re suitable for a number of future uses, such as spell-checking, thesaurus look-up, hyphenation and locale-savvy smart quotes.\parA language tag is basically a lowercase ISO-639 two- (or three-) letter language code, optionally followed by an underscore and by an uppercase ISO-3166 country code. For example, the following code marks the selection range as US-English:\par}{\pard\plain\f2\fs24\cf0\ql\li480 err = WESetOneAttribute ( kCurrentSelection,\par  kCurrentSelection, weTagLanguage, "en_US", 5, myWE ) ;\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 An empty tag ({\f2 ""}) means that the language is unknown or unspecified.\parThe current implementation of language tags relies on the Mac Locale APIs introduced in Mac OS 8.6, so it\'d5s non-functional on earlier versions of the system software.{\f2 \par}\'a5 A new read-only selector for {\f2 WEGetAttributes}, {\f2 weTagRunDirection}, returns true if the character at the specified offset belongs to a right-to-left script system. This new selector is a replacement for the old, seldom-used {\f2 WEGetRunDirection} API, which is now deprecated.\par\'a5 A new {\f2 WEGetSelectionAnchor} API returns the offset of the selection anchor, i.e., the endpoint that stays put when you shift-extend the selection.\par\'a5 You can now pass the {\f2 wePutAddToTypingSequence} option to {\f2 WEPut} even if you\'d5re not in the middle of a typing sequence (but you\'d5re adding new text at the insertion point). In this case, {\f2 WEPut} will create a new undoable action that behaves like a typing sequence. This allows several {\f2 WEPut} calls in a row, all appending text at the insertion point, to be treated as a single, typing-like, undoable action.\par\'a5 The sequence {\f2 WEBeginAction}/{\f2 WEEndAction}/{\f2 WEUndo} (with no intervening editing between {\f2 WEBeginAction} and {\f2 WEEndAction}) would crash WASTE. Now, closing an empty action sequence with {\f2 WEEndAction} will remove the empty action from the undo stack. In other words, calling {\f2 WEBeginAction} immediately followed by {\f2 WEEndAction} has no effect. Thanks to Jerry \'81man.\par\'a5 {\f2 WEKey} no longer bumps the modification count if you hit backspace when the insertion point is at the very beginning of the text, or if you hit forward delete when the insertion point is at the very end. Thanks to Chris Eplett.\par\'a5 Fixed a long-standing, elusive bug in the paragraph formatting code. To see what this bug did to earlier versions, try this: insert two paragraphs into a blank window, change some paragraph-level attribute of the second paragraph (e.g., make it centered). Then select the first paragraph, including the trailing carriage return, and delete it. In most cases, the second paragraph would incorrectly take up the formatting of the one just removed. The weird thing was, this wouldn\'d5t happen for any pair of paragraphs following the first one. Thanks to the invaluable Kuniaki Nakamitsu.\par\'a5 Fixed a problem in the RTF parser: MS Word (and possibly other programs as well) use the {\f2 \\highlight0} idiom to remove the highlighting altogether, while WASTE would set the highlight color to black, making the text illegible. Thanks to Casey Gorsuch.\par\'a5 Converted this document (the Change History) to RTF format.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.1a3 (October 2001)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 {\f2 WENew} could potentially crash in low-memory situations. Fixed.\par\'a5 {\f2 WEGetIndUndoInfo} would likely crash if passed zero in {\f2 inUndoLevel}. Fixed.\par\'a5 {\f2 WEBeginAction} and {\f2 WEEndAction} were broken in version 2.1a2. Hopefully fixed. Thanks to David Rydh.\par\'a5 Paragraph bottom borders are now drawn even when the paragraph {\f2 spaceAfter} value is less than 2 pt. Thanks to Tom Bender and David Rydh.\par\'a5 Incorporated tentative fix for the \'d2disappearing hilite\'d3 bug noted when undoing/redoing some action and when the current selection and the restored selection ranges live on different lines.  Thanks to Kuniaki Nakamitsu and David Rydh.\par\'a5 {\f2 WEKey} now handles page keys (page up, page down, home and end).\par\'a5 Source code: WASTE wouldn\'d5t link if compiled with the {\f2 WASTE_DRAG_AND_DROP} switch turned off.\par\'a5 Source code: eliminated warnings about missing braces in {\f2 struct} initializers and missing parameter names given by Project Builder.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE Demo 2.1a3 (September 2001)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 This is a major overhaul of the demo application shipped with public WASTE distributions from version 1.x to 2.0b3. The new demo is Carbon-only, requires Mac OS 9.1 or newer and is simpler than the old demos. Among the new features:\par\'a5 Event dispatching is now based on Carbon events. This means less code and (hopefully) better CPU utilization. It will mean even less code as soon as WASTE is updated to better support the Carbon event model.\par\'a5 {\f2 FSSpec}\'d5s have been replaced by {\f2 FSRef}\'d5s everywhere. As a side effect of this change, we now support long (> 32 characters) file names and file names containing arbitrary Unicode characters.\par\'a5 Navigation dialogs now use (actually, require) Navigation Services 3.0 or newer. All navigation dialogs are either window-modal or modeless on OS X.\par\'a5 Document windows support live resizing.\par\'a5 Several seldom-used menus have been removed for the sake of simplicity.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.1a2 (August 2001)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 The source code has been cleaned up so that it compiles with the latest Universal Headers (3.4), CodeWarrior Pro 7 and Project Builder.\par\'a5 A Mach-O static library (WASTE.a) is now included in the public distribution.\par\'a5 The WASTE Demo has been repackaged as a hybrid CFM/Mach-O bundle that can run under Mac OS 8.6 through 10.1.\par\'a5 The Carbon builds of WASTELib will now call Internet Config directly rather than through the Component Manager interface, as the latter is not implemented in Mac OS X. In other words, command-clicking URLs now works again on Mac OS X.\par\'a5 Various private data structures are now malloc-based rather than handle-based. In particular, storage for WASTE instances, action records (used in undo/redo stacks), print sessions and embedded object descriptors is now obtained through {\f2 malloc} calls. This eliminates a lot of extra pointer dereferences and locking/unlocking of handles. Old-style Memory Manager handles are currently still used for growable blocks.\parThis is a purely internal change: an implementation detail you should not be concerned with unless your code incorrectly assumes {\i opaque reference types} like {\f2 WEReference} and {\f2 WEPrintSession} are actual Memory Manager handles.\par\'a5 The Carbon version of WASTELib will use {\f2 TrackMouseLocationWithOptions}, if available, instead of a {\f2 GetMouse}/{\f2 WaitMouseUp} combination, for mouse tracking within {\f2 WEClick}. This results in better CPU utilization, especially under Mac OS X.\par\'a5 Fixed a bug whereby typing command-right arrow to go to the end of the second-to-last line of a document ending with a CR would incorrectly move the cursor down to the last line. Also fixed a similar problem involving command-left arrow. Thanks to Christopher Stone.\par\'a5 Fixed a bug in the undo code that prevented {\f2 WEBeginAction}/{\f2 WEEndAction} from working correctly with {\f2 WECut} and {\f2 WEPaste}. Thanks to Chris Eplett.\par\'a5 Incorporated fix for spurious strikethrough artifact in zero-width style runs such as blank lines. Thanks to Tom Bender.\par\'a5 A new {\f2 WEFindPreviousObject} call complements the existing {\f2 WEFindNextObject} API:\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal SInt32 WEFindPreviousObject\par  (\par    SInt32               inOffset,\par    WEObjectReference *  outObject,   // can be NULL\par    WEReference          inWE\par  );\par\par}{\pard\plain\f2\fs24\cf0\qj\sa120\fi120 WEFindPreviousObject{\f1  looks for the first embedded object }{\f1\i preceding}{\f1  the specified offset: if one is found, a reference to it is returned in }outObject{\f1  and the byte offset to the embedded object in the text stream is returned as function result. If there is no object before the specified offset, }WEFindPreviousObject{\f1  returns }-1{\f1  as function result and sets }outObject{\f1  to }NULL{\f1 .\parYou can pass }NULL{\f1  in }outObject{\f1  if you\'d5re not interested in the object reference.\parYou can pass }-1{\f1  in }inOffset{\f1  as a shortcut for }WEGetTextLength ( inWE ){\f1 .\par\'a5 A new field in the }WEPrintOptions{\f1  record, }firstPageOffset{\f1 , allows you to instruct WASTE to leave a blank area of specified height at the top of the first page. This effectively lets you specify different heights for the first page and for subsequent pages.\parAlso, a new }WEGetPageHeight{\f1  API lets you obtain the pixel height actually used by the printed text on any given page of a print session. This is usually equal to, or slightly less than, the page height, except possibly for the last page. When called for the last page in the range, this call allows you to position objects to be printed after the text.\par}}{\pard\plain\f2\fs24\cf0\ql\li480 pascal SInt32 WEGetPageHeight\par  (\par    SInt32               inPageIndex,\par    WEPrintSession       inPrintSession\par  );\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 The value returned by {\f2 WEGetPageHeight} for the first page includes the height of the blank band at the top specified using {\f2 firstPageOffset} (see above).\parThanks to Richard Aurbach for suggesting these enhancements.\par\'a5 {\f2 WESetAttributes} and {\f2 WESetOneAttribute} now recognize additional meta-selectors that allow you to increase or decrease various paragraph-level attributes by a given delta throughout the specified range.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0b3 (October 2000)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 The fix for the {\f2 FetchFontInfo} problem in 2.0b2 was incomplete, causing the Carbon version of WASTELib to crash on OS 8.5 + CarbonLib 1.0.x. It turns out that CarbonLib 1.0.x does not export {\f2 FetchFontInfo} correctly in OS 8.5, even if that API is in fact available to classic apps (via the {\f2 FontManager} stub). Yes, that definitely looks like a CarbonLib bug. Now we only try to call {\f2 FetchFontInfo} if the system version is 8.6 or newer. Thanks again to the Macster team for reporting this problem.\par\'a5 When styled Unicode import fails because the TEC can\'d5t recognize the target encoding hint, WASTE will now try again with the corresponding base encoding. This fixes a problem where WASTE running on a system prior to Mac OS 8.5 would fail to accept styled Unicode text created under Mac OS 8.5 or newer, because pre-Allegro TECs don't recognize the Euro variant of MacRoman.\par\'a5 When converting traditional styled text to Unicode, WASTE will now silently discard partial source characters rather than stop the convertion process and return an error code.  Partial (or incomplete) characters are errant halves of double-byte characters occurring at the end of a script run. They\'d5re uncommon, but may occur in traditional text if the user forces a font change affecting the underlying text encoding.\par\'a5 Mac OS X Public Beta seems to have a bug (Radar #2551463) in its implementation of {\f2 UpgradeScriptInfoToTextEncoding} (it will return {\f2 paramErr} with some perfectly legal combinations of input parameters) which creates several problems for WASTE. In particular, Japanese inline input was totally broken in OS X PB because of this. To work around this problem, this version of WASTE will use its own fallback implementation if {\f2 UpgradeScriptInfoToTextEncoding} fails, rather than propagating the error up the call chain.\par\'a5 Fixed several issues with {\f2 U+FFFC OBJECT REPLACEMENT CHARACTER}s, used by WASTE as placeholders for embedded objects in Unicode text. WASTE now installs a custom fallback handler during Unicode to text conversion to remap {\f2 U+FFFC} to {\f2 ASCII 1}, which is historically used as a placeholder for embedded objects in traditional Mac encodings.\par{\fs20\b Known problem}{\fs20 : Unfortunately, old (how old?) versions of the Text Encoding Converter treat }{\f2\fs20 U+FFFC}{\fs20  as an undefined, rather than an unmappable, code point, stopping the conversion process without even giving the fallback handler a chance. To work around this problem, you should either make sure you\'d5re using a recent version of the Text Encoding Converter (1.5 is fine) or manually pre-filter the Unicode text replacing }{\f2\fs20 U+FFFC}{\fs20  with }{\f2\fs20 U+0001}{\fs20 .\par}\'a5 Changed {\f2 (x << 16)} to {\f2 BSL(x,16)} in a couple of spots in the source code to prevent problems when compiling with 16-bit ints. Thanks to Tom Bender.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0b2 (August 2000)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 The Carbon version of WASTELib 2.0b1 would crash when running on Mac OS 8.1 with CarbonLib 1.0.x, because it would try to call {\f2 FetchFontInfo} which is never available on OS 8.1 (even if the t-vector in CarbonLib is nonzero). Thanks to Chris Silverberg and Jason Toffaletti.\par\'a5 Action sequences (the internal mechanism used to implement a sequence of undoable actions to be treated as a single action) were badly broken in that consecutive sequences were incorrectly merged into a single sequence. This affected both {\f2 WEBeginAction} / {\f2 WEEndAction} and undo of drag-and-drop actions. In this release, action sequences have been completely reimplemented using a different mechanism. Thanks to Dennis Ionov.\par\'a5 {\f2 WEUndo} and {\f2 WERedo} will now return an explicit error code ({\f2 weProtocolErr}) if called within a {\f2 WEBeginAction} / {\f2 WEEndAction} pair.\par\'a5 {\f2 WEEndAction} will return an error code ({\f2 paramErr}) if the {\f2 inActionKind} parameter is zero or negative.\par\'a5 Automatic keyboard synchronization no longer occurs in inactive WASTE instances.\par\'a5 Bottom borders now honor paragraph indents.\par\'a5 {\f2 kCurrentSelection} can now be passed to {\f2 WEGetRunDirection}.\par\'a5 Source code problem: {\f2 ItemReference} is now used instead of {\f2 DragItemRef} for compatibility with version 3.2 of the Universal Interfaces. Thanks to Mark Bernstein.\par\'a5 Removed use of {\f2 TrackMouseLocation} to allow Carbon target to be compiled with version 3.3 of Universal Headers.\par\'a5 Removed {\f2 WEPutCFString} (undocumented but exported by WASTELib 2.0b1). I will put it back after 2.0.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0b1 (July 2000)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 {\f2 WESetAttributes} (and {\f2 WESetOneAttribute}) would crash if passed out-of-range parameters in {\f2 inRangeStart} and {\f2 inRangeEnd}. Fixed. Thanks to Adam Woodworth for first reporting this.\par\'a5 Fixed a problem with drag-and-drop text editing under Mac OS X where a WASTE instance would fail to detect drags originating from itself.\par\'a5 Fixed a problem in {\f2 WEPut} where unstyled text inserted at a location other than the current insertion point was incorrectly picking up the null style. Thanks to Tom Bender.\par\'a5 The Carbon version of WASTE was assuming {\f2 FetchFontInfo} is always available under Carbon, which is not the case for CarbonLib 1.0.x running under Mac OS 8.1. Thanks to Jason Toffaletti.\par\'a5 The CFM termination routine in the WASTELib shared library (invoked automatically by the Code Fragment Manager when the connection to the library is closed) now performs some cleanup. Global data structures are released and Apple event handlers installed by WASTE are removed. In most cases, this cleanup is not necessary, as the connection to WASTELib is only closed when the client application quits, but it\'d5s a good idea for clients that manually load and unload WASTELib.\par\'a5 Added a {\f2 WERemoveObjectHandler} API that complements the existing {\f2 WEInstallObjectHandler}.\par\'a5 The {\f2 DisposeWE*UPP} routines now perform some stricter tests on their input and will do nothing if the opaque UPP you pass in is null or doesn\'d5t look like something that was created by the corresponding {\f2 NewWE*UPP} call.\par\'a5 A couple of points in the source code (in {\f2 WEGetAttributes} and {\f2 WEMatchAttributes}) incorrectly assumed {\f2 sizeof(int) == 4}. Fixed, although this was only a problem if you compiled your own version of the library. Thanks to Tom Bender for spotting this.\par\'a5 Fixed a problem where some WASTE calls were tapping temporary memory for potentially large blocks meant to be kept around after the completion of the call, even if you don\'d5t have the {\f2 weFUseTempMem} feature flag enabled. Specifically, WASTE would unconditionally tap temporary memory for embedded object data and for the undo/redo stacks. Now, if you have the {\f2 weFUseTempMem} feature flag disabled, all temporary memory allocated by WASTE calls will be released before the call returns. Thanks to Glenn Berntson.\par\'a5 Upped the default memory partition allocated to the carbonated WASTE Demo to two megs (from 512K) to cope with increasingly memory-hungry builds of CarbonLib 1.1.  This solves a number of silent failures reported with the previous version.\par\'a5 The carbonated WASTE Demo now supports both the old, sessionless Carbon printing APIs and the new, session-oriented printing APIs introduced with CarbonLib 1.1, which are the recommended APIs for Mac OS X. The pre-built demo apps that comes with this distribution uses the old APIs for compatibility with CarbonLib 1.0.x.\par\'a5 The WASTE Demo will now treat \'d4TEXT\'d5 files that begin with what looks like a byte-order mark ({\f2 0xFEFF} or {\f2 0xFFFE}) as Unicode text files.\par\'a5 Fixed a bug in the WASTE Demo where it was calling {\f2 CheckMenuItem} with a zero item parameter.\par\'a5 WASTE Demo: the \'d4Quit\'d5 menu item is now removed from the File menu when running under Mac OS X.\par\'a5 WASTE Demo: the icon for \'d4utxt\'d5 files sports a distinctive badge with the Unicode logo.\par\'a5 WASTE Demo: added stationery pad support.\par\'a5 WASTE Demo: added a format popup to the Save As dialog.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a15 (April 2000)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 Fixed a couple of stupid, evil and probably crashing bugs. Spotlight is a godsend.\par\'a5 The WASTE Demo will now save embedded objects in Unicode text files.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a14 (April 2000)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 Added support for exchanging {\b styled Unicode text} with the external world. This completes my planned feature set for version 2.0 and makes this version a {\b beta candidate}.\parStyled Unicode text in the WASTE 2.0 sense is a UTF-16 stream accompanied by the usual four WASTE 2.0 formatting scraps ({\f2 WEcf}, {\f2 WEst}, {\f2 WEpf} and {\f2 WEru}). A couple of considerations about these scraps. First, the text offsets in the {\f2 WEcf} and {\f2 WEpf} scraps are relative to the Unicode text, not to the original text, but they\'d5re nonetheless {\b byte} offsets (and thus always even numbers). Secondly, the text encodings specified in the {\f2 WEst} scrap using the \'d4ptxe\'d5 tag are merely {\b hints} used to convert the Unicode text back to traditional Mac OS encodings, while the same tags specify the actual encoding of the corresponding text range when a {\f2 WEst} scrap is used for traditional text.\parTo obtain styled Unicode text for a given range, first use {\f2 WEStreamRange} to create the formatting scraps, then use the new API {\f2 WEGetTextRangeAsUnicode} to convert the specified range to Unicode while at the same time remapping offsets in the {\f2 WEcf} and {\f2 WEpf} scraps.\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr WEGetTextRangeAsUnicode\par  (\par    SInt32               inRangeStart,\par    SInt32               inRangeEnd,\par    Handle               outUnicodeText,\par    Handle               ioCharFormat,       // 'WEcf'\par    Handle               ioParaFormat,       // 'WEpf'\par    TextEncodingVariant  inUnicodeVariant,\par    TextEncodingFormat   inTransformationFormat,\par    OptionBits           inGetOptions,\par    WEReference          inWE\par  );\par}{\pard\plain\f2\fs24\cf0\qj\sa120\fi120 WEGetTextRangeAsUnicode{\f1  is the low-level routine used internally by WASTE when you call }WEStreamRange{\f1  with the }kTypeUnicodeText{\f1  or }kTypeUTF8Text{\f1  selectors: }inRangeStart{\f1  and }inRangeEnd{\f1  specify a range to convert, }outUnicodeText{\f1  is a handle to hold the converted text, }ioCharFormat{\f1  and }ioParaFormat{\f1 , both optional, are handles to }WEcf{\f1  and }WEpf{\f1  scraps, respectively, to be remapped for the converted text. The }inTransformationFormat{\f1  parameter allows you to specify UTF-16 or UTF-8 Unicode. You can pass }weGetLittleEndian{\f1  in the }inGetOptions{\f1  parameter to specify that you want the text in little-endian byte-order (only applicable to UTF-16), and }weGetAddUnicodeBOM{\f1  to prepend a byte-order mark to the converted text.\par}WEPut{\f1  now accepts styled Unicode text created in this way.\par\'a5 WASTE 2.0 style tables (}WEst{\f1  scraps) can now optionally include embedded objects. Such style tables obviate the need for a separate }SOUP{\f1  scrap, and are the only supported way to save embedded object information for styled Unicode text.\parTo create a style table containing embedded object descriptions, call }WEStreamRange{\f1  with the }kTypeStyleScrap{\f1  selector, specifying }weStreamIncludeObjects{\f1  in the }inStreamOptions{\f1  parameter. }WEPut{\f1  will automatically recognize style tables containing embedded object information.\par\'a5 Changed the WASTE Demo so that it can read and write (styled) Unicode text files.\par}{\f1\fs20\b\ul NOTE:}{\f1\fs20  According to Apple\'d5s guidelines, such files have a \'d4utxt\'d5 file type and begin with a byte-order mark. Currently, only a few Macintosh applications can read such files. BBEdit Lite (as of version 4.6) and Style (as of version 1.6.1) are two of them. Microsoft Word 98 kind of works, but doesn\'d5t recognize Unicode paragraph separators (U+2029) correctly.\par}{\f1 \'a5 Revised the }{\f1\b Intro to WASTE 2.0}{\f1  document. A new section discusses compatibility issues and lists deprecated APIs.\par\'a5 Converted all documentation files (including the one you\'d5re reading now) to Unicode format.\par\'a5 Included a tentative fix for the long-standing \'d2ghost trail\'d3 problem occasionally seen on Japanese systems, where a phantom glyph is still visible at the end of a line but the real character has been moved to the beginning of the following line by the line-breaking algorithm. Thanks to Koiso Norihito for suggesting this fix.\par\'a5 Fixed a nasty bug in }WEStreamRange{\f1  (actually, in the previously undocumented }WEGetTextRangeAsUnicode{\f1 ) that could corrupt memory and cause intermittent crashes.\par\'a5 Slightly tweaked the Roman line-breaking algorithm in an attempt to make its behavior reflect as closely as possible what TextEdit does. Thanks to Dave Perman for suggesting this.\par\'a5 Fixed a bug in }WEPut{\f1  introduced in version 2.0a13, where WASTE would fail to delete the specified text range if passed zero in the }inTextLength{\f1  parameter. Again, thanks to Koiso Norihito for catching and reporting this.\par}}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a13 (March 2000)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 {\f2 WEPut} no longer honors the {\f2 weFReadOnly} feature flag.\par{\fs20 However, other routines that call }{\f2\fs20 WEPut}{\fs20  internally, like }{\f2\fs20 WEPaste}{\fs20 , }{\f2\fs20 WEInsert}{\fs20  and }{\f2\fs20 WEInsertFormattedText}{\fs20  will return a }{\f2\fs20 weReadOnlyErr}{\fs20  result code if called with the read-only feature on, as they did in all previous versions.\par}\'a5 {\f2 WESetAttributes} and {\f2 WESetOneAttribute} no longer honor the {\f2 weFReadOnly} feature flag.\par\'a5 Added support for inserting Unicode text in the canonical UTF-16 format using {\f2 WEPut}. To insert Unicode text, pass {\f2 kTextEncodingUnicodeDefault} in the {\f2 inTextEncoding} parameter. Formatting flavors will be ignored. WASTE will use all of the installed scripts and fonts in an attempt to render Unicode characters not covered by the font used at the insertion point. For example, if you call {\f2 WEPut} to insert the Unicode character {\f2 U+0411} ({\f2\fs20 CYRILLIC CAPITAL LETTER BE}) and the font at the insertion point is Geneva but you have Osaka installed on your system, WASTE will use Osaka to render the Cyrillic character, because Osaka includes the corresponding glyph, while Geneva does not.\parBy default, {\f2 WEPut} assumes the Unicode text has a big-endian byte order and does not begin with a byte-order mark (BOM). However, if you specify the {\f2 wePutDetectUnicodeBOM} in the {\f2 inPutOptions} parameter, WASTE will look for a byte-order mark (i.e., it will test the first two bytes against {\f2 0xFEFF} and {\f2 0xFFFE}), strip it off and endian-swap the remaining words if necessary. It is recommended that you always look for and add BOMs when exchanging UTF-16 text with external sources.\par\'a5 In this version, the only allowed values for the {\f2 inTextEncoding} parameter in {\f2 WEPut} are {\f2 kTextEncodingMultiRun} and {\f2 kTextEncodingUnicodeDefault}. {\f2 WEPut} will fail with a {\f2 weInvalidTextEncodingErr} result code if any other value is passed. Future releases will accept additional encodings.\par{\fs20\b\ul NOTE}{\fs20 : the }{\f2\fs20 inTextEncoding}{\fs20  parameter was simply ignored in 2.0a11 and 2.0a12.\par}\'a5 WASTE will now look for a 'utxt' flavor (Unicode text in UTF-16 format) in the clipboard and in incoming drags, but only if no 'TEXT' is found.\par\'a5 Changed the WASTE Demo so it can read 'utxt' files.\par\'a5 {\f2 WEBeginAction} and {\f2 WEEndAction} are now implemented.\par\'a5 Fixed a bug introduced in version 2.0a10 that caused extra spaces introduced by intelligent cut and paste rules to be included in the selection when drag-moving a text range towards the beginning of the text.\par\'a5 Fixed a printing bug that caused certain glyphs extending past the leftmost or rightmost edge of the printable area to get clipped. This would usually happen with italic text at large font sizes.\par\'a5 Added declarations to the header files for the previously undocumented custom font mapper hooks. These are two callbacks, identified by the {\f2 weFontFamilyToNameHook} and {\f2 weFontNameToFamilyHook} selectors, invoked by WASTE when it creates and when it parses scraps that contain font names (the \'d4WEst\'d5 style scrap and the old \'d4FISH\'d5 font table). The prototypes for these hooks are the previously defined {\f2 WEFontIDToNameProcPtr} and {\f2 WEFontNameToIDProcPtr}.\par\'a5 Added a special {\f2 kNullStyle} constant for {\f2 WEGetAttributes} (thanks to Kuniaki Nakamitsu for suggesting this). Passing this constant in the {\f2 inRangeStart} and {\f2 inRangeEnd} parameters allows you to retrieve the so-called \'d2null\'d3 style, i.e., the style that WASTE would apply to the next typed character. When the selection is empty, the null style may not be the same as the style at the current insertion point. This happens because when the selection is empty, there is no proper range to which style changes can be applied, so WASTE needs an internal record to keep track of these changes. You can get the style at the current insertion point (as opposed to the null style) by passing {\f2 kCurrentSelection} in the {\f2 inRangeStart}/{\f2 inRangeEnd} parameters.\par{\fs20\b\ul NOTE:}{\fs20  This new behavior (changed from version 2.0a12) only affects }{\f2\fs20 WEGetAttributes}{\fs20  and its simplified version }{\f2\fs20 WEGetOneAttribute}{\fs20 . It does not affect }{\f2\fs20 WEMatchAttributes}{\fs20 .\par}\'a5 In Carbon builds, WASTE will ignore result codes from the Toolbox routine {\f2 UpgradeScriptInfoToTextEncoding}, as a workaround for a bug in Mac OS X Developer Preview 3.\par\'a5 Added a \'d4carb\'d5 resource to carbonated demo so it is launched as a Carbon app in OS X DP3.\par\'a5 Fixed invalid memory access caught by Spotlight in {\f2 SLPixelToChar}.\par\'a5 All calls to {\f2 NewRgn} now always check for a null result.\par\'a5 Fixed old UPP macros in {\f2 WASTE.h} (thanks to Brian Stern). The old {\f2 NewWExProc} and {\f2 CallWExProc} macros are now mapped to {\f2 NewWExUPP} and {\f2 InvokeWExUPP}, respectively.\par\'a5 Fixed a problem with UPPs in the Pascal interface file (thanks to Glenn Bertson for reporting this).\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a12 (January 2000)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 Fixed a nasty undo-related bug in {\f2 WEPut} (thanks to Koiso Norihito).\par\'a5 Plugged a memory leak in {\f2 WEMatchAttributes}.\par\'a5 Fixed a bug in {\f2 WEUseText}.\par\'a5 Changed {\f2 WEMatchAttributes} and {\f2 WEGetAttribute} so that they use the \'d2null style\'d3 when appropriate.\par\'a5 {\f2 WEPut} no longer moves the selection range (leaving ghost hilites) when called for ranges that don\'d5t overlap the selection range.\par\'a5 {\f2 WESetAttributes} and {\f2 WESetOneAttribute} could mess up the selection hilite when called for a range other than the selection range.\par\'a5 Fixed a couple of problems in the Pascal interface file (missing {\f2 weTagStrikethrough}, misspelled {\f2 weTagRightIndent}).\par\'a5 You can now pass {\f2 kCurrentSelection} to {\f2 WEGetRunInfo} and {\f2 WEGetParaInfo}.\par\'a5 {\f2 WEGetAttributes} and {\f2 WEGetOneAttribute} now recognize two additional read-only tags: {\f2 weTagQDStyles} and {\f2 weTagTETextStyle}. The first tag returns the QuickDraw styles as a {\f2 Style} quantity; the second tag returns a {\f2 TextStyle} record.\par\'a5 Added {\f2 WEGetObjectAtOffset} API.\par\'a5 The Carbon version of WASTELib now supports command-clicking of URLs via Internet Config (even when linking against CarbonLib 1.0 at runtime).\par\'a5 A static library for Carbon is now included.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a11 (January 2000)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 WASTE 2.0a10 had some major problems when running under non-Roman system software. These problems are hopefully fixed in this version. Thanks to Koiso Norihito and Kuniaki Nakamitsu.\par\'a5 The classic 68K static library in the a10 distribution was broken in many ways due to wrong compiler settings. This is fixed in a11. Again, thanks to Kuniaki Nakamitsu.\par\'a5 Fixed a serious bug in {\f2 WENewPrintSession} that would corrupt the WASTE instance if its destination rectangle and the specified page rectangle had the same width.\par\'a5 A new {\f2 WEPut} API lets you insert text accompanied by the new character formatting scraps introduced in WASTE 2.0a10, while providing a superset of the functionality exposed by {\f2 WEInsert} and {\f2 WEInsertFormattedText}.\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr WEPut\par  (\par    SInt32               inRangeStart,\par    SInt32               inRangeEnd,\par    const void *         inTextPtr,\par    SInt32               inTextLength,\par    TextEncoding         inTextEncoding,\par    OptionBits           inPutOptions,\par    ItemCount            inFlavorCount,\par    const FlavorType *   inFlavorTypes,\par    const Handle *       inFlavorHandles,\par    WEReference          inWE\par  );\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \parSome interesting properties of {\f2 WEPut}:\par}{\pard\plain\f1\fs24\cf0\qj\sa120\li400 First of all, {\f2 WEPut} allows you to insert text at an arbitrary offset (not just at the current insertion point), optionally replacing the range specified by {\f2 inRangeStart} and {\f2 inRangeEnd}. Pass {\f2 kCurrentSelection} in these parameters to add the new text at the current insertion point, just like {\f2 WEInsert} would do.\parThe parameters {\f2 inFlavorCount}, {\f2 inFlavorTypes} and {\f2 inFlavorHandles} specify a set of formatting scraps to be applied to the inserted text. Several flavor combinations are possible. For example, you can specify a TextEdit-style \'d2styl\'d3 scrap, optionally accompanied by a WASTE 1.x \'d2FISH\'d3 font table. Or you can specify WASTE 2.0 formatting scraps (\'d2WEcf\'d3, \'d2WEst\'d3, \'d2WEpf\'d3 and \'d2WEru\'d3). You can specify an optional \'d2SOUP\'d3 scrap in both cases. Pass zero in {\f2 inFlavorCount} to insert raw text.\parThe {\f2 inTextEncoding} parameter specifies the encoding of the source text, and should be used when the encoding is not already implicitly specified by the formatting information, as is the case with WEcf/WEst pairs. If the formatting scraps implicitly specify the text encoding(s) used in the source text, these encodings override whatever you pass in {\f2 inTextEncoding}, so it is recommended that you pass {\f2 kTextEncodingMultiRun} in this situation. {\fs20\b\ul NOTE}{\fs20 : the }{\f2\fs20 inTextEncoding}{\fs20  parameter is ignored in this version of WASTE.}\parPassing {\f2 wePutIntCutAndPaste} in the {\f2 inPutOptions} parameter allows you to specify whether intelligent cut and paste rules should be applied to the inserted text or not. Unlike {\f2 WEInsert} and {\f2 WEInsertFormattedText}, {\f2 WEPut} ignores the state of the {\f2 weFIntCutAndPaste} feature flag.\parPassing {\f2 wePutAddToTypingSequence} in the {\f2 inPutOptions} parameter allows you to insert text at the current insertion point without disrupting the ongoing typing sequence (if any). Normally, calling {\f2 WEPut} breaks any ongoing typing sequence and generates a new, separate undoable action. When you specify {\f2 wePutAddToTypingSequence} (and some suitable conditions are met), WASTE treats the new text somewhat as if it were inserted by repeated calls to {\f2 WEKey}. This option can be used to implement an auto-indent feature.\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 Added support for the {\strike strikethrough} style attribute. You can set and inspect the state of this attribute using the new {\f2 weTagStrikethrough} tag in conjuction with {\f2 WESetAttributes}, {\f2 WEGetAttributes}, etc.\par\'a5 The WASTE Demo now saves extended formatting information in text files and reads it back using {\f2 WEPut}.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a10 (November 1999)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 WASTE now keeps track internally of the {\b text encoding} associated with each style run. Like the script code, the text encoding can be derived from the font family number, but unlike the script code, the text encoding describes the mapping between code points and characters in a much more precise way.\par\'a5 WASTE will now export character formatting information in a new scrap format, in addition to the TextEdit-style \'d4styl\'d5 format. This scrap format mirrors the one used for paragraph-level formatting: it\'d5s split into two interdependent flavors: a style table (flavor type \'d4WEst\'d5), which lists each unique style used in the text, and a character formatting array (flavor type \'d4WEcf\'d5) that maps text offsets to style table entries. The advantages of this new format are the following:\par}{\pard\plain\f1\fs24\cf0\qj\sa120\li400 Memory-efficient. The size of the new flavors combined is typically less than the size of a \'d4styl\'d5 scrap.\parExtensible. Styles are stored in a tree-like structure modeled after Apple event lists/records, and tagged with four-letter codes. When new styles are added to future versions of WASTE, older programs can still parse the tags they understand and skip the ones they don\'d5t.\parPreserves the new character formatting styles introduced in WASTE 2.0a9 (vertical shift and background color).\parStores font names (with their corresponding text encoding) rather than font family numbers, obviating the need for a separate font table (the \'d4FISH\'d5 flavor that can still be used to complement \'d4styl\'d5 scraps).\parAccurately describes the text encoding of the accompanying text.\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 A new read-only attribute selector, {\f2 weTagTextEncoding} (type {\f2 TextEncoding}), can be used to retrieve the text encoding associated with any character in the text. This attribute tag can is only valid in calls to {\f2 WEGetAttributes} or {\f2 WEGetOneAttribute}.\par\'a5 A new {\f2 weTagTransferMode} attribute selector can be used to specify the QuickDraw text transfer mode to be used to combine text and background color. Most applications should stick with the default transfer mode traditionally used by WASTE, {\f2 srcOr}.\par\'a5 Optimized some low-level routines to reduce the number of calls to {\f2 FetchFontInfo} (or {\f2 GetFontInfo}, in systems prior to 8.5) to the absolute minimum.\par\'a5 Fixed a bug in the cursor-adjusting code introduced in version 2.0a8, which prevented the cursor from being turned into an arrow over selected embedded objects without a hover handler (or with a hover handler returning {\f2 weNotHandledErr}).\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a9 (October 1999)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 Introduced a new set of extensible, tag-based accessors for both character-level and paragraph-level attributes. These new accessors do not depend on rigid structures like {\f2 WETextStyle} and {\f2 WERuler}, so they allow for easier introduction of new attributes in future versions of WASTE. The functionality made available by the new attribute accessors is a superset of what you can do with {\f2 WESetStyle}, {\f2 WESetRuler}, {\f2 WEContinuousStyle} and {\f2 WEContinuousRuler}.\parThe new generic attribute-setter function is called {\f2 WESetAttributes} and it looks like this:\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr WESetAttributes\par  (\par    SInt32               inRangeStart,\par    SInt32               inRangeEnd,\par    ItemCount            inAttributeCount,\par    const WESelector     inAttributeSelectors [ ],\par    const void * const   inAttributeValues [ ],\par    const ByteCount      inAttributeValueSizes [ ],\par    WEReference          inWE\par  );\par{\f1 \par}}{\pard\plain\f2\fs24\cf0\qj\sa120\fi120 WESetAttributes{\f1  can apply any number of attributes at once (even a mixture of character-level and paragraph-level attributes) on any text range (not just the selected text) as a single undoable action. You pass it three arrays, each one having the number of items specified in }inAttributeCount{\f1 : }inAttributeSelectors{\f1  is an array of four-letter tags specifying the attributes to be applied, }inAttributeValues{\f1  is an array of pointers to the corresponding attribute values, and }inAttributeValueSizes{\f1  specifies the size in bytes of each attribute value.\parA conveniently simplified version of this call, }WESetOneAttribute{\f1 , can be used when there\'d5s only one attribute to set:\par}}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr WESetOneAttribute\par  (\par    SInt32               inRangeStart,\par    SInt32               inRangeEnd,\par    WESelector           inAttributeSelector,\par    const void *         inAttributeValue,\par    ByteCount            inAttributeValueSize,\par    WEReference          inWE\par  );\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 Unsurprisingly, the new generic attribute-getter function is called {\f2 WEGetAttributes} and is declared like this:\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr WEGetAttributes\par  (\par    SInt32               inOffset,\par    ItemCount            inAttributeCount,\par    const WESelector     inAttributeSelectors [ ],\par    void * const         outAttributeValues [ ],\par    const ByteCount      inAttributeValueSizes [ ],\par    WEReference          inWE\par  );\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \parThis call lets you retrieve any number of attributes at once for any given character in the text. This call, too, has a conveniently simplified version to get just one attribute, {\f2 WEGetOneAttribute}.\parYou pass a single offset to {\f2 WEGetAttributes}, rather than a range, because the same attribute can have multiple values over an arbitrary range. In fact, applications often need to determine whether a given attribute value, or a set of attribute values, are present over a range, and whether they\'d5re continuous. The old {\f2 WEContinuousStyle} and {\f2 WEContinuousRuler} APIs addressed this need, but had various shortcomings. The new {\f2 WEMatchAttributes} is an attempt to overcome those shortcomings and is declared like this:\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr WEMatchAttributes\par  (\par    SInt32               inRangeStart,\par    SInt32               inRangeEnd,\par    WESelector           inAttributeSelector,\par    ByteCount            inAttributeValueSize,\par    ItemCount            inArraySize,\par    const void *         inValueArray,\par    Boolean              outWhichValuesArePresent [ ],\par    Boolean *            outIsContinuous,\par    WEReference          inWE\par  );\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \parYou pass it an array of homogeneous attribute values (i.e., an array of fonts, or an array of colors) to be matched against existing attribute values over a given selection range. {\f2 WEMatchAttributes} will fill in an array of Booleans, setting the entries corresponding to attribute values which are represented in the specified range. It will also set {\f2 outIsContinuous} to true if the specified attribute has only one continuous value across the whole range. Applications can use {\f2 WEMatchAttributes} to mark Font, Size and Style menus according to Apple\'d5s Human Interface Guidelines, which dictate the use of checkmarks for continuous styles, and dashes for discontinuous styles.\parHere are the character-level attribute selectors (four-letter tags) currently supported by the new accessors, along with the corresponding data types:\par}{\pard\plain\f2\fs24\cf0\qj\sa120\li400 weTagFontFamily{\f1  (type }FMFontFamily{\f1 , or }SInt16{\f1  for pre-Sonata headers) specifies the font family.\par}weTagFontSize{\f1  (type }Fixed{\f1 ) specifies the font size in PostScript points as a fixed-point (16:16) quantity for future extension, even if the fractional part is currently ignored by WASTE.\par}weTagBold{\f1 , }weTagItalic{\f1 , }weTagUnderline{\f1 , }weTagOutline{\f1 , }weTagShadow{\f1 , }weTagCondensed{\f1  and }weTagExtended{\f1  (type }Boolean{\f1 ) specify the corresponding QuickDraw styles. Since these are considered separate attributes, you can selectively turn one on while turning another off at the same time and leave every other style alone, all with a single call to }WESetAttributes{\f1 . Okay, you could do the same thing using }WESetStyle{\f1  with the }weDoFaceMask{\f1  selector, but the new scheme is more straightforward. Note that }weTagCondensed{\f1  and }weTagExtended{\f1  are mutually exclusive (setting either one automatically clears the other).\par}weTagPlain{\f1  (type }Boolean{\f1 ) is really a meta-attribute specifying the absence of all QuickDraw styles. Setting this attribute to }true{\f1  removes all QuickDraw styles, while setting it to false has no effect. Matching this attribute against }true{\f1  with }WEMatchAttributes{\f1  will tell you whether any portion of the selection is plain, and whether the whole selection is plain. You couldn\'d5t determine this using }WEContinuousStyle{\f1 .\par}weTagTextColor{\f1  (type }RGBColor{\f1 ) specifies the foreground color applied to the text, while }weTagBackgroundColor{\f1  (type }RGBColor{\f1 ) specifies the background color in effect when the QuickDraw text-drawing primitive is invoked. }{\f1\fs20\b\ul Warning}{\f1\fs20 : the background color is an experimental feature that may be removed in future versions, so don\'d5t rely on it. The selection hilite doesn\'d5t display well on text with background color, and there is currently no way to remove the background color once it\'d5s set.}{\f1 \par}weTagVerticalShift{\f1  (type }Fixed{\f1 ) specifies a vertical dislocation from the baseline applied to the affected glyphs or embedded objects, expressed in PostScript points as a fixed-point quantity (the fractional part is currently ignored). Positive values move the affected glyphs up, while negative values move them down. This attribute can be used to implement subscripts and superscripts.\parAnd now the paragraph-level selectors:\par}weTagAlignment{\f1  (type }WESelector{\f1 ) specifies the paragraph alignment. Its value can be one of }weTagAlignmentDefault{\f1  (align according to system direction), }weTagAlignmentLeft{\f1 , }weTagAlignmentCenter{\f1 , }weTagAlignmentRight{\f1  or }weTagAlignmentFull{\f1  (full justification).\par}weTagLeftIndent{\f1  and }weTagRightIndent{\f1  (type }Fixed{\f1 ) specify the amount of extra horizontal space between the paragraph and the left and right margins of the destination rectangle. }weTagFirstLineIndent{\f1  specifies an extra margin for the first line only.\par}weTagLineSpacing{\f1  (type }Fixed{\f1 ) specifies the amount of vertical spacing between paragraph lines, relative to the line height: }0.0{\f1  represents the normal spacing, }0.5{\f1  stands for one-and-half spacing, and }1.0{\f1  signifies double line spacing.\par}weTagSpaceBefore{\f1  and }weTagSpaceAfter{\f1  (type }Fixed{\f1 ) specify the amount of extra vertical space before and after a paragraph.\par}weTagDirection{\f1  (type }WESelector{\f1 ) specifies the dominant (primary) line direction in a bidirectional script environment. Its value can be one of }weTagDirectionDefault{\f1  (arrange bidirectional text according to the system direction), }weTagDirectionLeftToRight{\f1  or }weTagDirectionRightToLeft{\f1 .\par}weTagBottomBorderStyle{\f1  (type }WESelector{\f1 ) can be used to add a horizontal border line below the last line of the paragraph. In order for this border to be drawn correctly, there must be some extra space after the paragraph, or more than single line spacing must be used. Currently supported border styles include thin, thick and dotted.\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 All the new attribute accessors accept {\f2 kCurrentSelection} as a meta-value to signify the current selection range.\par\'a5 Updated the WASTE Demo to show the use of the new attribute accessors.\par\'a5 Starting from this release, WASTELib contains three versions of the library merged into one file: the CFM-68K version, the \'d2classic\'d3 PowerPC version, and the Carbon version. In order to use the Carbon version of the library, link your application against the \'d2CarbonWASTELib\'d3 stub library.\par\'a5 A new feature flag, {\f2 weFNoKeyboardSync}, allows you to disable the automatic font/keyboard synchronization normally performed by WASTE as per Human Interface Guidelines. This runtime flag replaces the old {\f2 WASTE_NO_SYNCH} compile-time switch.\par\'a5 Carbon status: the carbonated WASTELib has been tested with the CarbonLib in beta and final candidate versions of Sonata (Mac OS 9.0) and seems as stable as the classic (non-Carbon) version.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a8 (September 1999)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 Fixed a bug in {\f2 WEGetObjectSize} (thanks to Kuniaki Nakamitsu).\par\'a5 Re-implemented some low-level plumbing for embedded objects. As a result, some calls, like {\f2 WEGetObjectOffset}, are now much faster than before.\par\'a5 Added a new {\f2 WEGetObjectFrame} API that returns the bounding box of an embedded object, in long coordinates (as the object may be outside the Quickdraw space). It is illegal to call this new API from within a \'d2new\'d3 handler.\par\'a5 Added a new \'d2hover\'d3 handler for embedded objects. This handler can be used to set the cursor when the mouse is over an object, or to display help balloons or status messages when the mouse enters and leaves an object. A hover handler looks like this:\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr MyHoverHandler\par  (\par    SInt16               inMouseAction,\par    Point                inMouseLoc,\par    RgnHandle            inMouseRgn,\par    WEObjectReference    inObjectRef\par  );\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \parThe {\f2 inMouseAction} parameter can be one of {\f2 weMouseEnter}, {\f2 weMouseWithin} or {\f2 weMouseLeave}. The {\f2 inMouseLoc} parameter is the current mouse location, in local (port) coordinates. The {\f2 inMouseRgn} parameter is only valid when {\f2 inMouseAction} is {\f2 weMouseEnter} or {\f2 weMouseWithin}. Its initial value is the rectangular region (in local coordinates) enclosing the object. The handler can restrict this region to be a portion of the object frame: WASTE will call the handler again as soon as the mouse leaves this region. This is useful for complex objects that need to set the cursor to several different shapes.\parThe hover handler should set the cursor when {\f2 inMouseAction} is {\f2 weMouseEnter} (and optionally, when {\f2 inMouseAction} is {\f2 weMouseWithin}); it shouldn\'d5t touch the cursor when {\f2 inMouseAction} is {\f2 weMouseLeave}. To have WASTE take care of the cursor for you, return {\f2 weNotHandledErr} from the handler.\parHover handlers are invoked from {\f2 WEAdjustCursor}, so your application must call {\f2 WEAdjustCursor} and {\f2 WaitNextEvent} in the usual way for hover handlers to work correctly.\parHere\'d5s a sample hover handler that turns the cursor into a hand when the mouse is over a picture:\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr MyHoverHandler\par  (\par    SInt16               inMouseAction,\par    Point                /*inMouseLoc*/,\par    RgnHandle            /*inMouseRgn*/,\par    WEObjectReference    /*inObjectRef*/\par  )\par\{\par    if ( inMouseAction == weMouseEnter )\par    \{\par        SetCursor ( * GetCursor ( kHandCursorID ) ) ;\par    \}\par\par    return noErr ;\par\}\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 Install the handler code like this:\par}{\pard\plain\f2\fs24\cf0\ql\li480 static WEHoverObjectUPP upp = NULL ;\par\parif ( upp == NULL )\par\{\par    upp = NewWEHoverObjectUPP ( MyHoverHandler ) ;\par\}\par\parWEInstallObjectHandler ( 'PICT', weHoverHandler, upp, myWE ) ;\par}{\pard\plain\f2\fs24\cf0\qj\sa120\fi120 \par{\f1 \'a5 WASTE Demo: re-implemented live scrolling in Apple-blessed (and Appearance-dependent) way.\par\'a5 WASTE Demo: implemented window transitions (aka zooming rectangles).\par\'a5 Some routines, like }WEStreamRange{\f1  and }WEGetHiliteRgn{\f1 , now accept a }kCurrentSelection{\f1  (}-1{\f1 ) meta-value, that can be used to signify the current selection range.\par\'a5 Fixed a problem that caused }WEGetObjectOffset{\f1  to return }kInvalidOffset{\f1  (}-1{\f1 ) in some rare circumstances.\par}}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a7 (August 1999)\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 Fixed a problem with the command-right arrow combination introduced in the previous version.\par\'a5 Fixed a potentially crashing bug in {\f2 WEGetIndRunInfo} (thanks to Timothy Paustian).\par\'a5 Added new printing APIs, described in a separate document.\par\'a5 Added {\f2 WEFind}, a new string matching API. The implementation of this call is based on a variation of the Boyer-Moore string matching algorithm: the longer the search string, the faster the search. The implementation has not been tested with non-Roman script systems yet, but the final release will support them.\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal OSErr WEFind\par  (\par    const char *      inKey,\par    SInt32            inKeyLength,\par    TextEncoding      inKeyEncoding,\par    OptionBits        inMatchOptions,\par    SInt32            inRangeStart,\par    SInt32            inRangeEnd,\par    SInt32 *          outMatchStart,\par    SInt32 *          outMatchEnd,\par    WEReference       inWE\par  );\par\par}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 The search string is described by the first three parameters: {\f2 inKey} points to the first character of the string, {\f2 inKeyLength} specifies the length of the search string in bytes and {\f2 inKeyEncoding} tells WASTE how the search string is encoded (pass {\f2 0 = smRoman} if you\'d5re looking for a plain ASCII string). Currently, {\f2 inKeyEncoding} must be the script code of an installed and enabled script system. You can specify various search options with the {\f2 inMatchOptions} parameter, including {\f2 weFindWholeWords}, {\f2 weFindCaseInsensitive} and {\f2 weFindDiacriticalInsensitive}. The search can be limited to a given text range using the {\f2 inRangeStart} and {\f2 inRangeEnd} parameters.\parOn exit, {\f2 outMatchStart} and {\f2 outMatchEnd} specify the start and end offsets of the first occurrence of the search string, if one is found. If no match is found, {\f2 WEFind} returns a {\f2 weTextNotFoundErr} result code.\par\'a5 Added {\f2 WERemoveUserInfo} to complement the existing {\f2 WESetUserInfo} and {\f2 WEGetUserInfo}.\par\'a5 The WASTE Demo has been updated. Printing (both classic and Carbon) is now supported. Various window management routines have been rewritten according to modern Window Manager 2.0 guidelines. Text is now soft-wrapped (re-wrapped dynamically to the window width as the window is resized, \'88 la SimpleText).\parThe WASTE Demo now requires Mac OS 8.6 or newer.\par\'a5 Carbon status: to compile this release for Carbon you\'d5ll need version 3.3d2 or newer of the unified Carbon/Sonata headers, which are not available to the general public at the time of this writing. I\'d5m not sure I can report on other Carbon-related changes without breaking my NDA.\par\'a5 {\b Where\'d5s the source code??}  It\'d5s now distributed as a separate archive to registered users. If you\'d5re a freeware author and need a free copy of the latest source code, please drop me a note. If you\'d5re a registered commercial developer and haven\'d5t received your password yet, contact me ASAP.\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a6\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 The work on WASTE carbonization continues, closely tracking the evolution of the Carbon specification and SDK. WASTE can now be compiled with the Carbon headers and linked against CarbonLib (or LiteCarbonLib).\par\'a5 The WASTE Demo is back!  The old demo application from the WASTE 1.3 Distribution has been updated for Mac OS 8.5 and Carbon. It also shows off some of the new features in WASTE 2.0.\par\'a5 If your application links against WASTELib and you\'d5re planning to carbonize it, you may want to adopt some new APIs in 2.0a6 designed to help you create and dispose of UPPs for WASTE callbacks. These new APIs have names like {\f2 NewWEClickLoopUPP} and {\f2 DisposeWEClickLoopUPP}, and are meant to be used instead of {\f2 NewWEClickLoopProc} (and similarly named macros) and {\f2 DisposeRoutineDescriptor}. In a classic world, {\f2 NewWEClickLoopUPP} will return a pointer to a routine descriptor, just like the {\f2 NewWEClickLoopProc} macro. In a Carbon world, where routine descriptors are obsolete, {\f2 NewWEClickLoopUPP} returns the function pointer itself, although this may change in the future. Of course, if you treat UPPs as opaque data types, you no longer have to worry. These new APIs also obviate the need for special glue code for Pascal.\par\'a5 Removed all dependecies on AEGizmos, since this library isn\'d5t likely to be supported under Carbon.\par\'a5 The {\f2 weFInhibitICSupport} feature flag was broken and is now fixed (thanks to Linda Peting).\par\'a5 A long standing bug involving the use of option-left-arrow with certain non-Roman scripts was hopefully fixed (thanks to James Jennings).\par}{\pard\plain\f0\fs36\cf0\ql\sb360\sa240\brdrb\brdrs {\b New in WASTE 2.0a5\par}}{\pard\plain\f1\fs24\cf0\qj\sa120\fi120 \'a5 WASTELib is now fat (PPC/CFM68K).\par\'a5 Fixed a potential crasher in {\f2 WEContinuousStyle} inadvertently introduced in version 2.0a2 (thanks to Timothy Paustian).\par\'a5 Added a new low-level API to retrieve style run information associated with a given style run index:\par}{\pard\plain\f2\fs24\cf0\ql\li480 pascal void WEGetIndRunInfo\par  (\par    SInt32            inStyleRunIndex,\par    WERunInfo *       outStyleRunInfo,\par    WEReference       inWE\par  );\par}{\pard\plain\f2\fs24\cf0\qj\sa120\fi120 \par{\f1 This call is similar to }WEGetRunInfo{\f1 , but takes a style run index rather than an offset into the text. The valid range for the style run index parameter is }0{\f1  to }WECountRuns(inWE) - 1{\f1 .\par\'a5 Added four new APIs for low-level access to paragraph run information. These APIs mimic existing APIs for style run information:\par}}{\pard\plain\f2\fs24\cf0\ql\li480 pascal SInt32 WECountParaRuns\par  (\par    WEReference       inWE\par  );\par\parpascal SInt32 WEOffsetToParaRun\par  (\par    SInt32            inOffset,\par    WEReference       inWE\par  );\par\parpascal void WEGetParaRunRange\par  (\par    SInt32            inParaRunIndex,\par    SInt32 *          outParaRunStart,\par    SInt32 *          outParaRunEnd,\par    WEReference       inWE\par  );\par\parpascal void WEGetIndParaInfo\par  (\par    SInt32            inParaRunIndex,\par    WEParaInfo *      outParaInfo,\par    WEReference       inWE\par  );\par}{\pard\plain\f2\fs24\cf0\qj\sa120\fi120 \par{\f1 A }{\f1\b paragraph run}{\f1  is a sequence of one or more paragraphs sharing the same ruler (set of paragraph styles). }WECountParaRuns{\f1  returns the total number of paragraph runs in the text. }WEOffsetToParaRun{\f1  maps a byte offset into the text to a paragraph run index in the range }0{\f1  to }WECountParaRuns(inWE) - 1{\f1 . You call }WEGetParaRunRange{\f1  to determine where in the text a given paragraph run begins and ends (the same information is returned by }WEGetIndParaInfo{\f1 ).\par\'a5 The meaning of the }inDestinationKind{\f1  parameter passed to object streaming handlers has changed slightly. Previous versions of WASTE pass }weToSoup{\f1  in this parameter whenever they have to create a \'d4SOUP\'d5 scrap (a data type used to describe objects embedded in the text), regardless of whether the scrap is to be used internally (e.g., to support undo/redo) or whether the scrap is to be copied to a \'d2public\'d3 location (i.e., the desk scrap or a drag). This makes it difficult for streaming handlers to determine whether the object data must be converted to a format suitable for public consumption or whether it can be left in a private format (of course, this issue doesn\'d5t affect simple handler sets, like PICT handlers, that use common formats in the first place and thus don\'d5t need customized streaming).\parStarting from this release, WASTE will pass }weToScrap{\f1  (instead of }weToSoup{\f1 ) to streaming handlers when it\'d5s building a SOUP scrap to be copied to the desk scrap, and }weToDrag{\f1  (instead of }weToSoup{\f1 ) when it\'d5s building a scrap to be copied to a drag. On the other hand, }weToSoup{\f1  will still be used for scraps created internally for undo/redo purposes, and when the streaming handler is called from the now deprecated }WECopyRange{\f1 .\parFinally, when }WEStreamRange{\f1  is called to create a SOUP scrap, the low byte of the }inFlags{\f1  parameter is interpreted as a destination kind to be passed on to streaming handlers. This allows further customization of the SOUP creation process.\parThanks for Rainer Brockerhoff for suggesting these changes.\par\'a5 Started work to make WASTE Carbon-compliant.}\par}}