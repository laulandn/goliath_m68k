// ===========================================================================//	UDrawingState.cp			PowerPlant 2.1		©1993-2000 Metrowerks Inc.// ===========================================================================////	Classes for saving/restoring the drawing state////	For each class, the Constructor saves the current state and the//	Destructor restores it, so you can use stack-based objects to//	automatically save and restore the state.////	There are separate Save and Restore functions in case you want to//	explicitly change the state (at other than construct and destruct time).////	Finally, each class has a Normalize function which sets the state of//	the current GrafPort to default values (same as those set by OpenPort).////	NOTE: Except for StGrafPortSaver, StPortOriginState, and StColorPortState,//	all classes assume that the current port does not change between calls//	to the constructor and destructor. If your code (or some routine you//	call) could change the port, you should use an StGrafPortSaver to//	save/restore the port. For example,////		StColorState	saveColors;//		StGrafPortSaver	savePort;////			// Code here that changes fore/back colors//			//  and might change the current port////	It's important to declare the StGrafPortSave AFTER the other class.//	Destructors get called in inverse order of declaration, so the port//	gets restored by ~StGrafPortSaver before the colors get restored//	by ~StColorState.#ifdef PowerPlant_PCH	#include PowerPlant_PCH#endif#include <UDrawingState.h>#include <UTBAccessors.h>#include <Dialogs.h>#include <Fonts.h>#include <LowMem.h>PP_Begin_Namespace_PowerPlant// ---------------------------------------------------------------------------//	Color Constantsconst RGBColor	Color_White	= { 65535, 65535, 65535 };const RGBColor	Color_Black = { 0, 0, 0 };// ===========================================================================//	UQDGlobals - Classic Version// ===========================================================================#if PP_Target_Classic#pragma mark === Classic ===// ---------------------------------------------------------------------------//	Pointer to the QuickDraw globalsQDGlobals*	UQDGlobals::sQDGlobals;// ---------------------------------------------------------------------------//	¥ InitializeToolbox												 [Classic]// ---------------------------------------------------------------------------//	Standalone applications should call this function near the beginning//	of the program initialize the standard Toolbox managersvoidUQDGlobals::InitializeToolbox(){	sQDGlobals = &qd;	::InitGraf(&sQDGlobals->thePort);		// Toolbox Managers	::InitFonts();	::InitWindows();	::InitMenus();	::TEInit();	::InitDialogs(nil);}// ---------------------------------------------------------------------------//	¥ InitializeToolbox												 [Classic]// ---------------------------------------------------------------------------//	Standalone applications should call this function near the beginning//	of the program to set the QD globals pointer and initialize the//	standard Toolbox managersvoidUQDGlobals::InitializeToolbox(	QDGlobals	*inQDGlobals){	sQDGlobals = inQDGlobals;	::InitGraf(&sQDGlobals->thePort);		// Toolbox Managers	::InitFonts();	::InitWindows();	::InitMenus();	::TEInit();	::InitDialogs(nil);}// ---------------------------------------------------------------------------//	¥ SetCodeResourceQDGlobals										 [Classic]// ---------------------------------------------------------------------------//	Code resources should call this function to set the QD globals pointervoidUQDGlobals::SetCodeResourceQDGlobals(){		// The memory layout of the A5 world is:		//		//				QuickDraw Globals struct		//					"Other" fields		//		A5 -->		Current GrafPtr		//		// Where the Current GrafPtr is the last field in the		// QDGlobals struct. To get a pointer to the beginning of the		// QDGlobals struct, we need to back up from A5 by the		// size of the "other fields", which is the difference between		// the size of the entire QDGlobals struct and the size of		// the current GrafPtr field.		//		// Note that LMGetCurrentA5() returns a pointer to the A5 value		// and not the value itself.	sQDGlobals = (QDGlobalsPtr) (*(char**) LMGetCurrentA5() -									(sizeof(QDGlobals) - sizeof(GrafPtr)));}// ---------------------------------------------------------------------------//	¥ GetCurrentPort												 [Classic]// ---------------------------------------------------------------------------//	Returns a pointer to the current GrafPortGrafPtrUQDGlobals::GetCurrentPort(){	GrafPtr		currPort;	::GetPort(&currPort);	return currPort;}// ---------------------------------------------------------------------------//	¥ GetCurrentWindowPort											 [Classic]// ---------------------------------------------------------------------------//	Returns a pointer to the current WindowPtr////	Warning: This function just typecasts the current GrafPtr to a WindowPtr.//	The caller must be sure that the current port is a Window.WindowPtrUQDGlobals::GetCurrentWindowPort(){	return (WindowPtr) GetCurrentPort();}#endif // PP_Target_Classic#pragma mark -// ===========================================================================//	UQDGlobals - Carbon Version// ===========================================================================#if PP_Target_Carbon#pragma mark === Carbon ===// ---------------------------------------------------------------------------//	¥ InitializeToolbox												  [Carbon]// ---------------------------------------------------------------------------//	Carbon automatically initializes the Toolbox, so this function is empty.voidUQDGlobals::InitializeToolbox(){}// ---------------------------------------------------------------------------//	¥ GetCurrentPort												  [Carbon]// ---------------------------------------------------------------------------//	Returns a pointer to the current GrafPortGrafPtrUQDGlobals::GetCurrentPort(){	GrafPtr		currPort;	::GetPort(&currPort);	return currPort;}// ---------------------------------------------------------------------------//	¥ GetCurrentWindowPort											  [Carbon]// ---------------------------------------------------------------------------//	Returns a pointer to the current WindowPtrWindowPtrUQDGlobals::GetCurrentWindowPort(){	return ::GetWindowFromPort(UQDGlobals::GetCurrentPort());}#endif // PP_Target_Carbon#pragma mark -// ===========================================================================//	StGrafPortSaver// ===========================================================================////	Constructor saves current GrafPort. Destructor restores it.StGrafPortSaver::StGrafPortSaver(){	::GetPort(&mGrafPtr);}StGrafPortSaver::StGrafPortSaver(		// Save Current Port	GrafPtr		inGrafPtr)				//   and switch to new Port{	::GetPort(&mGrafPtr);	::MacSetPort(inGrafPtr);}StGrafPortSaver::~StGrafPortSaver(){	::MacSetPort(mGrafPtr);}#pragma mark -// ===========================================================================//	StColorState// ===========================================================================////	Color State Info://		Foreground Color//		Background ColorStColorState::StColorState(){	Save();}StColorState::~StColorState(){	Restore();}voidStColorState::Save(){	::GetForeColor(&mForegroundColor);	::GetBackColor(&mBackgroundColor);}voidStColorState::Restore(){	::RGBForeColor(&mForegroundColor);	::RGBBackColor(&mBackgroundColor);}voidStColorState::Normalize(){	::RGBForeColor(&Color_Black);	::RGBBackColor(&Color_White);}#pragma mark -// ===========================================================================//	StColorPenState// ===========================================================================////	Color Pen State Info://		Foreground Color//		Background Color//		Pen Location//		Pen Size//		Pen Mode//		Pen PatternStColorPenState::StColorPenState(){	::GetPenState(&mPenState);}StColorPenState::~StColorPenState(){	::SetPenState(&mPenState);}voidStColorPenState::Save(){	mColorState.Save();	::GetPenState(&mPenState);}voidStColorPenState::Restore(){	mColorState.Restore();	::SetPenState(&mPenState);}voidStColorPenState::Normalize(){	StColorState::Normalize();	::PenNormal();}voidStColorPenState::SetGrayPattern(){	Pattern	grayPat;	::PenPat(UQDGlobals::GetGrayPat(&grayPat));}#pragma mark -// ===========================================================================//	StTextState// ===========================================================================////	Text State Info://		Font Number//		Text Size//		Text Style//		Text ModeStTextState::StTextState(){	Save();}StTextState::~StTextState(){	Restore();}voidStTextState::Save(){	GrafPtr		currPort = UQDGlobals::GetCurrentPort();	mFontNumber	= ::GetPortTextFont(currPort);	mSize		= ::GetPortTextSize(currPort);	mStyle		= ::GetPortTextFace(currPort);	mMode		= ::GetPortTextMode(currPort);}voidStTextState::Restore(){	::TextFont(mFontNumber);	::TextSize(mSize);	::TextFace(mStyle);	::TextMode(mMode);}voidStTextState::Normalize(){	::TextFont(systemFont);	::TextSize(0);	::TextFace(0);	::TextMode(srcOr);}#pragma mark -// ===========================================================================//	StClipRgnState// ===========================================================================////	ClipRgn State Info://		Clipping RegionStClipRgnState::StClipRgnState(){	Save();}StClipRgnState::StClipRgnState(	const Rect	&inClipRect){	Save();	::ClipRect(&inClipRect);}StClipRgnState::StClipRgnState(	RgnHandle	inClipRgnH){	Save();	if (inClipRgnH != nil) {		::SetClip(inClipRgnH);	} else {		::ClipRect(&Rect_0000);	}}StClipRgnState::~StClipRgnState(){	Restore();}// ---------------------------------------------------------------------------//	¥ ClipToIntersection// ---------------------------------------------------------------------------//	Sets the clipping region of the current port to the intersection of//	the saved clip region and the specified region/rectanglevoidStClipRgnState::ClipToIntersection(	RgnHandle	inRgnH){	StRegion	overlap;	::SectRgn(mClipRgn, inRgnH, overlap);	::SetClip(overlap);}voidStClipRgnState::ClipToIntersection(	const Rect	&inRect){	StRegion	rgn(inRect);	ClipToIntersection(rgn);}// ---------------------------------------------------------------------------//	¥ ClipToDifference// ---------------------------------------------------------------------------//	Sets the clipping region of the current port to the difference of//	the saved clip region and the specified region/rectanglevoidStClipRgnState::ClipToDifference(	RgnHandle	inRgnH){	StRegion	difference;	::DiffRgn(mClipRgn, inRgnH, difference);	::SetClip(difference);}voidStClipRgnState::ClipToDifference(	const Rect	&inRect){	StRegion	rgn(inRect);	ClipToDifference(rgn);}voidStClipRgnState::Normalize(){	Rect	wideOpen = { min_Int16, min_Int16, max_Int16, max_Int16 };	::ClipRect(&wideOpen);}// ---------------------------------------------------------------------------//	¥ SectWithCurrent// ---------------------------------------------------------------------------//	Sets the clipping region of the current port to the intersection of//	the current clip region and the specified region/rectanglevoidStClipRgnState::SectWithCurrent(	RgnHandle	inRgnH){	StRegion	clipRgn;	::GetClip(clipRgn);	::SectRgn(clipRgn, inRgnH, clipRgn);	::SetClip(clipRgn);}voidStClipRgnState::SectWithCurrent(	const Rect	&inRect){	StRegion	rgn(inRect);	SectWithCurrent(rgn);}// ---------------------------------------------------------------------------//	¥ DiffWithCurrent// ---------------------------------------------------------------------------//	Sets the clipping region of the current port to the difference of//	the current clip region and the specified region/rectanglevoidStClipRgnState::DiffWithCurrent(	RgnHandle	inRgnH){	StRegion	clipRgn;	::GetClip(clipRgn);	::DiffRgn(clipRgn, inRgnH, clipRgn);	::SetClip(clipRgn);}voidStClipRgnState::DiffWithCurrent(	const Rect	&inRect){	StRegion	rgn(inRect);	DiffWithCurrent(rgn);}#pragma mark -// ===========================================================================//	StPortOriginState// ===========================================================================////	Port Origin State Info://		GrafPtr upon entry//		Port Origin of input GrafPtrStPortOriginState::StPortOriginState(	GrafPtr		inGrafPtr){	Save(inGrafPtr);}StPortOriginState::~StPortOriginState(){	Restore();}voidStPortOriginState::Save(	GrafPtr		inGrafPtr){	mNewGrafPtr  = inGrafPtr;	mSaveGrafPtr = UQDGlobals::GetCurrentPort();	::MacSetPort(inGrafPtr);#if PP_Target_Carbon	Rect	portRect;	::GetPortBounds(inGrafPtr, &portRect);	mOrigin = topLeft(portRect);#else	mOrigin = topLeft(inGrafPtr->portRect);#endif}voidStPortOriginState::Restore(){	::MacSetPort(mNewGrafPtr);	::SetOrigin(mOrigin.h, mOrigin.v);	::MacSetPort(mSaveGrafPtr);}#pragma mark -// ===========================================================================//	StColorPortState// ===========================================================================////	ColorPort State Info://		GrafPtr upon entry//		Port Origin//		ColorPen State//		Text State//		Clipping RegionStColorPortState::StColorPortState(	GrafPtr		inGrafPtr)		: mPortOriginState(inGrafPtr){}StColorPortState::~StColorPortState(){}voidStColorPortState::Save(	GrafPtr		inGrafPtr){	mPortOriginState.Save(inGrafPtr);	mColorPenState.Save();	mTextState.Save();	mClipRgnState.Save();}voidStColorPortState::Restore(){	mColorPenState.Restore();	mTextState.Restore();	mClipRgnState.Restore();	mPortOriginState.Restore();}voidStColorPortState::Normalize(){	StPortOriginState::Normalize();	StColorPenState::Normalize();	StTextState::Normalize();	StClipRgnState::Normalize();}#pragma mark -// ===========================================================================//	StHidePen// ===========================================================================////	Constructor (inline) hides pen. Destructor shows pen.StHidePen::~StHidePen(){	::ShowPen();}#pragma mark -// ===========================================================================//	StVisRgn// ===========================================================================////	Constructor saves a Port's visible region, then sets it to a//	different region specified by an input parameter////	Destructor restores original visible region////	NOTE: Only valid for "classic" target. Changing the visRgn is not//	allowed under Carbon#if PP_Target_ClassicStVisRgn::StVisRgn(					// Make visRgn empty, which effectively	GrafPtr		inPort)				//   suppresses all drawing in the Port{	mGrafPtr = inPort;	if (inPort != nil) {		StRegion	newVisRgn;		mSaveVisRgnH	= inPort->visRgn;		inPort->visRgn	= newVisRgn.Release();		mSaveTopLeft	= topLeft((**(inPort->visRgn)).rgnBBox);	} else {						// Do nothing for nil GrafPtr		mSaveVisRgnH	= nil;	}}StVisRgn::StVisRgn(					// Set visRgn to the intersection of the	GrafPtr		inPort,				//   current visRgn and the specified	RgnHandle	inRgnH)				//   region{	mGrafPtr = inPort;	if (inPort != nil) {		mSaveVisRgnH	= inPort->visRgn;		::SectRgn(mSaveVisRgnH, inRgnH, inRgnH);		inPort->visRgn	= inRgnH;		mSaveTopLeft	= topLeft((**inRgnH).rgnBBox);	} else {						// Do nothing for nil GrafPtr		mSaveVisRgnH	= nil;	}}StVisRgn::StVisRgn(					// Set visRgn to the intersection of the	GrafPtr		inPort,				//   current visRgn and the specified	const Rect	&inRect)			//   rectangle{	mGrafPtr = inPort;	if (inPort != nil) {		StRegion	newVisRgn(inRect);		newVisRgn &= inPort->visRgn;		mSaveVisRgnH	= inPort->visRgn;		inPort->visRgn	= newVisRgn.Release();		mSaveTopLeft	= topLeft(inRect);	} else {						// Do nothing for nil GrafPtr		mSaveVisRgnH	= nil;	}}RgnHandle							// Restore original visRgn and returnStVisRgn::Restore()					//   the old visRgn{	RgnHandle	oldVisRgnH = nil;	if (mSaveVisRgnH != nil) {		// Origin might have moved since constructor saved the		// visRgn. Offset the saved visRgn by the same amount		// that the top left of the current (temporary) visRgn		// has moved since it was installed.		Point	currTopLeft = topLeft((**(mGrafPtr->visRgn)).rgnBBox);		::MacOffsetRgn(mSaveVisRgnH, (SInt16) (currTopLeft.h - mSaveTopLeft.h),								     (SInt16) (currTopLeft.v - mSaveTopLeft.v));		oldVisRgnH = mGrafPtr->visRgn;		mGrafPtr->visRgn = mSaveVisRgnH;		mSaveVisRgnH = nil;	}	return oldVisRgnH;}void								// Set visRgn to the intersection of theStVisRgn::Set(						//   current visRgn and the specified	RgnHandle	inRgnH)				//   region{	if (mGrafPtr != nil) {		RgnHandle	tempRgnH = Restore();		if (tempRgnH != nil) {			::DisposeRgn(tempRgnH);		}		mSaveVisRgnH = mGrafPtr->visRgn;		::SectRgn(mSaveVisRgnH, inRgnH, inRgnH);		mGrafPtr->visRgn = inRgnH;		mSaveTopLeft = topLeft((**inRgnH).rgnBBox);	}}StVisRgn::~StVisRgn(){	RgnHandle	tempRgnH = Restore();	if (tempRgnH != nil) {		::DisposeRgn(tempRgnH);	}}#endif // PP_Target_Classic#pragma mark -// ===========================================================================//	StCQDProcsState// ===========================================================================////	Constructor sets the QD drawing procs for a Port (if inSetProcs is true)//	Destructor restores original QD drawing procsStCQDProcsState::StCQDProcsState(	bool		inSetProcs,	CQDProcs*	inCQDProcs,	CGrafPtr	inPort){	mSetProcs	= inSetProcs;	mPort		= inPort;	mCQDProcs	= nil;	if (inPort != nil) {		#if PP_Target_Carbon			mCQDProcs	= ::GetPortGrafProcs(inPort);		#else			mCQDProcs	= inPort->grafProcs;		#endif		SetProcs(inSetProcs, inCQDProcs);	}}StCQDProcsState::~StCQDProcsState(){	ResetProcs();}voidStCQDProcsState::SetProcs(	bool		inSetProcs,	CQDProcs*	inCQDProcs){	if (inSetProcs && (mPort != nil)) {		#if PP_Target_Carbon			::SetPortGrafProcs(mPort, inCQDProcs);		#else			mPort->grafProcs = inCQDProcs;		#endif		mSetProcs = true;	}}voidStCQDProcsState::ResetProcs(){	if (mSetProcs && (mPort != nil)) {		#if PP_Target_Carbon			::SetPortGrafProcs(mPort, mCQDProcs);		#else			mPort->grafProcs = mCQDProcs;		#endif		mSetProcs = false;	}}// ===========================================================================//	StGDeviceSaver// ===========================================================================////	Constructor gets the current CGrafPtr and GDevice//	Destructor restores themStGDeviceSaver::StGDeviceSaver(){	::GetGWorld(&mSavePort, &mSaveDevice);}StGDeviceSaver::~StGDeviceSaver(){	::SetGWorld(mSavePort, mSaveDevice);}PP_End_Namespace_PowerPlant