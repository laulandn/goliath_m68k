/************************************************************Created: Tuesday, September 5, 1995 at 9:30:04 AM    somobj.hh	    C++ Interface to SOM        © Apple Computer, Inc. 1995-1996        All rights reserved************************************************************/#ifndef	__SOMOBJ__#define	__SOMOBJ__#ifndef	__SOMDTS__#include <somdts.h>#endif#if __SOM_ENABLED__//	declare the kernel meta-classclass SOMClass;#endifclass SOMObject {#if !__SOM_ENABLED__private:			long fRefCount;	//	to simulate SOM's refcounting#endifpublic:			SOMObject ();	//	all constructors must be parameter-less	//	and correspond to the IDL method "somInit"		virtual	~SOMObject ();	//	all destructors are virtual	//	and correspond to the IDL method "somUninit"		virtual	void *somDuplicateReference ();	// duplicates a reference to the object which must be	// released with "somRelease" when no longer needed		virtual	boolean somCompareReference (SOMObject *anObject);	// compares a reference to another object reference	// returns true if objects references are to the same object	// use instead of arithmetic pointer compare esp. for remote	// proper remote operation.			void *somRelease ();	// releases a reference obtained either by allocating a new	// object or via "somDuplicateReference".  invokes "somCanDelete"	// when the last reference has been released.  deletes object	// if authorized by "somCanDelete". always returns NULL.	// if invoked on an unreferenced object, no action will be taken	// (see description under "somCanDelete").			void somFree ();	// behaves the same as "somRelease" outstanding references, except	// always deletes the object if there were no references	// (see description under "somCanDelete").	//	the rest doesn't make any sense outside of SOM#if __SOM_ENABLED__			void *somGetClass ();	// Return a duplicated reference to the receiver's class.	// must be freed with "somRelease" or "somFree"				const char *somGetClassName ();	// Returns the name of the receiver's class	//	this method should be changed to return some different	//	type of value.  strings in CORBA are client owned entities	//	which you should free.  this string is a constant and	//	the system might die if you try to free it.					long somGetSize ();	// Return the size of the receiver object.				boolean somIsA (IN SOMClass *aClassObj);	// Returns 1 (true) if the receiver responds to methods	// introduced by <aClassObj>, and 0 (false) otherwise.				boolean somIsInstanceOf (IN SOMClass *aClassObj);	// Returns 1 (true) if the indicated method can be invoked	// on the receiver and 0 (false) otherwise.			boolean somRespondsTo (IN somId mId);	// Returns 1 (true) if the receiver is an instance of	// <aClassObj> and 0 (false) otherwise.	#endif /* __SOM_ENABLED__ */		//	we may want to consider removing these	virtual void *somPrintSelf ();	// writes a brief string with identifying information about this object.	// The default implementation just gives the object's class name and its	// address in memory. "this" is returned.	virtual void somDumpSelf (IN long level);	// writes a detailed description of this object and its current state.	//	// <level> indicates the nesting level for describing compound objects	// it must be greater than or equal to zero.  All lines in the	// description will be preceeded by <2*level> spaces.	//	// This routine only actually writes the data that concerns the object	// as a whole, such as class, and uses <somDumpSelfInt> to describe	// the object's current state.  This approach allows readable	// descriptions of compound objects to be constructed.	//	// Generally it is not necessary to override this method, if it is	// overriden it generally must be completely replaced.protected:	virtual	boolean somCanDelete ();	// invoked by "somRelease" or "somFree" just as the last	// reference to an object is being discarded.  default behavior	// is to return TRUE which authorizes the kernel to destruct the	// object.  returning FALSE will block destruction, "somUninit"	// will not be invoked, and your object will be left "in limbo"	// with no outstanding references.  your implementation is then	// free to do what it needs to with the limbo object.	// override this methd to block or alter the behavior of deletion.		virtual void somDumpSelfInt (IN long level);	// Uses <SOMOutCharRoutine> to write in the current state of this object.	// Generally this method will need to be overridden.  When overriding	// it, begin by calling the parent class form of this method and then	// write in a description of your class's instance data. This will	// result in a description of all the object's instance data going	// from its root ancestor class to its specific class.#if __SOM_ENABLED__#pragma SOMReleaseOrder (somInit,somUninit,somDuplicateReference,		\			somCompareReference,somRelease,somFree,somCanDelete,		\			somGetClass,somGetClassName,somGetSize,somIsA,				\			somRespondsTo,somIsInstanceOf,somDispatch,somClassDispatch,	\			somCastObj,somResetObj,somDumpSelf,somPrintSelf,somDumpSelfInt)#pragma SOMClassVersion (SOMObject, 70, 1)#pragma SOMCallStyle OIDL#endif};#endif	/* __SOMOBJ__ */