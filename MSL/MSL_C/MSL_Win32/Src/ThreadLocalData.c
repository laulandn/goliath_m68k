/*  Metrowerks Standard Library  *//*  $Date: 2000/08/19 19:49:59 $  *  $Revision: 1.3.12.3.2.2 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//* *		ThreadLocalData.c */ #include "ThreadLocalData.h"#include <cstdlib>    /* hh 980122 added <cstdlib> for atexit*/#define WIN32_LEAN_AND_MEAN#include <windows.h>#include "critical_regions.h"// Private function set up to be called "atexit" by _InitializeThreadDataIndex./* void _DisposeThreadDataIndex(void); */static unsigned long _gThreadDataIndex = -1;// this static variable points the the head of the linked list of thread// local data structures.  When the process ends, all of these are freed.static _ThreadLocalData *firstTLD;// This function must be called before _InitializeThreadData.// Returns false on error, true on success.int _InitializeThreadDataIndex(void){	if (_gThreadDataIndex != -1) {		// _gThreadDataIndex is already initialized		return 1;	}		_gThreadDataIndex = TlsAlloc();	if (_gThreadDataIndex == -1) {		// The allocation failed.		return 0;	}/*		if (atexit(_DisposeThreadDataIndex)) {		return 0;	} else {		return 1;	}*/return 1;	}void _DisposeThreadDataIndex(void){	if (_gThreadDataIndex == -1) {		// _gThreadDataIndex has an invalid value.		// Maybe it was never allocated?		return;	}		TlsFree(_gThreadDataIndex);	_gThreadDataIndex = -1;}// This function sets up a structure of thread local data needed by various MSL functions.// When the thread ends it should call _DisposeThreadData.// Returns false on error, true on success.int _InitializeThreadData(void *inThreadHandle){	HANDLE threadHandle = (HANDLE)inThreadHandle;	_ThreadLocalData * theThreadLocalData;		theThreadLocalData = TlsGetValue(_gThreadDataIndex);		if (theThreadLocalData == 0)	{		if (GetLastError() == NO_ERROR)		{			theThreadLocalData =				(_ThreadLocalData *)malloc(sizeof(_ThreadLocalData));					if (!theThreadLocalData)			{				return 0;			}			// add TLD to head of linked list			__begin_critical_region(thread_access);			theThreadLocalData->next = firstTLD;			firstTLD = theThreadLocalData;						__end_critical_region(thread_access);						// All initialization of items in the _ThreadLocalData structure			// goes here...						theThreadLocalData->errno = 0;				theThreadLocalData->random_next = 1;			theThreadLocalData->strtok_n = (unsigned char *) "";			theThreadLocalData->strtok_s = (unsigned char *) "";			theThreadLocalData->thread_handle = threadHandle;			return TlsSetValue(_gThreadDataIndex, theThreadLocalData);		}		return 0;	// problem retreiving TLS handle	}	return 1;	// data is already setup, just return success	}int _InitializeMainThreadData(void){    // First, get the thread data index by using tlsAlloc        if (_InitializeThreadDataIndex())    {        // now, get the data for the main thread		// (thread handle is NULL since you never call endthread() or		// endthreadex() on the main thread of the program)                if (_InitializeThreadData(NULL))        {            return 1;        }    }        return 0;}static void release_thread_data(_ThreadLocalData *tld){	_ThreadLocalData **current;	__begin_critical_region(thread_access);	current = &firstTLD;		while (*current)	{		if (*current == tld)			break;		current = &(*current)->next;	}	if (*current)	{		_ThreadLocalData *next = (*current)->next;		free (*current);		*current = next;	}	__end_critical_region(thread_access);}void _DisposeAllThreadData(){	_ThreadLocalData *current;	__begin_critical_region(thread_access);	current = firstTLD;	while (current)	{		_ThreadLocalData *next = current->next;		free(current);		current = next;	}	firstTLD = NULL;	__end_critical_region(thread_access);}void _DisposeThreadData(void){	_ThreadLocalData * theThreadLocalData = _GetThreadLocalData();		if (!theThreadLocalData) {		return;	}	TlsSetValue(_gThreadDataIndex, 0);	/* release_thread_data(theThreadLocalData); 	   not sure about the above.  Not sure if all calls are	   safe.	*/}_ThreadLocalData * _GetThreadLocalData(void){    _ThreadLocalData *tld;    	tld = (_ThreadLocalData *)TlsGetValue(_gThreadDataIndex);		if (tld == 0)	{		_InitializeThreadData(NULL);		tld = (_ThreadLocalData *)TlsGetValue(_gThreadDataIndex);	}		if (tld == 0)	{	    MessageBox(NULL, TEXT("Could not get thread local data"), TEXT("MW Win32 Runtime"), MB_OK);	    exit(0);	}	return tld;}/*hh  980122 added <cstdlib>hh  980122 replaced <wtypes.h> with <WINDEF.H> rjk 980314 fixed _GetThreadLocalData to allocate it if it was not alreadyblc 990317 modified Windows.h include strategy, added threadHandle supportmf  000710 Glen's changes to making global linked list threadsafe.*/