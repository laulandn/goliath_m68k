/************************************************************************//* Project...: C++ and ANSI-C Compiler Environment			*//* Name......: Startup.c						*//* Purpose...: Application startup code					*//* Copyright.: Copyright © 1993-1997 Metrowerks, Inc.			*//************************************************************************/#include "Startup.h"#include <Types.h>#include <Errors.h>#include <Memory.h>#include <Resources.h>#include <Assembler.h>#include <CPlusLib.h>#include <NMWException.h>#include <Exception68K.h>#include "StartupLib68K.h"// 'objd' resource IDs:// 0:	application startup// 1:	code resource startup (single segment)// 2:	code resource startup (multi segment)// 3:	DRVR startup (single segment)// 4:	DRVR startup (multi segment)// 5:	application startup (Jasik version)// 6:	MPW tool startup#ifndef JASIK#define JASIK		0		// 1: custom startup for Jasik's debugger#endif#ifndef MPWSTARTUP#define MPWSTARTUP	0		// 1: MPW tool startup code#endif#if JASIK && MPWSTARTUP#error					// JASIK + MPWSTARTUP not supported#endif#define	DATAPTR	A5			// register used to address near data#if MPWSTARTUP#include <stdlib.h>#elseextern far void abort(void);#pragma overload extern far void abort(void);extern far void exit(int status);#pragma overload extern far void exit(int status);#endifextern void			__Startup__(void);	// startup code entry pointextern pascal void	__LoadSeg__(void);	// segment loader codeextern far int		main(void);			// this is the user main() called by __Startup__()extern far void		__InitCode__(void);	// this is data init code called by __Startup__()extern char			__4byteints__;		// true: 4-byte ints; false 2-byte intsextern far segment_map	SEGMAPNAME[];	// exception segment mapextern far void 	__PreInit__(void);	// function called before global initialization#pragma overload far void __PreInit__(void);typedef struct SegmentHeader CODEHeader;/*typedef struct CODEHeader {		// header of a CODE resource	short	jtsoffset;			// A5 relative offset of this segments jump table (short version)	short	jtentries;			// number of entries in this segments jump table	long	jtloffset;			// A5 relative offset of this segments jump table (long version)	long	xrefoffset;			// offset of xref data in this CODE resource	char	code[];				// the code}	CODEHeader;*/char		qd[206];			// storage space for Quickdraw globals 206 bytesDestructorChain	*__global_destructor_chain;	// chain of global objects that need destructionstruct	SegmentLoadCallbacks __segcallbacks;	// callback structurevoid		*__local_destructor_chain;	// dummy, was: chain of local objects that need destructionstatic Boolean	__flushinstruction__;		// true: flush instruction cachestatic Ptr	__CODE1Base__;			// base address of CODE segment 1static long	__oldLoadSeg__;			// old LoadSeg trap addressstatic long	__oldUnloadSeg__;		// old UnloadSeg trap addressstatic long	__oldExitToShell__;		// old ExitToShell trap address#if JASIK#include "RTLib.h"typedef struct JasikRecord {	ProcPtr	Post_Load_Proc;	ProcPtr	preUnLoad_Proc;	ProcPtr	Del_MMU_Prot_Proc;	ProcPtr	Set_MMU_Prot_Proc;}	JasikRecord;static JasikRecord	jasikrecord;static void		__jasikdispatch__(short selector:__D0);static RTState		rtstate;#endif#if MPWSTARTUP#include "setjmp.h"extern jmp_buf 	__target_for_exit;extern long 	__setjmp(jmp_buf);void 			(__exit)(void); // this func will be passed to atexit in the startup codeextern void		__cleanupandexit__(void);/* MPW Globals *///  Integrated Environment (MPW) Globalsextern long	StandAlone;		// a long, 0 if in shell, 1 if standaloneextern long	errno;			// a long, error number; set on unsuccessful I/O callsextern short MacOSErr;		// a word;  set along with errno if appropriate//  Integrated Environment Routinesextern void _DataInit(void);	// this is stubbed out because we don't use MPW's _DataInitextern void __CplusInit(void);	// this is stubbed out because we don't use MPW's CplusInit// _RTInit is from MPW's Runtime.o see IntEnv.a// your tool MUST call this routine on startupextern int	_RTInit(long returnaddress, long *argc, long **argv, long **envp, long ispascal);// our globals to hold some parameters.static char	**__MPWenvp;static char	**__MPWargv;static long	__MPWargc;#elsestatic void		__A5WorldCheck__(short is_loadseg);static void		__A5WorldSetup__(void);extern void		__TrapUnpatch__(void);#endif /*MPWSTARTUP*/static pascal void	__UnloadSeg__(Ptr);				// forwardstatic char *		__relocate__(char *xref:__A0,char *segm:__A1);	// forwardstatic char		*__decomp_data__(char *ptr,char *datasegment);	// forward/****************************************************************//* Purpose..: The Startup routine for Applications		*//* Input....: ---						*//* Returns..: ---						*//****************************************************************/extern asm void __Startup__(void){	// this must be the first code module in this filefunctionstart:	suba.l	a6,a6			// helps for stack crawl#if JASIK	sub.w	#sizeof(JasikRecord),sp	clr.l	struct(JasikRecord.Post_Load_Proc)(sp)	clr.l	struct(JasikRecord.preUnLoad_Proc)(sp)	clr.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp)	clr.l	struct(JasikRecord.Set_MMU_Prot_Proc)(sp)	move.l	0x38,a0	cmp.w	#0x487A,(a0)	bne.s	nojas	pea	(sp)	moveq	#27,d0	trap	#7	move.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp),a0	jsr	(a0)			// disable MMU protectionnojas:#endif	// clear the global data area	subq.l	#4,sp			// get CODE resource 0	move.l	#'CODE',-(sp)	clr.w	-(sp)	_GetResource	move.l	(sp),d0			// keep handle on stack for later ReleaseResource	beq	error	movea.l	d0,a0	movea.l	(a0),a0	move.l	(a0)+,d7		// d7:data bytes above DATAPTR	move.l	(a0),d6			// d6:data bytes below DATAPTR#if MPWSTARTUP	move.l (sp)+,a0			// mpw loaded this resource and left it purgable	_HPurge#else	_ReleaseResource		// release CODE resource 0#endif	moveq	#0,d0			// clear data area below DATAPTR	movea.l	DATAPTR,a0	suba.l	d6,a0	bra	loop1eloop1:	move.b	d0,(a0)+loop1e:	cmpa.l	DATAPTR,a0	blt	loop1	lea	32+8(DATAPTR),a0	// clear data area above DATAPTR	lea	0(DATAPTR,d7.l),a1	bra	loop2eloop2:	move.b	d0,(a0)+loop2e:	cmpa.l	a1,a0	blt	loop2	// initialize global data area	subq.l	#4,sp			// get the DATA Resource 0	move.l	#'DATA',-(sp)	clr.w	-(sp)	_GetResource	movea.l	(sp),a0			// keep handle on stack for later ReleaseResource	move.l	a0,d0	beq	error//// DATA 0 resource layout://// +---------------------------------+// | long:   offset of CODE 1 xrefs  |---+// +---------------------------------+   |// | char[]: compressed init data    |   |// +---------------------------------+   |// | char[]: compressed DATA 0 xrefs |   |// +---------------------------------+   |// | char[]: compressed CODE 1 xrefs |<--+// +---------------------------------+//	move.l	DATAPTR,-(sp)	move.l	(a0),a0			// push pointer to init data	pea	4(a0)	jsr	__decomp_data__	addq.l	#8,sp	// relocate data and CODE segment 1	lea	functionstart-4,a1	move.l	a1,__CODE1Base__	// store the base address of CODE segment 1 in CODE1Base	move.l	DATAPTR,a1		// relocate the data segment	jsr	__relocate__	move.l	__CODE1Base__,a1	// relocate CODE segment 1	jsr	__relocate__	_ReleaseResource		// release DATA resource	// initialize our A5 world checking routine#if !MPWSTARTUP	jsr	__A5WorldSetup__#endif	// setup __flushinstruction__ global and flush cache	clr.b	__flushinstruction__	move.w	#_Unimplemented,d0	_GetToolTrapAddress	move.l	a0,-(a7)	move.w	#_HWPriv,d0	_GetOSTrapAddress	cmpa.l	(a7)+,a0	beq.s	dontflush	move.b	#true,__flushinstruction__	_FlushInstructionCachedontflush:#if JASIK	move.l	struct(JasikRecord.Post_Load_Proc)(sp),jasikrecord.Post_Load_Proc	move.l	struct(JasikRecord.preUnLoad_Proc)(sp),jasikrecord.preUnLoad_Proc	move.l	struct(JasikRecord.Del_MMU_Prot_Proc)(sp),jasikrecord.Del_MMU_Prot_Proc	move.l	struct(JasikRecord.Set_MMU_Prot_Proc)(sp),jasikrecord.Set_MMU_Prot_Proc	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	__jasikdispatch__	// enable MMU protection#endif#if MPWSTARTUP	jsr		__PreInit__	jsr		__InitCode__		// data init code// this is the code to setup MPW// note that the stack must be where it was when this routine was first called.	movea.l	(a7),a0				// copy MPW's return address	move.l	#0,-(a7)			// setup for C strings	pea		__MPWenvp			// get the environment pointer	pea		__MPWargv			// get argv from MPW	pea		__MPWargc			// get argc from MPW	move.l	a0,-(a7)			// push original return address	jsr		_RTInit				// call MPW's Runtime Init.	move.l	d0,StandAlone		// record if we are standalone or not		lea     20(sp),sp	pea     __target_for_exit	// defined in Apple's runtime	jsr     __setjmp	addq.w  #4,sp	tst.l   d0	bne.s   shellreturn// install some exit procs	pea		__exit	jsr		atexit	addq.w  #4,sp	tst.l   d0	bne.s   shellreturn	pea		__destroy_global_chain	jsr		atexit	addq.w  #4,sp	tst.l   d0	bne.s   shellreturn	move.l	__MPWenvp,-(sp)		// pass envp	move.l	__MPWargv,-(sp)		// pass argv	move.l	__MPWargc,-(sp)		// pass argc	jsr		main				// start user main// if exit isn't called in tool, main drops through, otherwise there is a longjmp	lea		12(sp),sp	move.l  d0,-(sp)	jsr     exit	addq.w  #4,sp 				// not really needed since exit doesn't return shellreturn:	jsr		__cleanupandexit__	// unrelocate our selfs and exit	rtserror:	addq.w   #4,sp				// we goto here if we fail loading a resource	rts  					#else /* MPWSTARTUP */	// patch LoadSeg, UnloadSeg & ExitToShell traps	move.w	#_LoadSeg,D0		// LoadSeg	_GetToolTrapAddress	move.l	A0,__oldLoadSeg__	move.w	#_UnLoadSeg,D0		// UnloadSeg	_GetToolTrapAddress	move.l	A0,__oldUnloadSeg__	move.w	#_ExitToShell,D0	// ExitToShell	_GetToolTrapAddress	move.l	A0,__oldExitToShell__	move.w	#_LoadSeg,D0		// LoadSeg	lea	__LoadSeg__,A0	_SetToolTrapAddress	move.w	#_UnLoadSeg,D0		// UnloadSeg	lea	__UnloadSeg__,A0	_SetToolTrapAddress	move.w	#_ExitToShell,D0	// ExitToShell	lea	__ExitToShell__,A0	_SetToolTrapAddress	// intitialize static C++ data objects and call main()	jsr	__PreInit__	jsr	__InitCode__		// data init code	pea	argv			// fake dummy argv	tst.b	__4byteints__	beq.s	int161	clr.w	-(sp)			// fake dummy argc 32-bit intint161:	clr.w	-(sp)			// fake dummy argc 16-bit int	jsr	main			// call user main	addq.l	#6,sp	clr.l	-(sp)	jsr	exit			// call exit(0)//	tst.b	__4byteints__//	beq.s	int162//	addq.l	#2,sp////int162:	move.l	__exit_proc__,d0	// Call exit function//	beq.s	skip_exit_proc//	move.l	d0,a0//	jsr	(a0)////skip_exit_proc://	jsr	__destroy_global_chain	// destroy global objects__ExitToShell__:	jsr	__TrapUnpatch__error:	_ExitToShellargv:	dc.l	0#endif /* MPWSTARTUP */}/****************************************************************//* Purpose..: Decompress the DATA resource			*//* Input....: pointer to DATA resource data			*//* Input....: pointer to A5 resource				*//* Returns..: pointer to data after init data			*//****************************************************************/typedef union GetData {	char	raw[4];	short	word;	long	lword;}	GetData; ////	Pack Patterns:////	0x1xxx xxxx: <raw data>		x+1 (1..128)	raw data bytes//	0x01xx xxxx:			x+1 (1..64)		<x> 0x00 data bytes//	0x001x xxxx: yyyy yyyy		x+2 (2..33)		<x> <y> data bytes//	0x0001 xxxx:			x+1 (1..16)		<x> 0xFF data bytes//	0x0000 0001:			pattern: 0x00000000FFFFXXXX//	0x0000 0010:			pattern: 0x00000000FFXXXXXX//	0x0000 0011:			pattern: 0xA9F00000XXXX00XX//	0x0000 0100:			pattern: 0xA9F000XXXXXX00XX//	0x0000 0000:	end of data//static char *__decomp_data__(char *ptr,char *datasegment){	GetData	ldata;	int	i,data;	char	*to,c;	for(i=0; i<3; i++)	{		ldata.raw[0]=*ptr++; ldata.raw[1]=*ptr++; ldata.raw[2]=*ptr++; ldata.raw[3]=*ptr++;		to=datasegment+ldata.lword;		while(1)		{			data=*ptr++;			if(data&0x80)			{	//	decompress (x&0x7f)+1 raw data bytes				data&=0x7F; do *to++=*ptr++; while(--data>=0); continue;			}			if(data&0x40)			{	//	decompress (x&0x3f)+1 0x00 data bytes//				data&=0x3F; c=0x00; goto cloop;				to+=(data&0x3F)+1; continue;	//	data is already initilized to 0x00			}			if(data&0x20)			{	//	decompress (x&0x1f)+2 repeating data bytes				data=(data&0x1F)+1; c=*ptr++; goto cloop;			}			if(data&0x10)			{	//	decompress (x&0x0f)+1 0xFF data bytes				data&=0x0F; c=0xFF;			cloop:	do *to++=c; while(--data>=0); continue;			}			switch(data)			{			case 0x00: break;//			case 0x01: *to++=0x00; *to++=0x00; *to++=0x00; *to++=0x00; *to++=0xFF; *to++=0xFF; *to++=*ptr++; *to++=*ptr++; continue;//			case 0x02: *to++=0x00; *to++=0x00; *to++=0x00; *to++=0x00; *to++=0xFF; *to++=*ptr++; *to++=*ptr++; *to++=*ptr++; continue;//			case 0x03: *to++=0xA9; *to++=0xF0; *to++=0x00; *to++=0x00; *to++=*ptr++; *to++=*ptr++; *to++=0x00; *to++=*ptr++; continue;//			case 0x04: *to++=0xA9; *to++=0xF0; *to++=0x00; *to++=*ptr++; *to++=*ptr++; *to++=*ptr++; *to++=0x00; *to++=*ptr++; continue;			case 0x01: to+=4; *to++=0xFF; *to++=0xFF; *to++=*ptr++; *to++=*ptr++; continue;			case 0x02: to+=4; *to++=0xFF; *to++=*ptr++; *to++=*ptr++; *to++=*ptr++; continue;			case 0x03: *to++=0xA9; *to++=0xF0; to+=2; *to++=*ptr++; *to++=*ptr++; to++; *to++=*ptr++; continue;			case 0x04: *to++=0xA9; *to++=0xF0; to++; *to++=*ptr++; *to++=*ptr++; *to++=*ptr++; to++; *to++=*ptr++; continue;			default:   SysError(dsLoadErr);			}			break;		}	}	return ptr;}/****************************************************************//* Purpose..: Relocate code/data references of a segment	*//* Input....: pointer to relocation data			*//* Input....: pointer to segments base address			*//* Input....: pointer to reloaction base address		*//* Returns..: pointer to end of relocation data			*//****************************************************************/static char *__reloc_compr__(char *ptr,char *segment,long relocbase){	GetData	data;	long	offset,relocations;	char	c;	data.raw[0]=*ptr++; data.raw[1]=*ptr++; data.raw[2]=*ptr++; data.raw[3]=*ptr++;	relocations=data.lword;	for(offset=0L; relocations>0; relocations--)	{		c=*ptr++;		if(c&0x80)		{	//	8-bit signed delta			c<<=1; offset+=c;		}		else		{			data.raw[0]=c; data.raw[1]=*ptr++;			if(c&0x40)			{	//	15-bit unsigned delta								offset+=(short)(data.word<<2)>>1;			}			else			{	//	direct signed 31-bit offset				data.raw[2]=*ptr++; data.raw[3]=*ptr++;				offset=(data.lword<<2)>>1;			}		}		*(long *)(segment+offset)+=relocbase;	}	return ptr;}/****************************************************************//* Purpose..: Relocate code/data references of segment		*//* Input....: a0: pointer to xref data				*//* Input....: a1: pointer to current segment			*//* Returns..: pointer to data after xref			*//****************************************************************/static asm char *__relocate__(char *xref:__A0,char *segm:__A1){	move.l	a2,-(sp)	move.l	a1,a2			// a2: base address of relocated segment	move.l	DATAPTR,-(a7)		// relocate references to DATA segment	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__reloc_compr__	move.l	__CODE1Base__,-(a7)	// relocate references to CODE segment 1	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__reloc_compr__	move.l	a2,-(a7)		// relocate references to same CODE segment	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__reloc_compr__	lea	3*3*4(a7),a7		// remove c function arguments	move.l	(sp)+,a2	rts}/****************************************************************//* Purpose..: Unrelocate code/data references of segment	*//* Input....: a0: pointer to xref data				*//* Input....: a1: pointer to current segment			*//* Returns..: pointer to data after xref			*//****************************************************************/static asm char *__unrelocate__(char *xref:__A0,char *segm:__A1){	move.l	a2,-(sp)	move.l	a1,a2			// a2: base address of relocated segment	move.l	DATAPTR,-(a7)		// relocate references to DATA segment	neg.l	(a7)	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__reloc_compr__	move.l	__CODE1Base__,-(a7)	// relocate references to CODE segment 1	neg.l	(a7)	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__reloc_compr__	move.l	a2,-(a7)		// relocate references to same CODE segment	neg.l	(a7)	move.l	a2,-(a7)	move.l	a0,-(a7)	jsr	__reloc_compr__	lea	3*3*4(a7),a7		// remove c function arguments	move.l	(sp)+,a2	rts}#if !MPWSTARTUP/****************************************************************//* Purpose..: Check if this is the correct A5 world		*//* Input....: true: _LoadSeg; false: _UnloadSeg			*//* Returns..: ---						*//****************************************************************/static asm void __A5WorldCheck__(short is_loadseg){	cmp.l	our_a5,A5	bne.s	other_a5_world	rtsother_a5_world:				// this is not our A5 world (use original trap routines)	movem.l	a0/a5,-(sp)		// save used registers//// Stack layout at this point:// 0:	dc.l	saved A5// 4:	dc.l	saved A0// 8:	dc.l	return address (no longer needed)// 12:	dc.w	is_loadseg// 14:	_LoadSeg/_UnloadSeg arguments ...//	move.l	our_a5,a5		// setup our a5 so we can use globals	move.l	__oldLoadSeg__,a0	// load original _LoadSeg/_UnloadSeg address into a0	tst.w	12(sp)	bne.s	ldseg	move.l	__oldUnloadSeg__,a0ldseg:	move.l	a0,10(sp)		// store return address (destroys argument)	movem.l	(sp)+,a0/a5		// restore used registers 	addq.w	#2,sp			// adjust stack pointer	rts				// jump to original _LoadSeg/_UnloadSegour_a5:	dc.l	0			// memory location used to store our A5	entry	__A5WorldSetup__	lea	our_a5,a0	move.l	a5,(a0)	rts}#endif/****************************************************************//* Purpose..: FIxup Segment address				*//* Input....: new segment address (in A0)			*//* Input....: segment number (in D0)				*//* Returns..: ---						*//****************************************************************/static asm void __PatchSegmentMap__(void *segaddr:__A0,short segn:__D0){	lea	SEGMAPNAME,a1	mulu.w	#sizeof(segment_map),d0	move.l	a0,struct(segment_map.codeptr)-sizeof(segment_map)(a1,d0.L)	rts}/****************************************************************//* Purpose..: Load a segment into memory and relocate it	*//* Input....: (sp) has the address of jumptable entry		*//* Returns..: does not return directly				*//****************************************************************/extern asm pascal void __LoadSeg__(void){#if MPWSTARTUP	moveq	#dsLoadErr,d0	_SysError	rts#else	move.w	#1,-(sp)	jsr	__A5WorldCheck__	addq.w	#2,sp#if JASIK	move.l	sp,rtstate.fSP	movem.l	d0-d7/a0-a6,rtstate.fRegisters#endif	movem.l	d0-d2/a0-a2,-(sp)		// save registers	subq.l	#2,24(sp)			// adjust return address	movea.l	24(sp),a2			// a2: base address of jumptable entry	move.l	__segcallbacks.PreLoadSeg,d0	beq.s	nopreload	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spnopreload:#if JASIK	move.l	a2,rtstate.fJTAddr	move.w	struct(JumpTableEntry.segment)(a2),rtstate.fSegNo	move.l	#'CODE',rtstate.fSegType	moveq	#struct(JasikRecord.Del_MMU_Prot_Proc),d0	jsr	__jasikdispatch__		// disable MMU protection#endif	st	0x0A5E				// ResLoad	subq.l	#4,sp				// get the CODE Resource nretryload:	move.l	#'CODE',-(sp)	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	_GetResource	move.l	(sp),d0	bne.s	noerr	move.l	__segcallbacks.LoadSegErr,d0	bne.s	loaderrcallback	moveq	#dsLoadErr,d0	_SysErrorloaderrcallback:	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,sp	bra	retryloadnoerr:	tst.b	0x0BB2					// SegHiEnable	beq.s	nohi	move.l	d0,a0					// move the code resource to high memory	_MoveHHinohi:	move.l	(sp),a0					// lock code resource	_HLock	move.l	(sp)+,a0				// get the stripped address of code segment	movea.l	(a0),a0	move.l	a0,d0	_StripAddress	move.l	d0,a0	move.l	a0,-(sp)				// save address	// patch segment map	move.w	struct(JumpTableEntry.segment)(a2),d0	jsr	__PatchSegmentMap__	// relocate segment	move.l	a0,a1	add.l	struct(SegmentHeader.xrefoffset)(a0),a0	jsr	__relocate__				// relocate the new segment	// set jumptable to loaded state 	movea.l	(sp)+,a0				// a0: address of segment	movea.l	DATAPTR,a1				// a1: address of first jumptable entry	add.l	struct(SegmentHeader.jtloffset)(a0),a1	move.w	struct(SegmentHeader.jtentries)(a0),d0	// d0: number of jumptable entries	move.l	a0,d1					// d1: code resource base address	bra.s	loopeloop:	move.w	#0x4EF9,struct(JumpTableEntry.jumpinstruction)(a1)	add.l	d1,struct(JumpTableEntry.jumpaddress)(a1)	addq.l	#sizeof(struct JumpTableEntry),a1loope:	dbf	d0,loop	tst.b	__flushinstruction__	beq.s	dontflush	_FlushInstructionCachedontflush:	move.l	__segcallbacks.PostLoadSeg,d0	beq.s	nopostload	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spnopostload:#if JASIK	move.w	#kVersion16bit,rtstate.fVersion	move.l	#32000,rtstate.fSegSize		// not the correct size !!!	move.b	#true,rtstate.fSegInCore	clr.b	rtstate.fReserved1	clr.w	rtstate.fOSErr	clr.l	rtstate.fReserved2	move.l	jasikrecord.Post_Load_Proc,d0	beq.s	nojas	move.l	d0,a0	pea	rtstate	jsr	(a0)	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	__jasikdispatch__		// enable MMU protectionnojas:#endif	movem.l	(sp)+,d0-d2/a0-a2		// restore registers	tst.b	0x012D				// LoadTrap: true: call debugger when LoadSeg is called	beq.s	notrap	_Debuggernotrap:	rts					// return to new address#endif /* MPWSTARTUP */}/****************************************************************//* Purpose..: Unload a segment from memory			*//*		this function replaces the _UnloadSeg trap !!!	*//* Input....: routine address on stack				*//* Returns..: ---						*//****************************************************************/static pascal asm void __UnloadSeg__(Ptr routineAddr){#if MPWSTARTUP	moveq	#dsLoadErr,d0	_SysError	rts#else	move.w	#0,-(sp)	jsr	__A5WorldCheck__	addq.w	#2,sp#if JASIK	move.l	sp,rtstate.fSP	movem.l	d0-d7/a0-a6,rtstate.fRegisters#endif	move.l	a2,-(sp)			// save a2 register	move.l	8(sp),a2			// a2:address of function jtentry	cmp.w	#0x4EF9,struct(JumpTableEntry.jumpinstruction)(a2)	bne	end				// return if file is not in loaded state	cmp.w	#2,struct(JumpTableEntry.segment)(a2)	blt	end				// only segments >=2 can be unloaded	// patch segment map	sub.l	a0,a0	move.w	struct(JumpTableEntry.segment)(a2),d0	jsr	__PatchSegmentMap__#if JASIK	move.l	a2,rtstate.fJTAddr	move.w	struct(JumpTableEntry.segment)(a2),rtstate.fSegNo	move.l	#'CODE',rtstate.fSegType	move.w	#kVersion16bit,rtstate.fVersion	move.l	#32000,rtstate.fSegSize			// not the correct size !!!	move.b	#true,rtstate.fSegInCore	clr.b	rtstate.fReserved1	clr.w	rtstate.fOSErr	clr.l	rtstate.fReserved2	move.l	jasikrecord.preUnLoad_Proc,d0	beq.s	nojas	pea	rtstate	move.l	d0,a0	jsr	(a0)	moveq	#struct(JasikRecord.Del_MMU_Prot_Proc),d0	jsr	__jasikdispatch__			// disable MMU protectionnojas:#endif	subq.l	#4,sp					// get the CODE Resource n	move.l	#'CODE',-(sp)	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	_GetResource	move.l	(sp),d0	bne.s	gotres	addq.l	#4,sp	bra	endgotres:	move.l	d0,a0					// unrelocate CODE resource	move.l	(a0),a0					// dereference code resource handle	move.l	a0,a1	add.l	struct(SegmentHeader.xrefoffset)(a0),a0	jsr	__unrelocate__	// restore jumptable to unloaded state 	move.l	(sp),a0					// a0: address of segment	move.l	(a0),a0					// dereference code resource handle	move.l	DATAPTR,a1				// a1: address of first jumptable entry	add.l	struct(SegmentHeader.jtloffset)(a0),a1	move.w	struct(SegmentHeader.jtentries)(a0),d0	// d0: number of jumptable entries	move.l	a0,d1					// d1: code resource base address	bra.s	loopeloop:	move.w	#0xA9F0,struct(JumpTableEntry.jumpinstruction)(a1)	sub.l	d1,struct(JumpTableEntry.jumpaddress)(a1)	addq.l	#sizeof(struct JumpTableEntry),a1loope:	dbf	d0,loop	move.l	(sp),a0					// unlock CODE resource	_HUnlock	move.l	(sp)+,a0				// and make it purgeable	_HPurge#if JASIK	moveq	#struct(JasikRecord.Set_MMU_Prot_Proc),d0	jsr	__jasikdispatch__			// enable MMU protection#endif	tst.b	__flushinstruction__	beq.s	dontflush	_FlushInstructionCachedontflush:	move.l	__segcallbacks.PostUnloadSeg,d0	beq.s	end	move.l	d0,a0	move.w	struct(JumpTableEntry.segment)(a2),-(sp)	jsr	(a0)	addq.l	#2,spend:	move.l	(sp)+,a2				// restore a2 register	move.l	(sp)+,(sp)				// pop return address	rts#endif /* MPWSTARTUP */}/************************************************************************//* Purpose..: Dummy function called before global initialization	*//* Input....: ---							*//* Return...: ---							*//************************************************************************/extern asm void __PreInit__(void){	rts}#if JASIK/****************************************************************//* Purpose..: Dispatch to jasik functions			*//* Input....: dispatch selector (in register D0)		*//* Returns..: ---						*//****************************************************************/static asm void __jasikdispatch__(short selector:__D0){	lea	jasikrecord,a0	move.l	0(a0,d0.w),d0	beq.s	end	move.l	d0,a0	jsr	(a0)end:	rts}#endif#if MPWSTARTUP/****************************************************************//* Purpose..: Unrelocate our selves before returning to MPW	*//* Input....: None						*//* Returns..: D0=0						*//****************************************************************/asm void __cleanupandexit__(void){	subq.l	#4,sp				// get the DATA Resource 0	move.l	#'DATA',-(sp)	clr.w	-(sp)	_GetResource	movea.l	(sp),a0				// keep handle on stack for later ReleaseResource	move.l	a0,d0	bne.s	gotres	addq.l	#4,sp	bra.s	errgotres:	move.l	(a0),a0			// deref handle	add.l	(a0),a0				// add offset to CODE 1 xref data	move.l	__CODE1Base__,a1	// unrelocate CODE segment 1	jsr	__unrelocate__	_ReleaseResource			// release DATA resourceerr:	rts						// Return to __Startup__	}/****************************************************************//* Purpose..: This stub is here because MPW's RTInit calls it	*//* 	      and MetroWerks does it's own Data Initialization	*//* Input....: None						*//* Returns..: D0=0						*//****************************************************************/asm void _DataInit(void){	moveq	#0,d0	rts}/****************************************************************//* Purpose..: This stub is here because MPW's RTInit calls it	*//* 	      and MetroWerks does it's own.			*//* Input....: None						*//* Returns..: D0=0						*//****************************************************************/asm void __CplusInit(void){	rts}#else/****************************************************************//* Purpose..: Dummy stdlib abort()				*//* Input....: ---						*//* Returns..: ---						*//****************************************************************/extern far void abort(void){	ExitToShell();}/****************************************************************//* Purpose..: Dummy stdlib exit()				*//* Input....: exit status					*//* Returns..: ---						*//****************************************************************/extern far void exit(int status){	#pragma unused(status)	__destroy_global_chain();	ExitToShell();}/****************************************************************//* Purpose..: Unpatch traps					*//* Input....: ---						*//* Returns..: ---						*//****************************************************************/extern asm void __TrapUnpatch__(void){	move.l	0x0904,a5		// CurrentA5	move.w	#_ExitToShell,D0	// restore ExitToShell	move.l	__oldExitToShell__,A0	_SetToolTrapAddress	move.w	#_LoadSeg,D0		// restore LoadSeg	move.l	__oldLoadSeg__,A0	_SetToolTrapAddress	move.w	#_UnLoadSeg,D0		// restore UnloadSeg	move.l	__oldUnloadSeg__,A0	_SetToolTrapAddress	rts}#endif /* MPWSTARTUP */#include "StartupCommon68K.c"