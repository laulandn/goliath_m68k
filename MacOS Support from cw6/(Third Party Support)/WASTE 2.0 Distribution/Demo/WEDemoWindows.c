/* *	WASTE Demo Project: *	Window Handling * *	Copyright © 1993-2000 Marco Piovanelli *	All Rights Reserved * *	C port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __ALIASES__#include <Aliases.h>#endif#ifndef __ERRORS__#include <Errors.h>#endif#ifndef __FIXMATH__#include <FixMath.h>#endif#ifndef __FOLDERS__#include <Folders.h>#endif#ifndef __WEDEMO__#include "WEDemo.h"#endif//	miscellaneous constantsenum{	kMinWindowWidth		= 200,		//	minimum allowed window width (used by DoGrow)	kMinWindowHeight	= 80		//	minimum allowed window height (used by DoGrow)} ;enum{	kScrollStepTag		= 'STEP'	//	user tag used to save scroll step information in scrollbars} ;//	static variablesstatic SInt32 sScrollStep; // how many pixels to scroll (used by ScrollProc)static void	CalcTextRect ( WindowRef window, Rect * textRect ){	Rect portRect ;	GetWindowPortBounds ( window, & portRect ) ;	textRect->top = 0;	textRect->left = 0;	textRect->bottom = portRect.bottom - (kBarWidth - 1);	textRect->right = portRect.right - (kBarWidth - 1);	InsetRect( textRect, kTextMargin, kTextMargin );}static void	CalcScrollBarRect( WindowRef window, int orientation, Rect *barRect ){	Rect portRect ;	GetWindowPortBounds ( window, & portRect ) ;	switch ( orientation )	{		case kVertical :		{			barRect->top = -1;			barRect->left = portRect.right - (kBarWidth - 1);			barRect->bottom = portRect.bottom - (kBarWidth - 2);			barRect->right = portRect.right + 1;			break;		}		case kHorizontal :		{			barRect->top = portRect.bottom - (kBarWidth - 1);			barRect->left = -1;			barRect->bottom = portRect.bottom + 1;			barRect->right = portRect.right - (kBarWidth - 2 );			break;		}	}}static void	ScrollBarChanged ( WindowRef window ){	// scroll text to reflect new scroll bar setting	DocumentHandle	hDocument = GetWindowDocument ( window ) ;	WEReference		we = ( * hDocument ) -> we ;	LongRect		viewRect ;	LongRect		destRect ;	WEGetViewRect ( & viewRect, we ) ;	WEGetDestRect ( & destRect, we ) ;	WEScroll	(		viewRect.left - destRect.left - GetControl32BitValue( (*hDocument)->scrollBars[ kHorizontal ] ),		viewRect.top - destRect.top - GetControl32BitValue( (*hDocument)->scrollBars[ kVertical ] ),		we	);}static void	AdjustBars ( WindowRef window ){	DocumentHandle	hDocument = GetWindowDocument ( window ) ;	WEReference		we = ( * hDocument ) -> we ;	LongRect		viewRect ;	LongRect		destRect ;	SInt32			visible ;	SInt32			total ;	SInt32			value ;	SInt32			max ;	ControlRef		bar ;	// get the view and destination rectangle	WEGetViewRect ( & viewRect, we ) ;	WEGetDestRect ( & destRect, we ) ;	//	do the vertical axis	//	get scroll bar handle	bar = ( * hDocument ) -> scrollBars [ kVertical ] ;	//	calculate new scroll bar settings	//	NOTE:  (destRect.bottom - destRect.top) always equals the total text height because	//	WASTE automatically updates destRect.bottom whenever line breaks are recalculated	total = destRect . bottom - destRect . top ;	//	total pixel height	visible = viewRect . bottom - viewRect . top ;	//	visible pixel height	max = total - visible ;							//	scrollable range (in pixels)	value = viewRect . top - destRect . top ;		//	thumb location within scrollable range	//	make sure max is always non-negative	if ( max <= 0 ) max = 0 ;	//	set visible size	SetControlViewSize ( bar, visible ) ;	//	reset the scroll bar	SetControl32BitMaximum ( bar, max ) ;	SetControl32BitValue ( bar, value ) ;	//	if value exceeds max then the bottom of the destRect is above	//	the bottom of the view rectangle:  we need to scroll the text downward	if ( value > max )	{		ScrollBarChanged ( window ) ;	}	//	now do the horizontal axis	//	get scroll bar handle	bar = ( * hDocument ) -> scrollBars [ kHorizontal ] ;	//	calculate new scroll bar settings	total = destRect . right - destRect . left ;	//	total pixel width	visible = viewRect . right - viewRect . left ;	//	visible pixel width	max = total - visible ;							//	scrollable range (in pixels)	value = viewRect . left - destRect . left ;		//	thumb location within scrollable range	//	make sure max is always non-negative	if ( max <= 0 ) max = 0 ;	//	set visible size	SetControlViewSize ( bar, visible ) ;	//	reset the scroll bar	SetControl32BitMaximum ( bar, max ) ;	SetControl32BitValue ( bar, value ) ;}static void	ViewChanged ( WindowRef window ){	DocumentHandle	hDocument ;	ControlRef		bar ;	Rect			r ;	LongRect		viewRect ;	int				orientation ;	hDocument = GetWindowDocument ( window ) ;	//	resize the text area	CalcTextRect ( window, & r ) ;	WERectToLongRect ( & r, & viewRect ) ;	WESetViewRect ( & viewRect, ( * hDocument ) -> we ) ;	//	 move and resize the control bars	for ( orientation = kVertical; orientation <= kHorizontal; orientation ++ )	{		bar = ( * hDocument ) -> scrollBars [ orientation ] ;		HideControl ( bar ) ;		CalcScrollBarRect ( window, orientation, & r ) ;#if TARGET_API_MAC_CARBON		SetControlBounds ( bar, & r ) ;#else		( * bar ) -> contrlRect = r ;#endif		ShowControl ( bar ) ;		ValidWindowRect ( window, & r ) ;	}	//	reset the thumb positions and the max values of the control bars	AdjustBars ( window ) ;}DocumentHandle GetWindowDocument ( WindowRef window ){	//	make sure window is not nil and is one of our windows	if ( ( window == nil ) || ( GetWindowKind ( window ) != userKind ) )	{		return nil ;	}	// a handle to the document structure is kept in the window refCon	return ( DocumentHandle ) GetWRefCon ( window ) ;}WEReference GetWindowWE ( WindowRef window ){	DocumentHandle	document ;	if ( ( document = GetWindowDocument ( window ) ) != nil )	{		return ( * document ) -> we ;	}	else	{		return nil ;	}}void DoDrag ( Point thePoint, WindowRef window ){	Rect	desktopBounds ;	DragWindow ( window, thePoint, GetRegionBounds ( GetGrayRgn ( ), & desktopBounds ) ) ;}void DoPathSelect ( WindowRef window ){	SInt32	menuChoice = 0 ;	if ( ( WindowPathSelect ( window, nil, & menuChoice ) == noErr ) &&		 ( ( menuChoice & 0x0000FFFF ) > 1 ) )	{		//	bring the Finder to the foreground		SwitchToFinder ( ) ;	}}static void WindowResized ( const Rect * oldTextRect, WindowRef window ){	WEReference		we = GetWindowWE ( window ) ;	RgnHandle		tempRgn ;	RgnHandle		dirtyRgn ;	Rect			r ;	LongRect		lr ;	SInt16			oldTextWidth ;	SInt16			newTextWidth ;	SInt32			topCharOffset ;	LongPt			topCharPosition ;	Boolean			rewrapText = true ;	//	create temporary regions for calculations	tempRgn = NewRgn ( ) ;	dirtyRgn = NewRgn ( ) ;	//	calculate original text width	oldTextWidth = ( oldTextRect -> right - oldTextRect -> left ) ;	RectRgn ( tempRgn, oldTextRect ) ;	//	get new text rect	CalcTextRect ( window, & r ) ;	newTextWidth = ( r . right - r . left ) ;	RectRgn ( dirtyRgn, & r ) ;	//	width changed?	if ( newTextWidth == oldTextWidth )	{		//	nope: no need to rewrap text		rewrapText = false ;	}	if ( rewrapText )	{		//	remember offset of first visible character		WEGetViewRect ( & lr, we ) ;		topCharPosition = * ( LongPt * ) & lr ;		topCharOffset = WEGetOffset ( & topCharPosition, nil, we ) ;		//	reset destination rectangle and recalculate line breaks		WEGetDestRect ( & lr, we ) ;		lr . right = lr . left + newTextWidth ;		WESetDestRect ( & lr, we ) ;		WECalText ( we ) ;		//	should check for errors!		//	scroll the destination rectangle to keep the previous		//	first visible character at the top of the view rectangle		WEGetPoint ( topCharOffset, kHilite, & topCharPosition, nil, we ) ;		WEGetDestRect ( & lr, we ) ;		WEOffsetLongRect ( & lr, 0, kTextMargin - topCharPosition . v ) ;		WESetDestRect ( & lr, we ) ;	}	ViewChanged ( window ) ;	//	calculate the dirty region (to be updated)	if ( rewrapText )	{		InsetRgn ( dirtyRgn, - kTextMargin, - kTextMargin ) ;	}	else	{		XorRgn ( dirtyRgn, tempRgn, dirtyRgn ) ;		InsetRect ( & r, - kTextMargin, - kTextMargin ) ;		RectRgn ( tempRgn, & r ) ;		SectRgn ( dirtyRgn, tempRgn, dirtyRgn ) ;	}	//	mark the dirty region as invalid	InvalWindowRgn ( window, dirtyRgn ) ;	//	throw away temporary regions	DisposeRgn ( tempRgn ) ;	DisposeRgn ( dirtyRgn ) ;}void DoGrow ( Point hitPt, WindowRef window ){	const Rect		sizeConstraints = { kMinWindowHeight, kMinWindowWidth, 0x7FFF, 0x7FFF } ;	Rect			newContentRect ;	Rect			oldTextRect ;	//	remember original text rectangle	CalcTextRect ( window, & oldTextRect ) ;	//	resize the window	if ( ! ResizeWindow ( window, hitPt, & sizeConstraints, & newContentRect ) )	{		return ;	}	//	resize the text area	WindowResized ( & oldTextRect, window ) ;}void DoZoom ( SInt16 partCode, WindowRef window ){	WEReference		we = GetWindowWE ( window ) ;	Rect			portBounds ;	Rect			oldTextRect ;	LongRect		destRect ;	SInt32			idealHeight ;	Point			idealSize ;	//	determine the ideal size for this window	//	the ideal height is the number of pixels needed to see the whole text	WEGetDestRect ( & destRect, we ) ;	idealHeight = ( destRect . bottom - destRect . top ) + ( 2 * kTextMargin + ( kBarWidth - 1 ) ) ;	//	the ideal height should always be at least kMinWindowHeight	if ( idealHeight < kMinWindowHeight )	{		idealHeight = kMinWindowHeight ;	}	else if ( idealHeight > 0x7FFF )	{		//	and must fit in a SInt16		idealHeight = 0x7FFF ;	}	idealSize . v = idealHeight ;	//	since the text is automatically soft-wrapped to the window width,	//	there's no "ideal" window width	idealSize . h = GetWindowPortBounds ( window, & portBounds ) -> right ;	//	determine whether the window is currently in "standard" state or in "user" state	partCode = IsWindowInStandardState ( window, & idealSize, nil ) ? inZoomIn : inZoomOut ;	//	remember original text rectangle	CalcTextRect ( window, & oldTextRect ) ;	//	zoom the window	ZoomWindowIdeal ( window, partCode, & idealSize ) ;	//	resize the text area	WindowResized ( & oldTextRect, window ) ;}// this is a callback routine called by the Toolbox Control Managerstatic pascal void ScrollProc ( ControlRef bar, ControlPartCode partCode ){	switch ( partCode )	{		case kControlUpButtonPart :		case kControlDownButtonPart :		case kControlPageUpPart :		case kControlPageDownPart :		{			SInt32		value = GetControl32BitValue ( bar ) ;			SInt32		max = GetControl32BitMaximum ( bar ) ;			SInt32		step = 0 ;			UInt32		actualSize ;			//	retrieve precalculated step value from scroll bar			if ( GetControlProperty ( bar, sigWASTEDemo, kScrollStepTag, sizeof ( step ),				& actualSize, & step ) != noErr )			{				return ;			}			//	move the scroll bar thumb by the precalculated step			//	and scroll the text accordingly			if ( ( ( value < max ) && ( step > 0 ) ) ||				 ( ( value > 0 ) && ( step < 0 ) ) )			{				SetControl32BitValue ( bar, value + step ) ;				ScrollBarChanged ( GetControlOwner ( bar ) ) ;			}			break ;		}		case kControlIndicatorPart :		{			ScrollBarChanged ( GetControlOwner ( bar ) ) ;			break ;		}	}}static void	DoScrollBar ( Point hitPt, EventModifiers modifiers, WindowRef window ){	DocumentHandle				hDocument;	ControlRef					bar = nil;	LongRect					viewRect;	ControlPartCode				partCode;	SInt32						pageSize;	SInt32						step = 0;	static ControlActionUPP		sScrollerUPP = nil;	if ( sScrollerUPP == nil )	{		sScrollerUPP = NewControlActionProc ( ScrollProc ) ;	}	hDocument = GetWindowDocument ( window ) ;	WEGetViewRect ( & viewRect, ( * hDocument ) -> we ) ;	//	find out which control was hit (if any) and in which part	partCode = FindControl ( hitPt, window, & bar ) ;	//	if any control was hit, it must be one of our two scroll bars:	//	find out which and calculate the page size for it	if ( bar == ( * hDocument ) -> scrollBars [ kVertical ] )	{		pageSize = viewRect.bottom - viewRect.top ;	}	else if ( bar == ( * hDocument ) -> scrollBars [ kHorizontal ] )	{		pageSize = viewRect.right - viewRect.left ;	}	else	{		return;		// return immediately if none of our scrollbars was hit	}	//	calculate the "scroll step" according to the part hit	switch ( partCode )	{		case kControlUpButtonPart:		{			step = - ( ( modifiers & optionKey ) ? 1 : kScrollDelta ) ;			break ;		}		case kControlDownButtonPart:		{			step = + ( ( modifiers & optionKey ) ? 1 : kScrollDelta ) ;			break ;		}		case kControlPageUpPart:		{			step = - ( pageSize - kScrollDelta ) ;			break ;		}		case kControlPageDownPart:		{			step = + ( pageSize - kScrollDelta ) ;			break ;		}	}	// switch	//	save scroll step as a control property	SetControlProperty ( bar, sigWASTEDemo, kScrollStepTag, sizeof ( step ), & step ) ;	//	track the mouse	TrackControl ( bar, hitPt, sScrollerUPP ) ;}/* *	TextScrolled * *	This is a callback routine called whenever the text is scrolled automatically. *	Since auto-scrolling is enabled, WEScroll may be invoked internally by WASTE *	in many different circumstances, and we want to be notified when this happens *	so we can adjust the scroll bars */static pascal void TextScrolled ( WEReference we ){	WindowRef window = nil ;	//	get window reference associated with WE instance	if ( WEGetUserInfo ( kWindowTag, ( SInt32 * ) & window, we ) != noErr )	{		return ;	}	//	make sure the scroll bars are in synch with the destination rectangle	AdjustBars ( window ) ;}static pascal OSErr AddClippingName ( DragReference drag, WEReference we ){	//	add a 'clnm' flavor containing the name of the document originating the drag	//	this flavor is used by the Finder (version 8.0 and later) to determine the	//	name of the clipping file	WindowRef		window = nil ;	Str255			windowTitle ;	//	get window reference associated with WE instance	if ( WEGetUserInfo ( kWindowTag, ( SInt32 * ) & window, we ) != noErr )	{		return paramErr ;	}	//	get the window title	GetWTitle ( window, windowTitle ) ;	//	put the window title into the drag, as a 'clnm' flavor	//	we add this flavor to the same drag item used by WASTE to add the TEXT	//	(note that the reference number of this drag item = the WEReference )	return AddDragItemFlavor ( drag, ( ItemReference ) we, kFlavorTypeClippingName, windowTitle,		StrLength ( windowTitle ) + 1, flavorNotSaved ) ;}Boolean	DoContent ( Point hitPt, const EventRecord * event, WindowRef window ){	WEReference		we = GetWindowWE ( window ) ;	Rect			textRect ;	GrafPtr			savePort ;	Boolean			isMyClick = false ;	//	set up the port	GetPort ( & savePort ) ;	SetPortWindowPort ( window ) ;	//	convert the point to local coordinates	GlobalToLocal ( & hitPt ) ;	//	a click in an inactive window should normally activate it,	//	but the availability of the Drag Manager introduces an exception to this rule:	//	a click in the background selection may start a drag gesture,	//	without activating the window	if ( IsWindowHilited ( window ) )	{		isMyClick = true ;			//	active window -> always handle click	}	else	{		RgnHandle selRgn = WEGetHiliteRgn ( kCurrentSelection, kCurrentSelection, we ) ;		isMyClick = PtInRgn ( hitPt, selRgn ) && WaitMouseMoved ( event -> where ) ;		DisposeRgn ( selRgn ) ;	}	if ( isMyClick )	{		CalcTextRect ( window, & textRect ) ;		if ( PtInRect ( hitPt, & textRect ) )		{			WEClick ( hitPt, event -> modifiers, event -> when, we ) ;		}		else		{			DoScrollBar ( hitPt, event -> modifiers, window ) ;		}	}	//	restore the port	SetPort ( savePort ) ;	//	return true if the click should activate this window	return ! isMyClick ;}static void	DoScrollKey ( SInt16 keyCode, WindowRef window ){	DocumentHandle		hDocument ;	ControlRef		bar ;	SInt32				value ;	LongRect			viewRect ;	hDocument = GetWindowDocument ( window ) ;	bar = ( * hDocument ) -> scrollBars [ kVertical ] ;	//	get current scroll bar value	value = GetControl32BitValue ( bar ) ;	//	get text view rect	WEGetViewRect ( & viewRect, ( * hDocument ) -> we ) ;	switch ( keyCode )	{		case keyPgUp:		{			value -= ( viewRect . bottom - viewRect . top ) - kScrollDelta ;			break ;		}		case keyPgDn:		{			value += ( viewRect . bottom - viewRect . top ) - kScrollDelta ;			break ;		}		case keyHome:		{			value = 0 ;			break ;		}		case keyEnd:		{			value = 0x7FFFFFFF ;			break ;		}	}	// switch	//	set the new scroll bar value and scroll the text pane accordingly	SetControl32BitValue ( bar, value ) ;	ScrollBarChanged ( window ) ;}void DoKey ( SInt16 key, const EventRecord * event ){	WindowRef		window ;	SInt16			keyCode ;	//	do nothing if no window is active	if ( ( window = FrontWindow ( ) ) == nil )		return;	//	extract virtual key code from event record	keyCode = ( event->message & keyCodeMask ) >> 8 ;	// page movement keys are handled by DoScrollKey()	switch ( keyCode )	{		case keyPgUp:		case keyPgDn:		case keyHome:		case keyEnd:		{			DoScrollKey ( keyCode, window ) ;			break ;		}		default:		{			WEKey ( key, event -> modifiers, GetWindowWE (window) ) ;			break ;		}	}}void DoUpdate ( WindowRef window ){	GrafPtr		savePort ;	RgnHandle	updateRgn ;#if TARGET_API_MAC_CARBON	Rect		portRect ;#endif	// if we have no windows, there's nothing to update!	if ( window == nil )	{		return ;	}	// save the old drawing port	GetPort ( & savePort ) ;	SetPortWindowPort ( window ) ;	// notify everything that we're doing an update.	BeginUpdate ( window ) ;	updateRgn = NewRgn ( ) ;#if TARGET_API_MAC_CARBON	//	set updateRgn to the whole window rectangle	//	in the future, when Carbon gives us an API to get the "drawable" region	//	of a window, use that!	RectRgn ( updateRgn, GetWindowPortBounds ( window, & portRect ) ) ;#else	//	in a classic, non-Carbon environment, the visRgn of the window	//	is set to the region to redraw between BeginUpdate and EndUpdate	MacCopyRgn ( window -> visRgn, updateRgn ) ;#endif	// erase the update region	EraseRgn ( updateRgn ) ;	//	draw scroll bars	UpdateControls ( window, updateRgn ) ;	//	draw text	WEUpdate ( updateRgn, GetWindowWE ( window ) ) ;	// tell everything we're done updating	EndUpdate ( window ) ;	DisposeRgn ( updateRgn ) ;	// restore the old graphics port	SetPort ( savePort ) ;}void DoActivate ( Boolean isActivating, WindowRef window ){	DocumentHandle		hDocument ;	WEReference			we ;	GrafPtr				savePort ;	Rect				barRect ;	ControlPartCode		barHilite ;	SInt16				menuID ;	int					orientation ;	// if this is not one of our document windows, nothing to do here...	if ( ( hDocument = GetWindowDocument ( window ) ) == nil )	{		return ;	}	we = ( * hDocument ) -> we ;	//	sanity check: do nothing if required activation state	//	is the same as the current activation state	if ( isActivating == WEIsActive ( we ) )	{		return ;	}	//	 set up the port	GetPort ( & savePort ) ;	SetPortWindowPort ( window ) ;	// activate or deactivate the text (and any other relevant stuff) depending on just	// what we're doing here...	if ( isActivating )	{		WEActivate ( we ) ;		barHilite = kControlNoPart ;	}	else	{		WEDeactivate ( we ) ;		barHilite = kControlDisabledPart ;	}	//	redraw the scroll bars with the new highlighting (and validate their rects)	for ( orientation = kVertical ; orientation <= kHorizontal ; orientation ++ )	{		HiliteControl ( ( * hDocument ) -> scrollBars [ orientation ], barHilite ) ;		CalcScrollBarRect ( window, orientation, & barRect ) ;		ValidWindowRect ( window, & barRect ) ;	}	//	if activating, undim text-related menus	if ( isActivating )	{		for ( menuID = kMenuEdit ; menuID <= kMenuFeatures ; menuID ++ )		{			EnableMenuItem ( GetMenuHandle ( menuID ), 0 ) ;		}	}	// invalidate the menu bar	InvalMenuBar ( ) ;	// restore the old graphics port..	SetPort ( savePort ) ;}void DoIdle ( UInt32 * sleepTime, WindowRef window ){	WEReference		we = GetWindowWE ( window ) ;	FSSpec			spec ;	//	blink the caret if necessary	WEIdle ( sleepTime, we ) ;	//	update the window modification state according to the text modification count	//	(if this window has not been saved before, the proxy icon should remain dimmed	//	at all times)	SetWindowModified ( window, ( WEGetModCount ( we ) > 0 ) ||		( GetWindowProxyFSSpec ( window, & spec ) != noErr ) ) ;}OSStatus CreateWindow ( const FSSpec * pFileSpec, WindowRef * outWindow ){	static WEScrollUPP			sScroller = nil ;	static WEPreTrackDragUPP	sPreTracker = nil ;	const Rect					initialWindowBounds = { 48, 12, 48 + 280, 12 + 440 } ;	const SInt32				translucencyThreshold = kStandardTranslucencyThreshold ;	Str255						initialWindowTitle ;	Cursor						arrow ;	DocumentHandle				hDocument = nil ;	WindowRef					window = nil ;	AliasHandle					alias = nil ;	WEReference					we = nil ;	ControlRef					bar = nil ;	Handle						hPageMargins = nil ;	PageMarginRec				pageMargins ;	FInfo						finderInfo ;	Rect						textRect ;	Rect						fileRect ;	const Rect *				transitionSrcRect = nil ;	LongRect					lr ;	int							orientation ;	OSStatus					err ;	//	allocate UPPs first time thru	if ( sScroller == nil )	{		sScroller = NewWEScrollUPP ( TextScrolled ) ;		sPreTracker = NewWEPreTrackDragUPP ( AddClippingName ) ;	}	//	allocate a relocateable block to hold a document record	hDocument = ( DocumentHandle ) NewHandleClear ( sizeof ( DocumentRecord ) ) ;	if ( ( err = MemError( ) ) != noErr )	{		goto cleanup ;	}	( * hDocument ) -> docType = kTypeText ;	//	create the window	if ( ( err = CreateNewWindow ( kDocumentWindowClass,		kWindowCloseBoxAttribute | kWindowVerticalZoomAttribute | kWindowCollapseBoxAttribute | kWindowResizableAttribute, & initialWindowBounds, & window ) ) != noErr )	{		goto cleanup ;	}	GetIndString ( initialWindowTitle, kMiscStringsID, 3 ) ;	SetWTitle ( window, initialWindowTitle ) ;	// link the document record to the window and the other way around	SetWRefCon ( window, ( SInt32 ) hDocument ) ;	( * hDocument ) -> owner = window ;	// we got a window, so tell QuickDraw where to draw...	SetPortWindowPort ( window ) ;	//	calculate the text rectangle	CalcTextRect ( window, & textRect ) ;	WERectToLongRect ( & textRect, & lr ) ;	//	create a new WASTE instance	if ( ( err = WENew ( & lr, & lr, weDoAutoScroll |									 weDoOutlineHilite |									 weDoUndo |									 weDoMultipleUndo |									 weDoIntCutAndPaste |									 weDoDragAndDrop |									 weDoUseTempMem |									 weDoDrawOffscreen, & we) ) != noErr )	{		goto cleanup ;	}	//	save a reference to the window in the WE instance	if ( ( err = WESetUserInfo ( kWindowTag, ( SInt32 ) window, we ) ) != noErr )	{		goto cleanup ;	}	//	now the other way around:  save the WE reference in the document record	( * hDocument ) -> we = we ;	//	set up our scroll callback	if ( ( err = WESetInfo ( weScrollProc, & sScroller, we ) ) != noErr )	{		goto cleanup ;	}	//	set up our pre-TrackDrag callback	if ( ( err = WESetInfo ( wePreTrackDragHook, & sPreTracker, we ) ) != noErr )	{		goto cleanup ;	}	//	enable translucent text dragging	WESetInfo ( weTranslucencyThreshold, & translucencyThreshold, we ) ;	//	associate a default page margins record with the WE reference	pageMargins . top = 72 << 16 ;			//	one inch	pageMargins . bottom = 72 << 16 ;	pageMargins . left = 72 << 16 ;	pageMargins . right = 72 << 16 ;	if ( ( err = PtrToHand ( & pageMargins, & hPageMargins, sizeof ( pageMargins ) ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = WESetUserInfo ( kPageMarginsTag, ( SInt32 ) hPageMargins, we ) ) != noErr )	{		goto cleanup ;	}	hPageMargins = nil ;	//	create the scroll bars from a control template	for ( orientation = kVertical ; orientation <= kHorizontal; orientation ++ )	{		Rect scrollBarRect ;		CalcScrollBarRect ( window, orientation, & scrollBarRect ) ;		if ( ( bar = NewControl ( window, & scrollBarRect, "\p", false, 0, 0, 0, kControlScrollBarLiveProc, 0 ) ) == nil )		{			err = memFullErr ;			goto cleanup ;		}		HiliteControl ( bar, kControlDisabledPart ) ;		ShowControl ( bar ) ;		//	save control handle in the document record		( * hDocument ) -> scrollBars [ orientation ] = bar ;	}	// for	//	ViewChanged adjusts the scroll bars rectangles to the window frame	ViewChanged ( window ) ;	//	if pFileSpec is not nil, it points to a file to read, so let's read it!	if ( pFileSpec )	{		// turn the cursor into a wristwatch because this can be a lengthy operation		SetCursor ( * GetCursor ( watchCursor ) ) ;		//	retrieve finder information		if ( ( err = FSpGetFInfo ( pFileSpec, & finderInfo ) ) != noErr )		{			goto cleanup ;		}		//	read in the file		switch ( finderInfo . fdType )		{			case kTypeText :			{				if ( ( err = ReadTextFile ( pFileSpec, we ) ) != noErr )				{					goto cleanup ;				}				break ;			}			case kTypeUnicodeText :			{				//	read in the file				if ( ( err = ReadUnicodeTextFile ( pFileSpec, we ) ) != noErr )				{					goto cleanup ;				}				break ;			}			default :			{				err = badFileFormat ;				goto cleanup ;			}		}		if ( finderInfo . fdFlags & kIsStationery )		{			//	the file we just read was a stationery pad, so don't associate it with the window			SetWindowProxyCreatorAndType ( window, finderInfo . fdCreator, finderInfo . fdType, pFileSpec -> vRefNum ) ;		}		else		{			//	set the window title			SetWTitle ( window, pFileSpec -> name ) ;			//	set the window icon			SetWindowProxyFSSpec ( window, pFileSpec ) ;			SetWindowModified ( window, false ) ;		}		( * hDocument ) -> docType = finderInfo . fdType ;		//	get icon rect		if ( GetFileRect ( pFileSpec, & fileRect ) == noErr )		{			transitionSrcRect = & fileRect ;		}		//	make the cursor happy		SetCursor ( GetQDGlobalsArrow ( & arrow ) ) ;	}	else	{		SetWindowProxyCreatorAndType ( window, sigWASTEDemo, kTypeText, kOnSystemDisk ) ;	}	//	adjust scroll bar settings based on the total text height	AdjustBars ( window ) ;	//	position the window	RepositionWindow ( window, FrontWindow ( ), kWindowCascadeOnParentWindow ) ;	//	finally!  show the document window	TransitionWindow ( window, kWindowZoomTransitionEffect, kWindowShowTransitionAction, transitionSrcRect ) ;	//	copy window ref for caller	if ( outWindow )	{		* outWindow = window ;	}cleanup :	if ( err != noErr )	{		ErrorAlert ( err ) ;	}	ForgetHandle ( & hPageMargins ) ;	return err ;}void DestroyWindow ( WindowRef window ){	DocumentHandle	hDocument ;	WEReference		we ;#if TARGET_API_MAC_CARBON	Handle			hPageFormat = nil ;#else	Handle			hPrintRecord = nil ;#endif	Handle			hPageMargins = nil ;	FSSpec			fileSpec ;	Rect			fileRect ;	const Rect *	transitionDstRect = nil ;	SInt16			menuID ;	hDocument = GetWindowDocument ( window ) ;	we = ( * hDocument ) -> we ;#if TARGET_API_MAC_CARBON	//	get rid of the page format, if any	if ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & hPageFormat, we ) == noErr )	{		ForgetHandle ( & hPageFormat ) ;		WERemoveUserInfo ( kPageFormatTag, we ) ;	}#else	//	get rid of the print record, if any	if ( WEGetUserInfo ( kPrintRecordTag, ( SInt32 * ) & hPrintRecord, we ) == noErr )	{		ForgetHandle ( & hPrintRecord ) ;		WERemoveUserInfo ( kPrintRecordTag, we ) ;	}#endif	//	get rid of the page margin record, if any	if ( WEGetUserInfo ( kPageMarginsTag, ( SInt32 * ) & hPageMargins, we ) == noErr )	{		ForgetHandle ( & hPageMargins ) ;		WERemoveUserInfo ( kPageMarginsTag, we ) ;	}	//	destroy the WASTE instance	WEDispose ( we ) ;	//	if this document has an associated file, get its icon rectangle	if ( ( GetWindowProxyFSSpec ( window, & fileSpec ) == noErr ) && ( GetFileRect ( & fileSpec, & fileRect ) == noErr ) )	{		transitionDstRect = & fileRect ;	}	//	hide the window	TransitionWindow ( window, kWindowZoomTransitionEffect, kWindowHideTransitionAction, transitionDstRect ) ;	//	destroy the window record and all associated data structures	DisposeWindow ( window ) ;	//	finally, dispose of the document record	DisposeHandle ( ( Handle ) hDocument ) ;	// adjust the menus to suit	for ( menuID = kMenuFont ; menuID <= kMenuFeatures ; menuID ++ )	{		DisableMenuItem ( GetMenuHandle ( menuID ), 0 ) ;	}	InvalMenuBar ( ) ;}