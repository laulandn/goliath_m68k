/*  Metrowerks Standard Library  *//*  $Date: 1999/01/22 23:43:04 $  *  $Revision: 1.2 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//* *	path2fss.c *	 *	 *	Routines *	-------- *		__path2fss * *	Description *	----------- * *		This function is similar to PBMakeFSSpec with three major *		differences: * *		   1) Takes only a path name as input (as a C string); *					no parameter block * *		   2) Only makes FSSpecs for files, not directories. * *		   3) Works on *any* HFS Mac (Mac 512KE, Mac Plus or later) *					under any system version that supports HFS. * *		   4) Deals correctly with MFS disks (correctly traps *					file names longer than 63 chars and returns bdNamErr). * *		Like PBMakeFSSpec, this function returns fnfErr if the specified *		file does not exist but the FSSpec is still valid for the purposes *		of creating a new file. Errors are also returned for invalid path *		names or path names that specify directories rather than files *		(directories are excluded because you can't talk about them in *		stdio, but maybe this needs rethinking for unixio). * * */#include <Errors.h>#include <Files.h>#include <string.h>#include "path2fss.h"static void copy_c_to_pascal_str(StringPtr dst, const char * src){	size_t len = strlen(src);		memcpy(&dst[1], &src[0], len);		dst[0] = len;}OSErr __path2fss(const char * pathName, FSSpecPtr spec){	Str255				pathNameStr;	char					cPathNameStr[256];	char *				fileName;	int						fileNameLen;	HVolumeParam	vpb;	CInfoPBRec		cpb;	OSErr					ioResult, result = noErr;		if (!pathName || !*pathName || strlen(pathName) > 255)		return(bdNamErr);/* Extract file name (if any) */		strcpy(cPathNameStr, pathName);		fileName = strrchr(cPathNameStr, ':');		if (!fileName++)		fileName = cPathNameStr;		fileNameLen = strlen(fileName);	/*	if (!fileNameLen || fileNameLen > sizeof(spec->name) - 1 || *fileName == '.')   hh 10/25/97*//* Want to allow filenames begining with '.'.  */	if (!fileNameLen || fileNameLen > sizeof(spec->name) - 1)		return(bdNamErr);		copy_c_to_pascal_str(spec->name, fileName);/* Use PBGetCatInfo to get parID */		copy_c_to_pascal_str(pathNameStr, pathName);		cpb.hFileInfo.ioNamePtr = pathNameStr;	cpb.hFileInfo.ioVRefNum = 0;	cpb.hFileInfo.ioFDirIndex = 0;	cpb.hFileInfo.ioDirID = 0;		ioResult = PBGetCatInfoSync((CInfoPBPtr) &cpb);		if (ioResult)	{		if (ioResult != fnfErr)			return(ioResult);		/* If file not found, we still need to get parID */	/* Truncate path name and try again              */				if (fileName == cPathNameStr)			*fileName++ = ':';				*fileName = 0;				copy_c_to_pascal_str(pathNameStr, cPathNameStr);				if ((ioResult = PBGetCatInfoSync((CInfoPBPtr) &cpb)) != 0)			return(ioResult);				if (!(cpb.hFileInfo.ioFlAttrib & ioDirMask))		/* make sure we got a directory */			return(bdNamErr);				spec->parID = cpb.dirInfo.ioDrDirID;				result = fnfErr;	}	else	{		if (cpb.hFileInfo.ioFlAttrib & ioDirMask)				/* see if we got a directory */			/*return(notAFileErr);*/			result = notAFileErr;							/* mm 980416 */				spec->parID = cpb.hFileInfo.ioFlParID;	}/* Use PBHGetVInfo to get vRefNum */		copy_c_to_pascal_str(pathNameStr, pathName);		vpb.ioNamePtr = pathNameStr;	vpb.ioVRefNum = 0;	vpb.ioVolIndex = -1;		ioResult = PBHGetVInfoSync((HParmBlkPtr) &vpb);		if (ioResult)		return(ioResult);		spec->vRefNum = vpb.ioVRefNum;		return(result);}/*  Change Record *	16-Aug-95 JFH  First code release. * hh 971025  File names beginning with '.' can now be opened * mm 980416  Allow the selection of a directory and make a note of it.    MW00456*/