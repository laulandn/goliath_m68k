// ===========================================================================//	UTBAccessors.h				PowerPlant 2.1		©1999-2000 Metrowerks Inc.// ===========================================================================////	Accessor functions for Toolbox data structures that are opaque in Carbon////	In Apple's headers, accessor functions are define when the symbol//	ACCESSOR_CALLS_ARE_FUNCTIONS is 1 (true). By default, this is true//	for Carbon targets. For simplicity in maintaining a single source base for//	Carbon and Classic targets, we define equivalent inline functions//	when the Toolbox doesn't define them.////	Note: This file does not depend on PowerPlant (it includes no PP headers).#ifndef _H_UTBAccessors#define _H_UTBAccessors#pragma once#include <ConditionalMacros.h>#if !ACCESSOR_CALLS_ARE_FUNCTIONS		// Function are NOT defined, so we										//   define them#include <Controls.h>#include <Lists.h>#include <LowMem.h>#include <Menus.h>#include <QuickDraw.h>#include <MacWindows.h>// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	Control ManagerinlineRect*			GetControlBounds( ControlHandle control, Rect* bounds )					{						*bounds = (**control).contrlRect;						return bounds;					}inlinevoid			SetControlBounds( ControlHandle control, const Rect* bounds )					{						(**control).contrlRect = *bounds;					}inlineWindowPtr		GetControlOwner( ControlHandle control )					{						return (**control).contrlOwner;					}inlineBoolean			IsControlHilited( ControlHandle control )					{						return (**control).contrlHilite != 255;					}#pragma mark -// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	List ManagerinlineControlHandle	GetListVerticalScrollBar( ListRef list )					{						return (**list).vScroll;					}inlineControlHandle	GetListHorizontalScrollBar( ListRef list )					{						return (**list).hScroll;					}inlineRect*			GetListViewBounds( ListRef list, Rect* view )					{						*view = (**list).rView;						return view;					}#pragma mark -// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	Menu Managertypedef SInt16		MenuID;		// Define for UH 3.2inlineMenuID			GetMenuID( MenuRef menu )					{						return (**menu).menuID;					}inlineSInt16			GetMenuWidth( MenuRef menu )					{						return (**menu).menuWidth;					}#pragma mark -// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	QuickDrawinlineRect*			GetPortBounds( CGrafPtr port, Rect* rect )					{						*rect = port->portRect;						return rect;					}inlineRect*			GetPortBounds( GrafPtr port, Rect* rect )					{						*rect = port->portRect;						return rect;					}inlinevoid			SetPortBounds( CGrafPtr port, const Rect* rect )					{						port->portRect = *rect;					}inlinevoid			SetPortBounds( GrafPtr port, const Rect* rect )					{						port->portRect = *rect;					}inlinePixMapHandle	GetPortPixMap( CGrafPtr port )					{						return port->portPixMap;					}inlineshort			GetPixDepth( PixMapHandle pixMap )					{						return (**pixMap).pixelSize;					}inlineRgnHandle		GetPortVisibleRegion( CGrafPtr port, RgnHandle visRgn )					{						::MacCopyRgn(port->visRgn, visRgn);						return visRgn;					}inlineRgnHandle		GetPortVisibleRegion( GrafPtr port, RgnHandle visRgn )					{						::MacCopyRgn(port->visRgn, visRgn);						return visRgn;					}inlinevoid			SetPortVisibleRegion( CGrafPtr port, RgnHandle visRgn )					{						::MacCopyRgn(visRgn, port->visRgn);					}inlinevoid			SetPortVisibleRegion( GrafPtr port, RgnHandle visRgn )					{						::MacCopyRgn(visRgn, port->visRgn);					}inlineshort			GetPortTextFont( CGrafPtr port )					{						return port->txFont;					}inlineshort			GetPortTextFont( GrafPtr port )					{						return port->txFont;					}inlineStyle			GetPortTextFace( CGrafPtr port )					{						return port->txFace;					}inlineStyle			GetPortTextFace( GrafPtr port )					{						return port->txFace;					}inlineshort			GetPortTextMode( CGrafPtr port )					{						return port->txMode;					}inlineshort			GetPortTextMode( GrafPtr port )					{						return port->txMode;					}inlineshort			GetPortTextSize( CGrafPtr port )					{						return port->txSize;					}inlineshort			GetPortTextSize( GrafPtr port )					{						return port->txSize;					}inlineRect*			GetRegionBounds( RgnHandle region, Rect* bounds )					{						*bounds = (**region).rgnBBox;						return bounds;					}#pragma mark -// ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ//	Window ManagerinlineRect*			GetWindowPortBounds( WindowRef window, Rect* bounds )					{						*bounds = window->portRect;						return bounds;					}inlineWindowRef		GetWindowList()					{						return LMGetWindowList();					}					inlineWindowRef		GetWindowFromPort( CGrafPtr port )					{						return (WindowRef) port;					}					inlineWindowRef		GetWindowFromPort( GrafPtr port )					{						return (WindowRef) port;					}#endif // !ACCESSOR_CALLS_ARE_FUNCTIONS#endif