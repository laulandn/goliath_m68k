/*  Metrowerks Standard Library  *//*  $Date: 2000/06/08 14:57:53 $  *  $Revision: 1.4.8.9 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//* *	File:		unistd.win32.c * *	Content:	Interface file to standard UNIX-style entry points ... * *	NB:			This file implements some UNIX low level support.  These functions *				are not guaranteed to be 100% conformant. * *//* #include <x86_prefix.h>   mf  980518  */#include <cstdlib>#include <cerrno>#define WIN32_LEAN_AND_MEAN#include <windows.h>#include "crtl.h"/*#include <unistd.h>*/#ifdef _WINSIOUX                    /* mm 980119 */	#include <WinSIOUX.h>				/* mm 990423 */#endif /* _WINSIOUX  */             /* mm 980119 */ FileStruct *_HandleTable[NUM_HANDLES];int _HandPtr;#if (__dest_os==__win32_os)  /*  mf  980518 *//* *	int chdir(const char *path) * *		Changes the current working directory  */int _chdir(const char * dirname)								/* mm 980518 */{    char path[_MAX_PATH];    char drive[4];        if (SetCurrentDirectory(dirname))    {        GetCurrentDirectory(_MAX_PATH, path);        if (path[1] == ':')        {            drive[0] = '=';            drive[1] = path[0];            drive[2] = ':';            drive[3] = 0;            SetEnvironmentVariable(drive, path);        }        return 0;    }    else        return -1;}/* The following stub is a hack for the benefit of legacy code mm 980518 *//*int _chdir(const char *dirname)							{																return (chdir(dirname));								}*//* *	char *getcwd(char *path, int size) * *		Returns the path to the current directory. */char* _getcwd(char * path, int maxlen)						/* mm 980518 */{    int len;        len = GetCurrentDirectory(0, NULL);    if (path == NULL)    {        if (maxlen > len)        {            len = maxlen;        }        path = (char*)malloc(len);            /* hh 971206 added (char*) cast */        if (!path)        {            errno = ENOMEM;            return NULL;        }    }    else if (len > maxlen)    {        errno = ERANGE;        return NULL;    }    GetCurrentDirectory(len, path);    return path;}/* The following stub is a hack for the benefit of legacy code mm 980518 *//* char* _getcwd(char *path, int maxlen)			{													return (getcwd(path, maxlen));				}												*//* *	int isatty(int fildes) * *		Determines is a filestream is going to the console window. */int _isatty(int fildes)									/* mm 980518 */{	extern long _get_osfhandle(int filehandle);    return GetFileType((void *)_get_osfhandle(fildes)) == FILE_TYPE_CHAR;}/* The following stub is a hack for the benefit of legacy code mm 980518 */															/* mm 980518 */#endif  /*  mf  980518 */																														/* mm 980518 *//* *	int close(int fildes) *	 *		Closes a file stream. */int _close(int fildes)										/* mm 980518 */{	HANDLE h;    if (fildes >= NUM_HANDLES || !_HandleTable[fildes])    {        return -1;    }    	h = _HandleTable[fildes]->handle;	    if (CloseHandle(h))    {        free(_HandleTable[fildes]);        _HandleTable[fildes] = 0;                return 0;    }    else    {		// get error code			_doserrno = GetLastError();				        return -1;    }}/* The following stub is a hack for the benefit of legacy code mm 980518 *//*int _close(int fildes)									{																return (close(fildes));									}															*//* *	char *cuserid(char *string) * *		Returns the user's name associated with the current process (owner name from *		Sharing Setup CP). */char *_cuserid(char * string){	char			*name = getlogin();	if (name != NULL && string != NULL)		strcpy(string, name);	return (name == NULL ? NULL : string == NULL ? name : string);}/* *	int exec(const char *path, ...) * *		Launchs an application and then quits the current app. */int _exec(const char */*path*/, ...)  /* hh 980122 commented out unused arg */{	return(-1);						/* mm 981230 */}/* *	char *getlogin(void) * *		Returns the current user's login name (owner name from Sharing Setup CP). */char * _getlogin(void){	return(getenv("USERNAME"));               /* mm 981230 */}/* *	long lseek(int fildes, long offset,int whence) *	 *		Seek in a file (fildes is the MacOS refnum). */long _lseek(int fildes, long offset,int whence)				/* mm 980518 */{	HANDLE h;	DWORD method;    if (fildes >= NUM_HANDLES || !_HandleTable[fildes])    {		errno = EBADF;        return -1;    }    	h = _HandleTable[fildes]->handle;		switch(whence)	{	case SEEK_SET:	    method = FILE_BEGIN;		break;	case SEEK_CUR:	    method = FILE_CURRENT;		break;	case SEEK_END:		method = FILE_END;		break;	}    return SetFilePointer(h, offset, NULL, method);}/* *	int read(int fildes, void *buf, size_t count) *	 *		Read from a file (fildes is the file's MacOS refnum). *  Note: POSIX standard defines return value as of type ssize_t but says may be used instead     */int _read(int fildes, void * buf, size_t count)					/* mm 980518 */ /* mm 000607 */{    DWORD read;	HANDLE h;	int t;	int ReadResult;    if (fildes >= NUM_HANDLES || !_HandleTable[fildes])    {		errno = EBADF;        return -1;    }	h = _HandleTable[fildes]->handle;	t = _HandleTable[fildes]->translate;#ifdef _WINSIOUX                    /* mm 980119 */	if (fildes == 0)		ReadResult = ReadCharsFromConsole(buf, (DWORD)count, &read);   /* mm 000607 */	else#endif  /* if _WINSIOUX */			/* mm 980119 */		ReadResult = ReadFile(h, buf, (DWORD)count, &read, 0);	/* mm 000607 */    if (ReadResult)	{	    if (read && t)	    {	        char *cp, *op;	        int i, n;	       	        cp = op = buf;	        n = 0;	        for(i=0; i<read; i++)	        {	            // trun CRLF into just LF	            	            if (cp[0] == '\r' && i < (read-1) && cp[1] == '\n')  /* mm 000222 */	            {	                cp++;	                n++;	            }	            else	            {	                *op++ = *cp++;	            }	        }	        	        // If buffer ended in a CR and the read did not come up short due to hitting the 	        // end of file, pretend we did not see that CR and back up the file pointer.	        	        if (read == count && read > 1 && ((char*)buf)[read-1] == '\r') /* mm 000607 */	        {	            lseek(fildes, -1, SEEK_CUR); 	            n++;	        }	        read -= n;	    }	    return read;	}	else	{		// get error code			_doserrno = GetLastError();			    return 0;	}}														/* mm 980518 *//* *	int rmdir(const char *path) * *		Removes a directory (must be empty). */int _rmdir(const char *path)									/* mm 980518 */{	return RemoveDirectory((LPTSTR)path) ? 0 : 1;}/* The following stub is a hack for the benefit of legacy code mm 980518 */														/* mm 980518 *//* *	unsigned int sleep(unsigned int seconds) * *		Pauses program execution for seconds seconds. */unsigned int _sleep(unsigned int seconds){	Sleep(seconds * 1000);	return 0;}/* *	char *ttyname(int fildes) * *		Returns the name of the associated terminal or NULL if none. */char *_ttyname(int /*fildes*/)  /* hh 980122 commented out unused arg */{/*	if (fildes >=0 && fildes <= 2)		return __ttyname((long)fildes);	else*/		return NULL;}/* *	int unlink(const char *path) *	 *		Unlink (i.e. delete) a file. */int _unlink(const char * path)								/* mm 980518 */{    if (DeleteFile((LPCTSTR)path))    {        return 0;    }    else    {		/* get error code	 */		_doserrno = GetLastError();		        return -1;    }}/* *	int write(int fildes, const void *buf, size_t count) *	 *		Write to a file (fildes is the file's MacOS refnum). *  Note: POSIX standard defines return value as of type ssize_t but says may be used instead     */int _write(int fildes, const void *buf, size_t count)				/* mm 980518 */  /* mm 000607  */{    DWORD wrote;	HANDLE h;	int t;	char *bp = 0;	int status;	    if (fildes >= NUM_HANDLES || !_HandleTable[fildes])    {		errno = EBADF;        return -1;    }	h = _HandleTable[fildes]->handle;	t = _HandleTable[fildes]->translate;	    if (t)    {         int i, n;         char *cp;                  n = 0;         for (i=0; i<count; i++)         {             if (((char*)buf)[i] == '\n')    /* mm 000607 */             {                 n++;             }         }         bp = (char *)malloc(count + n);         cp = bp;         for (i=0; i<count; i++)         {             if (((char*)buf)[i] == '\n')  /* mm 000607 */             {                 *cp++ = '\r';             }             *cp++ = ((char*)buf)[i];   /* mm 000607 */         }         count += n;         buf = bp;    }        // Do the write operation        if (_HandleTable[fildes]->append)    {        lseek(fildes, 0, SEEK_END);    }#ifdef _WINSIOUX                    /* mm 980119 */    if ((fildes == 1) || (fildes == 2))    {    	WriteCharsToConsole(buf, count);    	status = 1;    	wrote  = count;    }    else#endif /* _WINSIOUX  */             /* mm 980119 */    status = WriteFile(h, buf, (DWORD)count, &wrote, 0);	/* mm 000607 */        // Free the local buffer if we allocated one        if (bp)    {        free(bp);    }        // And return status        if (status)	{	    return wrote;	}	else	{		// get error code			_doserrno = GetLastError();			    return 0;	}}/* The following stub is a hack for the benefit of legacy code mm 980518 *//* int _write(int fildes, const char *buf, int count)		{															return (write(fildes, buf, count));					}														*/// check accessibility of a file/* Begin mm 991216 */int _access(const char *path, int mode)						/* mm 980518 */{	DWORD Attributes;		if (path == NULL || path == "")	{		errno = ENOENT;		return -1;	}	if (strlen(path) > MAX_PATH)	{		errno = ENAMETOOLONG;		return -1;	}	Attributes = GetFileAttributes((LPCSTR)path);	if (Attributes == -1)	{		errno = ENOENT;		return -1;	}		if ((Attributes == FILE_ATTRIBUTE_READONLY) && (mode & W_OK))	{		errno = EACCES;		return -1;	}	else		return 0;    }/* End mm 991216 *//* The following stub is a hack for the benefit of legacy code mm 980518 *//*int _access(const char *path, int mode)					{															return (access(path, mode));						}														*//*	Change Record * hh 971206  Commented out _doserrno because it is already defined in extra.c * hh 971206  Added (char*) cast * hh 980122  Replaced <windows.h> with the following TWO includes because it is seriously              broken.  The following 2 includes must be carefully ordered as shown, because              they are broken too. * hh 980122  commented out unused arg 2 places * mf 980303  merged in support for Michael's winsioux * mm 980518  Changes to revert _lseek, _read, _write, _access, _close, _unlink,  *				_rmdir, _chdir, _getcwd to lseek, read, write, access, close etc. *				while accommodating legacy code.  Complement of changes in unistd.win32.h  * mf 980518  wince changes * mm 981230  Gave some body to getlogin() and exec() to prevent crash MW08465  * mm 990423  Made proper use of WinSIOUX.h instead of having builtin WinSIOUX prototypes * mm 991216  Reimplemented access() to work with directories as well as ordinary files  * cc 000209  changed windef.h to #define WIN32_LEAN_AND_MEAN & #include <windows.h> * mm 000222  Change to prevent possible access beyond the of read buffer IR9912-1054-1     * cc 000518  fixed #includes * mm 000607    Changed definitions of _read and _write to accord with POSIX Standard.*/