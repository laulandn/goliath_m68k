/*  Metrowerks Standard Library  *//*  $Date: 2000/05/30 20:03:32 $  *  $Revision: 1.4.10.2 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//* *	File:		stat.c * *	Content:	Interface file to standard UNIX-style entry points ... * *	NB:			This file implements some UNIX low level support.  These functions *				are not guaranteed to be 100% conformant. * */#include <stat.h>#include <errno.h>#include <unistd.h>#include <Files.h>#include <LowMem.h>#include <MacTypes.h>	/*  990421 vss */#include <time.mac.h>                  /*mm970514 *//* function prototypes for externally defined functions */extern int __ctopstring(const char *cstring, Str255 pstring);/* *	static int __stat(short vrefnum, long dirid, Str255 pname, struct stat *buf) * *		Returns information about a file (called by fstat and stat). */static int __stat(short vrefnum, long dirid, Str255 pname, struct _stat *buf){	HFileInfo		fpb;	HVolumeParam	vpb;	OSErr			err;	Str255			name;	fpb.ioNamePtr = pname;	fpb.ioFDirIndex = 0;	fpb.ioVRefNum = vrefnum;	fpb.ioDirID = dirid;	/* get the file's catalog info */	err = PBGetCatInfoSync((CInfoPBPtr)&fpb);	if (err == noErr) {		/* get the volume's info */		vpb.ioVolIndex = 0;		vpb.ioNamePtr = name;		vpb.ioVRefNum = vrefnum;		err = PBHGetVInfoSync((HParmBlkPtr)&vpb);		if (err == noErr && buf != NULL) {			/* fill in the data */			if (fpb.ioFlAttrib & 0x10)			{				buf->st_mode = S_IFDIR;				buf->st_nlink = 2;			}							else			{				buf->st_nlink = 1;				if (fpb.ioFlFndrInfo.fdFlags & 0x8000)					buf->st_mode = S_IFLNK;				else					buf->st_mode = S_IFREG;			}			buf->st_ino = fpb.ioDirID;			buf->st_dev = fpb.ioVRefNum;			buf->st_uid = getuid();			buf->st_gid = getgid();			buf->st_rdev = 0;			buf->st_size = fpb.ioFlLgLen;			buf->st_atime = buf->st_mtime = fpb.ioFlMdDat + _mac_msl_epoch_offset_; /*mm 970514*/ /* mm 990203 */			buf->st_ctime = fpb.ioFlCrDat + _mac_msl_epoch_offset_;                 /*mm 970514*/ /* mm 990203 */			buf->st_blksize = vpb.ioVAlBlkSiz;			buf->st_blocks = (buf->st_size + buf->st_blksize - 1) / buf->st_blksize;		}	}	if (err != noErr)		errno = err;	return (err == noErr ? 0 : -1);}/* *	int stat(char *path, struct stat *buf) * *		Returns information about a file. */int _stat(const char *path, struct _stat *buf){	Str255			ppath;	if (path) {		/* convert the C string into a Pascal string */		if (__ctopstring(path, ppath) != noErr) return (-1);			return (__stat(0, 0L, ppath, buf));	}	return (-1);}/* *	int fstat(int fildes, struct stat *buf) * *		Returns information about a file. */int _fstat(int fildes, struct _stat *buf){	Str255			fname;	FCBPBRec		fcbpb;	OSErr			err;	fcbpb.ioFCBIndx = 0;	fcbpb.ioRefNum = fildes;	fcbpb.ioNamePtr = (StringPtr)fname;	err = PBGetFCBInfoSync(&fcbpb);	if (err != noErr)		errno = err;	return (err == noErr ? __stat(fcbpb.ioFCBVRefNum, fcbpb.ioFCBParID, fcbpb.ioNamePtr, buf) : -1);}/* *	int mkdir(const char *path, int mode) * *		Creates a directory. (NB: mode is ignored on the mac) */int _mkdir(const char *path){	HFileParam		fpb;	Str255			ppath;	OSErr			err = -1;	if (path) {		/* convert the c string into a pascal string */		if (__ctopstring(path, ppath) != noErr) return (-1);		fpb.ioNamePtr = ppath;		fpb.ioVRefNum = 0;		fpb.ioDirID = 0L;		err = PBDirCreateSync((HParmBlkPtr)&fpb);	}	if (err != noErr)		errno = err;	return (err == noErr ? 0 : -1);}/*  Change Record *	30-Dec-95  JFH  Removed uses of OLDROUTINENAMES *  mm 970514       Added correction for difference in 1900Jan01 and 1904Jan01 epochs *  mm 990203	Corrected name of epoch conversion constant * vss 990421	Update to 3.2 Universal Headers *  cc 000531   changed _mkdir to one arg since second was not used  *  cc 000531   removed  #pragma unused in mkdir*/