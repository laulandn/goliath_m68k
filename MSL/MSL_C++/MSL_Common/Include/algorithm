/*  Metrowerks Standard Library  *//*  $Date: 2000/06/09 19:23:41 $  *  $Revision: 1.11.4.11 $  *  $NoKeywords: $  * *		Portions Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//** **   algorithm **/#ifndef _ALGORITHM#define _ALGORITHM#include <mslconfig>#include <cstdlib>#include <climits>#include <cstring>#include <iterator>#include <utility>#include <functional>#include <memory>#include <msl_utility>#ifndef RC_INVOKED#pragma options align=native#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#if _MSL_FORCE_ENUMS_ALWAYS_INT		#pragma enumsalwaysint on	#else		#pragma enumsalwaysint off	#endif#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT		#pragma bool on	#else		#pragma bool off	#endif#endif#ifndef _MSL_NO_CPP_NAMESPACE	namespace std {#endif//  lib.alg.nonmodifying, non-modifying sequence operations:// for_eachtemplate<class InputIterator, class Function>inlineFunctionfor_each(InputIterator first, InputIterator last, Function f){	for (; first != last; ++first)		f(*first);	return f;}// findtemplate <class InputIterator, class T>inlineInputIteratorfind(InputIterator first, InputIterator last, const T& value){	while (first != last && !(*first == value))		++first;	return first;}template <class InputIterator, class Predicate>inlineInputIteratorfind_if(InputIterator first, InputIterator last, Predicate pred){	while (first != last && !pred(*first))		++first;	return first;}// equaltemplate <class InputIterator1, class InputIterator2>inlineboolequal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2){	for (; first1 != last1; ++first1, ++first2)		if (!(*first1 == *first2))			return false;	return true;}template <class InputIterator1, class InputIterator2, class BinaryPredicate>inlineboolequal(InputIterator1 first1, InputIterator1 last1,      InputIterator2 first2, BinaryPredicate pred){	for (; first1 != last1; ++first1, ++first2)		if (!pred(*first1, *first2))			return false;	return true;}// searchtemplate <class ForwardIterator1, class ForwardIterator2>ForwardIterator1search(ForwardIterator1 first1, ForwardIterator1 last1,       ForwardIterator2 first2, ForwardIterator2 last2){	typename iterator_traits<ForwardIterator1>::difference_type d1 = distance(first1, last1);	typename iterator_traits<ForwardIterator2>::difference_type d2 = distance(first2, last2);	if (d1 < d2 || d2 == 0)		return last1;	for (; d1 >= d2; ++first1, --d1)		if (equal<ForwardIterator2, ForwardIterator1>(first2, last2, first1))			return first1;	return last1;}template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>ForwardIterator1search(ForwardIterator1 first1, ForwardIterator1 last1,       ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred){	typename iterator_traits<ForwardIterator1>::difference_type d1 = distance(first1, last1);	typename iterator_traits<ForwardIterator2>::difference_type d2 = distance(first2, last2);	if (d1 < d2 || d2 == 0)		return last1;	for (; d1 >= d2; ++first1, --d1)		if (equal				<ForwardIterator2, ForwardIterator1,					typename Metrowerks::add_reference<BinaryPredicate>::type>				(first2, last2, first1, pred))			return first1;	return last1;}// find_endtemplate <class ForwardIterator1, class ForwardIterator2>ForwardIterator1__find_end(ForwardIterator1 first1, ForwardIterator1 last1,           ForwardIterator2 first2, ForwardIterator2 last2, forward_iterator_tag){	first1 = search<ForwardIterator1, ForwardIterator2>(first1, last1, first2, last2);	ForwardIterator1 result = first1;	if (first1 != last1)	{		while (true)		{			++first1;			first1 = search<ForwardIterator1, ForwardIterator2>(first1, last1, first2, last2);			if (first1 == last1)				break;			result = first1;		}	}	return result;}template <class BidirectionalIterator1, class ForwardIterator2>BidirectionalIterator1__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,           ForwardIterator2 first2, ForwardIterator2 last2,           bidirectional_iterator_tag){	typename iterator_traits<BidirectionalIterator1>::difference_type d1 = distance(first1, last1);	typename iterator_traits<ForwardIterator2>::difference_type d2 = distance(first2, last2);	if (d1 < d2 || d2 == 0)		return last1;	BidirectionalIterator1 result = last1;	for (advance(result, -d2); result != first1; --result)		if (equal(first2, last2, result))			return result;	if (equal(first2, last2, first1))		return first1;	return last1;}template <class ForwardIterator1, class ForwardIterator2>inlineForwardIterator1find_end(ForwardIterator1 first1, ForwardIterator1 last1,         ForwardIterator2 first2, ForwardIterator2 last2){	typedef typename iterator_traits<ForwardIterator1>::iterator_category Category;	return __find_end(first1, last1, first2, last2, Category());}template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>ForwardIterator1__find_end(ForwardIterator1 first1, ForwardIterator1 last1,           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred,           forward_iterator_tag){	first1 = search<ForwardIterator1, ForwardIterator2,		typename Metrowerks::add_reference<BinaryPredicate>::type>			(first1, last1, first2, last2, pred);	ForwardIterator1 result = first1;	if (first1 != last1)	{		while (true)		{			++first1;			first1 = search<ForwardIterator1, ForwardIterator2,				typename Metrowerks::add_reference<BinaryPredicate>::type>					(first1, last1, first2, last2, pred);			if (first1 == last1)				break;			result = first1;		}	}	return result;}template <class BidirectionalIterator1, class ForwardIterator2, class BinaryPredicate>BidirectionalIterator1__find_end(BidirectionalIterator1 first1, BidirectionalIterator1 last1,           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred,           bidirectional_iterator_tag){	typename iterator_traits<BidirectionalIterator1>::difference_type d1 = distance(first1, last1);	typename iterator_traits<ForwardIterator2>::difference_type d2 = distance(first2, last2);	if (d1 < d2 || d2 == 0)		return last1;	BidirectionalIterator1 result = last1;	for (advance(result, -d2); result != first1; --result)		if (equal<ForwardIterator2, BidirectionalIterator1,				typename Metrowerks::add_reference<BinaryPredicate>::type>					(first2, last2, result, pred))			return result;	if (equal<ForwardIterator2, BidirectionalIterator1,			typename Metrowerks::add_reference<BinaryPredicate>::type>(first2, last2, first1, pred))		return first1;	return last1;}template <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>inlineForwardIterator1find_end(ForwardIterator1 first1, ForwardIterator1 last1,         ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred){	typedef typename iterator_traits<ForwardIterator1>::iterator_category Category;	return __find_end<ForwardIterator1, ForwardIterator2, BinaryPredicate>		(first1, last1, first2, last2, pred, Category());}// find_first_oftemplate <class ForwardIterator1, class ForwardIterator2>ForwardIterator1find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,              ForwardIterator2 first2, ForwardIterator2 last2){	for (; first1 != last1; ++first1)	{		for (ForwardIterator2 i = first2; i != last2; ++i)			if (*first1 == *i)				return first1;	}	return last1;}template <class ForwardIterator1, class ForwardIterator2,class BinaryPredicate>ForwardIterator1find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,              ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred){	for (; first1 != last1; ++first1)	{		for (ForwardIterator2 i = first2; i != last2; ++i)			if (pred(*first1, *i))				return first1;	}	return last1;}// adjacent_findtemplate <class ForwardIterator>inlineForwardIteratoradjacent_find(ForwardIterator first, ForwardIterator last){	if (first != last)	{		ForwardIterator i = first;		for (++i; i != last; ++i)		{			if (*first == *i)				return first;			first = i;		}	}	return last;}template <class ForwardIterator, class BinaryPredicate>inlineForwardIteratoradjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred){	if (first != last)	{		ForwardIterator i = first;		for (++i; i != last; ++i)		{			if (pred(*first, *i))				return first;			first = i;		}	}	return last;}// counttemplate <class InputIterator, class T>inlinetypename iterator_traits<InputIterator>::difference_typecount(InputIterator first, InputIterator last, const T& value){	typename iterator_traits<InputIterator>::difference_type result = 0;	for (; first != last; ++first)		if (*first == value)			++result;	return result;}template <class InputIterator, class Predicate>inlinetypename iterator_traits<InputIterator>::difference_typecount_if(InputIterator first, InputIterator last, Predicate pred){	typename iterator_traits<InputIterator>::difference_type result = 0;	for (; first != last; ++first)		if (pred(*first))			++result;	return result;}// mismatchtemplate <class InputIterator1, class InputIterator2>inlinepair<InputIterator1, InputIterator2>mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2){	for (; first1 != last1; ++first1, ++first2)		if (!(*first1 == *first2))			break;	return pair<InputIterator1, InputIterator2>(first1, first2);}template <class InputIterator1, class InputIterator2, class BinaryPredicate>inlinepair<InputIterator1, InputIterator2>mismatch(InputIterator1 first1, InputIterator1 last1,         InputIterator2 first2, BinaryPredicate pred){	for (; first1 != last1; ++first1, ++first2)		if (!pred(*first1, *first2))			break;	return pair<InputIterator1, InputIterator2>(first1, first2);}// search_ntemplate <class ForwardIterator, class Size, class T>ForwardIteratorsearch_n(ForwardIterator first, ForwardIterator last, Size count, const T& value){	Size d1 = static_cast<Size>(distance(first, last));	if (d1 < count || count == 0)		return last;	for (; d1 >= count; ++first, --d1)	{		ForwardIterator i = first;		for (Size n = 0; n < count; ++n, ++i, --d1)			if (!(*i == value))				goto not_found;		return first;	not_found:		first = i;	}	return last;}template <class ForwardIterator, class Size, class T, class BinaryPredicate>ForwardIteratorsearch_n(ForwardIterator first, ForwardIterator last,         Size count, const T& value, BinaryPredicate pred){	Size d1 = static_cast<Size>(distance(first, last));	if (d1 < count || count == 0)		return last;	for (; d1 >= count; ++first, --d1)	{		ForwardIterator i = first;		for (Size n = 0; n < count; ++n, ++i, --d1)			if (!pred(*i, value))				goto not_found;		return first;	not_found:		first = i;	}	return last;}//  lib.alg.min.max, minimum and maximum:#ifdef min#undef min#endiftemplate <class T>inlineconst T&min(const T& a, const T& b){	return b < a ? b : a;}template <class T, class Compare>inlineconst T&min(const T& a, const T& b, Compare comp){	return comp(b, a) ? b : a;}#ifdef max#undef max#endiftemplate <class T>inlineconst T&max(const T& a, const T& b){	return a < b ? b : a;}template <class T, class Compare>inlineconst T&max(const T& a, const T& b, Compare comp){	return comp(a, b) ? b : a;}template <class ForwardIterator>inlineForwardIteratormin_element(ForwardIterator first, ForwardIterator last){	ForwardIterator i = first;	if (first != last)		for (++first; first != last; ++first)			if (*first < *i)				i = first;	return i;}template <class ForwardIterator, class Compare>inlineForwardIteratormin_element(ForwardIterator first, ForwardIterator last, Compare comp){	ForwardIterator i = first;	if (first != last)		for (++first; first != last; ++first)			if (comp(*first, *i))				i = first;	return i;}template <class ForwardIterator>inlineForwardIteratormax_element(ForwardIterator first, ForwardIterator last){	ForwardIterator i = first;	if (first != last)		for (++first; first != last; ++first)			if (*i < *first)				i = first;	return i;}template <class ForwardIterator, class Compare>inlineForwardIteratormax_element(ForwardIterator first, ForwardIterator last, Compare comp){	ForwardIterator i = first;	if (first != last)		for (++first; first != last; ++first)			if (comp(*i, *first))				i = first;	return i;}template <class InputIterator1, class InputIterator2>inlineboollexicographical_compare(InputIterator1 first1, InputIterator1 last1,                        InputIterator2 first2, InputIterator2 last2){	for (; first1 != last1 && first2 != last2; ++first1, ++first2)	{		if (*first1 < *first2)			return true;		if (*first2 < *first1)			return false;	}	return static_cast<bool>(first2 != last2);}template <class InputIterator1, class InputIterator2, class Compare>boollexicographical_compare(InputIterator1 first1, InputIterator1 last1,                        InputIterator2 first2, InputIterator2 last2, Compare comp){	for (; first1 != last1 && first2 != last2; ++first1, ++first2)	{		if (comp(*first1, *first2))			return true;		if (comp(*first2, *first1))			return false;	}	return static_cast<bool>(first2 != last2);}//  lib.alg.modifying.operations, modifying sequence operations://  lib.alg.copy, copy:template <class InputIterator, class OutputIterator>inlineOutputIteratorcopy(InputIterator first, InputIterator last, OutputIterator result){	for (; first != last; ++first, ++result)		*result = *first;	return result;}template <class T, bool IsPOD = Metrowerks::is_POD<T>::value, bool IsSmall = sizeof(T) < sizeof(int)>struct __copy{	static T* copy(T* first, T* last, T* result)	{		for (; first < last; ++first, ++result)			*result = *first;		return result;	}};template <class T>struct __copy<T, true, true>{	static T* copy(T* first, T* last, T* result)	{		size_t n = static_cast<size_t>(last - first);		memcpy(result, first, n*sizeof(T));		return result + n;	}};template <class T>inlineT*copy(T* first, T* last, T* result){	return __copy<T>::copy(first, last, result);}template <class T>inlineT*copy(const T* first, const T* last, T* result){	return __copy<T>::copy(const_cast<T*>(first), const_cast<T*>(last), result);}// copy_backwardtemplate <class BidirectionalIterator1, class BidirectionalIterator2>inlineBidirectionalIterator2copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,              BidirectionalIterator2 result){	while (last != first)		*--result = *--last;	return result;}template <class T, bool IsPOD = Metrowerks::is_POD<T>::value, bool IsSmall = sizeof(T) < sizeof(int)>struct __copy_backward{	static T* copy_backward(T* first, T* last, T* result)	{		while (last > first)			*--result = *--last;		return result;	}};template <class T>struct __copy_backward<T, true, true>{	static T* copy_backward(T* first, T* last, T* result)	{		size_t n = static_cast<size_t>(last - first);		result -= n;		memmove(result, first, n);		return result;	}};template <class T>inlineT*copy_backward(T* first, T* last, T* result){	return __copy_backward<T>::copy_backward(first, last, result);}template <class T>inlineT*copy_backward(const T* first, const T* last, T* result){	return __copy_backward<T>::copy_backward(const_cast<T*>(first), const_cast<T*>(last), result);}//  lib.alg.swap, swap:template <class T>inlinevoidswap(T& a, T& b){	T tmp(a);	a = b;	b = tmp;}// iter_swap// hh 990817template <class ForwardIterator1, class ForwardIterator2>inlinevoiditer_swap(ForwardIterator1 a, ForwardIterator2 b){	swap(*a, *b);}// swap_rangestemplate <class ForwardIterator1, class ForwardIterator2>inlineForwardIterator2swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2){	for (; first1 != last1; ++first1, ++first2)		iter_swap(first1, first2);	return first2;}// transformtemplate <class InputIterator, class OutputIterator, class UnaryOperation>inlineOutputIteratortransform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op){	for (; first != last; ++first, ++result)		*result = op(*first);	return result;}template <class InputIterator1, class InputIterator2, class OutputIterator,         class BinaryOperation>inlineOutputIteratortransform(InputIterator1 first1, InputIterator1 last1,          InputIterator2 first2, OutputIterator result, BinaryOperation binary_op){	for (; first1 != last1; ++first1, ++first2, ++result)		*result = binary_op(*first1, *first2);	return result;}// replacetemplate <class ForwardIterator, class T>inlinevoidreplace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value){	for (; first != last; ++first)		if (*first == old_value)			*first = new_value;}template <class ForwardIterator, class Predicate, class T>inlinevoidreplace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value){	for (; first != last; ++first)		if (pred(*first))			*first = new_value;}// replace_copytemplate <class InputIterator, class OutputIterator, class T>inlineOutputIteratorreplace_copy(InputIterator first, InputIterator last,             OutputIterator result, const T& old_value, const T& new_value){	for (; first != last; ++first, ++result)		*result = *first == old_value ? new_value : *first;	return result;}template <class InputIterator, class OutputIterator, class Predicate, class T>inlineOutputIteratorreplace_copy_if(InputIterator first, InputIterator last,                OutputIterator result, Predicate pred, const T& new_value){	for (; first != last; ++first, ++result)		*result = pred(*first) ? new_value : *first;	return result;}// filltemplate <class ForwardIterator, class T>inlinevoidfill(ForwardIterator first, ForwardIterator last, const T& value){	for (; first != last; ++first)		*first = value;}template <class OutputIterator, class Size, class T>inlinevoidfill_n(OutputIterator first, Size n, const T& value){	for (; n > 0; ++first, --n)		*first = value;}// generatetemplate <class ForwardIterator, class Generator>inlinevoidgenerate(ForwardIterator first, ForwardIterator last, Generator gen){	for (; first != last; ++first)		*first = gen();}template <class OutputIterator, class Size, class Generator>inlinevoidgenerate_n(OutputIterator first, Size n, Generator gen){	for (; n > 0; ++first, --n)		*first = gen();}// remove_copytemplate <class InputIterator, class OutputIterator, class T>OutputIteratorremove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value){	for (; first != last; ++first)	{		if (!(*first == value))		{			*result = *first;			++result;		}	}	return result;}template <class InputIterator, class OutputIterator, class Predicate>OutputIteratorremove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred){	for (; first != last; ++first)	{		if (!pred(*first))		{			*result = *first;			++result;		}	}	return result;}// removetemplate <class ForwardIterator, class T>inlineForwardIteratorremove(ForwardIterator first, ForwardIterator last, const T& value){	ForwardIterator i = first = find(first, last, value);	return first == last ? first : remove_copy(++i, last, first, value);}template <class ForwardIterator, class Predicate>ForwardIteratorremove_if(ForwardIterator first, ForwardIterator last, Predicate pred){	ForwardIterator i = first = find_if		<ForwardIterator, typename Metrowerks::add_reference<Predicate>::type>(first, last, pred);	return first == last ? first :		remove_copy_if<ForwardIterator, ForwardIterator, Predicate>(++i, last, first, pred);}// unique_copytemplate <class InputIterator, class OutputIterator>OutputIterator__unique_copy(InputIterator first, InputIterator last, OutputIterator result,              output_iterator_tag){	if (first != last)	{		typename iterator_traits<InputIterator>::value_type tmp(*first);		*result = tmp;		++result;		for (++first; first != last; ++first)		{			if (!(tmp == *first))			{				tmp = *first;				*result = tmp;				++result;			}		}	}	return result;}template <class InputIterator, class ForwardIterator>ForwardIterator__unique_copy(InputIterator first, InputIterator last, ForwardIterator result,              forward_iterator_tag){	if (first != last)	{		*result = *first;		for (++first; first != last; ++first)			if (!(*result == *first))				*++result = *first;		++result;	}	return result;}template <class InputIterator, class OutputIterator>inlineOutputIteratorunique_copy(InputIterator first, InputIterator last, OutputIterator result){	typedef typename iterator_traits<OutputIterator>::iterator_category Category;	return __unique_copy(first, last, result, Category());}template <class InputIterator, class OutputIterator, class BinaryPredicate>OutputIterator__unique_copy(InputIterator first, InputIterator last, OutputIterator result,              BinaryPredicate pred, output_iterator_tag){	if (first != last)	{		typename iterator_traits<InputIterator>::value_type tmp(*first);		*result = tmp;		++result;		for (++first; first != last; ++first)		{			if (!pred(tmp, *first))			{				tmp = *first;				*result = tmp;				++result;			}		}	}	return result;}template <class InputIterator, class ForwardIterator, class BinaryPredicate>ForwardIterator__unique_copy(InputIterator first, InputIterator last, ForwardIterator result,              BinaryPredicate pred, forward_iterator_tag){	if (first != last)	{		*result = *first;		for (++first; first != last; ++first)			if (!pred(*result, *first))				*++result = *first;		++result;	}	return result;}template <class InputIterator, class OutputIterator, class BinaryPredicate>inlineOutputIteratorunique_copy(InputIterator first, InputIterator last,            OutputIterator result, BinaryPredicate pred){	typedef typename iterator_traits<OutputIterator>::iterator_category Category;	return __unique_copy<InputIterator, OutputIterator, BinaryPredicate>(first, last, result, pred, Category());}// uniquetemplate <class ForwardIterator>inlineForwardIteratorunique(ForwardIterator first, ForwardIterator last){	typedef typename iterator_traits<ForwardIterator>::value_type value_type;	return unique(first, last, equal_to<value_type>());}template <class ForwardIterator, class BinaryPredicate>ForwardIteratorunique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred){	typedef typename Metrowerks::add_reference<BinaryPredicate>::type PredRef;	first = adjacent_find<ForwardIterator, PredRef>(first, last, pred);	if (first == last)		return first;	// first < last-1 (adjacent_find won't return first == last-1)	ForwardIterator next = first;	++next;	++next;	while (next != last && pred(*first, *next))		++next;	return unique_copy<ForwardIterator, ForwardIterator, BinaryPredicate>(next, last, ++first, pred);}// reversetemplate <class BidirectionalIterator>inlinevoid__reverse(BidirectionalIterator first, BidirectionalIterator last, bidirectional_iterator_tag){	while (first != last)	{		--last;		if (first == last)			break;		iter_swap(first, last);		++first;	}}template <class RandomAccessIterator>inlinevoid__reverse(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag){	if (first != last)		for (; first < --last; ++first)			iter_swap(first, last);}template <class BidirectionalIterator>inlinevoidreverse(BidirectionalIterator first, BidirectionalIterator last){	typedef typename iterator_traits<BidirectionalIterator>::iterator_category Category;	return __reverse(first, last, Category());}template <class BidirectionalIterator, class OutputIterator>inlineOutputIteratorreverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result){	for (; first != last; ++result)		*result = *--last;	return result;}// rotatetemplate <class ForwardIterator>void__rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last, forward_iterator_tag){	ForwardIterator i = middle;	while (true)	{		iter_swap(first, i);		if (++first == middle)		{			if (++i == last)				break;			middle = i;		}		else if (++i == last)			i = middle;	}}template <class BidirectionalIterator, class Distance, class RandomAccessIterator>BidirectionalIterator__rotate(BidirectionalIterator first, BidirectionalIterator middle,         BidirectionalIterator last, Distance len1, Distance len2,         RandomAccessIterator buf_begin, RandomAccessIterator buf_end){	Distance buf_size = static_cast<Distance>(buf_end - buf_begin);	if (len1 <= len2 && len1 <= buf_size)	{		buf_end = copy(first, middle, buf_begin);		copy(middle, last, first);		return copy_backward(buf_begin, buf_end, last);	}	if (len2 <= buf_size)	{		buf_end = copy(middle, last, buf_begin);		copy_backward(first, middle, last);		return copy(buf_begin, buf_end, first);	}	__rotate(first, middle, last, forward_iterator_tag());	advance(first, len2);	return first;}template <class BidirectionalIterator>void__rotate(BidirectionalIterator first, BidirectionalIterator middle,         BidirectionalIterator last, bidirectional_iterator_tag){	typedef typename iterator_traits<BidirectionalIterator>::value_type T;	typedef typename iterator_traits<BidirectionalIterator>::difference_type D;	D len1 = distance(first, middle);	D len2 = distance(middle, last);	_TempVec<T> temp_buf(min(len1, len2));	__rotate(first, middle, last, len1, len2, temp_buf.begin(), temp_buf.end());}template <class ForwardIterator>inlinevoidrotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last){	if (first == middle || middle == last)		return;	typedef typename iterator_traits<ForwardIterator>::iterator_category Category;	__rotate(first, middle, last, Category());}template <class ForwardIterator, class OutputIterator>inlineOutputIteratorrotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last,            OutputIterator result){	return copy(first, middle, copy(middle, last, result));}// random_shuffle#ifndef _MSL_NO_PARTIAL_SPECIALIZATION	template <unsigned int _I>	struct __num_bits	{		static const int __value = 1 + __num_bits<_I >> 1>::__value;	};	template <>	struct __num_bits<0>	{		static const int __value = 0;	};	const int __rbits = __num_bits<RAND_MAX>::__value;	const int __lbits = sizeof(unsigned long) * CHAR_BIT;	template <int _NBits>	inline	unsigned long	__random_bits(int __numbits)	{		unsigned long __result = static_cast<unsigned long>(rand());		__numbits -= __rbits;		while (__numbits > 0)		{			int __lshift = std::min(__rbits, __numbits);			int __rshift = __rbits - __lshift;			__result = (__result << __lshift) | (rand() >> __rshift);			__numbits -= __lshift;		}		return __result;	}	template <>	inline	unsigned long	__random_bits<__rbits>(int)	{		return static_cast<unsigned long>(rand());	}	template <>	inline	unsigned long	__random_bits<2*__rbits>(int)	{		return (__random_bits<__rbits>(0) << __rbits) | __random_bits<__rbits>(0);	}	template <int _NBits>	inline	unsigned long	__slab_size(unsigned long __n)	{		return (1UL << _NBits) / __n;	}	template <>	inline	unsigned long	__slab_size<__lbits>(unsigned long __n)	{		return (__n >> __lbits-1) ? 1UL : 2UL;	}	template <int _NBits>	inline	unsigned long	__scaled_random_number(unsigned long __n, int __nb)	{		unsigned long __slab = __slab_size<_NBits>(__n);		unsigned long __usable = __slab * __n;		unsigned long __raw;		do			__raw = __random_bits<_NBits>(__nb);		while (__raw >= __usable);		return __raw / __slab;	}	template <bool __b>	unsigned long	__rs_default(unsigned long __n = 0)	{		switch (__n)		{		case 0:			return __random_bits<0>(__lbits);		case 1:			return 0;		}		int __nb = __rbits;		while (__nb < __lbits && __n > (1UL << __nb))			__nb += min(__rbits, __lbits - __nb);		switch (__nb)		{		case __rbits:			return __scaled_random_number<__rbits>(__n, __nb);		case 2*__rbits:			return __scaled_random_number<2*__rbits>(__n, __nb);		}		return __scaled_random_number<0>(__n, __nb);	}#else	#ifdef __POWERPC__		template <class T>		inline		T		__next_pow2(T d)		{			T lz = static_cast<T>(__cntlzw(static_cast<unsigned int>(d)));			T r = T(1) << (sizeof(unsigned int)*CHAR_BIT - lz - 1u);			T m = static_cast<T>(static_cast<unsigned int>(-1) >> (lz + 1u));			if (m & d)				r <<= 1;			return r;		}	#else		template <class T>		inline		T		__next_pow2(T x)		{			if(x == 0)				return x;			T shift = 0;			T result =1 ;			--x;  			while(x != 0)			{				x >>= 1;				++shift;			}			return result << shift; 		}	#endif	template <class T>	T	__rs_default(T n)	{		if (n <= RAND_MAX + 1)			return rand() * n / (RAND_MAX + 1);		T d = n / (RAND_MAX + 1);		if (n % (RAND_MAX + 1) != 0)			++d;		d = __next_pow2(d);		if (d > RAND_MAX + 1)			d = RAND_MAX + 1;		T s = __rs_default(d);		T h = n / d;		T hm = d - n % d;		if (s < hm)			return s * h + __rs_default(h);		return hm * h + (s - hm) * (h + 1) + __rs_default(h + 1);	}#endiftemplate <class RandomAccessIterator>inlinevoidrandom_shuffle(RandomAccessIterator first, RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	D d = last - first;	if (d > 1)	{		for (--last; first < last; ++first, --d)			iter_swap(first, first				+ static_cast<D>(__rs_default<true>(static_cast<unsigned long>(d))));	}}template <class RandomAccessIterator, class RandomNumberGenerator>inlinevoidrandom_shuffle(RandomAccessIterator first, RandomAccessIterator last,               RandomNumberGenerator& rand){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	D d = last - first;	if (d > 1)	{		for (--last; first < last; ++first, --d)			iter_swap(first, first + rand(d));	}}//  lib.alg.partitions// partition// hh 990817template <class BidirectionalIterator, class Predicate>inlineBidirectionalIterator__partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred,	bidirectional_iterator_tag){	while (true)	{		while (pred(*first))			++first;		if (first == last)			break;		while (!pred(*--last))			{}		if (first == ++last)			break;		iter_swap(first, --last);		++first;	}	return first;}// hh 990817template <class RandomAccessIterator, class Predicate>inlineRandomAccessIterator__partition(RandomAccessIterator first, RandomAccessIterator last, Predicate pred,	random_access_iterator_tag){	while (true)	{		while (pred(*first))			++first;		while (!pred(*--last))			{}		if (first >= last)			break;		iter_swap(first, last);		++first;	}	return first;}template <class BidirectionalIterator, class Predicate>BidirectionalIteratorpartition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred){	typedef typename iterator_traits<BidirectionalIterator>::iterator_category Category;	if (first == last)		return first;	bool guard_front = pred(*first);	bool guard_back = !pred(*--last);	if (guard_front && guard_back)		// *first == true, *last == false		return __partition<BidirectionalIterator,			typename Metrowerks::add_reference<Predicate>::type>(++first, last, pred, Category());	if (guard_back)	{		// *first == false, *last == false		if (first == last)			return first;		while (first != --last && !pred(*last))			{}		if (first == last)			return first;	}	else if (guard_front)	{		// *first == true, *last == true		++last;		++first;		while (first != last && pred(*first))			++first;		if (first == last)			return first;		--last;	}	// *first == false, *last == true	iter_swap(first, last);	return __partition<BidirectionalIterator,		typename Metrowerks::add_reference<Predicate>::type>(++first, last, pred, Category());}// __partition_const_reftemplate <class BidirectionalIterator, class Predicate>BidirectionalIterator__partition_const_ref(BidirectionalIterator first, BidirectionalIterator last, const Predicate& pred){	typedef typename iterator_traits<BidirectionalIterator>::iterator_category Category;	if (first == last)		return first;	bool guard_front = pred(*first);	bool guard_back = !pred(*--last);	if (guard_front && guard_back)		// *first == true, *last == false		return __partition<BidirectionalIterator, const Predicate&>(++first, last, pred, Category());	if (guard_back)	{		// *first == false, *last == false		if (first == last)			return first;		while (first != --last && !pred(*last))			{}		if (first == last)			return first;	}	else if (guard_front)	{		// *first == true, *last == true		++last;		++first;		while (first != last && pred(*first))			++first;		if (first == last)			return first;		--last;	}	// *first == false, *last == true	iter_swap(first, last);	return __partition<BidirectionalIterator, const Predicate&>(++first, last, pred, Category());}// stable_partitiontemplate <class BidirectionalIterator, class Predicate, class Distance, class RandomAccessIterator>BidirectionalIterator__stable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred,                   Distance len, RandomAccessIterator buf_begin, RandomAccessIterator buf_end){	// check for trivial cases	switch (len)	{	case 0:		return last;	case 1:		return pred(*first) ? last : first;	case 2:		if (pred(*first))		{			if (pred(*++first))				return last;			return first;		}		if (pred(*--last))		{			iter_swap(first, last);			return last;		}		return first;	}	// Try to do with temporary memory	if (len <= buf_end - buf_begin)	{		// Find first false		while (first != last && pred(*first))			++first;		if (first == last)  // if already partitioned			return last;		// first marks first false		BidirectionalIterator i = first;		// Find next true		i = find_if<BidirectionalIterator, typename Metrowerks::add_reference<Predicate>::type>			(++i, last, pred);		if (i == last)  // if already partitioned			return first;		// Put falses in temporary buffer, move trues towards first		RandomAccessIterator j = copy(first, i, buf_begin);		*first = *i;		for (++first, ++i; i != last; ++i)		{			if (pred(*i))			{				*first = *i;				++first;			}			else			{				*j = *i;				++j;			}		}		// Now move falses back to first		copy(buf_begin, j, first);		return first;	}	// Else make do with less memory	BidirectionalIterator mid = first;	Distance l2 = len / 2;	advance(mid, l2);	BidirectionalIterator first_false =		__stable_partition<BidirectionalIterator,		typename Metrowerks::add_reference<Predicate>::type,		Distance, RandomAccessIterator>(first, mid, pred, l2, buf_begin, buf_end);	BidirectionalIterator second_false =		__stable_partition<BidirectionalIterator,		typename Metrowerks::add_reference<Predicate>::type,		Distance, RandomAccessIterator>(mid, last, pred, len - l2, buf_begin, buf_end);	l2 = distance(mid, second_false);	if (l2 == 0)		return first_false;	len = distance(first_false, mid);	if (len > 0)		first_false = __rotate(first_false, mid, second_false, len, l2, buf_begin, buf_end);	else		advance(first_false, l2);	return first_false;}template <class BidirectionalIterator, class Predicate>BidirectionalIteratorstable_partition(BidirectionalIterator first, BidirectionalIterator last, Predicate pred){	// Attempt to shrink problem size	while (first != last && pred(*first))		++first;	typedef typename iterator_traits<BidirectionalIterator>::value_type T;	typedef typename iterator_traits<BidirectionalIterator>::difference_type D;	D len = distance(first, last);	// partition now known to start with false	switch (len)	{	case 0:	case 1:		return first;	case 2:		if (pred(*--last))		{			iter_swap(first, last);			return last;		}		return first;	}	_TempVec<T> temp_buf(len);	return __stable_partition<BidirectionalIterator, Predicate, D, _TempVec<T>::iterator>		(first, last, pred, len, temp_buf.begin(), temp_buf.end());}//  lib.alg.binary.search, binary search:// lower_boundtemplate <class ForwardIterator, class T>ForwardIteratorlower_bound(ForwardIterator first, ForwardIterator last, const T& value){	typedef typename iterator_traits<ForwardIterator>::difference_type D;	D len = distance(first, last);	while (len > 0)	{		ForwardIterator i = first;		D len2 = len / 2;		advance(i, len2);		if (*i < value)		{			first = ++i;			len -= len2 + 1;		}		else			len = len2;	}	return first;}template <class ForwardIterator, class T, class Compare>ForwardIteratorlower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp){	typedef typename iterator_traits<ForwardIterator>::difference_type D;	D len = distance(first, last);	while (len > 0)	{		ForwardIterator i = first;		D len2 = len / 2;		advance(i, len2);		if (comp(*i, value))		{			first = ++i;			len -= len2 + 1;		}		else			len = len2;	}	return first;}// upper_boundtemplate <class ForwardIterator, class T>ForwardIteratorupper_bound(ForwardIterator first, ForwardIterator last, const T& value){	typedef typename iterator_traits<ForwardIterator>::difference_type D;	D len = distance(first, last);	while (len > 0)	{		ForwardIterator i = first;		D len2 = len / 2;		advance(i, len2);		if (!(value < *i))		{			first = ++i;			len -= len2 + 1;		}		else			len = len2;	}	return first;}template <class ForwardIterator, class T, class Compare>ForwardIteratorupper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp){	typedef typename iterator_traits<ForwardIterator>::difference_type D;	D len = distance(first, last);	while (len > 0)	{		ForwardIterator i = first;		D len2 = len / 2;		advance(i, len2);		if (!comp(value, *i))		{			first = ++i;			len -= len2 + 1;		}		else			len = len2;	}	return first;}// equal_rangetemplate <class ForwardIterator, class T>pair<ForwardIterator, ForwardIterator>equal_range(ForwardIterator first, ForwardIterator last, const T& value){	typedef pair<ForwardIterator, ForwardIterator> Result;	typedef typename iterator_traits<ForwardIterator>::difference_type D;	D len = distance(first, last);	while (len > 0)	{		ForwardIterator i = first;		D len2 = len / 2;		advance(i, len2);		if (*i < value)		{			first = ++i;			len -= len2 + 1;		}		else if (value < *i)		{			len = len2;			last = i;		}		else		{			ForwardIterator j = i;			return Result(lower_bound(first, i, value), upper_bound(++j, last, value));		}	}	return Result(first, first);}template <class ForwardIterator, class T, class Compare>pair<ForwardIterator, ForwardIterator>equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp){	typedef pair<ForwardIterator, ForwardIterator> Result;	typedef typename iterator_traits<ForwardIterator>::difference_type D;	D len = distance(first, last);	while (len > 0)	{		ForwardIterator i = first;		D len2 = len / 2;		advance(i, len2);		if (comp(*i, value))		{			first = ++i;			len -= len2 + 1;		}		else if (comp(value, *i))		{			len = len2;			last = i;		}		else		{			ForwardIterator j = i;			return Result(lower_bound(first, i, value, comp),			              upper_bound(++j, last, value, comp));		}	}	return Result(first, first);}template <class ForwardIterator, class T>inlineboolbinary_search(ForwardIterator first, ForwardIterator last, const T& value){	ForwardIterator i = lower_bound(first, last, value);	return static_cast<bool>(i != last && !(value < *i));}template <class ForwardIterator, class T, class Compare>inlineboolbinary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp){	ForwardIterator i = lower_bound(first, last, value, comp);	return static_cast<bool>(i != last && !comp(value, *i));}// mergetemplate <class InputIterator1, class InputIterator2, class OutputIterator>OutputIteratormerge(InputIterator1 first1, InputIterator1 last1,      InputIterator2 first2, InputIterator2 last2, OutputIterator result){	typedef typename iterator_traits<InputIterator1>::value_type value_type;	for (; first1 != last1 && first2 != last2; ++result)	{		if (static_cast<value_type>(*first2) < static_cast<value_type>(*first1))		{			*result = *first2;			++first2;		}		else		{			*result = *first1;			++first1;		}	}	if (first1 == last1)		return copy(first2, last2, result);	return copy(first1, last1, result);}template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>OutputIteratormerge(InputIterator1 first1, InputIterator1 last1,      InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp){	for (; first1 != last1 && first2 != last2; ++result)	{		if (comp(*first2, *first1))		{			*result = *first2;			++first2;		}		else		{			*result = *first1;			++first1;		}	}	if (first1 == last1)		return copy(first2, last2, result);	return copy(first1, last1, result);}// __merge_backwardtemplate <class BidirectionalIterator1, class BidirectionalIterator2,          class BidirectionalIterator3>BidirectionalIterator3__merge_backward(BidirectionalIterator1 first1, BidirectionalIterator1 last1,                 BidirectionalIterator2 first2, BidirectionalIterator2 last2,                 BidirectionalIterator3 result){	typedef typename iterator_traits<BidirectionalIterator1>::value_type value_type;	if (first1 == last1)		return copy_backward(first2, last2, result);	if (first2 == last2)		return copy_backward(first1, last1, result);	--last1;	--last2;	while (true)	{		if (static_cast<value_type>(*last2) < static_cast<value_type>(*last1))		{			*--result = *last1;			if (first1 == last1)				return copy_backward(first2, ++last2, result);			--last1;		} else		{			*--result = *last2;			if (first2 == last2)				return copy_backward(first1, ++last1, result);			--last2;		}	}}template <class BidirectionalIterator1, class BidirectionalIterator2,          class BidirectionalIterator3, class Compare>BidirectionalIterator3__merge_backward(BidirectionalIterator1 first1, BidirectionalIterator1 last1,                 BidirectionalIterator2 first2, BidirectionalIterator2 last2,                 BidirectionalIterator3 result, Compare comp){	if (first1 == last1)		return copy_backward(first2, last2, result);	if (first2 == last2)		return copy_backward(first1, last1, result);	--last1;	--last2;	while (true)	{		if (comp(*last2, *last1))		{			*--result = *last1;			if (first1 == last1)				return copy_backward(first2, ++last2, result);			--last1;		} else		{			*--result = *last2;			if (first2 == last2)				return copy_backward(first1, ++last1, result);			--last2;		}	}}// inplace_mergetemplate <class BidirectionalIterator, class Distance, class RandomAccessIterator>void__inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,                BidirectionalIterator last, Distance len1, Distance len2,                RandomAccessIterator buf_beg, RandomAccessIterator buf_end){	if (first == middle || middle == last)		return;	if (len1 + len2 == 2)	{		if (*middle < *first)			iter_swap(first, middle);		return;	}	Distance buffer_size = static_cast<Distance>(buf_end - buf_beg);	if (len1 <= len2 && len1 <= buffer_size)		merge(buf_beg, copy(first, middle, buf_beg), middle, last, first);	else if (len2 <= buffer_size)		__merge_backward(first, middle, buf_beg, copy(middle, last, buf_beg), last);	else	{		BidirectionalIterator mid1, mid2;		Distance len12, len22;		if (len1 < len2)		{			len22 = len2 / 2;			mid2 = middle;			advance(mid2, len22);			mid1 = upper_bound(first, middle, *mid2);			len12 = distance(first, mid1);		}		else		{			len12 = len1 / 2;			mid1 = first;			advance(mid1, len12);			mid2 = lower_bound(middle, last, *mid1);			len22 = distance(middle, mid2);		}		middle = __rotate(mid1, middle, mid2, len1 - len12, len22, buf_beg, buf_end);		__inplace_merge(first, mid1, middle, len12, len22, buf_beg, buf_end);		__inplace_merge(middle, mid2, last, len1-len12, len2-len22, buf_beg, buf_end);	}}template <class BidirectionalIterator>voidinplace_merge(BidirectionalIterator first, BidirectionalIterator middle,              BidirectionalIterator last){	typedef typename iterator_traits<BidirectionalIterator>::difference_type D;	typedef typename iterator_traits<BidirectionalIterator>::value_type T;	D len1 = distance(first, middle);	if (len1 == 0)		return;	D len2 = distance(middle, last);	if (len2 == 0)		return;	_TempVec<T> temp_buf(min(len1, len2));	__inplace_merge(first, middle, last, len1, len2, temp_buf.begin(), temp_buf.end());}template <class BidirectionalIterator, class Compare, class Distance, class RandomAccessIterator>void__inplace_merge(BidirectionalIterator first, BidirectionalIterator middle,                BidirectionalIterator last, Compare comp, Distance len1, Distance len2,                RandomAccessIterator buf_beg, RandomAccessIterator buf_end){	if (first == middle || middle == last)		return;	if (len1 + len2 == 2)	{		if (comp(*middle, *first))			iter_swap(first, middle);		return;	}	Distance buffer_size = static_cast<Distance>(buf_end - buf_beg);	if (len1 <= len2 && len1 <= buffer_size)		merge(buf_beg, copy(first, middle, buf_beg), middle, last, first, comp);	else if (len2 <= buffer_size)		__merge_backward(first, middle, buf_beg, copy(middle, last, buf_beg), last, comp);	else	{		BidirectionalIterator mid1, mid2;		Distance len12, len22;		if (len1 <= len2)		{			len22 = len2 / 2;			mid2 = middle;			advance(mid2, len22);			mid1 = upper_bound(first, middle, *mid2, comp);			len12 = distance(first, mid1);		}		else		{			len12 = len1 / 2;			mid1 = first;			advance(mid1, len12);			mid2 = lower_bound(middle, last, *mid1, comp);			len22 = distance(middle, mid2);		}		middle = __rotate(mid1, middle, mid2, len1 - len12, len22, buf_beg, buf_end);		__inplace_merge(first, mid1, middle, comp, len12, len22, buf_beg, buf_end);		__inplace_merge(middle, mid2, last, comp, len1-len12, len2-len22, buf_beg, buf_end);	}}template <class BidirectionalIterator, class Compare>voidinplace_merge(BidirectionalIterator first, BidirectionalIterator middle,              BidirectionalIterator last, Compare comp){	typedef typename iterator_traits<BidirectionalIterator>::difference_type D;	typedef typename iterator_traits<BidirectionalIterator>::value_type T;	D len1 = distance(first, middle);	if (len1 == 0)		return;	D len2 = distance(middle, last);	if (len2 == 0)		return;	_TempVec<T> temp_buf(min(len1, len2));	__inplace_merge(first, middle, last, comp, len1, len2, temp_buf.begin(), temp_buf.end());}//  lib.alg.heap.operations, heap operations:// push_heaptemplate <class RandomAccessIterator>voidpush_heap(RandomAccessIterator first, RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	D hole = last - first;	if (hole < 2)		return;	--hole;	D parent = (hole - 1) / 2;	RandomAccessIterator parent_ptr = first + parent;	RandomAccessIterator hole_ptr = first + hole;	if (*parent_ptr < *hole_ptr)	{		T tmp(*hole_ptr);		do		{			*hole_ptr = *parent_ptr;			hole_ptr = parent_ptr;			if (hole_ptr == first)				break;			--parent;			parent /= 2;			parent_ptr = first + parent;		} while (*parent_ptr < tmp);		*hole_ptr = tmp;	}}template <class RandomAccessIterator, class Compare>voidpush_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	D hole = last - first;	if (hole < 2)		return;	--hole;	D parent = (hole - 1) / 2;	RandomAccessIterator parent_ptr = first + parent;	RandomAccessIterator hole_ptr = first + hole;	if (comp(*parent_ptr, *hole_ptr))	{		T tmp(*hole_ptr);		do		{			*hole_ptr = *parent_ptr;			hole_ptr = parent_ptr;			if (hole_ptr == first)				break;			--parent;			parent /= 2;			parent_ptr = first + parent;		} while (comp(*parent_ptr, tmp));		*hole_ptr = tmp;	}}// __insert_heap_downtemplate <class RandomAccessIterator, class Distance, class T>void__insert_heap_down(RandomAccessIterator first, Distance len, Distance hole,                   const T& temp){	RandomAccessIterator hole_ptr = first + hole;	Distance child = (hole + 1) * 2;	while (child <= len)	{		RandomAccessIterator child_ptr = first + child;		if (child == len || *child_ptr < *(child_ptr - 1))		{			--child;			--child_ptr;		}		if (!(temp < *child_ptr))			break;		*hole_ptr = *child_ptr;		hole_ptr = child_ptr;		++child;		child *= 2;	}	*hole_ptr = temp;}template <class RandomAccessIterator, class Distance, class T, class Compare>void__insert_heap_down(RandomAccessIterator first, Distance len, Distance hole,                   const T& temp, Compare comp){	RandomAccessIterator hole_ptr = first + hole;	Distance child = (hole + 1) * 2;	while (child <= len)	{		RandomAccessIterator child_ptr = first + child;		if (child == len || comp(*child_ptr, *(child_ptr - 1)))		{			--child;			--child_ptr;		}		if (!comp(temp, *child_ptr))			break;		*hole_ptr = *child_ptr;		hole_ptr = child_ptr;		++child;		child *= 2;	}	*hole_ptr = temp;}// pop_heaptemplate <class RandomAccessIterator>voidpop_heap(RandomAccessIterator first, RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	D len = last - first;	if (len < 2)		return;	--last;	if (len == 2)	{		iter_swap(first, last);		return;	}	--len;	T temp(*last);	*last = *first;	__insert_heap_down(first, len, D(0), temp);}template <class RandomAccessIterator, class Compare>voidpop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	D len = last - first;	if (len < 2)		return;	--last;	if (len == 2)	{		iter_swap(first, last);		return;	}	--len;	T temp(*last);	*last = *first;	__insert_heap_down(first, len, D(0), temp, comp);}// make_heaptemplate <class RandomAccessIterator>voidmake_heap(RandomAccessIterator first, RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	D len = last - first;	if (len < 2)		return;	D parent = (len - 2)/2;	RandomAccessIterator parent_ptr = first + parent;	D child2 = (parent + 1) * 2;	RandomAccessIterator child2_ptr = first + child2;	RandomAccessIterator child1_ptr = child2_ptr - 1;	D max_child = child2;	RandomAccessIterator max_child_ptr = child2_ptr;	if (child2 == len || *child2_ptr < *child1_ptr)	{		--max_child;		max_child_ptr = child1_ptr;	}	while (true)	{		if (*parent_ptr < *max_child_ptr)		{			T temp(*parent_ptr);			*parent_ptr = *max_child_ptr;			__insert_heap_down(first, len, max_child, temp);		}		if (parent-- == 0)			break;		--parent_ptr;		child2 -= 2;		child2_ptr -= 2;		child1_ptr -= 2;		max_child = child2;		max_child_ptr = child2_ptr;		if (*child2_ptr < *child1_ptr)		{			--max_child;			max_child_ptr = child1_ptr;		}	}}template <class RandomAccessIterator, class Compare>voidmake_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	D len = last - first;	if (len < 2)		return;	D parent = (len - 2)/2;	RandomAccessIterator parent_ptr = first + parent;	D child2 = (parent + 1) * 2;	RandomAccessIterator child2_ptr = first + child2;	RandomAccessIterator child1_ptr = child2_ptr - 1;	D max_child = child2;	RandomAccessIterator max_child_ptr = child2_ptr;	if (child2 == len || comp(*child2_ptr, *child1_ptr))	{		--max_child;		max_child_ptr = child1_ptr;	}	while (true)	{		if (comp(*parent_ptr, *max_child_ptr))		{			T temp(*parent_ptr);			*parent_ptr = *max_child_ptr;			__insert_heap_down(first, len, max_child, temp, comp);		}		if (parent-- == 0)			break;		--parent_ptr;		child2 -= 2;		child2_ptr -= 2;		child1_ptr -= 2;		max_child = child2;		max_child_ptr = child2_ptr;		if (comp(*child2_ptr, *child1_ptr))		{			--max_child;			max_child_ptr = child1_ptr;		}	}}//  sort_heaptemplate <class RandomAccessIterator>inlinevoidsort_heap(RandomAccessIterator first, RandomAccessIterator last){	for (; first != last; --last)		pop_heap(first, last);}template <class RandomAccessIterator, class Compare>inlinevoidsort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp){	for (; first != last; --last)		pop_heap(first, last, comp);}//  sort// hh 990106, 990817template<class ForwardIterator>void__sort3(ForwardIterator a1, ForwardIterator a2, ForwardIterator a3){	bool b1 = !(*a2 < *a1);	bool b2 = !(*a3 < *a2);	if (b1 && b2)		return;	if (!b1 && !b2)	{		iter_swap(a1, a3);		return;	}	if (*a3 < *a1)		iter_swap(a1, a3);	if (b1)		iter_swap(a2, a3);	else		iter_swap(a1, a2);}// hh 990106, 990817template<class ForwardIterator, class Compare>void__sort3(ForwardIterator a1, ForwardIterator a2, ForwardIterator a3, Compare comp){	bool b1 = !comp(*a2, *a1);	bool b2 = !comp(*a3, *a2);	if (b1 && b2)		return;	if (!b1 && !b2)	{		iter_swap(a1, a3);		return;	}	if (comp(*a3, *a1))		iter_swap(a1, a3);	if (b1)		iter_swap(a2, a3);	else		iter_swap(a1, a2);}template<class ForwardIterator>void__sort132(ForwardIterator a1, ForwardIterator a2, ForwardIterator a3){	bool b1 = !(*a2 < *a1);	bool b2 = !(*a3 < *a2);	bool b3 = b1 == b2 ? b1 : !(*a3 < *a1);	if (b1 && !b2 && b3)		return;	if (!b1 && b2 && !b3)	{		iter_swap(a1, a2);		return;	}	if (!b1)		iter_swap(a1, a2);	if (b2)		iter_swap(a2, a3);	else		iter_swap(a1, a3);}template<class ForwardIterator, class Compare>void__sort132(ForwardIterator a1, ForwardIterator a2, ForwardIterator a3, Compare comp){	bool b1 = !comp(*a2, *a1);	bool b2 = !comp(*a3, *a2);	bool b3 = b1 == b2 ? b1 : !comp(*a3, *a1);	if (b1 && !b2 && b3)		return;	if (!b1 && b2 && !b3)	{		iter_swap(a1, a2);		return;	}	if (!b1)		iter_swap(a1, a2);	if (b2)		iter_swap(a2, a3);	else		iter_swap(a1, a3);}// hh 990817template<class RandomAccessIterator>void__selection_sort(RandomAccessIterator first, RandomAccessIterator last){	if (first != last)	{		RandomAccessIterator stop = last - 1;		for (; first < stop; ++first)		{			RandomAccessIterator i = min_element(first, last);			if (i != first)				iter_swap(i, first);		}	}}// hh 990817template<class RandomAccessIterator, class Compare>void__selection_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp){	if (first != last)	{		RandomAccessIterator stop = last - 1;		for (; first < stop; ++first)		{			RandomAccessIterator i = min_element(first, last, comp);			if (i != first)				iter_swap(i, first);		}	}}template<class RandomAccessIterator>void__insertion_sort(RandomAccessIterator first, RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::value_type Value;	if (first != last)  // hh 991102	{		RandomAccessIterator i = first;		for (++i; i < last; ++i)		{			Value tmp = *i;			RandomAccessIterator j = i;			RandomAccessIterator k = j;			while (first < k && tmp < *--j)  // hh 990818			{				*k = *j;				--k;			}			*k = tmp;		}	}}template<class RandomAccessIterator, class Compare>void__insertion_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::value_type Value;	if (first != last)	{		RandomAccessIterator i = first;		for (++i; i < last; ++i)  // hh 991102		{			Value tmp = *i;			RandomAccessIterator j = i;			RandomAccessIterator k = j;			while (first < k && comp(tmp, *--j))  // hh 990818			{				*k = *j;				--k;			}			*k = tmp;		}	}}// hh 990817const int __sort_switch = 20;// hh 990817template<class RandomAccessIterator>voidsort(RandomAccessIterator first, RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::difference_type Difference;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	while (true)	{		Difference len = last - first;		if (len <= 1)			break;		if (len <= __sort_switch)		{			__selection_sort(first, last);			break;		}		static const int shuffle_range = __sort_switch / 4;		static int shuffle = -shuffle_range + 1;		RandomAccessIterator m = first + (len / 4 + shuffle % shuffle_range);		if (++shuffle >= shuffle_range)			shuffle = -shuffle_range + 1;		RandomAccessIterator i1 = first + (3*len / 4 + shuffle % shuffle_range); 		if (++shuffle >= shuffle_range)			shuffle = -shuffle_range + 1;		RandomAccessIterator j = last - 1;		__sort132(m, i1, j);		m = __partition_const_ref(first, j, __binder2nd_const_ref<less<T> >(less<T>(), *j));		if (m == first)		{			iter_swap(m, j);			++m;			m = __partition_const_ref(m, last, not1(__binder1st_const_ref<less<T> >(less<T>(), *first)));//			sort(m, last);			first = m;		}		else		{			if (m - first < last - m)			{				sort(first, m);//				sort(m, last);				first = m;			}			else			{				sort(m, last);//				sort(first, m);				last = m;			}		}	}}// hh 990817template<class RandomAccessIterator, class Compare>voidsort(RandomAccessIterator first, RandomAccessIterator last, Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::difference_type Difference;	while (true)	{		Difference len = last - first;		if (len <= 1)			break;		if (len <= __sort_switch)		{			__selection_sort(first, last, comp);			break;		}		static const int shuffle_range = __sort_switch / 4;		static int shuffle = -shuffle_range + 1;		RandomAccessIterator m = first + (len / 4 + shuffle % shuffle_range);		if (++shuffle >= shuffle_range)			shuffle = -shuffle_range + 1;		RandomAccessIterator i1 = first + (3*len / 4 + shuffle % shuffle_range); 		if (++shuffle >= shuffle_range)			shuffle = -shuffle_range + 1;		RandomAccessIterator j = last - 1;		__sort132(m, i1, j, comp);//		m = __partition_const_ref(first, j, __binder2nd_const_ref<Compare>(comp, *j));		m = first;		i1 = j;		while (comp(*m, *j))			++m;		while (m != --i1 && !comp(*i1, *j))			{}		if (m < i1)		{			iter_swap(m, i1);			++m;			while (true)			{				while (comp(*m, *j))					++m;				while (!comp(*--i1, *j))					{}				if (m >= i1)					break;				iter_swap(m, i1);				++m;			}		}		if (m == first)		{			iter_swap(m, j);			++m;//			m = __partition_const_ref(m, last, not1(__binder1st_const_ref<Compare>(comp, *first)));			i1 = last;			if (!comp(*first, *--i1))			{				while(m != last && !comp(*first, *m))					++m;				if (m < i1)					iter_swap(m, i1);			}			if (m < i1)			{				while (true)				{					while (!comp(*first, *m))						++m;					while (comp(*first, *--i1))						{}					if (m >= i1)						break;					iter_swap(m, i1);					++m;				}			}//			sort(m, last, comp);			first = m;		}		else		{			if (m - first < last - m)			{				sort(first, m, comp);//				sort(m, last, comp);				first = m;			}			else			{				sort(m, last, comp);//				sort(first, m, comp);				last = m;			}		}	}}// stable_sorttemplate <class RandomAccessIterator1, class RandomAccessIterator2>void__stable_sort_copy(RandomAccessIterator1 first1, RandomAccessIterator1 last1,                   RandomAccessIterator2 first2){	typedef typename iterator_traits<RandomAccessIterator1>::difference_type Difference;	Difference len = last1 - first1;	if (len <= 0)		return;	if (len == 1)	{		*first2 = *first1;		return;	}	if (len == 2)	{		if (*(last1-1) < *first1)			reverse_copy(first1, last1, first2);		else			copy(first1, last1, first2);		return;	}	if (len <= __sort_switch)	{		__insertion_sort(first1, last1);		copy(first1, last1, first2);		return;	}	Difference len2 = len / 2;	RandomAccessIterator1 middle = first1 + len2;	__stable_sort(first1, middle, first2, first2+len2);	__stable_sort(middle, last1, first2+len2, first2+len);	merge(first1, first1+len2, first1+len2, first1+len, first2);}template <class RandomAccessIterator1, class RandomAccessIterator2, class Compare>void__stable_sort_copy(RandomAccessIterator1 first1, RandomAccessIterator1 last1,                   RandomAccessIterator2 first2, Compare comp){	typedef typename iterator_traits<RandomAccessIterator1>::difference_type Difference;	Difference len = last1 - first1;	if (len <= 0)		return;	if (len == 1)	{		*first2 = *first1;		return;	}	if (len == 2)	{		if (comp(*(last1-1), *first1))			reverse_copy(first1, last1, first2);		else			copy(first1, last1, first2);		return;	}	if (len <= __sort_switch)	{		__insertion_sort(first1, last1, comp);		copy(first1, last1, first2);		return;	}	Difference len2 = len / 2;	RandomAccessIterator1 middle = first1 + len2;	__stable_sort(first1, middle, first2, first2+len2, comp);	__stable_sort(middle, last1, first2+len2, first2+len, comp);	merge(first1, first1+len2, first1+len2, first1+len, first2, comp);}template <class RandomAccessIterator1, class RandomAccessIterator2>void__stable_sort(RandomAccessIterator1 first, RandomAccessIterator1 last,              RandomAccessIterator2 buf_beg, RandomAccessIterator2 buf_end){	typedef typename iterator_traits<RandomAccessIterator1>::difference_type Difference;	Difference len = last - first;	if (len <= 1)		return;	if (len == 2)	{		--last;		if (*last < *first)			iter_swap(first, last);		return;	}	if (len <= __sort_switch)	{		__insertion_sort(first, last);		return;	}	RandomAccessIterator1 middle = first + len / 2;	if (len <= buf_end - buf_beg)	{		__stable_sort_copy(first, middle, buf_beg);		__stable_sort_copy(middle, last, buf_beg+len/2);		merge(buf_beg, buf_beg+len/2, buf_beg+len/2, buf_beg+len, first);		return;	}	__stable_sort(first, middle, buf_beg, buf_end);	__stable_sort(middle, last, buf_beg, buf_end);	__inplace_merge(first, middle, last, middle - first, last - middle, buf_beg, buf_end);}template <class RandomAccessIterator1, class RandomAccessIterator2, class Compare>void__stable_sort(RandomAccessIterator1 first, RandomAccessIterator1 last,              RandomAccessIterator2 buf_beg, RandomAccessIterator2 buf_end, Compare comp){	typedef typename iterator_traits<RandomAccessIterator1>::difference_type Difference;	Difference len = last - first;	if (len <= 1)		return;	if (len == 2)	{		--last;		if (comp(*last, *first))			iter_swap(first, last);		return;	}	if (len <= __sort_switch)	{		__insertion_sort(first, last, comp);		return;	}	RandomAccessIterator1 middle = first + len / 2;	if (len <= buf_end - buf_beg)	{		__stable_sort_copy(first, middle, buf_beg, comp);		__stable_sort_copy(middle, last, buf_beg+len/2, comp);		merge(buf_beg, buf_beg+len/2, buf_beg+len/2, buf_beg+len, first, comp);		return;	}	__stable_sort(first, middle, buf_beg, buf_end, comp);	__stable_sort(middle, last, buf_beg, buf_end, comp);	__inplace_merge(first, middle, last, comp, middle - first, last - middle, buf_beg,		buf_end);}template <class RandomAccessIterator>voidstable_sort(RandomAccessIterator first, RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::difference_type Difference;	Difference len = last - first;	if (len <= 1)		return;	if (len == 2)	{		--last;		if (*last < *first)			iter_swap(first, last);		return;	}	if (len <= __sort_switch)	{		__insertion_sort(first, last);		return;	}	typedef typename iterator_traits<RandomAccessIterator>::value_type Value;	_TempVec<Value> buf(len);	__stable_sort(first, last, buf.begin(), buf.end());}template <class RandomAccessIterator, class Compare>voidstable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::difference_type Difference;	Difference len = last - first;	if (len <= 1)		return;	if (len == 2)	{		--last;		if (comp(*last, *first))			iter_swap(first, last);		return;	}	if (len <= __sort_switch)	{		__insertion_sort(first, last, comp);		return;	}	typedef typename iterator_traits<RandomAccessIterator>::value_type Value;	_TempVec<Value> buf(len);	__stable_sort(first, last, buf.begin(), buf.end(), comp);}// partial_sorttemplate <class RandomAccessIterator>voidpartial_sort(RandomAccessIterator first, RandomAccessIterator middle,             RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	D midlen = middle - first;	switch (midlen)	{	case 0:		return;	case 1:		iter_swap(first, min_element(first, last));		return;	}	make_heap(first, middle);	for (RandomAccessIterator i = middle; i != last; ++i)	{		if (*i < *first)		{			T tmp(*i);			*i = *first;			__insert_heap_down(first, midlen, D(0), tmp);		}	}	sort_heap(first, middle);}template <class RandomAccessIterator, class Compare>voidpartial_sort(RandomAccessIterator first, RandomAccessIterator middle,             RandomAccessIterator last, Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	D midlen = middle - first;	switch (midlen)	{	case 0:		return;	case 1:		iter_swap(first, min_element(first, last, comp));		return;	}	make_heap(first, middle, comp);	for (RandomAccessIterator i = middle; i != last; ++i)	{		if (comp(*i, *first))		{			T tmp(*i);			*i = *first;			__insert_heap_down(first, midlen, D(0), tmp, comp);		}	}	sort_heap(first, middle, comp);}template <class InputIterator, class RandomAccessIterator>RandomAccessIteratorpartial_sort_copy(InputIterator first, InputIterator last,                  RandomAccessIterator result_first, RandomAccessIterator result_last){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	RandomAccessIterator result = result_first;	for (; first != last && result != result_last; ++first, ++result)		*result = *first;	D len = result - result_first;	if (len == 0)		return result;	make_heap(result_first, result);	for (; first != last; ++first)		if (*first < *result_first)			__insert_heap_down(result_first, len, D(0), *first);	sort_heap(result_first, result);	return result;}template <class InputIterator, class RandomAccessIterator, class Compare>RandomAccessIteratorpartial_sort_copy(InputIterator first, InputIterator last,                  RandomAccessIterator result_first, RandomAccessIterator result_last,                  Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	RandomAccessIterator result = result_first;	for (; first != last && result != result_last; ++first, ++result)		*result = *first;	D len = result - result_first;	if (len == 0)		return result;	make_heap(result_first, result, comp);	for (; first != last; ++first)		if (comp(*first, *result_first))			__insert_heap_down(result_first, len, D(0), *first, comp);	sort_heap(result_first, result, comp);	return result;}template <class RandomAccessIterator>voidnth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	D len = last - first;	while (len > 3)	{		if (nth == first)		{			iter_swap(first, min_element(first, last));			return;		}		RandomAccessIterator j = last - 1;		if (nth == j)		{			iter_swap(j, max_element(first, last));			return;		}		RandomAccessIterator m = first + len / 2;		__sort3(first, m, j);  // hh 990106		T part(*m);		m = partition(first + 1, j, bind2nd(less<T>(), *m));		if (nth < m)			last = m;		else			first = m;		len = last - first;	}	__insertion_sort(first, last);}template <class RandomAccessIterator, class Compare>voidnth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last,            Compare comp){	typedef typename iterator_traits<RandomAccessIterator>::difference_type D;	typedef typename iterator_traits<RandomAccessIterator>::value_type T;	D len = last - first;	while (len > 3)	{		if (nth == first)		{			iter_swap(first, min_element(first, last, comp));			return;		}		RandomAccessIterator j = last - 1;		if (nth == j)		{			iter_swap(j, max_element(first, last, comp));			return;		}		RandomAccessIterator m = first + len / 2;		__sort3(first, m, j, comp);  // hh 990106		T part(*m);		m = partition(first + 1, j, bind2nd(comp, *m));		if (nth < m)			last = m;		else			first = m;		len = last - first;	}	__insertion_sort(first, last, comp);}//  lib.alg.set.operations, set operations:template <class InputIterator1, class InputIterator2>inlineboolincludes(InputIterator1 first1, InputIterator1 last1,         InputIterator2 first2, InputIterator2 last2){	for (; first1 != last1 && first2 != last2; ++first1)	{		if (*first2 < *first1)			return false;		else if (!(*first1 < *first2))  // else if (*first1 == *first2)			++first2;	}	return static_cast<bool>(first2 == last2);}template <class InputIterator1, class InputIterator2, class Compare>inlineboolincludes(InputIterator1 first1, InputIterator1 last1,         InputIterator2 first2, InputIterator2 last2, Compare comp){	for (; first1 != last1 && first2 != last2; ++first1)	{		if (comp(*first2, *first1))			return false;		else if (!comp(*first1, *first2))  // else if (*first1 == *first2)			++first2;	}	return static_cast<bool>(first2 == last2);}template <class InputIterator1, class InputIterator2, class OutputIterator>OutputIteratorset_union(InputIterator1 first1, InputIterator1 last1,          InputIterator2 first2, InputIterator2 last2, OutputIterator result){	for (; first1 != last1 && first2 != last2; ++result)	{		if (*first2 < *first1)		{			*result = *first2;			++first2;		}		else if (*first1 < *first2)		{			*result = *first1;			++first1;		}		else		{			*result = *first1;			++first1;			++first2;		}	}	if (first2 == last2)		return copy(first1, last1, result);	return copy(first2, last2, result);}template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>OutputIteratorset_union(InputIterator1 first1, InputIterator1 last1,          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp){	for (; first1 != last1 && first2 != last2; ++result)	{		if (comp(*first2, *first1))		{			*result = *first2;			++first2;		}		else if (comp(*first1, *first2))		{			*result = *first1;			++first1;		}		else		{			*result = *first1;			++first1;			++first2;		}	}	if (first2 == last2)		return copy(first1, last1, result);	return copy(first2, last2, result);}template <class InputIterator1, class InputIterator2, class OutputIterator>OutputIteratorset_intersection(InputIterator1 first1, InputIterator1 last1,                 InputIterator2 first2, InputIterator2 last2, OutputIterator result){	while (first1 != last1 && first2 != last2)	{		if (*first2 < *first1)			++first2;		else if (*first1 < *first2)			++first1;		else		{			*result = *first1;			++result;			++first1;			++first2;		}	}	return result;}template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>OutputIteratorset_intersection(InputIterator1 first1, InputIterator1 last1,                 InputIterator2 first2, InputIterator2 last2, OutputIterator result,                 Compare comp){	while (first1 != last1 && first2 != last2)	{		if (comp(*first2, *first1))			++first2;		else if (comp(*first1, *first2))			++first1;		else		{			*result = *first1;			++result;			++first1;			++first2;		}	}	return result;}template <class InputIterator1, class InputIterator2, class OutputIterator>OutputIteratorset_difference(InputIterator1 first1, InputIterator1 last1,               InputIterator2 first2, InputIterator2 last2, OutputIterator result){	while (first1 != last1 && first2 != last2)	{		if (*first1 < *first2)		{			*result = *first1;			++result;			++first1;		}		else if (*first2 < *first1)			++first2;		else		{			++first1;			++first2;		}	}	return copy(first1, last1, result);}template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>OutputIteratorset_difference(InputIterator1 first1, InputIterator1 last1,               InputIterator2 first2, InputIterator2 last2, OutputIterator result,               Compare comp){	while (first1 != last1 && first2 != last2)	{		if (comp(*first1, *first2))		{			*result = *first1;			++result;			++first1;		}		else if (comp(*first2, *first1))			++first2;		else		{			++first1;			++first2;		}	}	return copy(first1, last1, result);}template <class InputIterator1, class InputIterator2, class OutputIterator>OutputIteratorset_symmetric_difference(InputIterator1 first1, InputIterator1 last1,                         InputIterator2 first2, InputIterator2 last2, OutputIterator result){	while (first1 != last1 && first2 != last2)	{		if (*first1 < *first2)		{			*result = *first1;			++result;			++first1;		}		else if (*first2 < *first1)		{			*result = *first2;			++result;			++first2;		}		else		{			++first1;			++first2;		}	}	if (first2 == last2)		return copy(first1, last1, result);	return copy(first2, last2, result);}template <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>OutputIteratorset_symmetric_difference(InputIterator1 first1, InputIterator1 last1,                         InputIterator2 first2, InputIterator2 last2,                         OutputIterator result, Compare comp){	while (first1 != last1 && first2 != last2)	{		if (comp(*first1, *first2))		{			*result = *first1;			++result;			++first1;		}		else if (comp(*first2, *first1))		{			*result = *first2;			++result;			++first2;		}		else		{			++first1;			++first2;		}	}	if (first2 == last2)		return copy(first1, last1, result);	return copy(first2, last2, result);}//  lib.alg.permutation.generators, permutationstemplate <class BidirectionalIterator>boolnext_permutation(BidirectionalIterator first, BidirectionalIterator last){	BidirectionalIterator i = last;	if (first == last || first == --i)		return false;	while (true)	{		BidirectionalIterator ip1 = i;		--i;		if (*i < *ip1)		{			BidirectionalIterator j = last;			--j;			while (!(*i < *j))				--j;			iter_swap(i, j);			reverse(ip1, last);			return true;		}		if (i == first)		{			reverse(first, last);			return false;		}	}}template <class BidirectionalIterator, class Compare>boolnext_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp){	BidirectionalIterator i = last;	if (first == last || first == --i)		return false;	while (true)	{		BidirectionalIterator ip1 = i;		--i;		if (comp(*i, *ip1))		{			BidirectionalIterator j = last;			--j;			while (!comp(*i, *j))				--j;			iter_swap(i, j);			reverse(ip1, last);			return true;		}		if (i == first)		{			reverse(first, last);			return false;		}	}}template <class BidirectionalIterator>boolprev_permutation(BidirectionalIterator first, BidirectionalIterator last){	BidirectionalIterator i = last;	if (first == last || first == --i)		return false;	while (true)	{		BidirectionalIterator ip1 = i;		--i;		if (*ip1 < *i)		{			BidirectionalIterator j = last;			--j;			while (!(*j < *i))				--j;			iter_swap(i, j);			reverse(ip1, last);			return true;		}		if (i == first)		{			reverse(first, last);			return false;		}	}}template <class BidirectionalIterator, class Compare>boolprev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp){	BidirectionalIterator i = last;	if (first == last || first == --i)		return false;	while (true)	{		BidirectionalIterator ip1 = i;		--i;		if (comp(*ip1, *i))		{			BidirectionalIterator j = last;			--j;			while (!comp(*j, *i))				--j;			iter_swap(i, j);			reverse(ip1, last);			return true;		}		if (i == first)		{			reverse(first, last);			return false;		}	}}#ifndef _MSL_NO_CPP_NAMESPACE	} // namespace std #endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#pragma enumsalwaysint reset#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#pragma bool reset#endif#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endif#pragma options align=reset#endif // RC_INVOKED#endif // _ALGORITHM// hh 971220 fixed MOD_INCLUDE// hh 971221  filename changed from algorithm.h// hh 971221  include guards given standard compliant name// hh 971221 added align and import pragmas// hh 971221 expanded namespace macro// hh 971221 added using namespace std::rel_ops;// hh 971230 added RC_INVOKED wrapper// hh 980520 Changed return on generate_n from OutputIterator to void// hh 980520 Simplified unique_copy (but kept same basic algorithm)// hh 980520 Rewrote reverse (used example from standard)// hh 980520  Did analysis of the 3 rotate algorithms (forward, bidirect, and random)//            The forward and rand access iterator versions have the same efficiency.//            The bidirectional version is more expensive.//            Simplifying the whole thing down to forward iterators.// hh 980902 #ifdef'd out exception code when ndef MSIPL_EXCEPT// hh 980911 unique_copy did not work for output iterators// hh 990106 Changed __sort3 to work with iterators instead of references to relax the//           requirement that *i returns a T&.// hh 990306 fixed bug in __partition when called with an empty range.// hh 990510 Rewrote.// hh 990817 Made several optimizations to iter_swap and sort routines to increase the//           efficiency of sorting heavy weight objects.  If this breaks your code//           because you are using proxies with your iterators, write a custom swap//           for your proxy.  See vector<bool> for an example.  Assistance provided by//           Darin Adler.// hh 990818 __insertion_sort was decrementing iterator beyond first.// hh 991102 Wrapped __insertion_sort in if (first != last) {...}// hh 991210 Protected min and max from macro abuse.// hh 000129 Recoded remove_if per Josuttis' recommendation.  Also modified the following//           algorithms with the same logic:  search, find_end, unique// hh 000207 Optimized copy and copy_backward