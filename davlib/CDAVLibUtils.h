/* ================================================================================================== * CDAVLibUtils.h														    *    Goliath - a Finder like application that implements WebDAV *    Copyright (C) 1999-2000  Thomas Bednarz * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com * =========================================================================== *//*!   @header DAVLib	This library implements HTTP 1.1 and the WebDAV (RFC 2518) extensions to HTTP.   This program is free software; you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation; either version 2 of the License, or   (at your option) any later version.    This program is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.*/#ifndef __CDAVLIBUTILS_H__#define __CDAVLIBUTILS_H__#include <string>#include <LDynamicBuffer.h>#include <LString.h>/*!  @defined DAVp2cstr  @discussion temporary macro for Carbon compliance.  p2cstr is not in the Carbon  Toolbox.  Luckily, the folks at Metrowerks have included a utility function in the  LString class to do the same thing.  Since CW Pro6 is not yet publicly available,  this macro will only use the LString version if a Carbon target is being built.  This allows for building a Classic version of DAVLib on earlier versions of   CodeWarrior.*/#if PP_Target_Carbon #define DAVp2cstr(a) LString::PToCStr(a)#else#define DAVp2cstr(a) p2cstr(a)#endif/*!   @class CXMLStringUtils   @discussion some handy XML document generation functions*/class CXMLStringUtils {   public:            /*!          @function beginXMLDAVBody         @discussion emits an XML PI into msgBody         @param msgBody      */      static void beginXMLDAVBody(std::string &msgBody);      /*!          @function startElement         @discussion emits a start element          @param str the output buffer         @param elem the generic identifier of the element      */      static void startElement(std::string &str, const char* elem);      /*!          @function startElementWithDAVNS         @discussion emits a start element          @param str the output buffer         @param elemname the generic identifier of the element      */      static void startElementWithDAVNS(std::string &str, const char* elemname);      /*!          @function endElement         @discussion emits the end of an element          @param str the output buffer         @param elemname the generic identifier of the element      */      static void startElementWithOtherNS(std::string &str, const char* elemname, const char* xmlnamespace);      static void endElement(std::string &str, const char* elem);      /*!          @function addEmptyElement         @discussion emits an empty element         @param str the output buffer         @param elemname the generic identifier of the element      */      static void addEmptyElement(std::string &str, const char* elemname) ;      /*!          @function beginXMLDAVBody         @discussion emits a start element          @param msgBody the output buffer      */      static void beginXMLDAVBody(LDynamicBuffer& msgBody);      /*!          @function startElement         @discussion emits a start element          @param elemname the generic identifier of the element         @param msgBody the output buffer      */      static void startElement(LDynamicBuffer& msgBody, const char* elemname);      /*!          @function startElementWithDAVNS         @discussion emits a start element          @param elemname the generic identifier of the element         @param msgBody the output buffer      */      static void startElementWithDAVNS(LDynamicBuffer& msgBody, const char* elemname);      /*!          @function endElement         @discussion emits the end of an element          @param elemname the generic identifier of the element         @param msgBody the output buffer      */      static void endElement(LDynamicBuffer& msgBody, const char* elemname);      static void startElementWithOtherNS(LDynamicBuffer &str, const char* elemname, const char* xmlnamespace);      /*!          @function addEmptyElement         @discussion emits an empty element         @param elemname the generic identifier of the element         @param msgBody the output buffer      */      static void addEmptyElement(LDynamicBuffer& msgBody, const char* elemname);            /*!          @function filterXMLContent         @discussion transforms any of the 5 reserved XM<L characters into entities         @param outData the output buffer         @param msgBody the input buffer      */      static void filterXMLContent(std::string& outData, std::string inData);};/*!   @class CHTTPStringUtils   @discussion some handy functions for encodings used in URIs (RFC1738)*/class CHTTPStringUtils {   public:      /*!          @function URLEncodeString         @discussion encodes a pascal string so it is safe to be used in a URL         @param inResource the string to encoded         @result a URL encoded LStr255 object      */     // static LStr255     URLEncodeString(LStr255& inResource);      /*!          @function URLEncodeString         @discussion encodes a C string so it is safe to be used in a URL         @param inResource the string to encoded         @result a URL encoded std::string object      */      static std::string URLEncodeString(const std::string& inResource);      /*!          @function URLDecodeString         @discussion decodes a URL encoded Pascal String         @param inResource the string to decoded         @result a URL decoded LStr255 object      */      static LStr255     URLDecodeString(LStr255& inResource);      /*!          @function URLDecodeString         @discussion decodes a URL encoded C String         @param inResource the string to decoded         @result a URL decoded std::string object      */      static std::string URLDecodeString(std::string& inResource);   };class CBase64StringUtils {	public:		static void Encode(const std::string& inData, std::string& outEncodedData);		static void Decode(const std::string& inEncodedData, std::string& outDecodedData);};/*!   @class CURLStringUtils   @discussion some handy functions for URL manipulation (RFC1738)*/class CURLStringUtils {   public:      /*!          @function GetURIParent         @discussion gets the parent of a resource specified         @param inOrigHREF the passed in URL         @param outParentHREF the parent of inOrigHREF         @result returns true if successful      */      static Boolean GetURIParent(LStr255 &inOrigHREF, LStr255 &outParentHREF);      /*!          @function GetURIParent         @discussion gets the parent of a resource specified         @param inOrigHREF the passed in URL         @param outParentHREF the parent of inOrigHREF         @result returns true if successful      */	  static Boolean GetURIParent(const PP_STD::string &inOrigHREF, PP_STD::string &outParentHREF);      /*!          @function GetURINodeName         @discussion gets the file name of a URL (kind of like the unix basename utility)         @param inOrigHREF the passed in URL         @param outParentHREF the filename of inOrigHREF         @result returns true if successful      */      static Boolean GetURINodeName(const std::string &inOrigHREF, std::string &outNodeHREF);   };const char* GetDAVLibMajorVersion();const char* GetDAVLibMinorVersion();void GetDAVLibVersionDisplayString(std::string &outString);#endif