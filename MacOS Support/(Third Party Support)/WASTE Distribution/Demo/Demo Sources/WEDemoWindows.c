/* *	WASTE Demo Project: *	Window Handling * *	Copyright © 1993-2002 Marco Piovanelli *	All Rights Reserved * *	Original C Port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __WEDEMO__#include "WEDemo.h"#endifenum{	kMinWindowHeight			=	80,	kMinWindowWidth				=	200} ;static Rect * CalcTextRectFromWindowBounds ( const Rect * inWindowBounds, Rect * outTextRect ){	SInt32		scrollBarWidth = 0 ;	GetThemeMetric ( kThemeMetricScrollBarWidth, & scrollBarWidth ) ;	outTextRect -> top = 0 ;	outTextRect -> left = 0 ;	outTextRect -> bottom = ( inWindowBounds -> bottom - inWindowBounds -> top ) - ( scrollBarWidth - 1 ) ;	outTextRect -> right = ( inWindowBounds -> right - inWindowBounds -> left ) - ( scrollBarWidth - 1 ) ;	InsetRect ( outTextRect, kTextMargin, kTextMargin ) ;	outTextRect -> left += kLeftClickMargin ;		/* for clicks in the left margin */	return outTextRect ;}static Rect * CalcTextRect ( WindowRef inWindow, Rect * outTextRect ){	Rect		windowBounds ;	return CalcTextRectFromWindowBounds ( GetWindowPortBounds ( inWindow, & windowBounds ), outTextRect ) ;}static Rect * CalcScrollBarRect ( WindowRef inWindow, int inOrientation, Rect * outScrollBarRect ){	SInt32		scrollBarWidth = 0 ;	Rect		windowBounds ;	GetWindowPortBounds ( inWindow, & windowBounds ) ;	GetThemeMetric ( kThemeMetricScrollBarWidth, & scrollBarWidth ) ;	switch ( inOrientation )	{		case kVertical :		{			outScrollBarRect -> top = -1 ;			outScrollBarRect -> left = windowBounds . right - ( scrollBarWidth - 1 ) ;			outScrollBarRect -> bottom = windowBounds . bottom - ( scrollBarWidth - 2 ) ;			outScrollBarRect -> right = windowBounds . right + 1 ;			break ;		}		case kHorizontal :		{			outScrollBarRect -> top = windowBounds . bottom - ( scrollBarWidth - 1 ) ;			outScrollBarRect -> left = -1 ;			outScrollBarRect -> bottom = windowBounds . bottom + 1 ;			outScrollBarRect -> right = windowBounds . right - ( scrollBarWidth - 2 ) ;			break ;		}	}	return outScrollBarRect ;}static void	ScrollBarChanged ( Document * inDocument ){	/* scroll text to reflect new scroll bar setting */	WEReference		text = inDocument -> text ;	LongRect		viewRect ;	LongRect		destRect ;	WEGetViewRect ( & viewRect, text ) ;	WEGetDestRect ( & destRect, text ) ;	WEScroll	(		viewRect . left - destRect . left - GetControl32BitValue ( inDocument -> scrollBars [ kHorizontal ] ) + kLeftClickMargin,		viewRect . top - destRect . top - GetControl32BitValue ( inDocument -> scrollBars [ kVertical ] ),		text	) ;}static void	AdjustBars ( Document * inDocument ){	WEReference		text = inDocument -> text ;	LongRect		viewRect ;	LongRect		destRect ;	SInt32			visible ;	SInt32			total ;	SInt32			value ;	SInt32			max ;	ControlRef		scrollBar ;	/* get the view and destination rectangle */	WEGetViewRect ( & viewRect, text ) ;	WEGetDestRect ( & destRect, text ) ;	/* do the vertical axis */	/* get scroll bar handle */	scrollBar = inDocument -> scrollBars [ kVertical ] ;	/* calculate new scroll bar settings */	/* NOTE:  (destRect.bottom - destRect.top) always equals the total text height because */	/* WASTE automatically updates destRect.bottom whenever line breaks are recalculated */	total = destRect . bottom - destRect . top ;	/* total pixel height */	visible = viewRect . bottom - viewRect . top ;	/* visible pixel height */	max = total - visible ;							/* scrollable range (in pixels) */	value = viewRect . top - destRect . top ;		/* thumb location within scrollable range */	/* make sure max is always non-negative */	if ( max <= 0 ) max = 0 ;	/* set visible size */	SetControlViewSize ( scrollBar, visible ) ;	/* reset the scroll bar */	SetControl32BitMaximum ( scrollBar, max ) ;	SetControl32BitValue ( scrollBar, value ) ;	/* if value exceeds max then the bottom of the destRect is above */	/* the bottom of the view rectangle:  we need to scroll the text downward */	if ( value > max )	{		ScrollBarChanged ( inDocument ) ;	}	/* now do the horizontal axis */	/* get scroll bar handle */	scrollBar = inDocument -> scrollBars [ kHorizontal ] ;	/* calculate new scroll bar settings */	total = destRect . right - destRect . left ;	/* total pixel width */	visible = viewRect . right - viewRect . left ;	/* visible pixel width */	max = total - visible ;							/* scrollable range (in pixels) */	value = viewRect . left - destRect . left ;		/* thumb location within scrollable range */	/* make sure max is always non-negative */	if ( max <= 0 ) max = 0 ;	/* set visible size */	SetControlViewSize ( scrollBar, visible ) ;	/* reset the scroll bar */	SetControl32BitMaximum ( scrollBar, max ) ;	SetControl32BitValue ( scrollBar, value ) ;}static OSStatus ViewChanged ( Document * inDocument ){	ControlRef		scrollBar ;	Rect			r ;	LongRect		viewRect ;	int				orientation ;	OSStatus		err ;	/* resize the text area */	WERectToLongRect ( CalcTextRect ( inDocument -> window, & r ), & viewRect ) ;	viewRect . left -= kLeftClickMargin ;	WESetViewRect ( & viewRect, inDocument -> text ) ;	/*  move and resize the control bars */	for ( orientation = kVertical; orientation <= kHorizontal; orientation ++ )	{		scrollBar = inDocument -> scrollBars [ orientation ] ;		HideControl ( scrollBar ) ;		SetControlBounds ( scrollBar, CalcScrollBarRect ( inDocument -> window, orientation, & r ) ) ;		ShowControl ( scrollBar ) ;		if ( ( err = ValidWindowRect ( inDocument -> window, & r ) ) != noErr )		{			goto cleanup ;		}	}	/* reset the thumb positions and the max values of the control bars */	AdjustBars ( inDocument ) ;	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}Document * GetWindowDocument ( WindowRef inWindow ){	/* make sure window is not NULL and is one of our windows */	if ( inWindow && ( GetWindowKind ( inWindow ) == userKind ) )	{		/* a pointer to the document structure is kept in the window refCon */		return ( Document * ) GetWRefCon ( inWindow ) ;	}	return NULL ;}WEReference GetWindowText ( WindowRef inWindow ){	Document *		document = GetWindowDocument ( inWindow ) ;	if ( document != NULL )	{		return document -> text ;	}	return NULL ;}static OSStatus WindowResized ( const Rect * inOldTextRect, Document * inDocument ){	WEReference		text = inDocument -> text ;	RgnHandle		tempRgn ;	RgnHandle		dirtyRgn ;	Rect			r ;	LongRect		lr ;	SInt16			oldTextWidth ;	SInt16			newTextWidth ;	SInt32			topCharOffset ;	LongPt			topCharPosition ;	Boolean			rewrapText = true ;		/* set to false to disable soft wrapping and enable horizontal scroll bar */	OSStatus		err ;	/* create temporary regions for calculations */	tempRgn = NewRgn ( ) ;	dirtyRgn = NewRgn ( ) ;	/* calculate original text width */	oldTextWidth = ( inOldTextRect -> right - inOldTextRect -> left ) ;	RectRgn ( tempRgn, inOldTextRect ) ;	/* get new text rect */	CalcTextRect ( inDocument -> window, & r ) ;	newTextWidth = ( r . right - r . left ) ;	RectRgn ( dirtyRgn, & r ) ;	/* width changed? */	if ( newTextWidth == oldTextWidth )	{		/* nope: no need to rewrap text */		rewrapText = false ;	}	if ( rewrapText )	{		/* remember offset of first visible character */		WEGetViewRect ( & lr, text ) ;		topCharPosition = * ( LongPt * ) & lr ;		topCharOffset = WEGetOffset ( & topCharPosition, NULL, text ) ;		/* reset destination rectangle and recalculate line breaks */		WEGetDestRect ( & lr, text ) ;		lr . right = lr . left + newTextWidth ;		WESetDestRect ( & lr, text ) ;		if ( ( err = WECalText ( text ) ) != noErr )		{			goto cleanup ;		}		/* scroll the destination rectangle to keep the previous */		/* first visible character at the top of the view rectangle */		WEGetPoint ( topCharOffset, kHilite, & topCharPosition, NULL, text ) ;		WEGetDestRect ( & lr, text ) ;		WEOffsetLongRect ( & lr, 0, kTextMargin - topCharPosition . v ) ;		WESetDestRect ( & lr, text ) ;	}	if ( ( err = ViewChanged ( inDocument ) ) != noErr )	{		goto cleanup ;	}	/* calculate the dirty region (to be updated) */	if ( rewrapText )	{		InsetRgn ( dirtyRgn, - kTextMargin, - kTextMargin ) ;	}	else	{		XorRgn ( dirtyRgn, tempRgn, dirtyRgn ) ;		InsetRect ( & r, - kTextMargin, - kTextMargin ) ;		RectRgn ( tempRgn, & r ) ;		SectRgn ( dirtyRgn, tempRgn, dirtyRgn ) ;	}	/* mark the dirty region as invalid */	if ( ( err = InvalWindowRgn ( inDocument -> window, dirtyRgn ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	/* throw away temporary regions */	DisposeRgn ( tempRgn ) ;	DisposeRgn ( dirtyRgn ) ;	/* return result code */	return err ;}/* this is a callback routine called by the Toolbox Control Manager */static pascal void DoScrollBarHit ( ControlRef inScrollBar, ControlPartCode inPartCode ){	Document *			document = GetWindowDocument ( GetControlOwner ( inScrollBar ) ) ;	if ( document == NULL )	{		return ;	}	if ( inPartCode == kControlIndicatorPart )	{		ScrollBarChanged ( document ) ;	}	else	{		LongRect		viewRect ;		SInt32			pageSize ;		SInt32			value = GetControl32BitValue ( inScrollBar ) ;		SInt32			max = GetControl32BitMaximum ( inScrollBar ) ;		SInt32			step = 0 ;		/* find out which scroll bar was hit (horizontal or vertical) and calculate the page size for it */		WEGetViewRect ( & viewRect, document -> text ) ;		if ( inScrollBar == document -> scrollBars [ kVertical ] )		{			pageSize = viewRect . bottom - viewRect . top ;		}		else if ( inScrollBar == document -> scrollBars [ kHorizontal ] )		{			pageSize = viewRect . right - viewRect . left ;		}		else		{			return ;		}		/* calculate the "scroll step" according to the part hit */		switch ( inPartCode )		{			case kControlUpButtonPart:			{				step = - kScrollDelta ;				break ;			}			case kControlDownButtonPart:			{				step = + kScrollDelta ;				break ;			}			case kControlPageUpPart:			{				step = - ( pageSize - kScrollDelta ) ;				break ;			}			case kControlPageDownPart:			{				step = + ( pageSize - kScrollDelta ) ;				break ;			}		}		/* move the scroll bar thumb by the precalculated step */		/* and scroll the text accordingly */		if ( ( ( value < max ) && ( step > 0 ) ) || ( ( value > 0 ) && ( step < 0 ) ) )		{			SetControl32BitValue ( inScrollBar, value + step ) ;			ScrollBarChanged ( document ) ;		}	}}/* *	TextScrolled * *	This is a callback routine called whenever the text is scrolled automatically. *	Since auto-scrolling is enabled, WEScroll may be invoked internally by WASTE *	in many different circumstances, and we want to be notified when this happens *	so we can adjust the scroll bars */static pascal void TextScrolled ( WEReference inText ){	Document *			document = NULL ;	/* get window reference associated with WE instance */	if ( WEGetUserInfo ( kDocumentTag, ( SInt32 * ) & document, inText ) != noErr )	{		return ;	}	/* make sure the scroll bars are in synch with the destination rectangle */	AdjustBars ( document ) ;}static OSStatus DoDrawContent ( Document * inDocument ){	RgnHandle			updateRgn = NULL ;	/* get the update region */	if ( ! EmptyRgn ( GetPortVisibleRegion ( GetWindowPort ( inDocument -> window ), updateRgn = NewRgn ( ) ) ) )	{		/* erase the update region */		EraseRgn ( updateRgn ) ;		/* draw scroll bars */		UpdateControls ( inDocument -> window, updateRgn ) ;		/* draw text */		WEUpdate ( updateRgn, inDocument -> text ) ;	}	DisposeRgn ( updateRgn ) ;	return noErr ;}static OSStatus DoActivate ( Document * inDocument ){	const EventTypeSpec			menuEventTypes [ ] =	{		{ kEventClassMenu,		kEventMenuEnableItems }	} ;	MenuID						menuID ;	MenuRef						menu ;	OSStatus					err ;	/* activate the text */	WEActivate ( inDocument -> text ) ;	/* activate controls */	if ( ( err = ActivateControl ( inDocument -> rootControl ) ) != noErr )	{		goto cleanup ;	}	/* enable text-related menus and install menu handlers */	for ( menuID = kMenuFont ; menuID <= kMenuAlignment ; menuID ++ )	{		if ( ( menu = GetMenuHandle ( menuID ) ) != NULL )		{			EnableMenuItem ( menu, 0 ) ;			if ( ( err = InstallMenuEventHandler ( menu, inDocument -> menuEventHandler, GetEventTypeCount ( menuEventTypes ),				menuEventTypes, inDocument, & inDocument -> menuEventHandlerRef [ menuID - kMenuFont ] ) ) != noErr )			{				goto cleanup ;			}		}	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}static OSStatus DoDeactivate ( Document * inDocument ){	MenuID						menuID ;	OSStatus					err ;	/* deactivate the text */	WEDeactivate ( inDocument -> text ) ;	/* deactivate controls */	if ( ( err = DeactivateControl ( inDocument -> rootControl ) ) != noErr )	{		goto cleanup ;	}	/* remove menu handlers */	for ( menuID = kMenuFont ; menuID <= kMenuAlignment ; menuID ++ )	{		if ( inDocument -> menuEventHandlerRef [ menuID - kMenuFont ] != NULL )		{			if ( ( err = RemoveEventHandler ( inDocument -> menuEventHandlerRef [ menuID - kMenuFont ] ) ) != noErr )			{				goto cleanup ;			}			inDocument -> menuEventHandlerRef [ menuID - kMenuFont ] = NULL ;		}	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}static OSStatus DoGetClickActivation ( EventRef inEvent, Document * inDocument ){	CGrafPtr					savePort = NULL ;	Point						globalMouse ;	Point						localMouse ;	RgnHandle					selectionRegion = NULL ;	Boolean						portWasChanged ;	OSStatus					err ;	/* set up the port */	portWasChanged = QDSwapPort ( GetWindowPort ( inDocument -> window ), & savePort ) ;	/* get mouse location */	if ( ( err = GetEventParameter ( inEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof ( globalMouse ), NULL, & globalMouse ) ) != noErr )	{		goto cleanup ;	}	/* convert to local coordinates */	localMouse = globalMouse ;	GlobalToLocal ( & localMouse ) ;	/* determine whether the click went into a background selection and a drag gesture is being initiated */	if ( inDocument -> text != NULL )	{		selectionRegion = WEGetHiliteRgn ( kCurrentSelection, kCurrentSelection, inDocument -> text ) ;		if ( PtInRgn ( localMouse, selectionRegion ) && WaitMouseMoved ( globalMouse ) )		{			const ClickActivationResult clickActivation = kDoNotActivateAndHandleClick ;			/* set click activation result */			if ( ( err = SetEventParameter ( inEvent, kEventParamClickActivation, typeClickActivationResult,				sizeof ( clickActivation ), & clickActivation ) ) != noErr )			{				goto cleanup ;			}			/* we handled the event */			err = noErr ;			goto cleanup ;		}	}	/* let the default handler handle this event */	err = eventNotHandledErr ;cleanup :	/* restore the port */	if ( portWasChanged )	{		QDSwapPort ( savePort, NULL ) ;	}	/* get rid of temporary regions */	if ( selectionRegion )	{		DisposeRgn ( selectionRegion ) ;		selectionRegion = NULL ;	}	/* return result code */	return err ;}static OSStatus DoBoundsChanged ( EventRef inEvent, Document * inDocument ){	WindowRef			window = inDocument -> window ;	WindowAttributes	windowAttributes = 0 ;	UInt32				eventAttributes = 0 ;	Rect				oldBounds ;	Rect				oldTextRect ;	OSStatus			err ;	/* get event attributes */	if ( ( err = GetEventParameter ( inEvent, kEventParamAttributes, typeUInt32, NULL, sizeof ( eventAttributes ), NULL, & eventAttributes ) ) != noErr )	{		goto cleanup ;	}	/* has the window size changed? */	if ( eventAttributes & kWindowBoundsChangeSizeChanged )	{		/* get original window bounds */		if ( ( err = GetEventParameter ( inEvent, kEventParamOriginalBounds, typeQDRectangle, NULL, sizeof ( oldBounds ), NULL, & oldBounds ) ) != noErr )		{			goto cleanup ;		}		/* calculate original text rect and resize content area */		if ( ( err = WindowResized ( CalcTextRectFromWindowBounds ( & oldBounds, & oldTextRect ), inDocument ) ) != noErr )		{			goto cleanup ;		}		/* get window attributes */		if ( ( err = GetWindowAttributes ( window, & windowAttributes ) ) != noErr )		{			goto cleanup ;		}		/* if live resizing is enabled for this window, force an immediate redraw of its contents */		if ( windowAttributes & kWindowLiveResizeAttribute )		{			CGrafPtr	savePort = NULL ;			Boolean		portWasChanged = QDSwapPort ( GetWindowPort ( window ), & savePort ) ;			BeginUpdate ( window ) ;			err = DoDrawContent ( inDocument ) ;			EndUpdate ( window ) ;			if ( portWasChanged )			{				QDSwapPort ( savePort, NULL ) ;			}			if ( err != noErr )			{				goto cleanup ;			}		}	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}static OSStatus DoCursorChange ( EventRef inEvent, Document * inDocument ){	Point				mouseLocation ;	OSStatus			err ;	/* get mouse location */	if ( ( err = GetEventParameter ( inEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof ( mouseLocation ), NULL, & mouseLocation ) ) != noErr )	{		goto cleanup ;	}	/* give WASTE a chance to adjust the cursor */	if ( ! ( WEIsActive ( inDocument -> text ) && WEAdjustCursor ( mouseLocation, NULL, inDocument -> text ) ) )	{		/* WASTE didn't set the cursor: default to arrow */		if ( ( err = SetThemeCursor ( kThemeArrowCursor ) ) != noErr )		{			goto cleanup ;		}	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}static OSStatus DoZoom ( Document * inDocument ){	WEReference			text = inDocument -> text ;	Rect				portBounds ;	Rect				oldTextRect ;	LongRect			destRect ;	SInt32				scrollBarWidth = 0 ;	SInt32				idealHeight ;	Point				idealSize ;	WindowPartCode		windowPart ;	OSStatus			err ;	/* determine the ideal size for this window */	/* the ideal height is the number of pixels needed to see the whole text */	WEGetDestRect ( & destRect, text ) ;	GetThemeMetric ( kThemeMetricScrollBarWidth, & scrollBarWidth ) ;	idealHeight = ( destRect . bottom - destRect . top ) + ( 2 * kTextMargin + ( scrollBarWidth - 1 ) ) ;	/* the ideal height should always be at least kMinWindowHeight */	if ( idealHeight < kMinWindowHeight )	{		idealHeight = kMinWindowHeight ;	}	else if ( idealHeight > 0x7FFF )	{		/* and must fit in a SInt16 */		idealHeight = 0x7FFF ;	}	idealSize . v = idealHeight ;	/* since the text is automatically soft-wrapped to the window width, */	/* there's no "ideal" window width */	idealSize . h = GetWindowPortBounds ( inDocument -> window, & portBounds ) -> right ;	/* determine whether the window is currently in "standard" state or in "user" state */	windowPart = IsWindowInStandardState ( inDocument -> window, & idealSize, NULL ) ? inZoomIn : inZoomOut ;	/* remember original text rectangle */	CalcTextRect ( inDocument -> window, & oldTextRect ) ;	/* zoom the window */	if ( ( err = ZoomWindowIdeal ( inDocument -> window, windowPart, & idealSize ) ) != noErr )	{		goto cleanup ;	}	/* resize the text area */	if ( ( err = WindowResized ( & oldTextRect, inDocument ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}static OSStatus DoGetMinimumSize ( EventRef inEvent, Document * inDocument ){#pragma unused ( inDocument )	const Point			kMinimumSize = { kMinWindowHeight, kMinWindowWidth } ;	OSStatus			err ;	/* set minimum size */	if ( ( err = SetEventParameter ( inEvent, kEventParamDimensions, typeQDPoint, sizeof ( kMinimumSize ), & kMinimumSize ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}static Boolean IsOffsetInRange ( SInt32 inOffset, WEEdge inEdge, SInt32 inRangeStart, SInt32 inRangeEnd ){	/*	return true if text position indicated by offset and edge is within the specified range */	if ( inEdge == kTrailingEdge )	{		inOffset -- ;	}	return ( ( inOffset >= inRangeStart ) && ( inOffset < inRangeEnd ) ) ;}static OSStatus PopulateContextualMenu ( MenuRef inMenu, WEReference inText ){	OSStatus			err ;	if ( ( err = AppendMenuItemTextWithCFString ( inMenu, CFSTR ( "Cut" ), 0, kHICommandCut, NULL ) ) != noErr )	{		return err ;	}	if ( ( err = AppendMenuItemTextWithCFString ( inMenu, CFSTR ( "Copy" ), 0, kHICommandCut, NULL ) ) != noErr )	{		return err ;	}	if ( WECanPaste ( inText ) )	{		if ( ( err = AppendMenuItemTextWithCFString ( inMenu, CFSTR ( "Paste" ), 0, kHICommandPaste, NULL ) ) != noErr )		{			return err ;		}	}	return noErr ;}static OSStatus DoContextualMenu ( EventRef inEvent, Document * inDocument ){	WEReference			text = inDocument -> text ;	CGrafPtr			savePort = NULL ;	Point				mouseLocation ;	Point				localMouse ;	SInt32				selStart = 0 ;	SInt32				selEnd = 0 ;	RgnHandle			selRgn = NULL ;	LongPt				longPoint ;	SInt32				offset ;	WEEdge				edge = 0 ;	UInt32				helpType = kCMHelpItemNoHelp ;	Handle				textHandle = NULL ;	AEDesc				selectionDesc ;	MenuRef				contextualMenu = NULL ;	UInt32				userSelectionType = 0 ;	MenuID				menuID = 0 ;	MenuItemIndex		menuItem = 0 ;	SInt32				systemVersion = 0 ;	Boolean				portWasChanged ;	OSStatus			err ;	AEInitializeDescInline ( & selectionDesc ) ;	/* the kCMHelpItemRemoveHelp help type is only available on X */	if ( ( Gestalt ( gestaltSystemVersion, & systemVersion ) == noErr ) && ( systemVersion > 0x1000 ) )	{		helpType = 3 /*kCMHelpItemRemoveHelp*/ ;	}	/* set up the port */	portWasChanged = QDSwapPort ( GetWindowPort ( inDocument -> window ), & savePort ) ;	/* get mouse location */	if ( ( err = GetEventParameter ( inEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof ( mouseLocation ), NULL, & mouseLocation ) ) != noErr )	{		goto cleanup ;	}	/* convert the mouse location to local coordinates */	localMouse = mouseLocation ;	GlobalToLocal ( & localMouse ) ;	/* convert mouse location to an offset/edge pair */	WEPointToLongPoint ( localMouse, & longPoint ) ;	offset = WEGetOffset ( & longPoint, & edge, text ) ;	/* get selection range */	WEGetSelection ( & selStart, & selEnd, text ) ;	/* if the selection is empty or if the click is outside the selected range, */	/* select the word under the mouse */	if ( ( selStart == selEnd ) || ! IsOffsetInRange ( offset, edge, selStart, selEnd ) )	{		WEFindWord ( offset, edge, & selStart, & selEnd, text ) ;		WESetSelection ( selStart, selEnd, text ) ;	}	/* get selection region */	selRgn = WEGetHiliteRgn ( selStart, selEnd, text ) ;	/* click in the selection range? */	if ( PtInRgn ( localMouse, selRgn ) )	{		/* make a copy of the selected text */		if ( ( err = WEStreamRange ( selStart, selEnd, typeUnicodeText, kNilOptions,			textHandle = NewHandle ( 0 ), text ) ) != noErr )		{			goto cleanup ;		}		/* create an Apple event descriptor for the selected text */		if ( ( err = AECreateDesc ( typeUnicodeText, * textHandle,			GetHandleSize ( textHandle ), & selectionDesc ) ) != noErr )		{			goto cleanup ;		}		/* create the contextual menu */		if ( ( err = CreateNewMenu ( kMenuContextual, 0, & contextualMenu ) ) != noErr )		{			goto cleanup ;		}		/* populate it */		if ( ( err = PopulateContextualMenu ( contextualMenu, text ) ) != noErr )		{			goto cleanup ;		}		/* display contextual menu */		err = ContextualMenuSelect ( contextualMenu, mouseLocation, false, helpType, NULL,			& selectionDesc, & userSelectionType, & menuID, & menuItem ) ;	}cleanup :	/* get rid of selection region */	if ( selRgn )	{		DisposeRgn ( selRgn ) ;	}	/* dispose of selection text and descriptor, if any */	ForgetHandle ( & textHandle ) ;	AEDisposeDesc ( & selectionDesc ) ;	/* release the menu */	if ( contextualMenu )	{		ReleaseMenu ( contextualMenu ) ;		contextualMenu = NULL ;	}	/* restore the port */	if ( portWasChanged )	{		QDSwapPort ( savePort, NULL ) ;	}	/* return result code */	return err ;}static OSStatus DoHandleContentClick ( EventRef inEvent, Document * inDocument ){	CGrafPtr			savePort = NULL ;	Point				mouseLocation ;	UInt32				modifiers = 0 ;	Boolean				portWasChanged ;	OSStatus			err ;	/* set up the port */	portWasChanged = QDSwapPort ( GetWindowPort ( inDocument -> window ), & savePort ) ;	/* get mouse location */	if ( ( err = GetEventParameter ( inEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof ( mouseLocation ), NULL, & mouseLocation ) ) != noErr )	{		goto cleanup ;	}	/* convert it to local coordinates */	GlobalToLocal ( & mouseLocation ) ;	/* get key modifiers */	if ( ( err = GetEventParameter ( inEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof ( modifiers ), NULL, & modifiers ) ) != noErr )	{		goto cleanup ;	}	/* let WASTE handle the click */	WEClick ( mouseLocation, modifiers, EventTimeToTicks ( GetEventTime ( inEvent ) ), inDocument -> text ) ;	/* clear result code */	err = noErr ;cleanup :	/* restore the port */	if ( portWasChanged )	{		QDSwapPort ( savePort, NULL ) ;	}	/* return result code */	return err ;}static pascal OSStatus HandleWindowEvent ( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData ){#pragma unused ( inHandlerCallRef )	Document *			document = ( Document * ) inUserData ;	OSStatus			err ;	switch ( GetEventKind ( inEvent ) )	{		case kEventWindowDrawContent :		{			err = DoDrawContent ( document ) ;			break ;		}		case kEventWindowClose :		{			err = DoClose ( kNavSaveChangesClosingDocument, savingAsk, document ) ;			break ;		}		case kEventWindowActivated :		{			err = DoActivate ( document ) ;			break ;		}		case kEventWindowDeactivated :		{			err = DoDeactivate ( document ) ;			break ;		}		case kEventWindowGetClickActivation :		{			err = DoGetClickActivation ( inEvent, document ) ;			break ;		}		case kEventWindowBoundsChanged :		{			err = DoBoundsChanged ( inEvent, document ) ;			break ;		}		case kEventWindowCursorChange :		{			err = DoCursorChange ( inEvent, document ) ;			break ;		}		case kEventWindowZoom :		{			err = DoZoom ( document ) ;			break ;		}		case kEventWindowGetMinimumSize :		{			err = DoGetMinimumSize ( inEvent, document ) ;			break ;		}		case kEventWindowContextualMenuSelect :		{			err = DoContextualMenu ( inEvent, document ) ;			break ;		}		case kEventWindowHandleContentClick :		{			err = DoHandleContentClick ( inEvent, document ) ;			break ;		}		default :		{			err = eventNotHandledErr ;			break ;		}	}	/* return result code */	return err ;}static OSStatus PrepareAttributeMenu	(		MenuRef				inMenu,						/* menu listing the attribute values to match against the selection */		WESelector			inAttributeSelector,		/* attribute to match (e.g., font family or alignment) */		ByteCount			inAttributeValueSize,		/* size of attribute values */		WEReference			inText	){	ItemCount			itemCount ;	ItemCount			itemIndex ;	char *				values = NULL ;	Boolean *			isPresent = NULL ;	Boolean				isContinuous = false ;	char				markChar ;	OSStatus			err ;	/* count menu items */	itemCount = CountMenuItems ( inMenu ) ;	/* allocate a buffer for holding attribute values */	err = memFullErr ;	if ( ( values = ( char * ) malloc ( itemCount * inAttributeValueSize ) ) == NULL )	{		goto cleanup ;	}	/* allocate a temporary buffer for the Boolean values */	if ( ( isPresent = ( Boolean * ) malloc ( itemCount ) ) == NULL )	{		goto cleanup ;	}	/* fill in the array of attribute values to match */	for ( itemIndex = 0 ; itemIndex < itemCount ; itemIndex ++ )	{		if ( ( err = GetMenuItemProperty ( inMenu, itemIndex + 1, kWASTECreator, inAttributeSelector,			inAttributeValueSize, NULL, values + itemIndex * inAttributeValueSize ) ) != noErr )		{			goto cleanup ;		}	}	/* determine which attribute values are present over the selection range */	if ( ( err = WEMatchAttributes ( kCurrentSelection, kCurrentSelection, inAttributeSelector,		inAttributeValueSize, itemCount, values, isPresent, & isContinuous, inText ) ) != noErr )	{		goto cleanup ;	}	/* mark menu items corresponding to attribute values used in the selection range */	/* if there is only one value used throughout the selection range, check it */	/* if more than one value is used in the selection range, mark them with dashes */	markChar = isContinuous ? checkMark : '-' ;	for ( itemIndex = 0 ; itemIndex < itemCount ; itemIndex ++ )	{		SetItemMark ( inMenu, itemIndex + 1, isPresent [ itemIndex ] ? markChar : 0 ) ;	}	/* clear result code */	err = noErr ;cleanup :	free ( values ) ;	free ( isPresent ) ;	/* return result code */	return err ;}static OSStatus PrepareStyleMenu ( MenuRef inStyleMenu, WEReference inText ){	ItemCount			itemCount ;	ItemCount			itemIndex ;	WESelector			attribute ;	Boolean				isPresent ;	Boolean				isContinuous ;	const Boolean		trueValue [ 1 ] = { true } ;	OSStatus			err ;	/* count menu items */	itemCount = CountMenuItems ( inStyleMenu ) ;	for ( itemIndex = 1 ; itemIndex <= itemCount ; itemIndex ++ )	{		/* get command ID (which has the same four-letter code as the corresponding style attribute) */		if ( ( err = GetMenuItemCommandID ( inStyleMenu, itemIndex, & attribute ) ) != noErr )		{			goto cleanup ;		}		if ( ! attribute )		{			continue ;		}		/* see whether the corresponding style is present and/or continuous over the current selection range */		if ( ( err = WEMatchAttributes ( kCurrentSelection, kCurrentSelection, attribute, sizeof ( Boolean ),			1, trueValue, & isPresent, & isContinuous, inText ) ) != noErr )		{			goto cleanup ;		}		SetItemMark ( inStyleMenu, itemIndex, isPresent ? ( isContinuous ? checkMark : '-' ) : 0 ) ;	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}static OSStatus DoEnableMenuItems ( MenuRef inMenu, Document * inDocument ){	WEReference		text = inDocument -> text ;	OSStatus		err = noErr ;	switch ( GetMenuID ( inMenu ) )	{		case kMenuFont :		{			err = PrepareAttributeMenu ( inMenu, weTagFontFamily, sizeof ( FMFontFamily ), text ) ;			break ;		}		case kMenuSize :		{			err = PrepareAttributeMenu ( inMenu, weTagFontSize, sizeof ( Fixed ), text ) ;			break ;		}		case kMenuStyle :		{			err = PrepareStyleMenu ( inMenu, text ) ;			break ;		}		case kMenuTextColor :		{			err = PrepareAttributeMenu ( inMenu, weTagTextColor, sizeof ( RGBColor ), text ) ;			break ;		}		case kMenuAlignment :		{			err = PrepareAttributeMenu ( inMenu, weTagAlignment, sizeof ( WESelector ), text ) ;			break ;		}		default :		{			err = eventNotHandledErr ;			break ;		}	}	/* return result code */	return err ;}static pascal OSStatus HandleMenuEvent ( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData ){#pragma unused ( inHandlerCallRef )	Document *		document = ( Document * ) inUserData ;	MenuRef			menu = NULL ;	OSStatus		err ;	/* extract menu from event */	if ( ( err = GetEventParameter ( inEvent, kEventParamDirectObject, typeMenuRef, NULL, sizeof ( menu ), NULL, & menu ) ) != noErr )	{		goto cleanup ;	}	switch ( GetEventKind ( inEvent ) )	{		case kEventMenuEnableItems :		{			err = DoEnableMenuItems ( menu, document ) ;			break ;		}		default :		{			err = eventNotHandledErr ;			break ;		}	}cleanup :	/* return result code */	return err ;}static OSStatus ProcessWindowHICommand ( const HICommand * inHICommand, Document * inDocument ){	OSStatus		err ;	switch ( inHICommand -> commandID )	{		case kHICommandClose :		{			err = DoClose ( kNavSaveChangesClosingDocument, savingAsk, inDocument ) ;			inDocument = NULL ;			break ;		}		case kHICommandSave :		{			err = DoSave ( inDocument, false ) ;			break ;		}		case kHICommandSaveAs :		{			err = DoSaveAs ( inDocument, false ) ;			break ;		}		case kHICommandPageSetup :		{			err = DoPageSetup ( inDocument ) ;			break ;		}		case kHICommandPrint :		{			err = DoPrint ( inDocument ) ;			break ;		}				default :		{			/* give WASTE a chance to handle this command */			err = WEProcessHICommand ( inHICommand, inDocument -> text ) ;			break ;		}	}	if ( inDocument )	{		UpdateModifiedFlag ( inDocument ) ;	}	return err ;}static void GetUndoString ( WEActionKind inActionKind, Boolean isRedo, Str255 outUndoString ){	if ( ( inActionKind < weAKNone ) || ( inActionKind > weAKObjectChange ) )	{		/* unknown action kind: map to unspecified */		inActionKind = weAKUnspecified ;	}	GetIndString ( outUndoString, kUndoStringsID, inActionKind * 2 + isRedo + 1 ) ;}static OSStatus UpdateWindowHICommandStatus ( const HICommand * inHICommand, Document * inDocument ){	WEReference			text = inDocument -> text ;	SInt32				selStart ;	SInt32				selEnd ;	WEActionKind		actionKind = weAKNone ;	Boolean				enabled = false ;	Str255				itemText ;	OSStatus			err = noErr ;	itemText [ 0 ] = 0 ;	switch ( inHICommand -> commandID )	{		case kHICommandClose :		case kHICommandSaveAs :		case kHICommandPageSetup :		case kHICommandPrint :		{			enabled = true ;			break ;		}		case kHICommandSave :		{			enabled = ( WEGetModCount ( text ) != inDocument -> cleanModCount ) ;			break ;		}		case kHICommandUndo :		{			actionKind = WEGetIndUndoInfo ( 1, text ) ;			enabled = ( actionKind > weAKNone ) ;			GetUndoString ( actionKind, false, itemText ) ;			break ;		}		case kHICommandRedo :		{			actionKind = WEGetIndUndoInfo ( -1, text ) ;			enabled = ( actionKind > weAKNone ) ;			GetUndoString ( actionKind, true, itemText ) ;			break ;		}		case kHICommandCut :		case kHICommandClear :		{			WEGetSelection ( & selStart, & selEnd, text ) ;			enabled = ( ( WEFeatureFlag ( weFReadOnly, weBitTest, text ) == weBitClear ) && ( selStart < selEnd ) ) ;			break ;		}		case kHICommandCopy :		{			WEGetSelection ( & selStart, & selEnd, text ) ;			enabled = ( selStart < selEnd ) ;			break ;		}		case kHICommandPaste :		{			enabled = WECanPaste ( text ) ;			break ;		}		case kHICommandSelectAll :		{			enabled = ( WEGetTextLength ( text ) > 0 ) ;			break ;		}		default :		{			err = eventNotHandledErr ;			break ;		}	}	if ( ( err == noErr ) && ( inHICommand -> attributes & kHICommandFromMenu ) && ( inHICommand -> menu . menuRef != NULL ) )	{		if ( enabled )		{			EnableMenuItem ( inHICommand -> menu . menuRef, inHICommand -> menu . menuItemIndex ) ;		}		else		{			DisableMenuItem ( inHICommand -> menu . menuRef, inHICommand -> menu . menuItemIndex ) ;		}		if ( StrLength ( itemText ) > 0 )		{			SetMenuItemText ( inHICommand -> menu . menuRef, inHICommand -> menu . menuItemIndex, itemText ) ;		}	}	return err ;}static pascal OSStatus HandleWindowCommand ( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData ){#pragma unused ( inHandlerCallRef )	Document *			document = ( Document * ) inUserData ;	HICommand			hiCommand ;	OSStatus			err ;	/* get HI command from event */	if ( ( err = GetEventParameter ( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof ( hiCommand ), NULL, & hiCommand ) ) != noErr )	{		return err ;	}	/* assume we won't handle this event */	err = eventNotHandledErr ;	if ( hiCommand . commandID == 0 )	{		return err ;	}	switch ( GetEventKind ( inEvent ) )	{		case kEventCommandProcess :		{			err = ProcessWindowHICommand ( & hiCommand, document ) ;			break ;		}		case kEventCommandUpdateStatus :		{			err = UpdateWindowHICommandStatus ( & hiCommand, document ) ;			break ;		}	}	/* return result code */	return err ;}static pascal OSStatus HandleTextEvent ( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData ){#pragma unused ( inHandlerCallRef )	Document *			document = ( Document * ) inUserData ;	EventRef			keyEvent = NULL ;	UInt32				modifiers = 0 ;	UInt8				key = 0 ;	OSStatus			err ;	/* extract the original keyboard event that originated this text input event */	if ( ( err = GetEventParameter ( inEvent, kEventParamTextInputSendKeyboardEvent, typeEventRef, NULL, sizeof ( keyEvent ), NULL, & keyEvent ) ) != noErr )	{		return err ;	}	/* extract character code */	if ( ( err = GetEventParameter ( keyEvent, kEventParamKeyMacCharCodes, typeChar, NULL, sizeof ( key ), NULL, & key ) ) != noErr )	{		return err ;	}	/* extract modifiers */	if ( ( err = GetEventParameter ( keyEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof ( modifiers ), NULL, & modifiers ) ) != noErr )	{		return err ;	}	/* filter out command-key combinations (except for arrow keys, backspace & delete) */	if ( ( modifiers & cmdKey ) && ( key >= kSpaceCharCode ) && ( key != kDeleteCharCode ) )	{		return eventNotHandledErr ;	}	/* map shift-backspace to forward-delete for keyboards that don't have this key */	if ( ( key == kBackspaceCharCode ) && ( modifiers & shiftKey ) )	{		key = kDeleteCharCode ;		modifiers &= ~shiftKey ;	}	/* let WASTE handle the key */	WEKey ( key, modifiers, document -> text ) ;	/* update modified status */	UpdateModifiedFlag ( document ) ;	return noErr ;}static pascal OSStatus HandleMouseWheel ( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData ){#pragma unused ( inHandlerCallRef )	Document *				document = ( Document * ) inUserData ;	EventMouseWheelAxis		wheelAxis = 0 ;	SInt32					wheelDelta = 0 ;	ControlRef				scrollbar ;	ControlPartCode			partCode ;	OSStatus				err ;	/* extract mouse wheel axis */	if ( ( err = GetEventParameter ( inEvent, kEventParamMouseWheelAxis, typeMouseWheelAxis, NULL, sizeof ( wheelAxis ), NULL, & wheelAxis ) ) != noErr )	{		return err ;	}	/* extract mouse wheel delta */	if ( ( err = GetEventParameter ( inEvent, kEventParamMouseWheelDelta, typeLongInteger, NULL, sizeof ( wheelDelta ), NULL, & wheelDelta ) ) != noErr )	{		return err ;	}	/* which scrollbar should we update? */	scrollbar = document -> scrollBars [ ( wheelAxis == kEventMouseWheelAxisX ) ? kHorizontal : kVertical ] ;	/* should it go up or down? */	partCode = ( wheelDelta > 0 ) ? kControlUpButtonPart : kControlDownButtonPart ;	DoScrollBarHit ( scrollbar, partCode ) ;	return noErr ;}static OSStatus ScrapFlavorsToTypeStringArray ( const ScrapFlavorType * inScrapFlavors, CFMutableArrayRef ioTypeStringArray ){	CFStringRef				typeString ;	for ( ; * inScrapFlavors ; inScrapFlavors ++ )	{		if ( ( typeString = CreateTypeStringWithOSType ( * inScrapFlavors ) ) == NULL )		{			return coreFoundationUnknownErr ;		}		CFArrayAppendValue ( ioTypeStringArray, typeString ) ;		CFRelease ( typeString ) ;	}	return noErr ;}static pascal OSStatus HandleServices ( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData ){#pragma unused ( inHandlerCallRef )	static const ScrapFlavorType	kCopyFlavors [ ] =	{		kTypeUnicodeText,		kTypeRTF,		0					/* end of list */	} ;	static const ScrapFlavorType	kPasteFlavors [ ] =	{		kTypeUnicodeText,		kTypeRTF,		kScrapFlavorTypePicture,		kScrapFlavorTypeSound,		0					/* end of list */	} ;	Document *				document = ( Document * ) inUserData ;	ScrapRef				scrap = NULL ;	CFMutableArrayRef		copyTypes = NULL ;	CFMutableArrayRef		pasteTypes = NULL ;	SInt32					selStart = 0 ;	SInt32					selEnd = 0 ;	WEObjectReference		objectRef = NULL ;	ScrapFlavorType			objectFlavors [ 2 ] ;	OSStatus				err ;	switch ( GetEventKind ( inEvent ) )	{		case kEventServiceCopy :		{			if ( ( err = GetEventParameter ( inEvent, kEventParamScrapRef, typeScrapRef, NULL, sizeof ( scrap ), NULL, & scrap ) ) != noErr )			{				return err ;			}			if ( ( err = WECopyToScrap ( scrap, kCopyFlavors, weCopyPromiseFlavors, document -> text ) ) != noErr )			{				return err ;			}			break ;		}		case kEventServicePaste :		{			if ( ( err = GetEventParameter ( inEvent, kEventParamScrapRef, typeScrapRef, NULL, sizeof ( scrap ), NULL, & scrap ) ) != noErr )			{				return err ;			}			if ( ( err = WEPasteFromScrap ( scrap, kNilOptions, document -> text ) ) != noErr )			{				return err ;			}			break ;		}		case kEventServiceGetTypes :		{			WEGetSelection ( & selStart, & selEnd, document -> text ) ;			/* non-empty selection? */			if ( selStart < selEnd )			{				/* enumerate copy types */				if ( ( err = GetEventParameter ( inEvent, kEventParamServiceCopyTypes, typeCFMutableArrayRef, NULL, sizeof ( copyTypes ), NULL, & copyTypes ) ) != noErr )				{					return err ;				}				/* is there a selected object? */				if ( WEGetSelectedObject ( & objectRef, document -> text ) == noErr )				{					objectFlavors [ 0 ] = WEGetObjectType ( objectRef ) ;					objectFlavors [ 1 ] = 0 ;					if ( ( err = ScrapFlavorsToTypeStringArray ( objectFlavors, copyTypes ) ) != noErr )					{						return err ;					}				}				else if ( ( err = ScrapFlavorsToTypeStringArray ( kCopyFlavors, copyTypes ) ) != noErr )				{					return err ;				}			}			/* enumerate paste types */			if ( ( err = GetEventParameter ( inEvent, kEventParamServicePasteTypes, typeCFMutableArrayRef, NULL, sizeof ( pasteTypes ), NULL, & pasteTypes ) ) != noErr )			{				return err ;			}			if ( ( err = ScrapFlavorsToTypeStringArray ( kPasteFlavors, pasteTypes ) ) != noErr )			{				return err ;			}			break ;		}	}	return noErr ;}static pascal OSErr DoTrackDrag ( DragTrackingMessage inMessage, WindowRef inWindow, void * inRefCon, DragRef inDrag ){#pragma unused ( inWindow )	Document *		document = ( Document * ) inRefCon ;	return WETrackDrag ( inMessage, inDrag, document -> text ) ;}static pascal OSErr DoReceiveDrag ( WindowRef inWindow, void * inRefCon, DragRef inDrag ){#pragma unused ( inWindow )	Document *		document = ( Document * ) inRefCon ;	return WEReceiveDrag ( inDrag, document -> text ) ;}void UpdateModifiedFlag ( Document * inDocument ){	/* update the window modification state according to the text modification count */	SetWindowModified ( inDocument -> window, WEGetModCount ( inDocument -> text ) != inDocument -> cleanModCount ) ;}OSStatus SetWindowTitleFromFile ( WindowRef inWindow, const FSRef * inFileRef ){	CFStringRef			fileName = NULL ;	OSStatus			err ;	if ( LSCopyDisplayNameForRef != NULL )	{		/* if Launch Services are available, get display name of file */		if ( ( err = LSCopyDisplayNameForRef ( inFileRef, & fileName ) ) != noErr )		{			goto cleanup ;		}	}	else	{		/* else use the real file name */		if ( ( err = FSGetObjectNameAsCFString ( inFileRef, & fileName ) ) != noErr )		{			goto cleanup ;		}	}	/* set the window title */	if ( ( err = SetWindowTitleWithCFString ( inWindow, fileName ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	if ( fileName )	{		CFRelease ( fileName ) ;		fileName = NULL ;	}	return err ;}OSStatus CreateDocument ( const FSRef * inFileRef, Document ** outDocument ){	const EventTypeSpec			windowEventTypes [ ] =	{		{ kEventClassWindow,	kEventWindowDrawContent },		{ kEventClassWindow,	kEventWindowClose },		{ kEventClassWindow,	kEventWindowActivated },		{ kEventClassWindow,	kEventWindowDeactivated },		{ kEventClassWindow,	kEventWindowGetClickActivation },		{ kEventClassWindow,	kEventWindowBoundsChanged },		{ kEventClassWindow,	kEventWindowCursorChange },		{ kEventClassWindow,	kEventWindowZoom },		{ kEventClassWindow,	kEventWindowGetMinimumSize },		{ kEventClassWindow,	kEventWindowContextualMenuSelect },		{ kEventClassWindow,	kEventWindowHandleContentClick }	} ;	const EventTypeSpec			windowCommandTypes [ ] =	{		{ kEventClassCommand,	kEventCommandProcess },		{ kEventClassCommand,	kEventCommandUpdateStatus }	} ;	const EventTypeSpec			textEventTypes [ ] =	{		{ kEventClassTextInput,	kEventTextInputUnicodeForKeyEvent }	} ;	const EventTypeSpec			mouseEventTypes [ ] =	{		{ kEventClassMouse,		kEventMouseWheelMoved }	} ;	const EventTypeSpec			serviceEventTypes [ ] =	{		{ kEventClassService,	kEventServiceCopy },		{ kEventClassService,	kEventServicePaste },		{ kEventClassService,	kEventServiceGetTypes }	} ;	const Rect					initialWindowBounds = { 48, 12, 48 + 280, 12 + 440 } ;	const SInt32				translucencyThreshold = kStandardTranslucencyThreshold ;	WindowAttributes			windowAttributes =		kWindowCloseBoxAttribute |		kWindowVerticalZoomAttribute |		kWindowCollapseBoxAttribute |		kWindowResizableAttribute |		kWindowStandardHandlerAttribute |		kWindowInWindowMenuAttribute |		kWindowLiveResizeAttribute ;	Document *					document = NULL ;	WindowRef					window = NULL ;	WindowRef					frontWindow = GetFrontWindowOfClass ( kDocumentWindowClass, true ) ;	Handle						hPageMargins = NULL ;	PageMarginRec				pageMargins ;	FileInfo					finderInfo ;	OSType						fileFormat ;	FSVolumeRefNum				volume = 0 ;	Rect						textRect ;	Rect						scrollBarRect ;	Rect						iconRect ;	const Rect *				transitionSrcRect = NULL ;	LongRect					destRect ;	LongRect					viewRect ;	int							orientation ;	OSStatus					err ;	/* allocate the document record */	if ( ( document = ( Document * ) malloc ( sizeof ( Document ) ) ) == NULL )	{		err = memFullErr ;		goto cleanup ;	}	BlockZero ( document, sizeof ( Document ) ) ;	document -> fileFormat = kTypeText ;	/* clear bits in windowAttributes corresponding to Window Manager features not supported on this platform */	/* (e.g., live resizing is supported under Mac OS X, but not under Mac OS 9) */	windowAttributes &= GetAvailableWindowAttributes ( kDocumentWindowClass ) ;	/* create the window */	if ( ( err = CreateNewWindow ( kDocumentWindowClass, windowAttributes, & initialWindowBounds, & window ) ) != noErr )	{		goto cleanup ;	}	/* set initial window title */	if ( ( err = SetWindowTitleWithCFString ( window, CFSTR ( "untitled" ) ) ) != noErr )	{		goto cleanup ;	}	/* link the document record to the window and the other way around */	SetWRefCon ( window, ( SInt32 ) document ) ;	document -> window = window ;	/* establish an embedding hierarchy for controls within this window */	if ( ( err = CreateRootControl ( window, & document -> rootControl ) ) != noErr )	{		goto cleanup ;	}	/* we got a window, so tell QuickDraw where to draw... */	SetPortWindowPort ( window ) ;	/* calculate the initial destination rectangle for the text */	WERectToLongRect ( CalcTextRect ( window, & textRect ), & destRect ) ;	/* the view rectangle matches the initial destination rectangle, but leaves a few extra pixels on the left */	viewRect = destRect ;	viewRect . left -= kLeftClickMargin ;	/* create a new WASTE instance */	if ( ( err = WENew ( & destRect, & viewRect,		weDoAutoScroll |		weDoAutoIdle |		weDoOutlineHilite |		weDoUndo |		weDoMultipleUndo |		weDoIntCutAndPaste |		weDoDragAndDrop |		weDoUseTempMem |		weDoDrawOffscreen |		weDoLeftMarginClick, & document -> text ) ) != noErr )	{		goto cleanup ;	}	/* save a reference to the document in the WE instance */	if ( ( err = WESetUserInfo ( kDocumentTag, ( SInt32 ) document, document -> text ) ) != noErr )	{		goto cleanup ;	}	/* create UPPs for callbacks */	document -> textScroller = NewWEScrollUPP ( TextScrolled ) ;	document -> windowEventHandler = NewEventHandlerUPP ( HandleWindowEvent ) ;	document -> menuEventHandler = NewEventHandlerUPP ( HandleMenuEvent ) ;	document -> windowCommandHandler = NewEventHandlerUPP ( HandleWindowCommand ) ;	document -> windowTextHandler = NewEventHandlerUPP ( HandleTextEvent ) ;	document -> mouseWheelHandler = NewEventHandlerUPP ( HandleMouseWheel ) ;	document -> servicesHandler = NewEventHandlerUPP ( HandleServices ) ;	document -> barScroller = NewControlActionUPP ( DoScrollBarHit ) ;	document -> dragTracker = NewDragTrackingHandlerUPP ( DoTrackDrag ) ;	document -> dragReceiver = NewDragReceiveHandlerUPP ( DoReceiveDrag ) ;	/* set up our scroll callback */	if ( ( err = WESetInfo ( weScrollProc, & document -> textScroller, document -> text ) ) != noErr )	{		goto cleanup ;	}	/* install an event handler for window events */	if ( ( err = InstallWindowEventHandler ( window, document -> windowEventHandler, GetEventTypeCount ( windowEventTypes ),		windowEventTypes, document, & document -> windowEventHandlerRef ) ) != noErr )	{		goto cleanup ;	}	/* install an event handler for HI commands aimed at windows */	if ( ( err = InstallWindowEventHandler ( window, document -> windowCommandHandler, GetEventTypeCount ( windowCommandTypes ),		windowCommandTypes, document, & document -> windowCommandHandlerRef ) ) != noErr )	{		goto cleanup ;	}	/* install an event handler for keyboard commands */	if ( ( err = InstallWindowEventHandler ( window, document -> windowTextHandler, GetEventTypeCount ( textEventTypes ),		textEventTypes, document, & document -> windowTextHandlerRef ) ) != noErr )	{		goto cleanup ;	}	/* install an event handler for mouse events */	if ( ( err = InstallWindowEventHandler ( window, document -> mouseWheelHandler, GetEventTypeCount ( mouseEventTypes ),		mouseEventTypes, document, & document -> mouseWheelHandlerRef ) ) != noErr )	{		goto cleanup ;	}	/* install an event handler for Mac OS X Services */	if ( ( err = InstallWindowEventHandler ( window, document -> servicesHandler, GetEventTypeCount ( serviceEventTypes ),		serviceEventTypes, document, & document -> servicesHandlerRef ) ) != noErr )	{		goto cleanup ;	}	/* install drag handlers */	if ( ( err = InstallTrackingHandler ( document -> dragTracker, window, document ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = InstallReceiveHandler ( document -> dragReceiver, window, document ) ) != noErr )	{		goto cleanup ;	}	/* enable translucent text dragging */	if ( ( err = WESetInfo ( weTranslucencyThreshold, & translucencyThreshold, document -> text ) ) != noErr )	{		goto cleanup ;	}	/* enable the built-in WASTE object handlers for all supported flavor types (as of this writing, just PICT and snd) */	if ( ( err = WEInstallStandardObjectHandlers ( typeWildCard, document -> text ) ) != noErr )	{		goto cleanup ;	}	/* associate a default page margins record with the WE reference */	pageMargins . top = 72 << 16 ;			/* one inch */	pageMargins . bottom = 72 << 16 ;	pageMargins . left = 72 << 16 ;	pageMargins . right = 72 << 16 ;	if ( ( err = PtrToHand ( & pageMargins, & hPageMargins, sizeof ( pageMargins ) ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = WESetUserInfo ( kPageMarginsTag, ( SInt32 ) hPageMargins, document -> text ) ) != noErr )	{		goto cleanup ;	}	hPageMargins = NULL ;	/* create the scroll bars */	for ( orientation = kVertical ; orientation <= kHorizontal; orientation ++ )	{		if ( ( err = CreateScrollBarControl ( window, CalcScrollBarRect ( window, orientation, & scrollBarRect ),			0, 0, 0, 0, true, document -> barScroller, & document -> scrollBars [ orientation ] ) ) != noErr )		{			err = memFullErr ;			goto cleanup ;		}	}	/* ViewChanged adjusts the scroll bars rectangles to the window frame */	if ( ( err = ViewChanged ( document ) ) != noErr )	{		goto cleanup ;	}	/* if inFileRef is not NULL, it points to a file to read, so let's read it! */	if ( inFileRef )	{		/* turn the cursor into a wristwatch because this can be a lengthy operation */		if ( ( err = SetThemeCursor ( kThemeWatchCursor ) ) != noErr )		{			goto cleanup ;		}		/* retrieve finder information */		if ( ( err = FSGetObjectFinderInfo ( inFileRef, & finderInfo ) ) != noErr )		{			goto cleanup ;		}		/* read in the file -- let WASTE guess the file format */		fileFormat = typeWildCard ;		if ( ( err = WELoad ( 0, 0, inFileRef, & fileFormat, NULL, NULL, document -> text ) ) != noErr )		{			goto cleanup ;		}		/* set the insertion point at the beginning of the text */		WESetSelection ( 0, 0, document -> text ) ;		/* reset the WE instance modification count */		WEResetModCount ( document -> text ) ;		if ( finderInfo . finderFlags & kIsStationery )		{			/* the file we just read was a stationery pad, so don't associate it with the window */			if ( ( err = FSGetObjectVolume ( inFileRef, & volume ) ) != noErr )			{				goto cleanup ;			}			if ( ( err = SetWindowProxyCreatorAndType ( window, finderInfo . fileCreator, finderInfo . fileType, volume ) ) != noErr )			{				goto cleanup ;			}		}		else		{			/* set the window title */			if ( ( err = SetWindowTitleFromFile ( window, inFileRef ) ) != noErr )			{				goto cleanup ;			}			/* remember file */			if ( ( err = FSNewAlias ( NULL, inFileRef, & document -> fileAlias ) ) != noErr )			{				goto cleanup ;			}			/* set window proxy icon */			if ( ( err = SetWindowProxyAlias ( window, document -> fileAlias ) ) != noErr )			{				goto cleanup ;			}			/* mark the window as clean */			if ( ( err = SetWindowModified ( window, false ) ) != noErr )			{				goto cleanup ;			}		}		document -> fileFormat = fileFormat ;		/* get icon rect */		if ( FSGetObjectIconRect ( inFileRef, & iconRect ) == noErr )		{			transitionSrcRect = & iconRect ;		}		/* make the cursor happy */		if ( ( err = SetThemeCursor ( kThemeArrowCursor ) ) != noErr )		{			goto cleanup ;		}	}	else	{		if ( ( err = SetWindowProxyCreatorAndType ( window, sigWASTE, kTypeText, kOnSystemDisk ) ) != noErr )		{			goto cleanup ;		}	}	/* adjust scroll bar settings based on the total text height */	AdjustBars ( document ) ;	/* position the window */	if ( ( err = RepositionWindow ( window, frontWindow, frontWindow ? kWindowCascadeOnParentWindow : kWindowCascadeOnMainScreen ) ) != noErr )	{		goto cleanup ;	}	/* finally!  show the document window */	if ( ( err = TransitionWindow ( window, kWindowZoomTransitionEffect, kWindowShowTransitionAction, transitionSrcRect ) ) != noErr )	{		goto cleanup ;	}	/* copy document pointer for caller */	if ( outDocument )	{		* outDocument = document ;	}cleanup :	if ( err != noErr )	{		ErrorAlert ( err ) ;	}	ForgetHandle ( & hPageMargins ) ;	return err ;}void DestroyDocument ( Document * inDocument ){	Handle					hPageFormat = NULL ;	Handle					hPageMargins = NULL ;	FSRef					fileRef ;	Rect					iconRect ;	Boolean					wasChanged = false ;	const Rect *			transitionDstRect = NULL ;	MenuID					menuID ;	/* remove window event handlers */	RemoveEventHandler ( inDocument -> windowEventHandlerRef ) ;	RemoveEventHandler ( inDocument -> windowCommandHandlerRef ) ;	RemoveEventHandler ( inDocument -> windowTextHandlerRef ) ;	RemoveEventHandler ( inDocument -> mouseWheelHandlerRef ) ;	RemoveEventHandler ( inDocument -> servicesHandlerRef ) ;	/* remove menu handlers and disable menus */	for ( menuID = kMenuFont ; menuID <= kMenuAlignment ; menuID ++ )	{		if ( inDocument -> menuEventHandlerRef [ menuID - kMenuFont ] != NULL )		{			RemoveEventHandler ( inDocument -> menuEventHandlerRef [ menuID - kMenuFont ] ) ;			inDocument -> menuEventHandlerRef [ menuID - kMenuFont ] = NULL ;		}		DisableMenuItem ( GetMenuHandle ( menuID ), 0 ) ;	}	/* remove drag handlers */	RemoveTrackingHandler ( inDocument -> dragTracker, inDocument -> window ) ;	RemoveReceiveHandler ( inDocument -> dragReceiver, inDocument -> window ) ;	/* get rid of the page format, if any */	if ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & hPageFormat, inDocument -> text ) == noErr )	{		ForgetHandle ( & hPageFormat ) ;		WERemoveUserInfo ( kPageFormatTag, inDocument -> text ) ;	}	/* get rid of the page margin record, if any */	if ( WEGetUserInfo ( kPageMarginsTag, ( SInt32 * ) & hPageMargins, inDocument -> text ) == noErr )	{		ForgetHandle ( & hPageMargins ) ;		WERemoveUserInfo ( kPageMarginsTag, inDocument -> text ) ;	}	/* remove WASTE object handlers (this is not strictly necessary, but it's here anyway for sake of completeness) */	WERemoveStandardObjectHandlers ( typeWildCard, inDocument -> text ) ;	/* destroy the WASTE instance */	WEDispose ( inDocument -> text ) ;	inDocument -> text = NULL ;	/* if this document has an associated file, get its icon rectangle */	if ( inDocument -> fileAlias )	{		if ( ( FSResolveAlias ( NULL, inDocument -> fileAlias, & fileRef, & wasChanged ) == noErr ) &&			 ( FSGetObjectIconRect ( & fileRef, & iconRect ) == noErr ) )		{			transitionDstRect = & iconRect ;		}		ForgetHandle ( ( Handle * ) & inDocument -> fileAlias ) ;	}	/* hide the window */	TransitionWindow ( inDocument -> window, kWindowZoomTransitionEffect, kWindowHideTransitionAction, transitionDstRect ) ;	/* destroy the window record and all associated data structures */	DisposeWindow ( inDocument -> window ) ;	/* get rid of callback UPPs */	DisposeEventHandlerUPP ( inDocument -> windowEventHandler ) ;	DisposeEventHandlerUPP ( inDocument -> menuEventHandler ) ;	DisposeEventHandlerUPP ( inDocument -> windowCommandHandler ) ;	DisposeEventHandlerUPP ( inDocument -> windowTextHandler ) ;	DisposeEventHandlerUPP ( inDocument -> mouseWheelHandler ) ;	DisposeEventHandlerUPP ( inDocument -> servicesHandler ) ;	DisposeWEScrollUPP ( inDocument -> textScroller ) ;	DisposeControlActionUPP ( inDocument -> barScroller ) ;	DisposeDragTrackingHandlerUPP ( inDocument -> dragTracker ) ;	DisposeDragReceiveHandlerUPP ( inDocument -> dragReceiver ) ;	/* finally, dispose of the document record */	free ( inDocument ) ;}