/*	LHTTP11Connection.cpp	Copyright (C) 2000 i-drive.com (email: opensource@mail.idrive.com)	This library is free software; you can redistribute it and/or	modify it under the terms of version 2.1 the GNU Lesser General	Public License as published by the Free Software Foundation.	This library is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU	Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public	License along with this library; if not, write to the Free Software	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA*/// ===========================================================================////   Portions of this file are based on the file LHTTPConnection.cp//   by Metrowerks, and are Copyrighted (C) 1996-2000 Metrowerks Inc.//// ===========================================================================#include <LHTTP11Connection.h>#include <LHTTP11Message.h>#include <UNetworkFactory.h>#include <UInternet.h>#include <LURL.h>#include "OpenSSLGlue.h"#include <LCookie.h>#include <UThread.h>#include <ctype.h>#include <cerrno>#include <algorithm>#include <assert.h>using namespace std;const SInt16 kHTTPSPort = 443;const char* LHTTP11Connection::kHTTP11Version				= "HTTP/1.1";const char* LHTTP11Connection::kFieldTransferEncoding		= "Transfer-Encoding";const char* LHTTP11Connection::kChunkedTransferEncoding		= "chunked";LStream* LHTTP11Connection::mLoggingStream = NULL;LMutexSemaphore LHTTP11Connection::mLoggingAccess;#define kHTTPNoContent				204#define kHTTPRequestUnauthorized	401#define kHTTPFound					302// ---------------------------------------------------------------------------//		¥ LHTTP11Connection()// ---------------------------------------------------------------------------//	ConstructorLHTTP11Connection::LHTTP11Connection (							LThread&		inThread,							LTCPEndpoint *	inEndpoint,							LCookieList  *  inOutCookieList,							bool			inSecure)	: LHTTPConnection (inThread), 		mIsSecure (inSecure),		mCookieList (inOutCookieList),		mWasCanceled (NULL), 		mWasClosed(false){	mEndpoint = inEndpoint;	mHasExternalEndpoint = (inEndpoint != NULL);	if (mEndpoint)		mEndpoint->AddListener(this);	mNoContent = false;}// ---------------------------------------------------------------------------//		¥ ResetMembers// ---------------------------------------------------------------------------//voidLHTTP11Connection::ResetMembers(){	if (mEndpoint && !mHasExternalEndpoint) {		mEndpoint->RemoveListener(this);		delete mEndpoint;		mEndpoint = nil;	}		mDisconnectReceived = false;	mStartDisconnect = false;	mProgressLastTicks = 0;}// ---------------------------------------------------------------------------//		¥ Connect// ---------------------------------------------------------------------------voidLHTTP11Connection::Connect(	ConstStr255Param	inRemoteHost,	SInt16				inRemotePort){	Connect (string ((char*)inRemoteHost + 1, inRemoteHost[0]), inRemotePort);}// ---------------------------------------------------------------------------//		¥ Connect// ---------------------------------------------------------------------------voidLHTTP11Connection::Connect(	const std::string&	inRemoteHost,	SInt16				inRemotePort){	if (mHTTPState == HTTPConnected) {		return;	}		ResetMembers();		if (inRemotePort == 0)		inRemotePort = mIsSecure ? kHTTPSPort: kHTTPPort;	if (!mHasExternalEndpoint)	{#if DAVLIB_SSL		if (mIsSecure || inRemotePort == kHTTPSPort)			mEndpoint = USecureNetworkFactory::CreateSecureTCPEndpoint();		else#endif			mEndpoint = UNetworkFactory::CreateTCPEndpoint();			mEndpoint->AddListener(this);	}		LInternetAddress localAddress(0, 0);	mEndpoint->Bind(localAddress);		LStr255 pHostAddress (inRemoteHost.c_str(), inRemoteHost.size());	LInternetAddress remoteAddress (pHostAddress, inRemotePort, false);	mDisconnectReceived = false;	mEndpoint->Connect(remoteAddress, mTimeoutSeconds);	mHTTPState = HTTPConnected;}// ---------------------------------------------------------------------------//		¥ DoHTTPMethod// ---------------------------------------------------------------------------//voidLHTTP11Connection::DoHTTPMethod(		EHTTPMethod			inMethod,		ConstStr255Param	inRemoteHost,		ConstStr255Param	inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod( inMethod,				PP_STD::string((char*)inRemoteHost+1, inRemoteHost[0]),				PP_STD::string((char*)inRequest+1, inRequest[0]),				inMessage,				outResponse,				inRemotePort);}// ---------------------------------------------------------------------------//		¥ DoHTTPMethod// ---------------------------------------------------------------------------//voidLHTTP11Connection::DoHTTPMethod(		EHTTPMethod			inMethod,		const PP_STD::string&	inRemoteHost,		const PP_STD::string&	inRequest,		LHTTPMessage&			inMessage,		LHTTPResponse&			outResponse,		SInt16					inRemotePort){	ThrowIf_ (inRequest.empty());		const char *theMethod;	switch (inMethod) {		case HTTPGet:			theMethod = kHTTPGet;			break;		case HTTPHead:			theMethod = kHTTPHead;			break;		case HTTPPost:			theMethod = kHTTPPost;			break;		case HTTPPut:			theMethod = kHTTPPut;			break;		default:			Throw_(err_AssertFailed);	}	DoHTTPMethod (theMethod, inRemoteHost, inRequest, inMessage, outResponse, inRemotePort);}// ---------------------------------------------------------------------------//		¥ DoHTTPMethod// ---------------------------------------------------------------------------//voidLHTTP11Connection::DoHTTPMethod(		const char			*inMethod,		const std::string&	inRemoteHost,		const std::string&	inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(inMethod, inRemoteHost, inRequest, inMessage, outResponse, inRemotePort, NULL);}		// ---------------------------------------------------------------------------//		¥ DoHTTPMethod// ---------------------------------------------------------------------------//voidLHTTP11Connection::DoHTTPMethod(		const char			*inMethod,		const std::string&	inRemoteHost,		const std::string&	inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort,		SProgressMessage	*inProgressMsg){		const string *field;		// Set up the progress message.	SProgressMessage localProgress;	SProgressMessage *progressMsg = inProgressMsg ? inProgressMsg : &localProgress;		progressMsg->theProtocol = this;	if (!inProgressMsg)	{		progressMsg->currentItem = LStr255 (inRemoteHost.c_str(), inRemoteHost.size());		progressMsg->totalBytes = 0;		progressMsg->completedBytes = 0;	}	progressMsg->totalItems = 1;	progressMsg->completedItems = 0;		if (!inProgressMsg)		BroadcastProgress(msg_OpeningConnection, *progressMsg, true);	Connect(inRemoteHost, inRemotePort);	if (!inProgressMsg)		BroadcastProgress(msg_Connected, *progressMsg, true);		string commandString;		commandString += inMethod;	commandString += " ";	commandString += inRequest;	commandString += " ";	commandString += mHasExternalEndpoint ? kHTTP11Version : kHTTPVersion;	commandString += CRLF;		mNoContent = (strcmp (inMethod, kHTTPHead) == 0);		try {		if (!inProgressMsg)		{			if (inRequest.size() > 255)				progressMsg->currentItem = LStr255 (inRequest.c_str() + inRequest.size() - 255, 255);			else				progressMsg->currentItem = LStr255 (inRequest.c_str(), inRequest.size());		}					SendCommandWithReply(commandString.c_str(),							inMessage,							outResponse,							*progressMsg);		if (outResponse.GetStatus() && !WasCancelled())			BroadcastProgress(msg_RetrieveItemSuccess, *progressMsg, true);		else			BroadcastProgress(msg_RetrieveItemFailed, *progressMsg, true);		if (!mHasExternalEndpoint 			|| ((field = outResponse.GetField ("Connection")) != NULL && *field == "close")			|| (field = outResponse.GetField("Via")))		{			Disconnect();			BroadcastProgress(msg_Disconnected, *progressMsg, true);			mWasClosed = true;		}		// Cookies are typically used to keep track of currently logged in users.// If login failed there's no point in using the cookie.		if (mCookieList /*&& outResponse.GetResponseCode() != kHTTPRequestUnauthorized*/)		{			for (int i = 0; (field = outResponse.GetField ("Set-Cookie", i)) != NULL; i++)				mCookieList->Add (field->c_str(), inRemoteHost.c_str());		}		// Handle redirect		if (outResponse.GetResponseCode() == kHTTPFound &&			MethodMayRedirect (inMethod) &&			(field = outResponse.GetField ("Location")) != NULL)		{			LURL redirectedURL (field->c_str(), field->size());			EURLType scheme = redirectedURL.GetSchemeType();			if (/* ***teb scheme == url_HTTPS ||*/ scheme == url_HTTP)			{				Disconnect ();								SInt16					port;				bool					secure = false;//(scheme == url_HTTPS);								if (secure)					port = redirectedURL.GetPort() ? redirectedURL.GetPort() : kHTTPSPort;				else					port = redirectedURL.GetPort() ? redirectedURL.GetPort() : kHTTPPort;				LHTTP11Connection newConnection (*mThread, NULL, mCookieList, secure);								LListener *listener;				for (int i=1; mListeners.FetchItemAt(i, listener); i++)					newConnection.AddListener (listener);				string newRequest (redirectedURL.GetPath());				newRequest += '?';				newRequest += redirectedURL.GetSearchPart();								newConnection.SetCancelFlag (mWasCanceled);				try				{					newConnection.DoHTTPMethod (inMethod, redirectedURL.GetHost(), newRequest, inMessage, outResponse, port, progressMsg);				}				catch (...)				{					newConnection.StopBroadcasting();					newConnection.SetCancelFlag (NULL);					throw;				}				newConnection.StopBroadcasting();				newConnection.SetCancelFlag (NULL);			}		}	}	catch (...)	{		mNoContent = false;		try		{			Disconnect();			mWasClosed = true;			BroadcastProgress(msg_Disconnected, *progressMsg, true);		}		catch(...)		{		}		throw;	}}// ---------------------------------------------------------------------------//		¥ MethodMayRedirect// ---------------------------------------------------------------------------//boolLHTTP11Connection::MethodMayRedirect (const char *inMethod){	return (strcmp (inMethod, kHTTPHead) == 0) || (strcmp (inMethod, kHTTPGet) == 0);}// ---------------------------------------------------------------------------//		¥ Get// ---------------------------------------------------------------------------//voidLHTTP11Connection::Get(		const string &		inRemoteHost,		const string &		inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(		HTTPGet,		inRemoteHost,		inRequest,		inMessage,		outResponse,		inRemotePort);}// ---------------------------------------------------------------------------//		¥ Get// ---------------------------------------------------------------------------//voidLHTTP11Connection::Get(		ConstStr255Param	inRemoteHost,		ConstStr255Param	inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(		HTTPGet,		string ((char*)inRemoteHost + 1, inRemoteHost[0]),		string ((char*)inRequest + 1, inRequest[0]),		inMessage,		outResponse,		inRemotePort);}// ---------------------------------------------------------------------------//		¥ Head// ---------------------------------------------------------------------------//voidLHTTP11Connection::Head(		const string &		inRemoteHost,		const string &		inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(		HTTPHead,		inRemoteHost,		inRequest,		inMessage,		outResponse,		inRemotePort);}// ---------------------------------------------------------------------------//		¥ Head// ---------------------------------------------------------------------------//voidLHTTP11Connection::Head(		ConstStr255Param	inRemoteHost,		ConstStr255Param	inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(		HTTPHead,		string ((char*)inRemoteHost + 1, inRemoteHost[0]),		string ((char*)inRequest + 1, inRequest[0]),		inMessage,		outResponse,		inRemotePort);}// ---------------------------------------------------------------------------//		¥ Post// ---------------------------------------------------------------------------//voidLHTTP11Connection::Post(		const string &		inRemoteHost,		const string &		inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(		HTTPPost,		inRemoteHost,		inRequest,		inMessage,		outResponse,		inRemotePort);}// ---------------------------------------------------------------------------//		¥ Post// ---------------------------------------------------------------------------//voidLHTTP11Connection::Post(		ConstStr255Param	inRemoteHost,		ConstStr255Param	inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(		HTTPPost,		string ((char*)inRemoteHost + 1, inRemoteHost[0]),		string ((char*)inRequest + 1, inRequest[0]),		inMessage,		outResponse,		inRemotePort);}// ---------------------------------------------------------------------------//		¥ Put// ---------------------------------------------------------------------------//voidLHTTP11Connection::Put(		const string &		inRemoteHost,		const string &		inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(		HTTPPut,		inRemoteHost,		inRequest,		inMessage,		outResponse,		inRemotePort);}// ---------------------------------------------------------------------------// ---------------------------------------------------------------------------//		¥ Put// ---------------------------------------------------------------------------//voidLHTTP11Connection::Put(		ConstStr255Param	inRemoteHost,		ConstStr255Param	inRequest,		LHTTPMessage&		inMessage,		LHTTPResponse&		outResponse,		SInt16				inRemotePort){	DoHTTPMethod(		HTTPPut,		string ((char*)inRemoteHost + 1, inRemoteHost[0]),		string ((char*)inRequest + 1, inRequest[0]),		inMessage,		outResponse,		inRemotePort);}// ---------------------------------------------------------------------------//		¥ SendCommandWithReply// ---------------------------------------------------------------------------// Remove extra CRLF from LHTTPConnection code; parse messagevoidLHTTP11Connection::SendCommandWithReply(const char * inString,										LHTTPMessage& inMessage,										LHTTPResponse& outResponse,										SProgressMessage& inProgressMsg){	LHeaderField contentEncField;	outResponse.ResetResponse();// Build HTTP request	LDynamicBuffer messageBuffer;		if (mHasExternalEndpoint)	{		LHTTP11Message *pMessage = dynamic_cast<LHTTP11Message*>(&inMessage);		if (pMessage)			pMessage->SetPersistent (true);	}	inMessage.GetMessage(&messageBuffer);	messageBuffer.PrependBuffer(inString);	SendData(&messageBuffer, inProgressMsg);	if (WasCancelled())		return;	WaitResponse(outResponse, inProgressMsg);	    LogHTTPRequest(messageBuffer, outResponse);}// ---------------------------------------------------------------------------//		¥ ReadUntilMatch// ---------------------------------------------------------------------------UInt32LHTTP11Connection::ReadUntilMatch( string&			inBuffer,									const char* 	inSuffix){	char			theData [kDefaultRcvSize];	UInt32			dataSize;	UInt32			totalData = 0;	Boolean 		dataExpedited;	const UInt32	suffixSize = strlen (inSuffix);	UInt32			found;	while (true)	{	// Search whatever's left in the buffer//		found = inBuffer.find (inSuffix, (totalData > suffixSize) ? totalData - suffixSize : 0);		found = inBuffer.find (inSuffix);		if (found != string::npos)			return found + suffixSize;		totalData += dataSize;			// Read more and try again		dataSize = sizeof (theData);		mEndpoint->ReceiveData (theData, dataSize, dataExpedited, mTimeoutSeconds);		inBuffer.append (theData, dataSize);	}}// ---------------------------------------------------------------------------//		¥ ReadBuffered// ---------------------------------------------------------------------------voidLHTTP11Connection::ReadBuffered( string&				inBuffer,									LDynamicBuffer&		target,									UInt32				requested,									SProgressMessage&	inProgressMsg){	char			theData [kDefaultRcvSize];	Boolean 		dataExpedited;	UInt32			bytesToRead;// Read from the buffer first	bytesToRead = min (requested, inBuffer.size());	target.ConcatenateBuffer(inBuffer.c_str(), bytesToRead);	inBuffer.erase (0, requested);		requested -= bytesToRead;// Read from endpoint	while (requested > 0)	{		if (WasCancelled())			break;		bytesToRead = min (requested, (UInt32)kDefaultRcvSize);		mEndpoint->ReceiveData (theData, bytesToRead, dataExpedited, mTimeoutSeconds);		requested -= bytesToRead;		target.ConcatenateBuffer (theData, bytesToRead);		inProgressMsg.completedBytes += bytesToRead;		BroadcastProgress (msg_ReceivingData, inProgressMsg);	}}// ---------------------------------------------------------------------------//		¥ WaitResponse// ---------------------------------------------------------------------------voidLHTTP11Connection::WaitResponse(							LHTTPResponse& outResponse,							SProgressMessage&	inProgressMsg){	string			sBuffer;	UInt32			dataSize;	UInt32			totalBytes = 0;	LHTTPMessage&	returnMessage = *outResponse.GetReturnMessage();	const string	*field;	bool			needsDisconnect = false;	inProgressMsg.completedBytes = 0;	try {		returnMessage.ResetMembers();				// Read the response line				dataSize = ReadUntilMatch ( sBuffer, CRLF);		outResponse.SetResponseText (sBuffer.c_str(), dataSize);		sBuffer.erase (0, dataSize);		// Read header and parse				dataSize = ReadUntilMatch ( sBuffer, kHeaderSep);		returnMessage.SetHeader (sBuffer.c_str(), dataSize);		sBuffer.erase (0, dataSize);		outResponse.Parse();						// Special case: head -- no body		if (mNoContent)			mNoContent = false;					// No content. Not strictly necessary.		else if (outResponse.GetResponseCode() == kHTTPNoContent) 		   ;		else if (outResponse.GetResponseCode() == 100) {		   returnMessage.ResetMembers();				   // Read the response line				   dataSize = ReadUntilMatch ( sBuffer, CRLF);		   outResponse.SetResponseText (sBuffer.c_str(), dataSize);		   sBuffer.erase (0, dataSize);		   dataSize = ReadUntilMatch ( sBuffer, kHeaderSep);		   returnMessage.SetHeader (sBuffer.c_str(), dataSize);		   sBuffer.erase (0, dataSize);		   outResponse.Parse();		   if ((field = outResponse.GetField (kFieldContentLength)) != NULL) {			  inProgressMsg.totalBytes = atol (field->c_str());			  if (inProgressMsg.totalBytes == 0)			     return;			  ReadBuffered ( sBuffer, *returnMessage.GetInternalMessageBody(), inProgressMsg.totalBytes, inProgressMsg);		   }		}				// Read body with content length field		else if ((field = outResponse.GetField (kFieldContentLength)) != NULL)		{			inProgressMsg.totalBytes = atol (field->c_str());			if (inProgressMsg.totalBytes == 0)			   return;			ReadBuffered ( sBuffer, *returnMessage.GetInternalMessageBody(), inProgressMsg.totalBytes, inProgressMsg);		}				// Read chunked message body		else if ((field = outResponse.GetField (kFieldTransferEncoding)) != NULL && *field == kChunkedTransferEncoding)		{			UInt32	chunkBytes;						do			{				UInt32 bytesToEnd;								bytesToEnd = ReadUntilMatch ( sBuffer, CRLF );								// Get chunk length and optional extension				errno = 0;				chunkBytes = strtol ( sBuffer.substr(0, bytesToEnd).c_str() , NULL, 16);	// Read chunk length. Extensions are ignored				if (errno)					throw LException (-1);				sBuffer.erase (0, bytesToEnd);				if (chunkBytes != 0)														// Read specified number of octets					ReadBuffered ( sBuffer, *returnMessage.GetInternalMessageBody(), chunkBytes, inProgressMsg);				bytesToEnd = ReadUntilMatch ( sBuffer, CRLF );								// Read terminating CRLF				sBuffer.erase (0, bytesToEnd);			} while (chunkBytes != 0);														// Last chunk is marked as 0 length		}				// Read message bodies with indeterminate length. These will be terminated by a disconnect.		else		{			needsDisconnect = true;			for (;;)			{				if (WasCancelled())					break;				ReadBuffered ( sBuffer, *returnMessage.GetInternalMessageBody(), kDefaultRcvSize, inProgressMsg);			}		}	}	catch (const LException& err) {		if (! (needsDisconnect && IsDisconnectError(err.GetErrorCode())) ) {			throw;		}	}		catch (ExceptionCode err) {		if (! (needsDisconnect && IsDisconnectError(err))) {			throw;		}	}	// Force the last msg_ReceivingData message just in case	BroadcastProgress(msg_ReceivingData, inProgressMsg, true);}// ---------------------------------------------------------------------------//		¥ SendData// ---------------------------------------------------------------------------//void LHTTP11Connection::SendData(LDynamicBuffer *inBuffer, SProgressMessage& inProgressMsg) {	Assert_(mEndpoint != nil);	if (!inProgressMsg.totalBytes)		inProgressMsg.totalBytes = inBuffer->GetBufferLength();	LStream * dataStream = inBuffer->GetBufferStream();	dataStream->SetMarker(0, streamFrom_Start);	SInt32 amountRead;	SInt32 amountSent = 0;	SInt32 sendBufferSize = (SInt32)GetSendSize();		do {        //***teb - hook into cancellation mechanism        if (WasCancelled())            break;		{			StPointerBlock tempSendBuffer(sendBufferSize, true);			amountRead = dataStream->ReadData(tempSendBuffer, sendBufferSize);			mEndpoint->Send(tempSendBuffer, amountRead);		}		amountSent = amountRead;				inProgressMsg.completedBytes += amountSent;		BroadcastProgress(msg_SendingData, inProgressMsg);	} while (amountRead == sendBufferSize);}// ---------------------------------------------------------------------------//		¥ SendData// ---------------------------------------------------------------------------voidLHTTP11Connection::SendData(	const char*			inData,	UInt32				totalSize,	SProgressMessage&	inProgressMsg){	Assert_(mEndpoint != nil);		if (!inProgressMsg.totalBytes)		inProgressMsg.totalBytes = totalSize;	UInt32 amountSent = 0;	const char * p = inData;	UInt32 sendBufferSize = GetSendSize();	while (amountSent < totalSize && !WasCancelled()) {		if (sendBufferSize > (totalSize - amountSent))			sendBufferSize = totalSize - amountSent;					mEndpoint->Send((void*)(p), sendBufferSize);		p += sendBufferSize;		amountSent = sendBufferSize;				inProgressMsg.completedBytes += amountSent;		BroadcastProgress(msg_SendingData, inProgressMsg);	}}// ---------------------------------------------------------------------------//		¥ SetLoggingStream// ---------------------------------------------------------------------------voidLHTTP11Connection::SetLoggingStream(	FSSpec *			logStream){	StMutex mutex(mLoggingAccess);   	if (NULL != mLoggingStream)		delete mLoggingStream;	if (logStream == NULL)	{		mLoggingStream = NULL;		return;	}	LFileStream *fileStream = new LFileStream(*logStream);	try {		fileStream->CreateNewDataFile('ttxt', 'TEXT');	} catch (LException& iErr) {							// It's ok if the file already exists as this will append				// or overwrite.		if (iErr.GetErrorCode() != dupFNErr) {			throw;		}	}	SInt16 fileRef = fileStream->OpenDataFork(fsRdWrPerm);	::SetEOF(fileRef, 0);	fileStream->CloseDataFork();	mLoggingStream = fileStream;}// ---------------------------------------------------------------------------//		¥ LogHTTPRequest// ---------------------------------------------------------------------------voidLHTTP11Connection::LogHTTPRequest(	LDynamicBuffer& message,	LHTTPResponse& response) {	StMutex mutex(mLoggingAccess);	if (NULL == mLoggingStream)	 return;	LFileStream *fileStream = (LFileStream*)mLoggingStream;	fileStream->OpenDataFork(fsRdWrPerm);	const char* crlf = "\r\n";	mLoggingStream->SetMarker(0, streamFrom_End); 	const char* reqHdrText = "\r\n\r\n====================== Outgoing Request ======================\r\n";	mLoggingStream->WriteBlock(reqHdrText, strlen(reqHdrText));	Handle hand = message.GetBufferDataH();	{		StHandleLocker locked(hand);		mLoggingStream->SetMarker(0, streamFrom_End); 		SInt32 handleLength = ::GetHandleSize(hand);		mLoggingStream->WriteBlock(*hand, handleLength);	}	DisposeHandle(hand);	mLoggingStream->WriteBlock(crlf, strlen(crlf));	mLoggingStream->SetMarker(0, streamFrom_End); 	const char* resHdrText = "\r\n\r\n====================== Incoming Response ======================\r\n";	mLoggingStream->WriteBlock(resHdrText, strlen(resHdrText));	mLoggingStream->WriteBlock(response.GetResponse(), strlen(response.GetResponse()));	mLoggingStream->WriteBlock(crlf, strlen(crlf));	LDynamicBuffer *outBuf = response.GetReturnMessage()->GetHeader();	hand = outBuf->GetBufferDataH();	{		StHandleLocker locked(hand);		mLoggingStream->SetMarker(0, streamFrom_End); 		SInt32 handleLength = ::GetHandleSize(hand);		mLoggingStream->WriteBlock(*hand, handleLength);	}	DisposeHandle(hand);   	mLoggingStream->WriteBlock(crlf, strlen(crlf));	outBuf = response.GetReturnMessage()->GetMessageBody();	hand = outBuf->GetBufferDataH();	{		StHandleLocker locked(hand);		mLoggingStream->SetMarker(0, streamFrom_End); 		SInt32 handleLength = ::GetHandleSize(hand);		mLoggingStream->WriteBlock(*hand, handleLength);	}	DisposeHandle(hand);   	mLoggingStream->WriteBlock(crlf, strlen(crlf));	fileStream->CloseDataFork();}		