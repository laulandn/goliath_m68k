/*________________________________________________________________________________	QCAPI.h		Application Programmer Interface (API) to QC(tm) development tool.		Copyright 1993-1996 Onyx Technology. All rights reserved worldwide.		revis:	06/04/93	dth - Date created			02/10/95	dth - Added 'testTrapPC' to QCPBRec.							- Added PPC mixed mode for QCInstallHandler().			08/01/95	dth - QCDeActivate() is now called QCDeactivate().							- a macro exists for those calling the old name			10/03/95	dth - Added QCDebugOptionsRec to QCOptionsData struct so								debug break options can be set now.			10/21/95	dth - Added 'QCValidateHPOptionsRec' data to set								options for 'Nil Handle/Ptr Warnings' test.			04/27/96	dth - Added '#pragma options align' settings to ensure								compatible structs between 68K & PPC environments.			06/12/00	JWW - Metrowerks cleanup for Universal Interfaces 3.3.2.________________________________________________________________________________*/#ifndef	_H_QCAPI#define	_H_QCAPI#if !defined(__MWERKS__) && !defined(THINK_C)	#ifndef	__TYPES__	#include <Types.h>	#endif	#ifndef	__MEMORY__	#include <Memory.h>	#endif	#ifndef	__OSUTILS__	#include <OSUtils.h>	#endif#endiftypedef	long	QCErr;							// QC error code typetypedef	long	QCType;							// QC type codestypedef	Handle	QCStateHandle;					// QC save/restore state data#if PRAGMA_STRUCT_ALIGN			// JWW - Instead of PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif//	Parameter block for custom error handlerstruct QCPBRec {	QCType		testID;							// the selector id of the test	QCErr		error;							// error detected (see below)	long		data;							// data/address from QCInstallHandler()	char		*errString;						// error string being reported	long		lastTestedTrapPC;				// PC of last trap QC detected error at	long		lastTrapPC;						// PC of last trap executed from user code};typedef struct QCPBRec QCPBRec;typedef	QCPBRec *QCPBPtr;// Test list handle returned by QCGetTestList(). Delete with DisposeHandle().struct QCTestRec {	QCType		testID;	Str32		testName;};typedef struct QCTestRec QCTestRec;typedef QCTestRec *QCTestPtr, **QCTestHandle;// Specific test option structs for use in QCGetTestOptions()/QCSetTestOptionsstruct QCAutoLaunchRec {	short		which;							// 1 = _InitGraf; 2 = _Get1Resource;	short		id;								// id for useGet1Resource	OSType		type;							// type for useGet1Resource};typedef	struct QCAutoLaunchRec QCAutoLaunchRec;struct QCReasonAllocRec {	short		which;							// 1 = use app heap; 2 = use specified	long		size;							// alloc size to break on >=};typedef	struct QCReasonAllocRec QCReasonAllocRec;struct QCBlockBoundsRec {	short		tagSize;						// block bounds size to tag blocks with};typedef	struct QCBlockBoundsRec QCBlockBoundsRec;struct QCDebugOptionsRec {	short		which;							// 1 = _DebugStr; 2 = _SysBreakStr};typedef struct QCDebugOptionsRec QCDebugOptionsRec;struct QCValidateHPOptionsRec {	short		nilHandleWarnings;				// true if you want NIL handle warnings	short		nilPointerWarnings;				// true if you want NIL pointer warnings};typedef	struct QCValidateHPOptionsRec QCValidateHPOptionsRec;union QCOptionData {	QCAutoLaunchRec			autoLaunch;			// AutoLaunch information	QCReasonAllocRec		reasonableAlloc;	// Reasonable Allocation information	QCBlockBoundsRec		blockBounds;		// BlockBounds information	QCDebugOptionsRec		debugOptions;		// Debugger Break option information	QCValidateHPOptionsRec	validateHPOptions;	// Validate Handle/Pointer information};typedef	union QCOptionData QCOptionData;struct	QCTestOptions {	QCType			testID;						// the test this data belongs to	QCOptionData	optionData;					// union specific data belongs here};typedef	struct QCTestOptions QCTestOptions;typedef	QCTestOptions *QCTestOptionsPtr;#if PRAGMA_STRUCT_ALIGN			// JWW - Instead of PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endifenum {	//	API result codes	kQCNoErr			= 0,	kQCInternalErr		= 9,	kQCNotInstalled,					// QC extension not installed	kQCNotActive,						// QC is not testing; must be to complete	kQCInvalidParam,					// invalid parameter passed to routine	kQCInvalidType,						// invalid QCType given to a routine	kQCPBRecMismatch,					// QCPBRec size mismatch.  QCAPI library in use										//	does not match API loaded extension needs.	kQCAPIMismatch,						// The QCAPI and loaded extension API's don't match!	kQCErrHandlerNotFound,				// QCRemoveHandler result when given proc was not										//	installed.	// API error detection result codes (given to handler routine (if installed)	kErrorBase	= 300,					// base index of all errors	kBadBlockLenErr,					// invalid physical block length	kBadRelHandErr,						// Offset from zone start to masterPtr invalid	kLostMasterPtrErr,					// master pointer is not in the heap	kBadMasterPtrErr,					// MasterPtr does not point to data	kBadNonRelocErr,					// Bad Non-reloc block: heap addr must follow physSize.	kBadBlockTypeErr,					// invalid block type (not reloc, non-reloc, or free)	kBadLastBlockErr,					// invalid physical block length (last block)	kWriteToZeroErr,					// write to location zero detected	kNilHandleErr,						// nil handle error	/*	10	*/	kHandleInFreeErr,					// handle is in a free block	// JWW - Use kQCBadHandleErr instead of kBandHandleErr because it conflicts with MacErrors.h	kQCBadHandleErr,					// handle is bad - not at start of relocatable block	kBadPtrErr,							// Ptr does not point to non-relocatable block	kNilPointerErr,						// nil pointer detected	kUnused,	kHeapStartEndErr,					// bkLim of heap has heap end before it starts	kFreeByteHeapErr,					// no. of free bytes exceeds heap size	kGrowZoneMismatchErr,				// grow zone function mistmatch!	kUnreasonableNewHandleErr,			// new handle size is questionable	kUnreasonableNewPtrErr,	/*	20	*/	kUnreasonableSetHandleSizeErr,	kUnreasonableReallocHandleErr,	kUnreasonableSetPtrSizeErr,	kReleaseHandleErr,					// called release resource on a handle	kDisposResourceErr,					// Trying to perform a DisposHandle on a resource	kBlockMoveDestFree,					// Destination ptr for BlockMove is in a free block	kBlockMoveDestMultiple,				// Destination ptr for BlockMove spans multiple blocks	kBlockMoveHeadOverwrite,			// Blockmove will overwrite a block header	kBlockMovePadOverwrite,				// Blockmove will overwrite padding in a block	/*	30	*/	kUnreasonableBlockMoveSize,			// Blockmove attempting to move an unreasonable size	kMemErrDetected,					// a MemErr value has been detected after a call	kEmptyHandleErr,					// Empty handle used by routine that needs data	kPtrBoundsErr,						// Write past end of non-relocatable block detected	kHandleBoundsErr,					// Write past end of relocatable block detected	kFreeMemOverwrite,					// Write has been made to a free block	kGrowLock,							// App is growing a locked block	kGrowPtr,							// App is growing a non-relocatable block	kBlockMoveNilSrc,					// source pointer is NIL!	kBlockMoveNilDest,					// destination pointer is NIL!	kErrorLimit							// max error id place holder};//	The following constants are valid QCType selectors:	#define	qcAutoLaunch				'auto'			// auto launch this app/file	#define	qcCheckSystemHeap			'cksh'			// check system heap	#define	qcValidateMasterPointers	'vlmp'			// validate master pointers	#define	qcValidateHandlePointers	'vlhp'			// validate handles/pointers	#define	qcDetectWriteToZero			'dtwz'			// detect write to zero	#define	qcDerefZeroCheck			'drzc'			// detect deref zero	#define	qcReasonableAllocation		'rall'			// reasonable allocation checks	#define	qcCheckDisposeRelease		'dprl'			// check DisposeHandle/ReleaseResource	#define	qcScrambleHeap				'schp'			// scramble heap	#define	qcPurgeHeap					'pghp'			// purge heap	#define	qcCheckHeap					'ckhp'			// check heap	#define	qcInvalidateFreeMemory		'infm'			// trample (invalidate) free memory	#define	qcCheckSystemCode			'csys'			// check system code	#define	qcErrorReporting			'erpt'			// error reporting	#define	qcDebugBreaks				'dbrk'			// debugger breaks	#define	qcBeepNotify				'beep'			// beep on activate/deactivate	#define	qcIconNotify				'sicn'			// rotate small icon when active	#define qcBlockMoveChecking			'bkmv'			// check BlockMove calls	#define qcBlockBoundsChecking		'bbck'			// block bounds checking	#define	qcMemErrDetection			'merr'			// (here for compatibility-see below)	#define	qcMemErrWarnings			'merr'			// MemErr value checking	#define	qcGrowLockChecking			'grlk'			// grow locked block checking	#define	qcGrowNonRelocChecking		'gron'			// grow non-reloc block checking	#define	qcAllTestsMask				'mask'			// all tests mask (activate/deactivate all)//	PowerPC mixed mode supportenum {	uppQCCallBackProcInfo = kCStackBased		| RESULT_SIZE(SIZE_CODE(sizeof(long)))		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(QCPBPtr)))};//	PowerPC mixed mode supportenum {	uppQCPascalCallBackProcInfo = kPascalStackBased		| RESULT_SIZE(SIZE_CODE(sizeof(long)))		| STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(QCPBPtr)))};// QCCallBack routine descriptors#if TARGET_RT_MAC_CFM			// JWW - Instead of GENERATINGCFMtypedef UniversalProcPtr QCCallBackUPP;#define NewQCCallBackProc(userRoutine)		\		(QCCallBackUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppQCCallBackProcInfo, GetCurrentISA())#define NewQCPascalCallBackProc(userRoutine)		\		(QCCallBackUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppQCPascalCallBackProcInfo, GetCurrentISA())#elsetypedef	ProcPtr	QCCallBackUPP;#define	NewQCCallBackProc(userRoutine)		\		((QCCallBackUPP) (userRoutine))#define	NewQCPascalCallBackProc(userRoutine)		\		((QCCallBackUPP) (userRoutine))#endif#ifdef __cplusplusextern "C" {#endif//	API Routinespascal QCErr		QCInstalled(void);						// is QC extension loaded and usable?pascal Boolean		QCIsActive(void);						// is QC currently testing an application?pascal QCErr		QCActivate(THz);						// activate QC on a specific heap zone															//	or current heap if 0L is specifiedpascal QCErr		QCDeactivate(void);						// deactivate QC testingpascal THz			QCTestingHeap(void);					// get the heap being testedpascal QCStateHandle 	QCGetState(void);					// get the current testing statepascal QCErr		QCSetState(QCStateHandle);				// restore the current testing statepascal QCErr		QCDisposeState(QCStateHandle);			// dispose of state handlepascal QCErr		QCGetTestState(QCType, long *);			// get state of a particular testpascal QCErr		QCSetTestState(QCType, long);			// set state of a particular testpascal QCErr 		QCGetTestOptions(QCTestOptionsPtr);		// get specific test optionspascal QCErr 		QCSetTestOptions(QCTestOptionsPtr);		// set specific test optionspascal QCErr		QCInstallHandler(QCCallBackUPP, long);	// install a C error handler routinepascal QCErr		QCInstallPascalHandler(QCCallBackUPP, long); // install a PASCAL error handler routinepascal QCErr		QCRemoveHandler(QCCallBackUPP);			// remove an error handler routinepascal QCErr		QCGetErrorText(QCErr, StringPtr);		// get error text for a particular errorpascal QCErr		QCHeapCheckNow(void);					// check the active heap nowpascal QCErr		QCScrambleHeapNow(void);				// scramble the active heap nowpascal QCErr		QCBlockBoundsCheckNow(void);			// perform a block bounds check nowpascal QCErr		QCVerifyHandle(Handle);					// verify the given handlepascal QCErr		QCVerifyPtr(Ptr);						// verify the given pointerpascal QCTestHandle	QCGetTestList(long *);					// Get a list of install/available tests															//	return # of tests in long*// This is around for compatibility because it used to have the capital 'A' in it.#define	QCDeActivate()	QCDeactivate()#ifdef __cplusplus}#endif#endif	// _H_QCAPI