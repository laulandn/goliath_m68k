/* *	CFM68K_StartupSharedLib.c	-	init/startup/termination routines for Metrowerks C++ (CFM68K) * *	Copyright © 1995-1997 Metrowerks, Inc. All Rights Reserved. * * *	THEORY OF OPERATION * *	This version of the PPC startup code is intended to be used for shared library *	components of multi-fragment applications. It is designed to properly support *	exceptions thrown across fragment boundaries, and proper initialization and *	termination--including construction and destruction of static objects--for *	a shared library that is one component of a complex, multi-fragment program. * *	The startup file defines 2 entry-points: * *		__initialize	This must be the Initialization Entry-Point for the Application. *						__initialize() registers the exception-handling info for *						the application, and calls all static initializers. * *		__terminate		This must be the Termination Entry-Point for the Application *						__terminate() unregisters the exception-handling info for the *						shared application before the fragment is unloaded. * *	The new zero-runtime-overhead exception-handling mechanism requires that we *	keep track of all loaded fragments and their code/data section ranges--we *	cannot use the OS data structures to do this--so we must call routines which *	register and unregister the exception-handling info as a fragment is loaded/unloaded. * *	When the shared library is loaded, __InitCode__() will call constructors for static *	objects, linking them into the (per-application) global destructor chain. These *	objects will be destroyed when the application component of the program calls *	__destroy_global_chain() as part of its exit() handling. This will ensure the *	proper ordering of destruction wrt calling _atexit() handlers, cleaning up the *	I/O and console packages, etc. * *	This startup file must -not- be used for shared libraries with shared data sections, *	since these may be linked into multiple applications simultaneously, and cannot *	have its static objects linked into the application's global destructor chain. * */#include <CodeFragments.h>#include <Exception68K.h>#include <NMWException.h>#include <Types.h>	/*	external data	*/extern far segment_map SEGMAPNAME[];	/*	private data	*/static long fragmentID;						/*	ID given to fragment by exception-handling	*/	/*	prototypes	*/#ifdef __cplusplusextern "C" {#endif#pragma internal onvoid __InitCode__(void);#pragma internal resetpascal OSErr __initialize(const CFragInitBlock *theInitBlock);pascal void __terminate(void);#ifdef __cplusplus}#endifchar *GetA5TOC(void) = 0x200D;			/* move.l a5,d0 *//* *	The linker will replace this dummy routine with a linker generated routine containing *	a list of calls to all our static initialization routines ... * *					MOVEA.L		(A1),A5 *					LINK		A6,#$FFF8 *					BSR.L		__InitCode0__ *					... *					BSR.L		__InitCodeN__ *					UNLK		A6 *					RTS * *	NB: for now this will only work under the single segment model */void __InitCode__(void){}/* *	__initialize	-	Default initialization routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF initialization routine in the container *	for any multi-fragment application. * */pascal OSErr __initialize(const CFragInitBlock *theInitBlock){#pragma unused(theInitBlock)	/* register this code fragment with the Exception Handling mechanism */	fragmentID = __register_fragment(SEGMAPNAME, GetA5TOC());		/* call all static initializers */	__InitCode__();		/* return success to Code Fragment Manager */	return(noErr);}/* *	__terminate	-	Default termination routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF termination routine in the container *	for any multi-fragment application. * */pascal void __terminate(void){	/* unregister this code fragment with the Exception Handling mechanism */	__unregister_fragment(fragmentID);}