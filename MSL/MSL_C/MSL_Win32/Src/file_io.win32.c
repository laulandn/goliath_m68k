/*  Metrowerks Standard Library  *//*  $Date: 2000/05/18 20:06:46 $  *  $Revision: 1.4.12.3 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//* *	file_io.win32.c *	 *	Routines *	-------- *		__open_file *		__open_temp_file *		__read_file *		__write_file *		__position_file *		__flush_file *		__close_file *		__temp_file_name *		__delete_file *		__rename_file * *		__handle_open *		__handle_reopen * *		__set_idle_proc */#include <cstdlib>/*#include <wstring.h>*//*#include <cwchar>*//*#include <cstring>*//*#include <cerrno>*//*#include <ctime>*/   /* call clock() to get a random number *//*hh 980122 Replaced <windows.h> with the following TWO includes because it is seriously          broken.  The following 2 includes must be carefully ordered as shown, because          they are broken too.#include <windows.h>*/#define WIN32_LEAN_AND_MEAN#include <windows.h>#include <winuser.h>#include "file_io.h"#include <fcntl.h>/*#include <unistd.h> */#include <tchar.h>#if __dest_os==__wince_os #ifdef UNICODE  #define _itot _itow #else  #define _itot _itoa #endif#endif #define _READWRITEMASK  3			/* mm 980909 *//* KO 961120 *//* One of these structs is used for every temporary file that is opened. */typedef struct {	__file_handle	mFileHandle;	 TCHAR			*mFileName;} temp_file_info;static temp_file_info	temp_info[FOPEN_MAX];#ifdef __INTEL__extern unsigned long mytime();#endifstatic temp_file_info * find_temp_info(__file_handle inHandle){	int theCount;	temp_file_info * theTempFileStruct;		for (theCount = 0, theTempFileStruct = temp_info;	     theCount < FOPEN_MAX; theCount++, theTempFileStruct++) {		if (theTempFileStruct->mFileHandle == inHandle)			return(theTempFileStruct);	}		return(0);}int	__open_file(const char * name, __file_modes mode, __file_handle * handle){		int h;		int flag = 0;			if ((mode.io_mode & _READWRITEMASK) == __read) flag |= O_RDONLY;	/* mm 980909 */		if ((mode.io_mode & _READWRITEMASK) == __write) flag |= O_WRONLY;	/* mm 980909 */		if ((mode.io_mode & _READWRITEMASK) == __read_write) flag |= O_RDWR;/* mm 980909 */		if (mode.io_mode & __append) flag |= O_APPEND;				if (mode.binary_io) flag |= O_BINARY;				if (mode.open_mode == __create_if_necessary) flag |= O_CREAT;		if (mode.open_mode == __create_or_truncate) flag |= (O_CREAT | O_TRUNC);					h = _open(name,flag);		if (h == -1) {			return __io_error;		}		else {			*handle = h;			return __no_io_error;		}			}static unsigned int __previous_time=0;void __temp_file_name(char * name_str, void * /*fsspec*/)  /* hh 980122 unused arg commented out */{	WIN32_FIND_DATA fd;	HANDLE			fh;	TCHAR tmpstr[6];  /*  vss 980729  */	int i=0;	       if(name_str)    {		do    	{     		_tcscpy((TCHAR*)name_str,_T(".\\MSL"));#if __INTEL__/* m.f. 020899 _tcscat((TCHAR*)name_str, _itot((mytime()%65536),tmpstr,10) );*/           __previous_time+=GetTickCount();           __previous_time%=65536;     		_tcscat((TCHAR*)name_str, _itot((__previous_time%65536),tmpstr,10) );#else		 		_tcscat((TCHAR*)name_str, _itot((clock()%65536),tmpstr,10) );#endif	 	 		_tcscat((TCHAR*)name_str,_T(".tmp"));	 			 		i++;	 		fh = FindFirstFile((LPCTSTR)name_str,&fd);	 		if (fh != INVALID_HANDLE_VALUE) FindClose(fh);    	}			while(!(GetLastError() == ERROR_FILE_NOT_FOUND) && (i<65536));  /* mm 980708 */			}}int __open_temp_file(__file_handle * handle){	int theError;	temp_file_info * theTempInfo;	TCHAR temp_name[1024];	theTempInfo = find_temp_info(0);		if (!theTempInfo) {return __io_error;}    __temp_file_name((char*)temp_name,	0);	theError = __open_file((char*)temp_name, __temp_file_mode, handle);			if (theError == __no_io_error) 	{		/* The file has successfully opened. Fill in a temporary info struct for it.*/ 		theTempInfo->mFileHandle = *handle;		/* Is 1024 a good max file path length to assume?*/ 		#if (__dest_os==__win32_os)		theTempInfo->mFileName = _fullpath(0, temp_name, 1024);		#else		theTempInfo->mFileName=(TCHAR*)malloc(sizeof(temp_name)+1);		_tcscpy(theTempInfo->mFileName,temp_name);		#endif	}		return theError;}int __read_file(__file_handle handle, unsigned char * buffer, size_t * count, __idle_proc /*idle_proc*/)  /* hh 980122 unused arg commented out */{	fflush(stdout);	/* KO 960903 */	*count =  read(handle,(char *) buffer,*count);	return *count ? __no_io_error : __io_EOF;	/* KO 961104 */}int __write_file(__file_handle handle, unsigned char * buffer, size_t * count, __idle_proc /*idle_proc*/)  /* hh 980122 unused arg commented out */{	size_t n;	n = write(handle,(char *) buffer,*count);	if (n >= *count) {		*count = n;		/*!!CAM!!  Testing */		return  __no_io_error;	}	else {		*count = n;		return __io_error;	}}/*int __position_file(__file_handle handle, long * position, int mode, __idle_proc idle_proc)*/int __position_file(__file_handle handle, fpos_t * position, int mode, __idle_proc /*idle_proc*/)  /* hh 980122 unused arg commented out */{		*position = lseek(handle, *position,mode);	return *position == -1 ? __io_error : __no_io_error;}int __close_file(__file_handle handle){	temp_file_info * theTempInfo;		if (close(handle) == -1) 		return __io_error;		/*	 * If this is a temporary file, there will be a temp_file_info struct for this	 * handle. In that case, delete the file and clean out the temp_file_info struct.	 * File handle 0 is a special case (these are ANSI file handles not Windows file	 * handles). File handle 0 is stdin which is not a temporary file. Since	 * find_temp_info on handle 0 returns an empty temp info structure rather than	 * a "not found" I'm special casing it.	 */	if (handle && (theTempInfo = find_temp_info(handle)) != NULL) {		int theError = __delete_file((char*)theTempInfo->mFileName);		free(theTempInfo->mFileName); /* matches malloc in _open_temp_file */		theTempInfo->mFileHandle = 0;		return theError;			} else {		return __no_io_error;	}}int __delete_file(const char* name){	return DeleteFile((LPCTSTR)name)  ? __no_io_error : __io_error;}int __rename_file(const char * old_name, const char * new_name){	return MoveFile((LPTSTR)old_name,(LPTSTR)new_name) ? __no_io_error : __io_error;}/*     Change RecordKO 960903		I added this flush line so output will be flushed while waiting for input.KO 961104		To accomodate the change mm 961031 in stdio.h.KO 961120		Added code to delete temporary files when they are closed.KO 961209		Fixed __close_file so it does not treat stdin as a temporary file.hh 980122 Replaced <windows.h> with the following TWO includes because it is seriously          broken.  The following 2 includes must be carefully ordered as shown, because          they are broken too.hh 980122 unused arg commented out in 4 placesmf 980518 wince changes-- using microsoft's common "_t" interface for supporting both          wchar and charmm 980708 Corrected terminating condition on construction of temp name to avoid duplicationvss 980729  Fix temp file name generationmm 980909 Changes to make our use of open() conform to Posix specificationmf 990208 fixed tmpfile bug on 486(some 486 machines don't have rdtsr instruction)cc 000209 changed windef.h to #define WIN32_LEAN_AND_MEAN & #include <windows.h>cc 000515 Fixed #include*/