/*********************************************************************This code is adapted from some public domain code written by MatthiasNeeracher.  It allows CW on PPC to call the PLString functions which arein StdCLib.  We can't always link directly to StdCLib because some symbolsconflict with our own ANSI libraries.*********************************************************************/#if !defined(Using_StdCLib)#include <Types.h>/*#include <FragLoad.h>*/#include <CodeFragments.h>#include <signal.h>#include <setjmp.h>#include <stdlib.h>#include <unistd.h>#include <IntEnv.h>Boolean _InitStdCLib();pascal Boolean TrapAvailable (short TrapNumber);int	faccess(char*, unsigned int, long*);int fcntl(int, unsigned int, int);int open(const char*, int);int creat(const char*);int ioctl(int fildes, unsigned int cmd, int *arg);#if !defined(powerc) && !defined(__powerc)#error "This file is neither needed nor working on an 68K"#endif/********************************************************************* * These procedure pointers will hold the glue routines to the MPW code */long	*_mpwerrno;int		*StdCLib_StandAlone;int		*__NubAt3Ptr;void	_BreakPoint(void);int		*__C_phasePtr;int		*_exit_statusPtr;jmp_buf	*__target_for_exitPtr;#pragma options align=mac68kstruct {		short	unknown;		long	ArgC;		char	**ArgV;		char	**EnvP;	} *_IntEnvPtr;#pragma options align=reset#if 0 //plauger_Sigfun*				(*_signal)(int sig, _Sigfun *fun);#endif#if 1 //plauger__signal_func_ptr (*_signal)(long sig,  __signal_func_ptr fun);#endifint 					(*_raise)(int sig);char 					*(*_getenv)(const char *name);static void 			(*StdCLib__BreakPoint)(void);static void 			(*StdCLib_abort)(void);static void 			(*StdCLib_exit)(int);static int 				(*StdCLib_atexit)(void (*func)(void));static int 				(*StdCLib_write)(int fildes, const char *buf, int count);static int 				(*StdCLib_read)(int fildes, char *buf, int count);static int 				(*StdCLib_close)(int fildes);static int 				(*StdCLib_unlink)(const char *path);static long				(*StdCLib_lseek)(int fildes, long offset, int whence);static int	 			(*StdCLib_ioctl)(int fildes, unsigned int cmd, int *arg);static int	 			(*StdCLib_faccess)(char*filename, unsigned int cmd, long* arg);static int	 			(*StdCLib_open)(const char* filename, int oflag);static int	 			(*StdCLib_fcntl)(int fildes, unsigned int cmd, int arg);static int	 			(*StdCLib_creat)(const char* filename);static OSErr			(*StdCLib_MakeResolvedFSSpec)(short volume, long directory, 							StringPtr path, FSSpec *theSpec, Boolean *isFolder, 							Boolean *hadAlias, Boolean *leafIsAlias);static OSErr			(*StdCLib_ResolveFolderAliases) (short volume, long directory, 							StringPtr path, Boolean resolveLeafAlias, FSSpec *theSpec, 							Boolean *isFolder, Boolean *hadAlias, Boolean *leafIsAlias);static OSErr			(*StdCLib_ResolvePath) (char *rawPath, char *resolvedPath, Boolean *isFolder, 							Boolean *hadAlias);static OSErr			(*StdCLib_MakeResolvedPath)(short volume, long directory, StringPtr path, Boolean resolveLeafAlias,							char *buffer, Boolean *isFolder, Boolean *hadAlias, 							Boolean *leafIsAlias);static pascal Boolean	(*StdCLib_TrapAvailable)(short);/*  * Initialize glue if necessary. */	Boolean _InitStdCLib(){	ConnectionID 	StdCLib;	SymClass		symClass;	Ptr 			whoCares;	Str255			error;				/* 	 * We interface to the MPW standard library by dynamically connecting to the 	 * code fragment. This technique has been suggested to me by Charlie Reiman.	 */	if (GetSharedLibrary(			(StringPtr)"\pStdCLib", kPowerPCArch, kLoadLib, &StdCLib, &whoCares, error)	)		return 0;		if (FindSymbol (StdCLib, (StringPtr)"\psignal", (Ptr *)&_signal, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\perrno", (Ptr *) &_mpwerrno, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\praise", (Ptr *) &_raise, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pgetenv", (Ptr *) &_getenv, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pexit", (Ptr *) &StdCLib_exit, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\patexit", (Ptr *) &StdCLib_atexit, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pabort", (Ptr *) &StdCLib_abort, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\p__NubAt3", (Ptr *) &__NubAt3Ptr, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\p__C_phase", (Ptr *) &__C_phasePtr, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\p_IntEnv", (Ptr *) &_IntEnvPtr, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\p_exit_status", (Ptr *) &_exit_statusPtr, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\p__target_for_exit", (Ptr *) &__target_for_exitPtr, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\p_BreakPoint", (Ptr *) &StdCLib__BreakPoint, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pwrite", (Ptr *) &StdCLib_write, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pread", (Ptr *) &StdCLib_read, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pclose", (Ptr *) &StdCLib_close, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\punlink", (Ptr *) &StdCLib_unlink, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\plseek", (Ptr *) &StdCLib_lseek, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pfcntl", (Ptr *) &StdCLib_fcntl, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\popen", (Ptr *) &StdCLib_open, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pioctl", (Ptr *) &StdCLib_ioctl, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pfaccess", (Ptr *) &StdCLib_faccess, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pcreat", (Ptr *) &StdCLib_creat, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pStandAlone", (Ptr *) &StdCLib_StandAlone, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pResolveFolderAliases", (Ptr *) &StdCLib_ResolveFolderAliases, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pMakeResolvedFSSpec", (Ptr *) &StdCLib_MakeResolvedFSSpec, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pResolvePath", (Ptr *) &StdCLib_ResolvePath, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pMakeResolvedPath", (Ptr *) &StdCLib_MakeResolvedPath, &symClass))		goto failed;	if (FindSymbol (StdCLib, (StringPtr)"\pTrapAvailable", (Ptr *) &StdCLib_TrapAvailable, &symClass))		goto failed;return 1;failed:	return 0;}void	_BreakPoint(void){		StdCLib__BreakPoint();}void	abort(void){		StdCLib_abort();}int (atexit)(void (*func)(void)){		StdCLib_atexit(func);}void	(exit)(int x){		StdCLib_exit(x);}int write(int fildes, const char *buf, int count){	return(StdCLib_write(fildes, buf, count));}int read(int fildes, char *buf, int count){	return(StdCLib_read(fildes, buf, count));}int close(int fildes){	return(StdCLib_close(fildes));}int unlink(const char *path){	return(StdCLib_unlink(path));}long lseek(int fildes, long offset, int whence){	return(StdCLib_lseek(fildes, offset, whence));}int faccess(char*filename, unsigned int cmd, long* arg){	return(StdCLib_faccess(filename, cmd, arg));}int fcntl(int fildes, unsigned int cmd, int arg){	return(StdCLib_fcntl(fildes, cmd, arg));}int open(const char* filename, int oflag){	return(StdCLib_open(filename, oflag));}int ioctl(int fildes, unsigned int cmd, int *arg){	return(StdCLib_ioctl(fildes, cmd, arg));}int creat(const char* filename){	return(StdCLib_creat(filename));}OSErr MakeResolvedFSSpec(short volume, long directory, StringPtr path,						  FSSpec *theSpec, Boolean *isFolder, Boolean *hadAlias,						  Boolean *leafIsAlias){	return StdCLib_MakeResolvedFSSpec (volume, directory, path, theSpec, isFolder, 		hadAlias, leafIsAlias);}OSErr ResolveFolderAliases (	/* Info in  */	short volume, long directory, StringPtr path, Boolean resolveLeafAlias,	/* Info out */	FSSpec *theSpec, Boolean *isFolder, Boolean *hadAlias, Boolean *leafIsAlias){	return StdCLib_ResolveFolderAliases(volume, directory, path, resolveLeafAlias,		theSpec, isFolder, hadAlias, leafIsAlias);}OSErr ResolvePath (char *rawPath, char *resolvedPath, Boolean *isFolder, Boolean *hadAlias){	return StdCLib_ResolvePath (rawPath, resolvedPath, isFolder, hadAlias);}OSErr MakeResolvedPath(short volume, long directory, StringPtr path, Boolean resolveLeafAlias,				char *buffer, Boolean *isFolder, Boolean *hadAlias, Boolean *leafIsAlias){	return StdCLib_MakeResolvedPath (volume, directory, path, resolveLeafAlias,						buffer, isFolder, hadAlias, leafIsAlias);}pascal Boolean TrapAvailable (short TrapNumber){	return StdCLib_TrapAvailable (TrapNumber);}#endif