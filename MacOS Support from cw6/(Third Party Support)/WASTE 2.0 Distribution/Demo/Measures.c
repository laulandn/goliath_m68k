/* *	WASTE Demo Project: *	Measure conversions * *	Copyright © 1993-2000 Marco Piovanelli *	All Rights Reserved * *	C port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#include "Measures.h"//	Mac OS #includes#ifndef __RESOURCES__#include <Resources.h>#endif#ifndef __INTLRESOURCES__#include <IntlResources.h>#endif#ifndef __SCRIPT__#include <Script.h>#endif#ifndef __ERRORS__#include <Errors.h>#endif#ifndef __FIXMATH__#include <FixMath.h>#endif#ifndef __FP__#include <fp.h>#endif#ifndef __NUMBERFORMATTING__#include <NumberFormatting.h>#endif//	externally defined routinesextern void ForgetHandle ( Handle * ) ;//	private constants and data typesenum{	kTypeUnitDesc	=	FOUR_CHAR_CODE ( 'UNIT' ),		//	type of unit description resources	kUnitBaseID		=	128								//	IDs of UNIT resources start from here} ;typedef struct UnitDesc{	UnitCode			code ;			//	unit code (should be = resource ID - kUnitBaseID)	UInt16				unused ;		//	padding	Fixed				convFactor ;	//	to convert to points, multiply by this factor	NumFormatString		formatSpec ;	//	canonical number format string} UnitDesc, * UnitDescPtr, ** UnitDescHandle ;//	private routinesstatic OSStatus FillPartsTable ( 			NumberParts *		outPartsTable ){	Handle		tableHandle = nil ;	SInt32		tableOffset = 0 ;	SInt32		tableSize = 0 ;	OSStatus	err ;	//	get the default number parts table for the system script	GetIntlResourceTable ( smSystemScript, smNumberPartsTable, & tableHandle, & tableOffset, & tableSize ) ;	if ( ( err = ResError ( ) ) != noErr )	{		goto cleanup ;	}	err = resNotFound ;	if ( tableHandle == nil )		//	should never happen, but checking doesn't hurt	{		goto cleanup ;	}	//	copy table to specified address	BlockMoveData ( * tableHandle + tableOffset, outPartsTable, sizeof ( * outPartsTable ) ) ;	//	clear result code	err = noErr ;cleanup :	//	return result code	return err ;}static OSStatus GetUnitInfo (				UnitCode			inUnit,											double_t *			outConversionFactor,											NumFormatString *	outFormat ){	Handle			descriptor ;	UnitDesc *		pDesc ;	SInt8			saveHState ;	OSStatus		err ;	//	get handle to unit descriptor resource	descriptor = GetResource ( kTypeUnitDesc, kUnitBaseID + inUnit ) ;	if ( ( err = ResError ( ) ) != noErr )	{		goto cleanup ;	}	err = resNotFound ;	if ( descriptor == nil )		//	should never happen, but checking doesn't hurt	{		goto cleanup ;	}	//	lock it	saveHState = HGetState ( descriptor ) ;	HLock ( descriptor ) ;	pDesc = * ( UnitDescHandle ) descriptor ;	//	get unit conversion factor as a double_t quantity	* outConversionFactor = Fix2X ( pDesc -> convFactor ) ;	//	get canonical format string	BlockZero ( outFormat, sizeof ( * outFormat ) ) ;	BlockMoveData ( & pDesc -> formatSpec, outFormat, pDesc -> formatSpec . fLength + 1 ) ;	//	unlock the unit descriptor resource	HSetState ( descriptor, saveHState ) ;	//	clear result code	err = noErr ;cleanup :	//	return result code	return err ;}static OSStatus ExtractUnitCode (			ConstStr255Param	inRepresentation,											UnitCode *			outUnit ){	//	parse representation, find the unit symbol (if any) and translate it to a unit code	enum { kMaxTokens = 8 } ;	Handle			tokenTables ;	TokenBlock		pb ;	TokenRec		tokenList [ kMaxTokens ] ;	TokenResults	resultCode ;	int				tokenIndex ;	TokenRec *		token ;	UnitString		symbol ;	Handle			descriptor ;	OSStatus		err ;	//	get a handle to the token tables for the current script	tokenTables = GetIntlResource ( tokenIntl ) ;	if ( ( err = ResError ( ) ) != noErr )	{		goto cleanup ;	}	err = resNotFound ;	if ( tokenTables == nil )		//	should never happen, but checking doesn't hurt	{		goto cleanup ;	}	//	set up the parameter block for the tokenizer	BlockZero ( & pb, sizeof ( pb ) ) ;	BlockZero ( tokenList, sizeof ( tokenList ) ) ;	pb . source = ( char * ) ( inRepresentation + 1 ) ;	pb . sourceLength = StrLength ( inRepresentation ) ;	pb . tokenList = ( char * ) tokenList ;	pb . tokenLength = kMaxTokens ;	pb . itlResource = tokenTables ;	//	tokenize our string	resultCode = IntlTokenize ( & pb ) ;	//	return an error code if tokenization has failed	err = errMeasuresTokenizationFailed ;	if ( resultCode != tokenOK )	{		goto cleanup ;	}	//	walk the token list generated by the tokenizer	for ( tokenIndex = 0, token = tokenList ; tokenIndex < pb . tokenCount ; tokenIndex ++, token ++ )	{		//	we're only really interested in alphabetic strings representing units		if ( token -> theToken != tokenAlpha )		{			continue ;		}		//	make sure maximum unit symbol length isn't exceeded		err = errMeasuresSyntaxError ;		if ( token -> length > kMaxUnitSymbolLength )		{			goto cleanup ;		}		//	make a copy of the token string		BlockMoveData ( token -> position, symbol + 1, token -> length ) ;		symbol [ 0 ] = token -> length ;		//	assuming this token is a unit symbol, try to get the associated unit descriptor		if ( ( descriptor = GetNamedResource ( kTypeUnitDesc, symbol ) ) != nil )		{			//	if a descriptor was successfully found, return the unit code			* outUnit = ( * ( UnitDescHandle ) descriptor ) -> code ;			break ;		}	}	//	clear result code	err = noErr ;cleanup :	//	return result code	return err ;}pascal OSStatus MeasureToString (			Fixed				inCanonicalValue,											UnitCode			inUnit,											Str255				outRepresentation ){	NumberParts			partsTable ;	NumFormatString		format ;	double_t			factor ;	double_t			value ;	extended80			x ;	FormatResultType	resultCode ;	OSStatus			err ;	* outRepresentation = 0 ;	//	get the default number parts table for the system script	if ( ( err = FillPartsTable ( & partsTable ) ) != noErr )	{		goto cleanup ;	}	//	get unit conversion factor and canonical format string	if ( ( err = GetUnitInfo ( inUnit, & factor, & format ) ) != noErr )	{		goto cleanup ;	}	//	convert specified value to double_t	value = Fix2X ( inCanonicalValue ) ;	//	perform unit conversion	value /= factor ;#if TARGET_CPU_PPC	//	on the PowerPC, double_t values are 64-bit wide, but ExtendedToString wants	//	an 80-bit wide extended value, so we have to perform an additional conversion step	dtox80 ( & value, & x ) ;#else	//	on the 68K (with 68881 code generation disabled), double_t is the same as extended80	x = value ;#endif	//	convert Extended value to a string representation	resultCode = ExtendedToString ( & x, & format, & partsTable, outRepresentation ) ;	//	return an error code if the conversion process wasn't completely successfully	err = errMeasuresBadValue ;	if ( resultCode != fFormatOK )	{		goto cleanup ;	}	//	clear result code	err = noErr ;cleanup :	//	return result code	return err ;}pascal OSStatus StringToMeasure (			ConstStr255Param	inRepresentation,											UnitCode			inDefaultUnit,											Fixed *				outCanonicalValue ){	UnitCode			unit = inDefaultUnit ;	NumberParts			partsTable ;	NumFormatString		format ;	double_t			factor ;	double_t			value ;	extended80			x ;	FormatResultType	resultCode ;	OSStatus			err ;	//	extract any explicit unit symbol from the representation string	if ( ( err = ExtractUnitCode ( inRepresentation, & unit ) ) != noErr )	{		goto cleanup ;	}	//	get the default number parts table for the system script	if ( ( err = FillPartsTable ( & partsTable ) ) != noErr )	{		goto cleanup ;	}	//	get unit conversion factor and canonical format string	if ( ( err = GetUnitInfo ( unit, & factor, & format ) ) != noErr )	{		goto cleanup ;	}	//	convert the string representation to an extended80 value	resultCode = StringToExtended ( inRepresentation, & format, & partsTable, & x ) ;#if TARGET_CPU_PPC	value = x80tod ( & x ) ;#else	value = x ;#endif	//	fFormatOK, fBestGuess and fSpuriousChars are acceptable; other result codes aren't	err = errMeasuresSyntaxError;	if ( ( resultCode != fFormatOK ) &&		 ( resultCode != fBestGuess ) &&		 ( resultCode != fSpuriousChars ) )	{		goto cleanup ;	}	//	perform unit conversion	value *= factor ;	//	return numeric result as a Fixed quantity	* outCanonicalValue = X2Fix ( value ) ;	//	clear result code	err = noErr ;cleanup :	//	return result code	return err ;}pascal OSStatus NewUnit (					UnitCode			inUnit,											Fixed				inConversionFactor,											ConstStr255Param	inFormatString,											Handle *			outDescriptor ){	NumberParts		partsTable ;	UnitDesc *		pDesc ;	OSStatus		err ;	* outDescriptor = nil ;	//	get the default number parts table for the system script	if ( ( err = FillPartsTable ( & partsTable ) ) != noErr )	{		goto cleanup ;	}	//	allocate the descriptor handle	* outDescriptor = NewHandleClear ( sizeof ( UnitDesc ) ) ;	if ( ( err = MemError ( ) ) != noErr )	{		goto cleanup ;	}	//	lock the handle	HLock ( * outDescriptor ) ;	pDesc = * ( UnitDescHandle ) ( * outDescriptor ) ;	//	fill in unit code and conversion factor	pDesc -> code = inUnit ;	pDesc -> convFactor = inConversionFactor ;	//	convert the human-readable format string to a format specification record	if ( ( err = StringToFormatRec ( inFormatString, & partsTable, & pDesc -> formatSpec ) ) != noErr )	{		goto cleanup ;	}	//	trim excess fat	SetHandleSize ( * outDescriptor, pDesc -> formatSpec . fLength +		( sizeof ( UnitDesc ) - sizeof ( NumFormatString ) + 1 ) ) ;	//	unlock the handle	HUnlock ( * outDescriptor ) ;	//	clear result code	err = noErr ;cleanup :	//	get rid of the handle if an error occurred	if ( err )	{		ForgetHandle ( outDescriptor ) ;	}	//	return result code	return err ;}pascal OSStatus NewUnitResource (			UnitCode			inUnit,											Fixed				inConversionFactor,											ConstStr255Param	inFormatString,											ConstStr255Param	inUnitSymbol ){	Handle			descriptor ;	OSStatus		err ;	//	create a new unit descriptor	if ( ( err = NewUnit ( inUnit, inConversionFactor, inFormatString, & descriptor ) ) != noErr )	{		goto cleanup ;	}	//	add it to the current resource map as a UNIT resource	AddResource ( descriptor, kTypeUnitDesc, kUnitBaseID + inUnit, inUnitSymbol ) ;	if ( ( err = ResError ( ) ) != noErr )	{		goto cleanup ;	}	//	write the resource	WriteResource ( descriptor ) ;	if ( ( err = ResError ( ) ) != noErr )	{		goto cleanup ;	}	//	release it	ReleaseResource ( descriptor ) ;	//	clear result code	err = noErr ;cleanup :	//	return result code	return err ;}