/* *	CFM68K_StartupDropIn.c	-	init/startup/termination routines for Metrowerks C++ (CFM68K) * *	Copyright © 1995-1997 Metrowerks, Inc. All Rights Reserved. * * *	THEORY OF OPERATION * *	This version of the PPC startup code is intended to be used for drop-in *	components of multi-fragment applications. It is designed to properly support *	exceptions thrown across fragment boundaries, and proper initialization and *	termination--including construction and destruction of static objects--for *	a drop-in that is one component of a complex, multi-fragment program, and which *	is loaded and unloaded (possibly more than once) while the application is running. * *	The startup file defines 2 entry-points: * *		__initialize	This must be the Initialization Entry-Point for the Application. *						__initialize() registers the exception-handling info for *						the application, and calls all static initializers. * *		__terminate		This must be the Termination Entry-Point for the Application *						__terminate() calls destructors for static objects defined by *						the drop-in, and unregisters the exception-handling info *						before the fragment is unloaded. * *	The new zero-runtime-overhead exception-handling mechanism requires that we *	keep track of all loaded fragments and their code/data section ranges--we *	cannot use the OS data structures to do this--so we must call routines which *	register and unregister the exception-handling info as a fragment is loaded/unloaded. * *	When the drop-in is loaded, __InitCode__() will call constructors for static *	objects, linking them into the (drop-in specific) global destructor chain. These *	objects will be destroyed by the __terminate() routine when the dropin fragment *	is unloaded. Because the dropin may be loaded/unloaded dynamically as the program *	is running, it must have its own global destructor chain. * */#include <CodeFragments.h>#include <Exception68K.h>#include <NMWException.h>#include <Types.h>	/*	external data	*/extern far segment_map SEGMAPNAME[];	/*	private data	*/static long fragmentID;						/*	ID given to fragment by exception-handling	*/	/*	prototypes	*/#ifdef __cplusplusextern "C" {#endif#pragma internal onvoid __InitCode__(void);#pragma internal resetpascal OSErr __initialize(const CFragInitBlock *theInitBlock);pascal void __terminate(void);#ifdef __cplusplus}#endifchar *GetA5TOC(void) = 0x200D;			/* move.l a5,d0 *//* *	The linker will replace this dummy routine with a linker generated routine containing *	a list of calls to all our static initialization routines ... * *					MOVEA.L		(A1),A5 *					LINK		A6,#$FFF8 *					BSR.L		__InitCode0__ *					... *					BSR.L		__InitCodeN__ *					UNLK		A6 *					RTS * *	NB: for now this will only work under the single segment model */void __InitCode__(void){}/* *	__initialize	-	Default initialization routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF initialization routine in the container *	for any multi-fragment application. * */pascal OSErr __initialize(const CFragInitBlock *theInitBlock){#pragma unused (theInitBlock)	/* register this code fragment with the Exception Handling mechanism */	fragmentID = __register_fragment(SEGMAPNAME, GetA5TOC());		/* call all static initializers */	__InitCode__();		/* return success to Code Fragment Manager */	return(noErr);}/* *	__terminate	-	Default termination routine for Metrowerks C++ (CFM68K) * *	This routine should be specified as the PEF termination routine in the container *	for any multi-fragment application. * */pascal void __terminate(void){	/* destroy all static objects */	__destroy_global_chain();	/* unregister this code fragment with the Exception Handling mechanism */	__unregister_fragment(fragmentID);}