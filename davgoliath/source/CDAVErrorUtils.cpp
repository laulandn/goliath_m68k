/* ================================================================================================== * CDAVErrorUtils.cpp															    *    Goliath - a Finder like application that implements WebDAV *    Copyright (C) 1999-2002  Thomas Bednarz * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com * =========================================================================== */#ifndef __CDAVERRORUTILS_h__#include "CDAVErrorUtils.h"#endif#ifndef _H_LHTTPResponse#include <LHTTPResponse.h>#endif#ifndef _H_LStaticText#include <LStaticText.h>#endif#ifndef __CDAVTableApp_h__ #include "CDAVTableApp.h"#endif#ifndef __CDAVCONNECTION_H__#include <CDAVConnection.h>#endif#include <string.h>// ---------------------------------------------------------------------------//		¥ DisplayDAVError()// ---------------------------------------------------------------------------//	void CDAVErrorUtils::DisplayDAVError(const LHTTPResponse *inResponse, const char* inDisplayString) {	const char* theError = inResponse->GetResponse();	    LStr255 errUIPString(str_UIStrings, str_UnknownConnectionErr);     std::string errUICstring;    errUICstring.assign(errUIPString.ConstTextPtr(), errUIPString.Length());		//against Apache 1.3.x on Win32 systems, the connection fails and returns a	//status of zero.  No time to track this one down right now, unfortunately.	if (((NULL==theError) || (strcmp(theError,"")==0)) && (NULL != inDisplayString)) {	   theError = inDisplayString;	   _DoDisplayDlog(theError);	   return;	} else {		DisplayDAVError(inResponse->GetResponseCode());	}		   }// ---------------------------------------------------------------------------//		¥ DisplayDAVError()// ---------------------------------------------------------------------------//	void CDAVErrorUtils::DisplayDAVError(SInt32 inErrorCode) {    std::string errUICstring;        if (CDAVConnection::kHTTPRequestUnauthorized == inErrorCode) {    	LStr255 errUIPString(str_ErrorStrings, str_errRequestUnauthorized);     	errUICstring.assign(errUIPString.ConstTextPtr(), errUIPString.Length());    } else if (CDAVConnection::kHTTPForbidden == inErrorCode) {    	LStr255 errUIPString(str_ErrorStrings, str_errRequestForbidden);     	errUICstring.assign(errUIPString.ConstTextPtr(), errUIPString.Length());    } else if (CDAVConnection::kHTTPNotFound == inErrorCode) {    	LStr255 errUIPString(str_ErrorStrings, str_errNotFound);     	errUICstring.assign(errUIPString.ConstTextPtr(), errUIPString.Length());    } else if (CDAVConnection::kHTTPMethodNotAllowed == inErrorCode) {    	LStr255 errUIPString(str_ErrorStrings, str_errNotAllowed);     	errUICstring.assign(errUIPString.ConstTextPtr(), errUIPString.Length());    } else {    	LStr255 errUIPString(str_UIStrings, str_UnknownConnectionErr);     	errUICstring.assign(errUIPString.ConstTextPtr(), errUIPString.Length());    }    	_DoDisplayDlog(errUICstring.c_str());}// ---------------------------------------------------------------------------//		¥ DisplayNoDAVSupportDlog()// ---------------------------------------------------------------------------//	void CDAVErrorUtils::DisplayNoDAVSupportDlog() {	PP_PowerPlant::StDialogHandler dialog(300,  GetApplicationInstance());	Assert_(dialog.GetDialog() != nil);	while (true) {		PP_PowerPlant::MessageT hitMessage = dialog.DoDialog();	    if (hitMessage == PP_PowerPlant::msg_OK)		   break;	}}// ---------------------------------------------------------------------------//		¥ DisplayDAVError()// ---------------------------------------------------------------------------//	void CDAVErrorUtils::DisplayDAVError(ResIDT inStrModule, ResIDT inStrId) {	LStr255 tmpStr(inStrModule, inStrId);	std::string tmpCstr;	tmpCstr.assign(tmpStr.TextPtr(), tmpStr.Length());		_DoDisplayDlog(tmpCstr.c_str());}// ---------------------------------------------------------------------------//		¥ _DoDisplayDlog()// ---------------------------------------------------------------------------//	void CDAVErrorUtils::_DoDisplayDlog(const char* inDisplayStr) {	PP_PowerPlant::StDialogHandler dialog(1300,  GetApplicationInstance());	Assert_(dialog.GetDialog() != nil);    PP_PowerPlant::LStaticText* errorField = dynamic_cast<PP_PowerPlant::LStaticText*>									(dialog.GetDialog()->FindPaneByID('ERRT'));		ThrowIfNil_ (errorField);	errorField->SetText(const_cast<char*>(inDisplayStr), strlen(inDisplayStr));	dialog.GetDialog()->Show();	while (true) {		PP_PowerPlant::MessageT hitMessage = dialog.DoDialog();	    if (hitMessage == PP_PowerPlant::msg_OK)			break;	}}// ---------------------------------------------------------------------------------//		¥ ReportInternalError// ---------------------------------------------------------------------------------//	void CDAVErrorUtils::ReportInternalError(ConstStringPtr inErrMsg) {	LStr255 msgStr;		if (NULL != inErrMsg) {	   msgStr.Append(LStr255(str_UIStrings ,str_InternalError));	   msgStr.Append(inErrMsg);	} else {	   msgStr.Append(LStr255(str_UIStrings ,str_InternalErrorNoParamText));		}		::ParamText(msgStr, Str_Empty, Str_Empty, Str_Empty);	UModalAlerts::CautionAlert(129);}