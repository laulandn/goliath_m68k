/*  Metrowerks Standard Library  *//*  $Date: 2000/08/19 19:32:35 $  *  $Revision: 1.12.8.3.2.5 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//* *	abort_exit.c *	 *	Routines *	-------- *		abort * *		atexit *		exit * *		__atexit *		__exit * *		__setup_exit *	 * */#include "abort_exit.h"#include "critical_regions.h"#include "misc_io.h"#include <csignal>#include <setjmp.h>#include <cstdlib>#include <cstdio>#include <pool_alloc.h>			/*  mf 980825  */#if macintosh && !defined(__dest_os)               /*MW-mm 960927a*/  #define __dest_os __mac_os                       /*MW-mm 960927a*/#endif                                             /*MW-mm 960927a*/#if __dest_os == __undef_os	#error __dest_os undefined#endif#if __dest_os == __mac_os	#include <console.h>	#include <SegLoad.h>	#include <Processes.h>#endif#if __dest_os == __win32_os || __dest_os == __wince_os	#include <stdarg.h>	#include <wchar.h>	#define WIN32_LEAN_AND_MEAN	#include <windows.h>#endif#define max_funcs	64#if defined(__CFM68K__)	#pragma import on#endifextern void __destroy_global_chain(void);#if defined(__CFM68K__)	#pragma import reset#endifint	__aborting = 0;       /* hh 971206  just moved from below *//*static void (*atexit_funcs[max_funcs])(void);static long	atexit_curr_func = 0;*/#if( __dest_os==__win32_os)extern void (*_atexit_funcs[])(void);extern long  _atexit_curr_func;#elsestatic void (*atexit_funcs[max_funcs])(void);static long	atexit_curr_func = 0;#endifstatic void (*__atexit_funcs[max_funcs])(void);static long	__atexit_curr_func = 0;void (* __stdio_exit)  (void) = 0;void (* __console_exit)(void) = 0;#if (__dest_os == __win32_os) && (STOP_PROGRAM_BEFORE_EXIT==1)	/* mm 981227 */static void __StopProgramBeforeExit();							/* mm 981227 */#endif															/* mm 981227 */#if __dest_os == __be_os							/* ELR */extern void (*__atexit_hook)(void);extern void (*___atexit_hook)(void);extern void ___teardown_be(int);static short exitSetup = 0;static void ANSI_Exit(void){	exit(0);}static void ANSI__Exit(void){	__exit(0);}void __setup_exit(void){	if (!exitSetup)	{		__atexit_hook	 = ANSI_Exit;		___atexit_hook = ANSI__Exit;		exitSetup++;	}}#endifvoid abort(void){#if (__dest_os == __win32_os) && (_WINSIOUX==1)						/* mm 981227 */	WinSIOUXAbort();												/* mm 981227 */#elif (__dest_os == __win32_os) && (STOP_PROGRAM_BEFORE_EXIT==1)	/* mm 981227 */	__StopProgramBeforeExit();										/* mm 981227 */#endif																/* mm 981227 */	raise(SIGABRT);		__aborting = 1;		exit(EXIT_FAILURE);}#if !(__dest_os == __win32_os)int atexit(void (*func)(void)){		if (atexit_curr_func == max_funcs)		return(-1);	__begin_critical_region(atexit_funcs_access);	/* 961218 KO */		__setup_exit();		atexit_funcs[atexit_curr_func++] = func;		__end_critical_region(atexit_funcs_access);	return(0);}int __atexit(void (*func)(void)){		if (__atexit_curr_func == max_funcs)		return(-1);	__begin_critical_region(atexit_funcs_access);	/* 961218 KO */		__setup_exit();		__atexit_funcs[__atexit_curr_func++] = func;		__end_critical_region(atexit_funcs_access);		return(0);}#endif /* #if !(__dest_os == __win32_os) *//*  mdf  971021  */#if (__dest_os == __win32_os) && (STOP_PROGRAM_BEFORE_EXIT==1)static void __StopProgramBeforeExit(){	DWORD read;	HANDLE h;	SECURITY_ATTRIBUTES sa={sizeof(SECURITY_ATTRIBUTES),NULL,TRUE};	char* buf="\n";	if(GetFileType(GetStdHandle(STD_OUTPUT_HANDLE))==FILE_TYPE_CHAR)	{				printf("\n \n Press Enter to continue \n");		/*  fflush(stdin);                   remove line  mdf  971119  */		/*  971019  mdf  */		h=CreateFile("CONIN$",				       GENERIC_READ | GENERIC_WRITE,					   FILE_SHARE_READ | FILE_SHARE_WRITE,					   &sa,				       OPEN_EXISTING,NULL,NULL);						       		if(!ReadFile(h, &buf, 1, &read,0))		{			read=GetLastError();			printf("exit routine error GetLastError=%i \n",read);		}	}	return;}#endif		/*  971019  end insert code  mdf  */	#if defined(__m56800__)	void exit_dsp568();	void exit(int status)	{		exit_dsp568();	}#elif defined(__m56300__)	void exit_dsp563();	void exit(int status)	{		exit_dsp563();	}#else#if __dest_os == __be_os							/* ELR */void _libc_exit_(int status)#elsevoid exit(int status)#endif{		if (!__aborting)	{		__begin_critical_region(atexit_funcs_access);#if (__dest_os == __win32_os)		while (_atexit_curr_func > 0)			(*_atexit_funcs[--_atexit_curr_func])();		#else		while (atexit_curr_func > 0)			(*atexit_funcs[--atexit_curr_func])();#endif			#if (__dest_os == __win32_os) && (_WINSIOUX==1)					/* mm 990122 */		WinSIOUXAbort();										/* mm 990122 */#elif (__dest_os == __win32_os) && (STOP_PROGRAM_BEFORE_EXIT==1)/* mm 990122 */		__StopProgramBeforeExit();								/* mm 981227 */#endif															/* mm 981227 */		__end_critical_region(atexit_funcs_access);	 /*	 970218 bkoz	 		need to move destroy global chain above __stdio_exit as		 	some static objects may have destructors that flush streams	 */	/* #if !__INTEL__ */	 #if __INTEL__ || __POWERPC__ || __CFM68K__ || (__MC68K__ && __A5__) || (__dest_os == __be_os)		__destroy_global_chain();	 #endif	 #if  __PPC_EABI__		{			typedef void (*voidfunctionptr) (void);	/* ptr to function returning void */			extern voidfunctionptr _dtors[];			voidfunctionptr *destructor;			/*			 *	call other destructors			 */			 for (destructor = _dtors; *destructor; destructor++) {			 	(*destructor)();			 }		}	 #endif/*	 #endif */#if !(__dest_os == __win32_os)		if (__stdio_exit)		{			(*__stdio_exit)();			__stdio_exit = 0;		}#endif			}	__exit(status);}#endif /* defined(__m56800__) */                   /* mm 981015 */ /* mm 981029 */void __exit(int status){#if __dest_os != __be_os	#pragma unused(status)#endif		__begin_critical_region(atexit_funcs_access);	while (__atexit_curr_func > 0)		(*__atexit_funcs[--__atexit_curr_func])();		__end_critical_region(atexit_funcs_access);#if __dest_os == __win32_os	_CleanUpMSL();#else	__kill_critical_regions(); #endif		if (__console_exit)	{		(*__console_exit)();		__console_exit = 0;	}#if __dest_os == __mac_os	ExitToShell();#elif __dest_os == __be_os															/* ELR */	___teardown_be(status);#elif __dest_os == __win32_os	ExitProcess(status);	#elif __dest_os == __wince_os	TerminateProcess(GetCurrentProcess(),status);	/*CE doesn't have ExitProcess */	  #elif __dest_os == __ppc_eabi || __dest_os == __nec_eabi || __dest_os == __emb_68k  /*  990727  beb  */	_ExitProcess();													#endif}/* hh 980122 #include "critical_regions.h" doesn't belong here#include "critical_regions.h"*//*     Change record *	14-Sep-95 JFH  First code release. *	12-Oct-95 JFH  Added #include of <SegLoad.h> for ExitToShell() (in case *								 MacHeaders not included). *	31-Oct-95 JFH  Fixed exit() to longjmp(__program_exit,1) instead of call _exit on PPC *	15-Dec-95 JFH  Reworked abort/exit handling to conform to new runtime architecture. *	20-Dec-95 JFH  Renamed _atexit/_exit to __atexit/__exit for ANSI naming conformance *	27-Dec-95 JFH  Pulled guts out of __setup_exit for new runtime. Tossed __program_exit *								 and added __aborting for PPC and CFM68K projects. *	12-Feb-96 JFH  Tossed __setup_exit, which had become a NOP. *	 1-Mar-96 JFH  Merged Be code into source. For the moment that means: __setup_exit(), *								 it's baaack! *	26-Apr-96 JFH  Merged Win32 changes in. *						CTV * MW-mm 960927a   Made sure dest_os set for Macintosh *  18-Dec-96 KO   Moved the begin_critical_region call after the error check. Before, if *                 there was an error, the critical section would be entered and never left. *  19-Dec-96 KO   Added CleanUpMSL. *  18-feb-97 bkoz line 154 moved call of __destroy_global_chain() up to  *			       exit() before stdio closed *	20-Jul-97 MEA  Changed __ppc_eabi_bare to __ppc_eabi. *  21-Aug-97 mdf  added printf/scanf to exit for win32 to allow control of *                 console apps  	 *  30-Sept-97 mdf wrapped immediately above change in GetFileType to prevent app from *				   stopping when output is redirected to a file. *                 Also add fflush so getc will have an empty stream                   when called in the exit routine		    *  21-Oct-97	mdf fixed exiting for windows console apps in cases where                    the app explicitly closes stdin before exit is reached.                    this can be done with fclose or freopen and then close on                    the file associated with the stdin stream.        *  19-Nov-97  mdf  Removed fflush on stdin                 * hh 980122      #include "critical_regions.h" doesn't belong here * #include <Windows.h> hh 980122 commented out.  A real problem child.                                  The next two includes do the job right. * mf 980512        changes for wince   * mf/blc 98081098  fix to x86 runtime dll crash(when > 1 dll is attached to MSL)  * mf  980825  		Deallocate memory pools allocated by system - this fixes a *					problem with memory leaking when multiple dll's are loaded and *					unloaded.                                * mm 981015        Added version of exit for __DSP568 * mea 981022       added calls to destructors   * mm 981029        Changed __DSP568 to __m56800__ * mm 981227        Avoided closing console windows during abort. WB1-1897 * mm 990122        Avoided closing console windows during exit. * hh 990227        Interface to __pool_free_all changed * beb 990727		Added __emb_68k to the guard around call to _ExitProcess. * mf  000514       call to __kill_critical_regions() in __exit was deleting data used                     by the dll upon unloading. This was crashing on windows.  The call to                     _CleanUpMSL() will simply tell the dll that the process is exiting and                    allow the dll to cleanup up it's own resources when it is sure all processes                    are detached.* mf  000731        reversed the order of calling __destroy_global_chain, and (*__stdio_exit)().                    __destroy_global_chain must occur first since one of the destructors it calls                    could rely on one of the standard handles (which __stdio_exit destroys).                    * mf 000808         moved _CleanUpMSL() into extras.win32.c.  This must always be in the dll.                    it can't be in the same source as abort_exit.c because of complications with                    the shared library.  See additional notes in extras.win32.c.  Also, atexit                    will be moved into atexit.c  for similar reasons. It is just preprocessed out                    for windows until next release.                                     */