// ===========================================================================//	UCarbonEvents.cp			PowerPlant 2.1			 ©2000 Metrowerks Inc.// ===========================================================================////	Carbon Event handler functions suitable for use with LEventHandlerFunctor#include <UCarbonEvents.h>#include <LCarbonWindow.h>#include <LCommander.h>#include <LMenuBar.h>#include <MacWindows.h>#include <Menus.h>PP_Begin_Namespace_PowerPlant// ---------------------------------------------------------------------------//	¥ DoSuspend// ---------------------------------------------------------------------------OSStatusUCarbonEvents::DoSuspend(	EventHandlerCallRef	/* inCallRef */,	EventRef			/* inEventRef */){	::HiliteMenu(0);				// Unhighlight menu titles	::HideFloatingWindows();		// When in the background, the program does not receive		// keystrokes and menu commands. Therefore, no Commander		// is on duty, and the Target should be nil.			LCommander::ForceTargetSwitch(nil);	return noErr;}// ---------------------------------------------------------------------------//	¥ DoResume// ---------------------------------------------------------------------------OSStatusUCarbonEvents::DoResume(	EventHandlerCallRef	/* inCallRef */,	EventRef			/* inEventRef */){	::ShowFloatingWindows();		if (LCommander::GetTarget() == nil) {				// Some Commander must be the Target when the program is			// in the foreground. No Window (or Window SubCommander)			// became the Target when the Desktop resumed, so we need			// to restore the Target here. The Target will be some			// Commander that's not part of a Window, possibly the			// Application itself.					LCommander	*topCommander = LCommander::GetTopCommander();		if (topCommander != nil) {			topCommander->RestoreTarget();		}	}	return noErr;}// ---------------------------------------------------------------------------//	¥ DoHICommand// ---------------------------------------------------------------------------//	Handler for HI Command EventsOSStatusUCarbonEvents::DoHICommand(	EventHandlerCallRef	/* inCallRef */,	EventRef			inEventRef){	OSStatus	result = eventNotHandledErr;		HICommand		theCommand;					// Get info about the command		::GetEventParameter( inEventRef,						 kEventParamDirectObject,						 typeHICommand,						 nil,						 sizeof(HICommand),						 nil,						 &theCommand);			// Menu selections generate HI commands. If this is a menu		// selection, we get the PP command number associated with		// the menu item and dispatch it to the PP command target.		SInt32	commandID = (SInt32) theCommand.commandID;	SInt16	menuIndex = 0;		if (theCommand.menu.menuRef != nil) {		menuIndex = (SInt16) theCommand.menu.menuItemIndex;		commandID = LMenuBar::GetCurrentMenuBar()->FindCommand(								::GetMenuID(theCommand.menu.menuRef),								menuIndex);	}		if (LCommander::GetTarget() != nil) {		if (LCommander::GetTarget()->ProcessCommand(commandID, &menuIndex)) {			result = noErr;			::HiliteMenu(0);		}	}		return result;}// ---------------------------------------------------------------------------//	¥ DoKeyDown// ---------------------------------------------------------------------------//	Handler for a KeystrokeOSStatusUCarbonEvents::DoKeyDown(	EventHandlerCallRef	/* inCallRef */,	EventRef			inEventRef){	OSStatus		result = eventNotHandledErr;		EventRecord		eventRec;		if (::ConvertEventRefToEventRecord(inEventRef, &eventRec)) {			if (LCommander::GetTarget() != nil) {				if (LCommander::GetTarget()->ProcessKeyPress(eventRec)) {				result = noErr;			}		}	}	return result;}PP_End_Namespace_PowerPlant