/*/  Metrowerks x86 Runtime Support Library  Version 1.0  06-May-96  /*//* *		conio.c * *		support for direct hardware access *	 *		Copyright © 1998 Metrowerks, Inc. *		All rights reserved. * */#ifndef _WIN32#define _WIN32#endif/*#include <cstdarg>*//*#include <cwchar>*/#define WIN32_LEAN_AND_MEAN#include <windows.h>#include <conio.h> unsigned char __declspec(naked) _inp(unsigned short port){  asm {    push edx    mov dx, port    in al, dx    pop edx    ret  }}unsigned short __declspec(naked) _inpw(unsigned short port){  asm {    push edx    mov dx, port    in ax, dx    pop edx    ret  }}unsigned long __declspec(naked) _inpd(unsigned short port){  asm {    push edx    mov dx, port    in eax, dx    pop edx    ret  }}void __declspec(naked) _outp(unsigned short port, unsigned char val){  asm {     push edx    mov dx, port    mov al, val    out dx, al    pop edx    ret  }}void __declspec(naked) _outpw(unsigned short port, unsigned short val){  asm {     push edx    mov dx, port    mov ax, val    out dx, ax    pop edx    ret  }}void __declspec(naked) _outpd(unsigned short port, unsigned long val){  asm {    push edx    mov dx, port    mov eax, val    out dx, eax    pop edx    ret  }}/* *  console emulation functions *  (these act a lot like the functions with similar names in *  Borland/Inprise's old compilers, but work in Win32 console *  windows) * *  some functions (gettext, puttext) aren't implemented because *  the model used for the Win32 screen buffer isn't compatible *  with the model used by those functions -- getting characters *  from the screen in Win32 returns an array of PCHARINFO types *  which can hold either 1-byte or 2-byte characters. * *  gettextinfo doesn't work because we don't have window() *  support * *  for the getch() and getche() calls to work correctly, you should *  call initscr() in your code first -- this will reset the default *  console screen and prevent character echoing or buffering */// set up standard 80x25 console with no scrolling regionvoid __initscr(void){	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	COORD c;	SMALL_RECT sr;		c.X = 80;	c.Y = 25;		sr.Top = 0;	sr.Bottom = 24;	sr.Left = 0; sr.Right = 79;		SetConsoleScreenBufferSize(hnd, c);	SetConsoleWindowInfo(hnd, TRUE, &sr);		hnd = GetStdHandle(STD_INPUT_HANDLE);	// Clear all input modes	SetConsoleMode(hnd, 0);}// returns true if characters waiting in input queue for console application// it has the side effect of eating any non-keyboard input records in the// console input queueint __kbhit(void){	INPUT_RECORD in;	DWORD numRead;	HANDLE hnd = GetStdHandle(STD_INPUT_HANDLE);	// peek through input buffer until we run out of	// records or we find a keyboard record		while (PeekConsoleInput(hnd, &in, 1, &numRead), numRead == 1)	{		if (in.EventType == KEY_EVENT && in.Event.KeyEvent.bKeyDown)		{			return 1;		}		// not a keydown event -- eat input		ReadConsoleInput(hnd, &in, 1, &numRead);	}	return 0;}// get a keyboard character without echoint __getch(void){	HANDLE hnd = GetStdHandle(STD_INPUT_HANDLE);	char ch;	DWORD numRead;		ReadConsole(hnd, &ch, 1, &numRead, NULL);	return ch;}// get a keyboard character with echoint __getche(void){	char ch = __getch();	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	DWORD numWritten;	WriteConsole(hnd, &ch, 1, &numWritten, NULL);	return ch;}// Clears console windowvoid __clrscr(void){	CONSOLE_SCREEN_BUFFER_INFO info;	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	COORD c;	DWORD cellsWritten;	int width, height;		c.X = 0;	c.Y = 0;		GetConsoleScreenBufferInfo(hnd, &info);	width = info.dwMaximumWindowSize.X;	height = info.dwMaximumWindowSize.Y;	FillConsoleOutputCharacter(hnd, ' ', width * height, c, &cellsWritten);	FillConsoleOutputAttribute(hnd, info.wAttributes, width * height, 		c, &cellsWritten);}// Position cursor in console windowvoid __gotoxy(int x, int y){	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	COORD c;	c.X = x; 	c.Y = y;	SetConsoleCursorPosition(hnd, c);}// return cursor x positionint __wherex(void){	CONSOLE_SCREEN_BUFFER_INFO info;	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	GetConsoleScreenBufferInfo(hnd, &info);	return info.dwCursorPosition.X;}// return cursor y positionint __wherey(void){	CONSOLE_SCREEN_BUFFER_INFO info;	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	GetConsoleScreenBufferInfo(hnd, &info);	return info.dwCursorPosition.Y;}void __textattr(int newattr){	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	SetConsoleTextAttribute(hnd, newattr);}void __textcolor(int newcolor){	CONSOLE_SCREEN_BUFFER_INFO info;	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	GetConsoleScreenBufferInfo(hnd, &info);	__textattr(info.wAttributes & ~0x0F | newcolor);}void __textbackground(int newcolor){	CONSOLE_SCREEN_BUFFER_INFO info;	HANDLE hnd = GetStdHandle(STD_OUTPUT_HANDLE);	GetConsoleScreenBufferInfo(hnd, &info);	__textattr(info.wAttributes & ~0xF0 | (newcolor << 4));}/*  Change History *  cc 000515 Fixed #include */