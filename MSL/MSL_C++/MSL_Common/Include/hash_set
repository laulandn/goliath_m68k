/*  Metrowerks Standard Library  *//*  $Date: 2000/06/09 19:24:36 $  *  $Revision: 1.1.2.3 $  *  $NoKeywords: $  * *		Portions Copyright © 1995-2000 Metrowerks, Inc. *		All rights reserved. */ /** **  hash_set **//*	WARNING - WARNING - WARNING		This header is NON-STANDARD		The classes herein are offered as extensions to the C++ standard.	They are marked as such by the namespace Metrowerks.*/#ifndef _HASH_SET#define _HASH_SET#include <mslconfig>#include <hash_table>#ifndef RC_INVOKED#pragma options align=native#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#if _MSL_FORCE_ENUMS_ALWAYS_INT		#pragma enumsalwaysint on	#else		#pragma enumsalwaysint off	#endif#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT		#pragma bool on	#else		#pragma bool off	#endif#endif#ifndef _MSL_NO_CPP_NAMESPACE	namespace Metrowerks {#else	#ifndef Metrowerks		#define Metrowerks	#endif#endiftemplate <class T, class Hash = hash<T>, class Compare = _STD::equal_to<T>,          class Allocator = _STD::allocator<T> >class hash_set{public:	//  types:	typedef T                                     key_type;	typedef T                                     value_type;	typedef Hash                                  key_hasher;	typedef Hash                                  value_hasher;	typedef Allocator                             allocator_type;	typedef typename Allocator::reference         reference;	typedef typename Allocator::const_reference   const_reference;	typedef typename Allocator::size_type         size_type;	typedef typename Allocator::difference_type   difference_type;	typedef typename Allocator::pointer           pointer;	typedef typename Allocator::const_pointer     const_pointer;	typedef Compare                               key_compare;	typedef Compare                               value_compare;private:	typedef hash_table<value_type, value_hasher, value_compare, Allocator> hash_type;public:	typedef typename hash_type::const_iterator    iterator;	typedef typename hash_type::const_iterator    const_iterator;	//  lib.set.cons construct/copy/destroy:	explicit hash_set(size_type num_buckets = 0)		: table_(num_buckets, key_hasher(), key_compare(), 2, 4, allocator_type()) {}	hash_set(size_type num_buckets, const key_hasher& hash)		: table_(num_buckets, hash, key_compare(), 2, 4, allocator_type()) {}	hash_set(size_type num_buckets, const key_hasher& hash, const key_compare& comp,		float load_factor_limit = 2, float growth_factor = 4)		: table_(num_buckets, hash, comp, load_factor_limit, growth_factor, allocator_type()) {}	hash_set(size_type num_buckets, const key_hasher& hash, const key_compare& comp,		float load_factor_limit, float growth_factor, const allocator_type& a)		: table_(num_buckets, hash, comp, load_factor_limit, growth_factor, a) {}	template <class InputIterator>		hash_set(InputIterator first, InputIterator last, size_type num_buckets = 0)			: table_(first, last, false, num_buckets, key_hasher(), key_compare(),			  2, 4, allocator_type()) {}	template <class InputIterator>		hash_set(InputIterator first, InputIterator last, size_type num_buckets,			const key_hasher& hash)			: table_(first, last, false, num_buckets, hash, key_compare(),			  2, 4, allocator_type()) {}	template <class InputIterator>		hash_set(InputIterator first, InputIterator last, size_type num_buckets,			const key_hasher& hash, const key_compare& comp,			float load_factor_limit = 2, float growth_factor = 4)			: table_(first, last, false, num_buckets, hash, comp,			  load_factor_limit, growth_factor, allocator_type()) {}	template <class InputIterator>		hash_set(InputIterator first, InputIterator last, size_type num_buckets,			const key_hasher& hash, const key_compare& comp,			float load_factor_limit, float growth_factor, const allocator_type& a)			: table_(first, last, false, num_buckets, hash, comp,			  load_factor_limit, growth_factor, a) {}	allocator_type get_allocator() const {return table_.get_allocator();}	//  iterators:	iterator       begin()       {return table_.begin();}	const_iterator begin() const {return table_.begin();}	iterator       end()         {return table_.end();}	const_iterator end() const   {return table_.end();}	//  capacity:	bool      empty() const                       {return table_.empty();}	size_type size() const                        {return table_.size();}	size_type max_size() const                    {return table_.max_size();}	size_type bucket_count() const                {return table_.bucket_count();}	size_type bucket_count(size_type num_buckets) {return table_.bucket_count(num_buckets);}	float     load_factor() const                 {return table_.load_factor();}	void      load_factor_limit(float lf)         {table_.load_factor_limit(lf);}	float     load_factor_limit() const           {return table_.load_factor_limit();}	void      growth_factor(float gf)             {table_.growth_factor(gf);}	float     growth_factor() const               {return table_.growth_factor();}	size_type collision(const_iterator i) const   {return table_.collision(i);}	//  modifiers:	_STD::pair<iterator, bool> insert(const value_type& x)   {return table_.insert_one(x);}	iterator insert(iterator, const value_type& x)           {return table_.insert_one(x).first;}	template <class InputIterator>		void insert(InputIterator first, InputIterator last) {table_.insert_one(first, last);}	void      erase(iterator position)             {table_.erase(position);}	size_type erase(const key_type& x)             {return table_.erase_one(x);}	void      erase(iterator first, iterator last) {table_.erase(first, last);}	void        swap(hash_set& y)              {Metrowerks::swap(  table_, y.table_);}	friend void swap(hash_set& x, hash_set& y) {Metrowerks::swap(x.table_, y.table_);}	void clear() {table_.clear();}	//  observers:	key_compare   key_comp() const   {return table_.value_comp();}	value_compare value_comp() const {return table_.value_comp();}	key_hasher    key_hash() const   {return table_.value_hash();}	value_hasher  value_hash() const {return table_.value_hash();}	//  set operations:	iterator  find(const key_type& x) const  {return table_.find(x);}	size_type count(const key_type& x) const {return table_.count_one(x);}	_STD::pair<iterator,iterator> equal_range(const key_type& x) const {return table_.equal_range(x);}private:	hash_type table_;};template <class T, class Hash, class Compare, class Allocator>inlinebooloperator==(const hash_set<T, Hash, Compare, Allocator>& x,           const hash_set<T, Hash, Compare, Allocator>& y){	return x.size() == y.size() && _STD::equal(x.begin(), x.end(), y.begin());}template <class T, class Hash, class Compare, class Allocator>inlinebooloperator!=(const hash_set<T, Hash, Compare, Allocator>& x,           const hash_set<T, Hash, Compare, Allocator>& y){	return !(x == y);}template <class T, class Hash = hash<T>, class Compare = _STD::equal_to<T>,          class Allocator = _STD::allocator<T> >class hash_multiset{public:	//  types:	typedef T                                     key_type;	typedef T                                     value_type;	typedef Hash                                  key_hasher;	typedef Hash                                  value_hasher;	typedef Allocator                             allocator_type;	typedef typename Allocator::reference         reference;	typedef typename Allocator::const_reference   const_reference;	typedef typename Allocator::size_type         size_type;	typedef typename Allocator::difference_type   difference_type;	typedef typename Allocator::pointer           pointer;	typedef typename Allocator::const_pointer     const_pointer;	typedef Compare                               key_compare;	typedef Compare                               value_compare;private:	typedef hash_table<value_type, value_hasher, value_compare, Allocator> hash_type;public:	typedef typename hash_type::const_iterator    iterator;	typedef typename hash_type::const_iterator    const_iterator;	//  lib.set.cons construct/copy/destroy:	explicit hash_multiset(size_type num_buckets = 0)		: table_(num_buckets, key_hasher(), key_compare(), 2, 4, allocator_type()) {}	hash_multiset(size_type num_buckets, const key_hasher& hash)		: table_(num_buckets, hash,  key_compare(), 2, 4, allocator_type()) {}	hash_multiset(size_type num_buckets, const key_hasher& hash, const key_compare& comp,		float load_factor_limit = 2, float growth_factor = 4)		: table_(num_buckets, hash, comp, load_factor_limit, growth_factor, allocator_type()) {}	hash_multiset(size_type num_buckets, const key_hasher& hash, const key_compare& comp,		float load_factor_limit, float growth_factor, const allocator_type& a)		: table_(num_buckets, hash, comp, load_factor_limit, growth_factor, a) {}	template <class InputIterator>		hash_multiset(InputIterator first, InputIterator last, size_type num_buckets = 0)			: table_(first, last, true, num_buckets, key_hasher(), key_compare(),				2, 4, allocator_type()) {}	template <class InputIterator>		hash_multiset(InputIterator first, InputIterator last, size_type num_buckets,			const key_hasher& hash)			: table_(first, last, true, num_buckets, hash, key_compare(),				2, 4, allocator_type()) {}	template <class InputIterator>		hash_multiset(InputIterator first, InputIterator last, size_type num_buckets,			const key_hasher& hash, const key_compare& comp,			float load_factor_limit = 2, float growth_factor = 4)			: table_(first, last, true, num_buckets, hash, comp,			  load_factor_limit, growth_factor, allocator_type()) {}	template <class InputIterator>		hash_multiset(InputIterator first, InputIterator last, size_type num_buckets,			const key_hasher& hash, const key_compare& comp,			float load_factor_limit, float growth_factor, const allocator_type& a)			: table_(first, last, true, num_buckets, hash, comp,				load_factor_limit, growth_factor, a) {}	allocator_type get_allocator() const {return table_.get_allocator();}	//  iterators:	iterator       begin()       {return table_.begin();}	const_iterator begin() const {return table_.begin();}	iterator       end()         {return table_.end();}	const_iterator end() const   {return table_.end();}	//  capacity:	bool      empty() const                       {return table_.empty();}	size_type size() const                        {return table_.size();}	size_type max_size() const                    {return table_.max_size();}	size_type bucket_count() const                {return table_.bucket_count();}	size_type bucket_count(size_type num_buckets) {return table_.bucket_count(num_buckets);}	float     load_factor() const                 {return table_.load_factor();}	void      load_factor_limit(float lf)         {table_.load_factor_limit(lf);}	float     load_factor_limit() const           {return table_.load_factor_limit();}	void      growth_factor(float gf)             {table_.growth_factor(gf);}	float     growth_factor() const               {return table_.growth_factor();}	size_type collision(const_iterator i) const   {return table_.collision(i);}	//  modifiers:	iterator insert(const value_type& x)             {return table_.insert_multi(x);}	iterator insert(iterator p, const value_type& x) {return table_.insert_multi(p, x);}	template <class InputIterator>		void insert(InputIterator first, InputIterator last) {table_.insert_multi(first, last);}	void      erase(iterator position)             {table_.erase(position);}	size_type erase(const key_type& x)             {return table_.erase_multi(x);}	void      erase(iterator first, iterator last) {table_.erase(first, last);}	void        swap(hash_multiset& y)                   {Metrowerks::swap(  table_, y.table_);}	friend void swap(hash_multiset& x, hash_multiset& y) {Metrowerks::swap(x.table_, y.table_);}	void clear() {table_.clear();}	//  observers:	key_compare   key_comp() const   {return table_.value_comp();}	value_compare value_comp() const {return table_.value_comp();}	key_hasher    key_hash() const   {return table_.value_hash();}	value_hasher  value_hash() const {return table_.value_hash();}	//  set operations:	iterator  find(const key_type& x) const  {return table_.find(x);}	size_type count(const key_type& x) const {return table_.count_multi(x);}	_STD::pair<iterator,iterator> equal_range(const key_type& x) const {return table_.equal_range(x);}private:	hash_type table_;};template <class T, class Hash, class Compare, class Allocator>inlinebooloperator==(const hash_multiset<T, Hash, Compare, Allocator>& x,           const hash_multiset<T, Hash, Compare, Allocator>& y){	return x.size() == y.size() && _STD::equal(x.begin(), x.end(), y.begin());}template <class T, class Hash, class Compare, class Allocator>inlinebooloperator!=(const hash_multiset<T, Hash, Compare, Allocator>& x,           const hash_multiset<T, Hash, Compare, Allocator>& y){	return !(x == y);}#ifndef _MSL_NO_CPP_NAMESPACE	} // namespace Metrowerks#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#pragma enumsalwaysint reset#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#pragma bool reset#endif#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endif#pragma options align=reset#endif // RC_INVOKED#endif  // _HASH_SET// hh 991213 Created