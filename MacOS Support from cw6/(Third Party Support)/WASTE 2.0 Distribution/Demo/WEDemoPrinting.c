/* *	WASTE Demo Project: *	Printing * *	Copyright © 1993-2000 Marco Piovanelli *	All Rights Reserved * *	C port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> *///	Mac OS #includes#ifndef __FIXMATH__#include <FixMath.h>#endif#if TARGET_API_MAC_CARBON	#ifndef __PMAPPLICATION__	#include <PMApplication.h>	#endif#else	#ifndef __PRINTING__	#include <Printing.h>	#endif#endif//	WASTE Demo #includes#include "WEDemo.h"static void ValidateMargins	(		const Rect *		inPaperRect,		//	paper rectangle		const Rect *		inMaxPageRect,		//	maximum printable area		PageMarginRec *		ioMargins			//	page margins	){	const Fixed			kMinPageWidth = ( 36 << 16 ) ;		//	half inch	const Fixed			kMinPageHeight = ( 36 << 16 ) ;		//	half inch	PageMarginRec		minMargins ;	PageMarginRec		maxMargins ;	//	find the narrowest possible margins allowed by the specified print record	minMargins.left = ( inMaxPageRect->left - inPaperRect->left ) << 16 ;	minMargins.right = ( inPaperRect->right - inMaxPageRect->right ) << 16 ;	minMargins.top = ( inMaxPageRect->top - inPaperRect->top ) << 16 ;	minMargins.bottom = ( inPaperRect->bottom - inMaxPageRect->bottom ) << 16 ;	//	and the widest possible margins	maxMargins.left = ( ( ( inPaperRect->right - inPaperRect->left ) << 16 ) - kMinPageWidth ) / 2 ;	maxMargins.top = ( ( ( inPaperRect->bottom - inPaperRect->top ) << 16 ) - kMinPageHeight ) / 2 ;	maxMargins.right = maxMargins.left ;	maxMargins.bottom = maxMargins.top ;	//	make sure the margins aren't too wide or too narrow	if ( ioMargins->top < minMargins.top )	{		ioMargins->top = minMargins.top ;	}	else if ( ioMargins->top > maxMargins.top )	{		ioMargins->top = maxMargins.top ;	}	if ( ioMargins->bottom < minMargins.bottom )	{		ioMargins->bottom = minMargins.bottom ;	}	else if ( ioMargins->bottom > maxMargins.bottom )	{		ioMargins->bottom = maxMargins.bottom ;	}	if ( ioMargins->left < minMargins.left )	{		ioMargins->left = minMargins.left ;	}	else if ( ioMargins->left > maxMargins.left )	{		ioMargins->left = maxMargins.left ;	}	if ( ioMargins->right < minMargins.right )	{		ioMargins->right = minMargins.right ;	}	else if ( ioMargins->right > maxMargins.right )	{		ioMargins->right = maxMargins.right ;	}}static void CalculatePageRect	(		const Rect *				inPaperRect,		const PageMarginRec *		inPageMargins,		Rect *						outPageRect	){	Rect marginRect ;	//	get page margins rounded to nearest integral values	marginRect.left = FixRound ( inPageMargins->left ) ;	marginRect.top = FixRound ( inPageMargins->top ) ;	marginRect.right = FixRound ( inPageMargins->right ) ;	marginRect.bottom = FixRound ( inPageMargins->bottom ) ;	//	calculate page rect (the destination rectangle for printing)	//	based on the paper rect and page margins	//	all values are expressed in integral PostScript points (1/72 inch)	outPageRect->left = ( inPaperRect->left + marginRect.left ) ;	outPageRect->top = ( inPaperRect->top + marginRect.top ) ;	outPageRect->right = outPageRect->left + ( ( inPaperRect->right - inPaperRect->left ) - ( marginRect.left + marginRect.right ) ) ;	outPageRect->bottom = outPageRect-> top + ( ( inPaperRect->bottom - inPaperRect->top ) - ( marginRect.top + marginRect.bottom ) ) ;}#if TARGET_API_MAC_CARBONstatic void PMRectToRect ( const PMRect * inPMRect, Rect * outRect ){	outRect->left = inPMRect->left ;	outRect->top = inPMRect->top ;	outRect->right = inPMRect->right ;	outRect->bottom = inPMRect->bottom ;}#if PM_USE_SESSION_APIS#pragma mark ====== Carbon Printing with Session APIs ======//	CARBON PRINTING WITH SESSION APIS//	Session APIs are the recommended APIs for Mac OS X and CarbonLib 1.1//	AFAIK, they're not available in CarbonLib 1.0.x, though, so if you//	need CarbonLib 1.0.x compatibility, you must use the "old" Carbon APIsOSStatus DoPageSetup ( WindowRef inWindow ){	DocumentHandle	hDocument ;	WEReference		we ;	PMPrintSession	printSession = nil ;	PMPageFormat	pageFormat = nil ;	Handle			oldFlattenedPageFormat = nil ;	Handle			newFlattenedPageFormat = nil ;	Boolean			accepted = false ;	OSStatus		err ;	hDocument = GetWindowDocument ( inWindow ) ;	we = ( * hDocument ) -> we ;	//	begin a print session	if ( ( err = PMCreateSession ( & printSession ) ) != noErr )	{		goto cleanup ;	}	//	get the PMPageFormat object associated with our WASTE instance, if any	if ( ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & oldFlattenedPageFormat, we ) == noErr ) &&		 ( oldFlattenedPageFormat != nil ) )	{		//	pre-existing flattened page format data: unflatten it		if ( ( err = PMUnflattenPageFormat ( oldFlattenedPageFormat, & pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	else	{		//	no pre-existing page format: create one		if ( ( err = PMCreatePageFormat ( & pageFormat ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = PMSessionDefaultPageFormat ( printSession, pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	//	display the page setup dialog	if ( ( err = PMSessionPageSetupDialog ( printSession, pageFormat, & accepted ) ) != noErr )	{		goto cleanup ;	}	if ( accepted )	{		//	flatten the page format so we can keep it around		if ( ( err = PMFlattenPageFormat ( pageFormat, & newFlattenedPageFormat ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = WESetUserInfo ( kPageFormatTag, ( SInt32 ) newFlattenedPageFormat, we ) ) != noErr )		{			goto cleanup ;		}		ForgetHandle ( & oldFlattenedPageFormat ) ;		newFlattenedPageFormat = nil ;	}	//	clear result code	err = noErr ;cleanup :	//	close the print session	if ( printSession != nil )	{		PMRelease ( printSession ) ;		printSession = nil ;	}	//	clean up	ForgetHandle ( & newFlattenedPageFormat ) ;	//	return result code	return err ;}OSStatus DoPrint ( WindowRef inWindow ){	DocumentHandle			hDocument ;	WEReference				we ;	WEPrintOptions			printOptions ;	Handle					flattenedPageFormat = nil ;	PMPrintSession			printSession = nil ;	PMPageFormat			pageFormat = nil ;	PMPrintSettings			printSettings = nil ;	WEPrintSession			wasteSession = nil ;	GrafPtr					printPort = nil ;	PageMarginRecHandle		hPageMargins = nil ;	PageMarginRec			pageMargins ;	PMRect					pmRect ;	Rect					paperRect ;	Rect					printableArea ;	UInt32					firstSelectedPage ;	UInt32					lastSelectedPage ;	SInt32					pageIndex ;	SInt32					pageCount ;	Boolean					accepted = false ;	OSStatus				err ;	hDocument = GetWindowDocument ( inWindow ) ;	we = ( * hDocument ) -> we ;	//	start a new print session	if ( ( err = PMCreateSession ( & printSession ) ) != noErr )	{		goto cleanup ;	}	//	get the PMPageFormat object associated with our WASTE instance, if any	if ( ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & flattenedPageFormat, we ) == noErr ) &&		 ( flattenedPageFormat != nil ) )	{		//	pre-existing flattened page format data: unflatten it		if ( ( err = PMUnflattenPageFormat ( flattenedPageFormat, & pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	else	{		//	no pre-existing page format: create one		if ( ( err = PMCreatePageFormat ( & pageFormat ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = PMSessionDefaultPageFormat ( printSession, pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	//	get the page margins record associated with our WASTE instance	if ( ( err = WEGetUserInfo ( kPageMarginsTag, ( SInt32 * ) & hPageMargins, we ) ) != noErr )	{		goto cleanup ;	}	pageMargins = ** hPageMargins ;	//	create a print settings object	if ( ( err = PMCreatePrintSettings ( & printSettings ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = PMSessionDefaultPrintSettings ( printSession, printSettings ) ) != noErr )	{		goto cleanup ;	}	//	display the print dialog	if ( ( err = PMSessionPrintDialog ( printSession, printSettings, pageFormat, & accepted ) ) != noErr )	{		goto cleanup ;	}	//	dialog accepted?	err = userCanceledErr ;	if ( ! accepted )	{		goto cleanup ;	}	//	get paper rectangle, rounded to nearest integral values	if ( ( err = PMGetAdjustedPaperRect ( pageFormat, & pmRect ) ) != noErr )	{		goto cleanup ;	}	PMRectToRect ( & pmRect, & paperRect ) ;	//	get printable page rectangle (actual page rect can't be larger than this)	if ( ( err = PMGetAdjustedPageRect ( pageFormat, & pmRect ) ) != noErr )	{		goto cleanup ;	}	PMRectToRect ( & pmRect, & printableArea ) ;	//	validate page margins	ValidateMargins ( & paperRect, & printableArea, & pageMargins ) ;	//	zero out the print options record (this is important for future compatibility!)	BlockZero ( & printOptions, sizeof ( printOptions ) ) ;	//	calculate page rectangle	CalculatePageRect ( & paperRect, & pageMargins, & printOptions . pageRect ) ;	//	copy it to a PMRect for PMBeginPage	pmRect . left = printOptions . pageRect . left ;	pmRect . top = printOptions . pageRect . top ;	pmRect . right = printOptions . pageRect . right ;	pmRect . bottom = printOptions . pageRect . bottom ;	//	create a WASTE print session	if ( ( err = WENewPrintSession ( & printOptions, we, & wasteSession ) ) != noErr )	{		goto cleanup ;	}	//	get page count	pageCount = WECountPages ( wasteSession ) ;	//	get page range selected by the user	if ( ( err = PMGetFirstPage ( printSettings, & firstSelectedPage ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = PMGetLastPage ( printSettings, & lastSelectedPage ) ) != noErr )	{		goto cleanup ;	}	//	sanity checks	if ( lastSelectedPage > pageCount )	{		lastSelectedPage = pageCount ;	}	//	begin document	if ( ( err = PMSessionBeginDocument ( printSession, printSettings, pageFormat ) ) != noErr )	{		goto cleanup ;	}	//	WASTE page indices are zero-based, while Printing Manager's are one-based	firstSelectedPage -= 1 ;	lastSelectedPage -= 1 ;	//	page loop	for ( pageIndex = firstSelectedPage ; pageIndex <= lastSelectedPage ; pageIndex ++ )	{		//	begin page		if ( ( err = PMSessionBeginPage ( printSession, pageFormat, & pmRect ) ) != noErr )		{			goto cleanup ;		}		//	get the graphics port associated with the print context		if ( ( err = PMSessionGetGraphicsContext ( printSession, nil, & printPort ) ) != noErr )		{			goto cleanup ;		}		//	print this page		if ( ( err = WEPrintPage ( pageIndex, printPort, nil, wasteSession ) ) != noErr )		{			goto cleanup ;		}		//	end page		if ( ( err = PMSessionEndPage ( printSession ) ) != noErr )		{			goto cleanup ;		}	}	//	end document	if ( ( err = PMSessionEndDocument ( printSession ) ) != noErr )	{		goto cleanup ;	}	//	clear result code	err = noErr ;cleanup :	//	clean up	if ( wasteSession )	{		WEDisposePrintSession ( wasteSession ) ;		wasteSession = nil ;	}	if ( printSettings )	{		PMRelease ( printSettings ) ;		printSettings = nil ;	}	if ( printSession )	{		PMRelease ( printSession ) ;		printSession = nil ;	}	//	return result code	return err ;}#else#pragma mark ====== Carbon Printing with the Old APIs ======//	CARBON PRINTING WITH THE OLD (SESSIONLESS) APIS//	Session APIs are the recommended APIs for Mac OS X and CarbonLib 1.1//	AFAIK, they're not available in CarbonLib 1.0.x, though, so if you//	need CarbonLib 1.0.x compatibility, you must use the "old" Carbon APIsOSStatus DoPageSetup ( WindowRef inWindow ){	DocumentHandle	hDocument ;	WEReference		we ;	PMPageFormat	pageFormat = nil ;	Handle			oldFlattenedPageFormat = nil ;	Handle			newFlattenedPageFormat = nil ;	Boolean			accepted = false ;	OSStatus		err ;	hDocument = GetWindowDocument ( inWindow ) ;	we = ( * hDocument ) -> we ;	if ( ( err = PMBegin ( ) ) != noErr )	{		goto cleanup ;	}	//	get the PMPageFormat object associated with our WASTE instance, if any	if ( ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & oldFlattenedPageFormat, we ) == noErr ) &&		 ( oldFlattenedPageFormat != nil ) )	{		//	pre-existing flattened page format data: unflatten it		if ( ( err = PMUnflattenPageFormat ( oldFlattenedPageFormat, & pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	else	{		//	no pre-existing page format: create one		if ( ( err = PMNewPageFormat ( & pageFormat ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = PMDefaultPageFormat ( pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	//	display the page setup dialog	if ( ( err = PMPageSetupDialog ( pageFormat, & accepted ) ) != noErr )	{		goto cleanup ;	}	if ( accepted )	{		//	flatten the page format so we can keep it around		if ( ( err = PMFlattenPageFormat ( pageFormat, & newFlattenedPageFormat ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = WESetUserInfo ( kPageFormatTag, ( SInt32 ) newFlattenedPageFormat, we ) ) != noErr )		{			goto cleanup ;		}		ForgetHandle ( & oldFlattenedPageFormat ) ;		newFlattenedPageFormat = nil ;	}	//	clear result code	err = noErr ;cleanup :	//	clean up	PMEnd ( ) ;	ForgetHandle ( & newFlattenedPageFormat ) ;	//	return result code	return err ;}OSStatus DoPrint ( WindowRef inWindow ){	DocumentHandle			hDocument ;	WEReference				we ;	WEPrintOptions			printOptions ;	Handle					flattenedPageFormat = nil ;	PMPageFormat			pageFormat = nil ;	PMPrintSettings			printSettings = nil ;	WEPrintSession			wasteSession = nil ;	PMPrintContext			printContext = nil ;	GrafPtr					printPort = nil ;	PageMarginRecHandle		hPageMargins = nil ;	PageMarginRec			pageMargins ;	PMRect					pmRect ;	Rect					paperRect ;	Rect					printableArea ;	UInt32					firstSelectedPage ;	UInt32					lastSelectedPage ;	UInt32					pageIndex ;	UInt32					pageCount ;	Boolean					accepted = false ;	OSStatus				err ;	hDocument = GetWindowDocument ( inWindow ) ;	we = ( * hDocument ) -> we ;	if ( ( err = PMBegin ( ) ) != noErr )	{		goto cleanup ;	}	//	get the PMPageFormat object associated with our WASTE instance, if any	if ( ( WEGetUserInfo ( kPageFormatTag, ( SInt32 * ) & flattenedPageFormat, we ) == noErr ) &&		 ( flattenedPageFormat != nil ) )	{		//	pre-existing flattened page format data: unflatten it		if ( ( err = PMUnflattenPageFormat ( flattenedPageFormat, & pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	else	{		//	no pre-existing page format: create one		if ( ( err = PMNewPageFormat ( & pageFormat ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = PMDefaultPageFormat ( pageFormat ) ) != noErr )		{			goto cleanup ;		}	}	//	get the page margins record associated with our WASTE instance	if ( ( err = WEGetUserInfo ( kPageMarginsTag, ( SInt32 * ) & hPageMargins, we ) ) != noErr )	{		goto cleanup ;	}	pageMargins = ** hPageMargins ;	//	create a print settings object	if ( ( err = PMNewPrintSettings ( & printSettings ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = PMDefaultPrintSettings ( printSettings ) ) != noErr )	{		goto cleanup ;	}	//	display the print dialog	if ( ( err = PMPrintDialog ( printSettings, pageFormat, & accepted ) ) != noErr )	{		goto cleanup ;	}	//	dialog accepted?	err = userCanceledErr ;	if ( ! accepted )	{		goto cleanup ;	}	//	get paper rectangle, rounded to nearest integral values	if ( ( err = PMGetAdjustedPaperRect ( pageFormat, & pmRect ) ) != noErr )	{		goto cleanup ;	}	PMRectToRect ( & pmRect, & paperRect ) ;	//	get printable page rectangle (actual page rect can't be larger than this)	if ( ( err = PMGetAdjustedPageRect ( pageFormat, & pmRect ) ) != noErr )	{		goto cleanup ;	}	PMRectToRect ( & pmRect, & printableArea ) ;	//	validate page margins	ValidateMargins ( & paperRect, & printableArea, & pageMargins ) ;	//	zero out the print options record (this is important for future compatibility!)	BlockZero ( & printOptions, sizeof ( printOptions ) ) ;	//	calculate page rectangle	CalculatePageRect ( & paperRect, & pageMargins, & printOptions . pageRect ) ;	//	copy it to a PMRect for PMBeginPage	pmRect . left = printOptions . pageRect . left ;	pmRect . top = printOptions . pageRect . top ;	pmRect . right = printOptions . pageRect . right ;	pmRect . bottom = printOptions . pageRect . bottom ;	//	create a WASTE print session	if ( ( err = WENewPrintSession ( & printOptions, we, & wasteSession ) ) != noErr )	{		goto cleanup ;	}	//	get page count	pageCount = WECountPages ( wasteSession ) ;	//	get page range selected by the user	if ( ( err = PMGetFirstPage ( printSettings, & firstSelectedPage ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = PMGetLastPage ( printSettings, & lastSelectedPage ) ) != noErr )	{		goto cleanup ;	}	//	sanity checks	if ( lastSelectedPage > pageCount )	{		lastSelectedPage = pageCount ;	}	//	set up the print context	if ( ( err = PMBeginDocument ( printSettings, pageFormat, & printContext ) ) != noErr )	{		goto cleanup ;	}	//	WASTE page indices are zero-based, while Printing Manager's are one-based	firstSelectedPage -= 1 ;	lastSelectedPage -= 1 ;	//	page loop	for ( pageIndex = firstSelectedPage ; pageIndex <= lastSelectedPage ; pageIndex ++ )	{		if ( ( err = PMBeginPage ( printContext, & pmRect ) ) != noErr )		{			goto cleanup ;		}		//	get the graphics port associated with the print context		if ( ( err = PMGetGrafPtr ( printContext, & printPort ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = WEPrintPage ( pageIndex, printPort, nil, wasteSession ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = PMEndPage ( printContext ) ) != noErr )		{			goto cleanup ;		}	}	//	clear result code	err = noErr ;cleanup :	//	clean up	if ( wasteSession )	{		WEDisposePrintSession ( wasteSession ) ;		wasteSession = nil ;	}	if ( printContext )	{		PMEndDocument ( printContext ) ;		printContext = nil ;	}	if ( printSettings )	{		PMDisposePrintSettings ( printSettings ) ;		printSettings = nil ;	}	PMEnd ( ) ;	//	return result code	return err ;}#endif /*PM_USE_SESSION_APIS*/#else#pragma mark ====== Classic Printing ======//	CLASSIC PRINTINGOSStatus DoPageSetup ( WindowRef inWindow ){	DocumentHandle			hDocument ;	WEReference				we ;	THPrint					hPrintRecord = nil ;	PageMarginRecHandle		hPageMargins = nil ;	Boolean					accepted = false ;	OSStatus				err ;	hDocument = GetWindowDocument ( inWindow ) ;	we = ( * hDocument ) -> we ;	PrOpen ( ) ;	if ( ( err = PrError ( ) ) != noErr )	{		goto cleanup ;	}	//	get the print record associated with our WASTE instance, if any	if ( ( WEGetUserInfo ( kPrintRecordTag, ( SInt32 * ) & hPrintRecord, we ) == noErr ) &&		 ( hPrintRecord != nil ) )	{		//	pre-existing print record: validate it		PrValidate ( hPrintRecord ) ;		if ( ( err = PrError ( ) ) != noErr )		{			goto cleanup ;		}	}	else	{		//	no pre-existing print record: create one		hPrintRecord = ( THPrint ) NewHandleClear ( sizeof ( TPrint ) ) ;		if ( ( err = MemError ( ) ) != noErr )		{			goto cleanup ;		}		PrintDefault ( hPrintRecord ) ;		if ( ( err = PrError ( ) ) != noErr )		{			goto cleanup ;		}	}	//	get the page margins record associated with our WASTE instance	if ( ( err = WEGetUserInfo ( kPageMarginsTag, ( SInt32 * ) & hPageMargins, we ) ) != noErr )	{		goto cleanup ;	}	//	display the page setup dialog	accepted = DoPrintDialog ( hPrintRecord, hPageMargins, kPageSetupDialog ) ;	if ( ( err = PrError ( ) ) != noErr )	{		goto cleanup ;	}	if ( accepted )	{		//	keep the print record around		if ( ( err = WESetUserInfo ( kPrintRecordTag, ( SInt32 ) hPrintRecord, we ) ) != noErr )		{			goto cleanup ;		}	}	//	clear result code	err = noErr ;cleanup :	//	clean up	PrClose ( ) ;	//	return result code	return err ;}OSStatus DoPrint ( WindowRef inWindow ){	DocumentHandle			hDocument ;	WEReference				we ;	WEPrintOptions			printOptions ;	THPrint					hPrintRecord = nil ;	WEPrintSession			wasteSession = nil ;	TPPrPortRef				printContext = nil ;	GrafPtr					printPort = nil ;	GrafPtr					savePort = nil ;	PageMarginRecHandle		hPageMargins = nil ;	PageMarginRec			pageMargins ;	Rect					paperRect ;	Rect					printableArea ;	UInt32					firstSelectedPage ;	UInt32					lastSelectedPage ;	UInt32					pageIndex ;	UInt32					pageCount ;	Boolean					accepted = false ;	OSStatus				err ;	hDocument = GetWindowDocument ( inWindow ) ;	we = ( * hDocument ) -> we ;	//	save the current graphics port	GetPort ( & savePort ) ;	//	open the print manager	PrOpen ( ) ;	if ( ( err = PrError ( ) ) != noErr )	{		goto cleanup ;	}	//	get the print record associated with our WASTE instance, if any	if ( ( WEGetUserInfo ( kPrintRecordTag, ( SInt32 * ) & hPrintRecord, we ) == noErr ) &&		 ( hPrintRecord != nil ) )	{		//	pre-existing print record: validate it		PrValidate ( hPrintRecord ) ;		if ( ( err = PrError ( ) ) != noErr )		{			goto cleanup ;		}	}	else	{		//	no pre-existing print record: create one		hPrintRecord = ( THPrint ) NewHandleClear ( sizeof ( TPrint ) ) ;		if ( ( err = MemError ( ) ) != noErr )		{			goto cleanup ;		}		PrintDefault ( hPrintRecord ) ;		if ( ( err = PrError ( ) ) != noErr )		{			goto cleanup ;		}	}	//	get the page margins record associated with our WASTE instance	if ( ( err = WEGetUserInfo ( kPageMarginsTag, ( SInt32 * ) & hPageMargins, we ) ) != noErr )	{		goto cleanup ;	}	pageMargins = ** hPageMargins ;	//	display the print dialog	accepted = DoPrintDialog ( hPrintRecord, nil, kPrintDialog ) ;	if ( ( err = PrError ( ) ) != noErr )	{		goto cleanup ;	}	//	dialog accepted?	err = userCanceledErr ;	if ( ! accepted )	{		goto cleanup ;	}	//	get paper rectangle	paperRect = ( * hPrintRecord ) -> rPaper ;	//	get printable page rectangle (actual page rect can't be larger than this)	printableArea = ( * hPrintRecord ) -> prInfo . rPage ;	//	validate page margins	ValidateMargins ( & paperRect, & printableArea, & pageMargins ) ;	//	zero out the print options record (this is important for future compatibility!)	BlockZero ( & printOptions, sizeof ( printOptions ) ) ;	//	calculate page rectangle	CalculatePageRect ( & paperRect, & pageMargins, & printOptions . pageRect ) ;	//	create a WASTE print session	if ( ( err = WENewPrintSession ( & printOptions, we, & wasteSession ) ) != noErr )	{		goto cleanup ;	}	//	get page count	pageCount = WECountPages ( wasteSession ) ;	//	get page range selected by the user	firstSelectedPage = ( * hPrintRecord ) -> prJob . iFstPage ;	lastSelectedPage = ( * hPrintRecord ) -> prJob . iLstPage ;	//	sanity checks	if ( lastSelectedPage > pageCount )	{		lastSelectedPage = pageCount ;	}	//	set up the print context	printContext = PrOpenDoc ( hPrintRecord, nil, nil ) ;	if ( ( err = PrError ( ) ) != noErr )	{		goto cleanup ;	}	//	get the graphics port associated with the print context	printPort = & printContext -> gPort ;	//	WASTE page indices are zero-based, while Printing Manager's are one-based	firstSelectedPage -= 1 ;	lastSelectedPage -= 1 ;	//	page loop	for ( pageIndex = firstSelectedPage ; pageIndex <= lastSelectedPage ; pageIndex ++ )	{		PrOpenPage ( printContext, nil ) ;		if ( ( err = PrError ( ) ) != noErr )		{			goto cleanup ;		}		if ( ( err = WEPrintPage ( pageIndex, printPort, nil, wasteSession ) ) != noErr )		{			goto cleanup ;		}		PrClosePage ( printContext ) ;		if ( ( err = PrError ( ) ) != noErr )		{			goto cleanup ;		}	}	//	clear result code	err = noErr ;cleanup :	//	clean up	if ( wasteSession )	{		WEDisposePrintSession ( wasteSession ) ;		wasteSession = nil ;	}	if ( printContext )	{		PrCloseDoc ( printContext ) ;		printContext = nil ;	}	PrClose ( ) ;	//	restore the original graphics port	SetPort ( savePort ) ;	//	return result code	return err ;}#endif