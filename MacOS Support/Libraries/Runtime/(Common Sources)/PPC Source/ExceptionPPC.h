////  ExceptionPPC.h	-	C++ Exception Table Format for CodeWarriorª (PowerPC)////  Copyright © 1995-2002 Metrowerks Corporation.  All rights reserved.////#ifndef __EXCEPTIONPPC_H__#define __EXCEPTIONPPC_H__#ifdef	__MWERKS__	#pragma options align=mac68k#endif//	Exception Table Actionstypedef unsigned char exaction_type;#define EXACTION_ENDBIT					0x80	//	action table end bit#define EXACTION_MASK					0x7F	//	action mask#define	EXACTION_ENDOFLIST				0#define	EXACTION_BRANCH					1typedef struct ex_branch {	exaction_type	action;				//	EXACTION_BRANCH	unsigned char	unused;				//	(reserved for future use)	unsigned short	target;				//	exception-table-relative offset of branch target} ex_branch;#define EXACTION_DESTROYLOCAL			2typedef struct ex_destroylocal {	exaction_type	action;				//	EXACTION_DESTROYLOCAL	unsigned char	unused;				//	(reserved for future use)	short			local;				//	16-bit frame-relative offset to local variable	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocal;#define EXACTION_DESTROYLOCALCOND		3typedef struct ex_destroylocalcond {	exaction_type	action;				//	EXACTION_DESTROYLOCALCOND	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					unused		: 7;	//	(reserved for future use)	short			cond;				//	16-bit frame-relative offset or GPR# of condition flag	short			local;				//	16-bit frame-relative offset to local variable	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalcond;#define EXACTION_DESTROYLOCALPOINTER	4typedef struct ex_destroylocalpointer {	exaction_type	action;				//	EXACTION_DESTROYLOCALPOINTER	unsigned char	regpointer	: 1,	//	1 -> pointer is in a GPR					unused		: 7;	//	(reserved for future use)	short			pointer;			//	16-bit frame-relative offset or GPR# of local pointer	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalpointer;#define EXACTION_DESTROYLOCALARRAY		5typedef struct ex_destroylocalarray {	exaction_type	action;				//	EXACTION_DESTROYLOCALARRAY	unsigned char	unused;				//	(reserved for future use)	short			localarray;			//	16-bit frame-relative offset to local array	unsigned short	elements;			//	number of array elements	unsigned short	element_size;		//	size of one array element	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalarray;#define EXACTION_DESTROYBASE			6#define EXACTION_DESTROYMEMBER			7typedef struct ex_destroymember {	exaction_type	action;				//	EXACTION_DESTROYMEMBER or EXACTION_DESTROYBASE	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymember;#define EXACTION_DESTROYMEMBERCOND		8typedef struct ex_destroymembercond {	exaction_type	action;				//	EXACTION_DESTROYMEMBERCOND	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 6;	//	(reserved for future use)	short			cond;				//	16-bit frame-relative offset or GPR# of condition flag	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymembercond;#define EXACTION_DESTROYMEMBERARRAY		9typedef struct ex_destroymemberarray {	exaction_type	action;				//	EXACTION_DESTROYMEMBERARRAY	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	long			elements;			//	number of array elements	long			element_size;		//	size of one array element	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymemberarray;#define EXACTION_DELETEPOINTER			10typedef struct ex_deletepointer {	exaction_type	action;				//	EXACTION_DELETEPOINTER	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	void*			deletefunc;			//	absolute pointer to TVector of deletefunc} ex_deletepointer;#define EXACTION_DELETEPOINTERCOND		11typedef struct ex_deletepointercond {	exaction_type	action;				//	EXACTION_DELETEPOINTERCOND	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 6;	//	(reserved for future use)	short			cond;				//	16-bit frame-relative offset or GPR# of condition flag	short			objectptr;			//	16-bit frame-relative offset or GPR# of object pointer	void*			deletefunc;			//	absolute pointer to TVector of deletefunc} ex_deletepointercond;#define EXACTION_CATCHBLOCK				12typedef struct ex_catchblock {	exaction_type	action;				//	EXACTION_CATCHBLOCK	unsigned char	unused;				//	(reserved for future use)	char*			catch_type;			//	absolute pointer to catch type info; 0 => catch(...)	unsigned short	catch_pcoffset;		//	16-bit function-relative offset to catch label	short			cinfo_ref;			//	16-bit frame-relative offset to local CatchInfo struct} ex_catchblock;#define EXACTION_ACTIVECATCHBLOCK		13typedef struct ex_activecatchblock {	exaction_type	action;				//	EXACTION_ACTIVECATCHBLOCK	unsigned char	unused;				//	(reserved for future use)	short			cinfo_ref;			//	16-bit frame-relative offset to local CatchInfo struct} ex_activecatchblock;#define EXACTION_TERMINATE				14typedef struct ex_terminate {	exaction_type	action;				//	EXACTION_TERMINATE	unsigned char	unused;				//	(reserved for future use)} ex_terminate;#define EXACTION_SPECIFICATION			15typedef struct ex_specification {	exaction_type	action;				//	EXACTION_SPECIFICATION	unsigned char	unused;				//	(reserved for future use)	unsigned short	specs;				//	number of specializations (0-n)	long			pcoffset;			//	32-bit function-relative offset to catch label	long			cinfo_ref;			//	32-bit frame-relative offset to local CatchInfo struct	char			*spec[];			//	array of absolute pointers to catch type info}	ex_specification;#if __MACH__#define EXACTION_CATCHBLOCK_32			16typedef struct ex_catchblock_32 {	exaction_type	action;				//	EXACTION_CATCHBLOCK_32	unsigned char	unused;				//	(reserved for future use)	char*			catch_type;			//	absolute pointer to catch type info; 0 => catch(...)	long			catch_pcoffset;		//	32-bit function-relative offset to catch label	long			cinfo_ref;			//	32-bit frame-relative offset to local CatchInfo struct} ex_catchblock_32;#endif#define EXACTION_DESTROYLOCAL_32		17typedef struct ex_destroylocal_32 {	exaction_type	action;				//	EXACTION_DESTROYLOCAL_32	unsigned char	unused;				//	(reserved for future use)	long			local;				//	32-bit frame-relative offset to local variable	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocal_32;#define EXACTION_DESTROYLOCALCOND_32	18typedef struct ex_destroylocalcond_32 {	exaction_type	action;				//	EXACTION_DESTROYLOCALCOND_32	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					unused		: 7;	//	(reserved for future use)	long			cond;				//	32-bit frame-relative offset or GPR# of condition flag	long			local;				//	32-bit frame-relative offset to local variable	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalcond_32;#define EXACTION_DESTROYLOCALPOINTER_32	19typedef struct ex_destroylocalpointer_32 {	exaction_type	action;				//	EXACTION_DESTROYLOCALPOINTER_32	unsigned char	regpointer	: 1,	//	1 -> pointer is in a GPR					unused		: 7;	//	(reserved for future use)	long			pointer;			//	32-bit frame-relative offset or GPR# of local pointer	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalpointer_32;#define EXACTION_DESTROYLOCALARRAY_32	20typedef struct ex_destroylocalarray_32 {	exaction_type	action;				//	EXACTION_DESTROYLOCALARRAY_32	unsigned char	unused;				//	(reserved for future use)	long			localarray;			//	32-bit frame-relative offset to local array	unsigned long	elements;			//	number of array elements	unsigned long	element_size;		//	size of one array element	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroylocalarray_32;#define EXACTION_DESTROYBASE_32			21#define EXACTION_DESTROYMEMBER_32		22typedef struct ex_destroymember_32 {	exaction_type	action;				//	EXACTION_DESTROYMEMBER_32 or EXACTION_DESTROYBASE_32	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	long			objectptr;			//	32-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymember_32;#define EXACTION_DESTROYMEMBERCOND_32	23typedef struct ex_destroymembercond_32 {	exaction_type	action;				//	EXACTION_DESTROYMEMBERCOND_32	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 6;	//	(reserved for future use)	long			cond;				//	32-bit frame-relative offset or GPR# of condition flag	long			objectptr;			//	32-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymembercond_32;#define EXACTION_DESTROYMEMBERARRAY_32	24typedef struct ex_destroymemberarray_32 {	exaction_type	action;				//	EXACTION_DESTROYMEMBERARRAY_32	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	long			objectptr;			//	32-bit frame-relative offset or GPR# of object pointer	long			offset;				//	offset of member in complete object	long			elements;			//	number of array elements	long			element_size;		//	size of one array element	void*			dtor;				//	absolute pointer to TVector of destructor} ex_destroymemberarray_32;#define EXACTION_DELETEPOINTER_32		25typedef struct ex_deletepointer_32 {	exaction_type	action;				//	EXACTION_DELETEPOINTER_32	unsigned char	regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 7;	//	(reserved for future use)	long			objectptr;			//	32-bit frame-relative offset or GPR# of object pointer	void*			deletefunc;			//	absolute pointer to TVector of deletefunc} ex_deletepointer_32;#define EXACTION_DELETEPOINTERCOND_32	26typedef struct ex_deletepointercond_32 {	exaction_type	action;				//	EXACTION_DELETEPOINTERCOND_32	unsigned char	regcond		: 1,	//	1 -> condition flag is in a GPR					regpointer	: 1,	//	1 -> object pointer is in a GPR					unused		: 6;	//	(reserved for future use)	long			cond;				//	32-bit frame-relative offset or GPR# of condition flag	long			objectptr;			//	32-bit frame-relative offset or GPR# of object pointer	void*			deletefunc;			//	absolute pointer to TVector of deletefunc} ex_deletepointercond_32;#define EXACTION_ACTIVECATCHBLOCK_32	27typedef struct ex_activecatchblock_32 {	exaction_type	action;				//	EXACTION_ACTIVECATCHBLOCK_32	unsigned char	unused;				//	(reserved for future use)	long			cinfo_ref;			//	32-bit frame-relative offset to local CatchInfo struct} ex_activecatchblock_32;//	Exception Table Rangestypedef struct ExceptionRangeSmall {	unsigned short	start;				//	start of PC range where actions apply	unsigned short	end;				//	end of PC range where actions apply	unsigned short	action;				//	table-relative offset to actions for an} ExceptionRangeSmall;					//	exception thrown in range start..endtypedef struct ExceptionRangeLarge {	unsigned long	start;				//	start of PC range where actions apply	unsigned short	size;				//	size of PC range/4 where actions apply	unsigned short	action;				//	table-relative offset to actions for an} ExceptionRangeLarge;					//	exception thrown in range start..end//	Exception Tables (per-function)typedef struct ExceptionTable {	unsigned short		savedGPRs	: 5,	//	# of saved GPRs (rN-r31)						savedFPRs	: 5,	//	# of saved FPRs (rN-r31)						savedCR		: 1,	//	1 -> saved CR in frame							hasframeptr	: 1,	//	1 -> frame uses R31 as frame pointer						largetable	: 1,	//  (always zero)#if __ALTIVEC__						hasaltivec	: 1,	//  next short has altivec info 						reserved	: 2;	//	(reserved for future use)#else						reserved	: 3;	//	(reserved for future use)#endif	ExceptionRangeSmall	ranges[];			//	table of PC ranges and their actions//	unsigned short		end = 0;			//	(marks end of range list)//	unsigned long		actions[];			//	arbitrary action data} ExceptionTable;typedef struct ExceptionTableSmall {	unsigned short		savedGPRs	: 5,	//	# of saved GPRs (rN-r31)						savedFPRs	: 5,	//	# of saved FPRs (rN-r31)						savedCR		: 1,	//	1 -> saved CR in frame							hasframeptr	: 1,	//	1 -> frame uses R31 as frame pointer						largetable	: 1,	//  (always zero)#if __ALTIVEC__						hasaltivec	: 1,	//  next short has altivec info 						reserved	: 2;	//	(reserved for future use)#else						reserved	: 3;	//	(reserved for future use)#endif	ExceptionRangeSmall	smallranges[];		//	table of small PC ranges and their actions//	unsigned short		end = 0;			//	(marks end of range list)//	unsigned long		actions[];			//	arbitrary action data} ExceptionTableSmall;#if __ALTIVEC__typedef struct ExceptionTableSmallVector {	unsigned short		savedGPRs	: 5,	//	# of saved GPRs (rN-r31)						savedFPRs	: 5,	//	# of saved FPRs (rN-r31)						savedCR		: 1,	//	1 -> saved CR in frame							hasframeptr	: 1,	//	1 -> frame uses R31 as frame pointer						largetable	: 1,	//  (always zero)						hasaltivec	: 1,	//  next short has altivec info 						reserved	: 2;	//	(reserved for future use)	unsigned short		savedVRs	: 5,	//	# of saved GPRs (vrN-vr31)						hasvrsave	: 1,	//  has vrsave available in frame						reservedv	: 10;	//  reserved	ExceptionRangeSmall	smallranges[];		//	table of small PC ranges and their actions//	unsigned short		end = 0;			//	(marks end of range list)//	unsigned long		actions[];			//	arbitrary action data} ExceptionTableSmallVector;#endif//	Exception Tables (per-function)typedef struct ExceptionTableLarge {	unsigned short		savedGPRs	: 5,	//	# of saved GPRs (rN-r31)						savedFPRs	: 5,	//	# of saved FPRs (rN-r31)						savedCR		: 1,	//	1 -> saved CR in frame							hasframeptr	: 1,	//	1 -> frame uses R31 as frame pointer						largetable  : 1,	//  (always 1)#if __ALTIVEC__						hasaltivec	: 1,	//  next short has altivec info 						reserved	: 2;	//	(reserved for future use)	unsigned short		savedVRs	: 5,	//	# of saved GPRs (vrN-vr31)						hasvrsave	: 1,	//  has vrsave available in frame						reservedv	: 10;	//  reserved#else						reserved	: 3;	//	(reserved for future use)	unsigned short		unused;				//  reserved (align ranges on 4 byte boundary)#endif	ExceptionRangeLarge	largeranges[];		//	table of large PC ranges and their actions//  unsigned long   	start = 0;			//  (marks end of range list)//	unsigned short		size = 0;			//	(marks end of range list)//	unsigned long		actions[];			//	arbitrary action data} ExceptionTableLarge;//	Exception Table Indices (per-function)#if __MACH__	typedef struct ExceptionTableIndex {		void *			functionaddr;           //      abs address of function		unsigned long	directstore		: 1,	//	1 -> 4 byte exception table is in 'exceptionoffset'						functionsize	: 31;	//	length of function		void *			exceptionaddr;          //      data-relative address of exception table	} ExceptionTableIndex;                      //      (or table itself if 'directstore' == 1)#else	typedef struct ExceptionTableIndex {		unsigned long	functionoffset;		//	code-relative address of function		unsigned long	directstore : 1,	//	1 -> 4 byte exception table is in 'exceptionoffset'						functionsize : 31;	//	length of function		unsigned long	exceptionoffset;	//	data-relative address of exception table	} ExceptionTableIndex;					//	(or table itself if 'directstore' == 1)#endif#ifdef	__MWERKS__	#pragma options align=reset#endif#endif/* Change record: * JWW 010306 Changed #if __VEC__ to #if __ALTIVEC__ for the generic runtime library -- whoohoo! * JWW 010531 Synchronized Mach-O and PEF runtime code * JWW 010728 Added in Rommel's support code for throwing exceptions with >32K stack frames */