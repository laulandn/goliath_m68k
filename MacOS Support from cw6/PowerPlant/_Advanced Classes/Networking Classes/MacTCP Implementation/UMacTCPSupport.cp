// ===========================================================================//	UMacTCPSupport.cp			PowerPlant 2.1		©1996-2000 Metrowerks Inc.// ===========================================================================////	Helpers for MacTCP classes.////	UMacTCPSupport-//		Handles gestalt checks for MacTCP//		Keeps global reference to MacTCP driver and DNS code segment.////	StMacTCPOperation-//		Manages TCPParamBlock and thread blocking for MacTCP interface calls////	LMacTCPDNSOperation-//		Manages thread blocking for MacTCP DNS interface calls////	StMacTCPUDPOperation-//		Manages UDPParamBlock and thread blocking for MacTCP related UDP interface calls////	LMacTCP_CloseResolver-//		Installs cleanup task to ensure that CloseResolver is called when necessary#include <UMacTCPSupport.h>#if PP_Target_Carbon		// MacTCP not supported. Remove this file from Carbon targets	#error "Carbon does not support MacTCP"#endif#include <UCallbackUtils.h>#include <PP_Networking.h>#include <LMacTCPTCPEndpoint.h>#include <LMacTCPUDPEndpoint.h>#include <Gestalt.h>#include <Processes.h>PP_Begin_Namespace_PowerPlant// ---------------------------------------------------------------------------//	Class VariablesSInt16					UMacTCPSupport::sMacTCPRefNum = 0;LMacTCP_CloseResolver*	UMacTCPSupport::sCloseResolverTask = nil;TCPIOCompletionUPP		StMacTCPOperation::sMacTCPCompletionProc											= NewTCPIOCompletionUPP(Int_TCPCompletionProc);ResultUPP				LMacTCPDNSOperation::sMacTCPDNSCompletionProc											= NewResultProc(Int_DNSCompletionProc);UDPIOCompletionUPP		StMacTCPUDPOperation::sMacTCPUDPCompletionProc											= NewUDPIOCompletionUPP(Int_UDPCompletionProc);LTCPParamBlockDeleteQueue*	StMacTCPOperation::sTCPParamBlockDeleteQueue = nil;LUDPParamBlockDeleteQueue*	StMacTCPUDPOperation::sUDPParamBlockDeleteQueue = nil;LDNSOperationDeleteQueue*	LMacTCPDNSOperation::sDNSOperationDeleteQueue = nil;UInt16					LMacTCPDNSOperation::sMacTCPDNSPendingOperations = 0;// ===========================================================================#pragma mark === UMacTCPSupport ===// ---------------------------------------------------------------------------//		¥ HasMacTCP// ---------------------------------------------------------------------------BooleanUMacTCPSupport::HasMacTCP(){	long				theResponse;	return (::Gestalt(FOUR_CHAR_CODE('mtcp'), &theResponse) == noErr);}// ---------------------------------------------------------------------------//		¥ OpenMacTCPDriver// ---------------------------------------------------------------------------voidUMacTCPSupport::OpenMacTCPDriver(){	// Open MacTCP driver if not already open.	if (sMacTCPRefNum == 0) {		ParamBlockRec theParamBlock;		theParamBlock.ioParam.ioNamePtr = "\p.IPP";		theParamBlock.ioParam.ioPermssn = fsCurPerm;		ThrowIfError_(::PBOpenSync(&theParamBlock));		sMacTCPRefNum = theParamBlock.ioParam.ioRefNum;	}	StMacTCPOperation::NewTCPParamBlockDeleteQueue();	StMacTCPUDPOperation::NewUDPParamBlockDeleteQueue();	LMacTCPDNSOperation::NewDNSOperationDeleteQueue();	// Open DNR code segment if not already done.	// Install a cleanup task that will ensure that the resolver	// gets closed when the app terminates.    if (sCloseResolverTask == nil) {        ThrowIfError_(::OpenResolver(nil));        sCloseResolverTask = new LMacTCP_CloseResolver;    }}// ---------------------------------------------------------------------------//		¥ GetMacTCPRefNum// ---------------------------------------------------------------------------SInt16UMacTCPSupport::GetMacTCPRefNum(){	return sMacTCPRefNum;}// ===========================================================================#pragma mark -#pragma mark === StMacTCPOperation ===// ---------------------------------------------------------------------------//		¥ StMacTCPOperation()// ---------------------------------------------------------------------------//	ConstructorStMacTCPOperation::StMacTCPOperation(	SInt16		inOperationCode,	StreamPtr	inStreamPtr){	mTCPParamBlock = new STCPParamBlock();	//Zero fill TCP param block	char * temp = (char*)mTCPParamBlock;	for (UInt16 i = 0; i < sizeof(STCPParamBlock); i++)		temp[i] = 0x00;	// Fill in all default TCP parameters.	mTCPParamBlock->csCode = inOperationCode;	mTCPParamBlock->ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();	mTCPParamBlock->ioCompletion = GetCompletionProc();	mTCPParamBlock->tcpStream = inStreamPtr;	mTCPParamBlock->mOperation = this;	mTCPParamBlock->mEndpoint = nil;	mTCPParamBlock->mEventCode = 0;}// ---------------------------------------------------------------------------//		¥ ~StMacTCPOperation// ---------------------------------------------------------------------------//	DestructorStMacTCPOperation::~StMacTCPOperation(){	//NOTE: mTCPParamBlock not necessarily deleted here since it may have to exist	//			outside the scope of the operation in the event of an abort	if (mTCPParamBlock->mOperation)		delete mTCPParamBlock;}// ---------------------------------------------------------------------------//		¥ Int_TCPCompletionProc// ---------------------------------------------------------------------------//	NOTE: This routine called at interrupt time#pragma profile offvoidStMacTCPOperation::Int_TCPCompletionProc(	STCPParamBlock*	inParamBlock		#if !TARGET_RT_MAC_CFM			: __A0		#endif	){	StMacTCPOperation* theOperation = inParamBlock->mOperation;	if (theOperation) {		StSetupGlobals globals(*theOperation);		theOperation->Int_AsyncResume(theOperation->mTCPParamBlock->ioResult);	} else {		//Check to see if we have an endpoint reference. If so,		//	send a Int_HandleAsyncEvent message back to that endpoint		LMacTCPTCPEndpoint* theEndpoint = inParamBlock->mEndpoint;		if (theEndpoint) {			theEndpoint->Int_HandleAsyncEvent(						inParamBlock->mEventCode,						0,						nil,						inParamBlock->tcpStream);		}		//queue param block for deletion at primary task time		sTCPParamBlockDeleteQueue->Append(inParamBlock);	}}#pragma profile reset// ---------------------------------------------------------------------------//		¥ Run// ---------------------------------------------------------------------------// Attempt the operation. Check for immediate failure.voidStMacTCPOperation::Run(){	//LOperationListMember stuff used by abort routines	LOperationListMember * operationListMem = new LOperationListMember(this);	try {		ThrowIfError_(::PBControlAsync((ParmBlkPtr)mTCPParamBlock));		WaitForResult();	} catch(...) {		delete operationListMem;		throw;	}	delete operationListMem;}// ---------------------------------------------------------------------------//		¥ AsyncRun// ---------------------------------------------------------------------------// Run the operation and return immediately. The completion will appear as a//	notification on the endpoint.// Functions using this method can NOT be aborted.// Presently used only for LMacTCPTCPEndpoint::SendDisconnect() to mimic//	behavior of OT.voidStMacTCPOperation::AsyncRun(LMacTCPTCPEndpoint*	inEndpoint,							UInt16				inEventCode){	mTCPParamBlock->mOperation = nil;	mTCPParamBlock->mEndpoint = inEndpoint;	mTCPParamBlock->mEventCode = inEventCode;	ThrowIfError_(::PBControlAsync((ParmBlkPtr)mTCPParamBlock));}// ADM 000412 - Bug #IL9905-0826 - Block Start// ---------------------------------------------------------------------------//		¥ NewTCPParamBlockDeleteQueue// ---------------------------------------------------------------------------// Allocate static sTCPParamBlockDeleteQueue.voidStMacTCPOperation::NewTCPParamBlockDeleteQueue(){	if ( sTCPParamBlockDeleteQueue == nil ) {		sTCPParamBlockDeleteQueue = new LTCPParamBlockDeleteQueue();	}}// ---------------------------------------------------------------------------//		¥ DeleteTCPParamBlockDeleteQueue// ---------------------------------------------------------------------------// Destroy static sTCPParamBlockDeleteQueue.voidStMacTCPOperation::DeleteTCPParamBlockDeleteQueue(){	if ( sTCPParamBlockDeleteQueue != nil ) {		delete sTCPParamBlockDeleteQueue;		sTCPParamBlockDeleteQueue = nil;	}}// ===========================================================================#pragma mark -#pragma mark === LMacTCPDNSOperation ===//	NOTE: This was StMacTCPDNSOperation in previous versions. It was determined that//			it was not stack safe and has been renamed. In addition its usage in//			LMacTCPInternetMapper has changed as well. This should not effect your//			code unless you are working direclty with this object for some reason.// ---------------------------------------------------------------------------//		¥ LMacTCPDNSOperation()// ---------------------------------------------------------------------------//	ConstructorLMacTCPDNSOperation::LMacTCPDNSOperation(){	mOperationListMem = nil;}// ---------------------------------------------------------------------------//		¥ ~LMacTCPDNSOperation// ---------------------------------------------------------------------------//	DestructorLMacTCPDNSOperation::~LMacTCPDNSOperation(){	delete mOperationListMem;}// ---------------------------------------------------------------------------//		¥ Int_DNSCompletionProc// ---------------------------------------------------------------------------//	NOTE: This routine called at interrupt time#pragma profile offpascal voidLMacTCPDNSOperation::Int_DNSCompletionProc(	hostInfo*	inHostInfoPtr,	Ptr			inUserDataPtr){	sMacTCPDNSPendingOperations--;	LMacTCPDNSOperation* theOperation = (LMacTCPDNSOperation*)inUserDataPtr;	StSetupGlobals globals(*theOperation);	theOperation->Int_AsyncResume(inHostInfoPtr->rtnCode);	sDNSOperationDeleteQueue->Append(theOperation);}pascal voidLMacTCPDNSOperation::Int_DNSCompletionProc2(	returnRec*	inReturnRecPtr,	Ptr			inUserDataPtr){	sMacTCPDNSPendingOperations--;	LMacTCPDNSOperation* theOperation = (LMacTCPDNSOperation*)inUserDataPtr;	StSetupGlobals globals(*theOperation);	theOperation->Int_AsyncResume(inReturnRecPtr->rtnCode);	sDNSOperationDeleteQueue->Append(theOperation);}#pragma profile resetvoidLMacTCPDNSOperation::WaitForCompletion(){	//Don't block the main thread?	if (mThread == LThread::GetMainThread())		Throw_(threadProtocolErr);	sMacTCPDNSPendingOperations++;	mOperationListMem = new LOperationListMember(this);	mThread->Block();	ThrowIfError_(mResult);}// ---------------------------------------------------------------------------//		¥ NewTCPParamBlockDeleteQueue// ---------------------------------------------------------------------------// Allocate static sDNSOperationDeleteQueue.voidLMacTCPDNSOperation::NewDNSOperationDeleteQueue(){	if ( sDNSOperationDeleteQueue == nil ) {		sDNSOperationDeleteQueue = new LDNSOperationDeleteQueue();	}}// ---------------------------------------------------------------------------//		¥ DeleteTCPParamBlockDeleteQueue// ---------------------------------------------------------------------------// Destroy static sDNSOperationDeleteQueue.voidLMacTCPDNSOperation::DeleteDNSOperationDeleteQueue(){	if ( sDNSOperationDeleteQueue != nil ) {		delete sDNSOperationDeleteQueue;		sDNSOperationDeleteQueue = nil;	}}// ===========================================================================#pragma mark -#pragma mark === StMacTCPUDPOperation ===// ---------------------------------------------------------------------------//		¥ StMacTCPUDPOperation()// ---------------------------------------------------------------------------//	ConstructorStMacTCPUDPOperation::StMacTCPUDPOperation(	SInt16		inOperationCode,	StreamPtr	inStreamPtr){	mUDPParamBlock = new SUDPParamBlock();	//Zero fill TCP param block	char * temp = (char*)mUDPParamBlock;	for (UInt16 i = 0; i < sizeof(SUDPParamBlock); i++)		temp[i] = 0x00;	// Fill in all default TCP parameters.	mUDPParamBlock->csCode = inOperationCode;	mUDPParamBlock->ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();	mUDPParamBlock->ioCompletion = GetCompletionProc();	mUDPParamBlock->udpStream = inStreamPtr;	mUDPParamBlock->mOperation = this;}// ---------------------------------------------------------------------------//		¥ ~StMacTCPUDPOperation// ---------------------------------------------------------------------------//	DestructorStMacTCPUDPOperation::~StMacTCPUDPOperation(){	//NOTE: mTCPParamBlock not necessarily deleted here since it may have to exist	//			outside the scope of the operation in the event of an abort	if (mUDPParamBlock->mOperation)		delete mUDPParamBlock;}// ---------------------------------------------------------------------------//		¥ Int_UDPCompletionProc// ---------------------------------------------------------------------------//	NOTE: This routine called at interrupt time#pragma profile offvoidStMacTCPUDPOperation::Int_UDPCompletionProc(	SUDPParamBlock* inParamBlock		#if !TARGET_RT_MAC_CFM			: __A0		#endif	){	StMacTCPUDPOperation* theOperation = inParamBlock->mOperation;	if (theOperation) {		StSetupGlobals globals(*theOperation);		theOperation->Int_AsyncResume(theOperation->mUDPParamBlock->ioResult);	} else {		//Check to see if we have an endpoint reference. If so,		//	send a Int_HandleAsyncEvent message back to that endpoint		LMacTCPUDPEndpoint* theEndpoint = inParamBlock->mEndpoint;		if (theEndpoint) {			theEndpoint->Int_HandleAsyncEvent(						(UInt16) inParamBlock->csCode,						nil,						inParamBlock->udpStream);		}		//queue param block for deletion at primary task time		sUDPParamBlockDeleteQueue->Append(inParamBlock);	}}#pragma profile reset// ---------------------------------------------------------------------------//		¥ Run// ---------------------------------------------------------------------------// Attempt the operation. Check for immediate failure.voidStMacTCPUDPOperation::Run(){	//LOperationListMember stuff used by abort routines	LOperationListMember * operationListMem = new LOperationListMember(this);	try {		ThrowIfError_(::PBControlAsync((ParmBlkPtr)mUDPParamBlock));		WaitForResult();	} catch(...) {		delete operationListMem;		throw;	}	delete operationListMem;}// ---------------------------------------------------------------------------//		¥ NewUDPParamBlockDeleteQueue// ---------------------------------------------------------------------------// Allocate static sUDPParamBlockDeleteQueue.voidStMacTCPUDPOperation::NewUDPParamBlockDeleteQueue(){	if ( sUDPParamBlockDeleteQueue == nil ) {		sUDPParamBlockDeleteQueue = new LUDPParamBlockDeleteQueue();	}}// ---------------------------------------------------------------------------//		¥ DeleteUDPParamBlockDeleteQueue// ---------------------------------------------------------------------------// Destroy static sUDPParamBlockDeleteQueue.voidStMacTCPUDPOperation::DeleteUDPParamBlockDeleteQueue(){	if ( sUDPParamBlockDeleteQueue != nil ) {		delete sUDPParamBlockDeleteQueue;		sUDPParamBlockDeleteQueue = nil;	}}// ===========================================================================#pragma mark -#pragma mark === LMacTCP_CloseResolver ===// ---------------------------------------------------------------------------//		¥ LMacTCP_CloseResolver// ---------------------------------------------------------------------------//	ConstructorLMacTCP_CloseResolver::LMacTCP_CloseResolver(){}// ---------------------------------------------------------------------------//		¥ ~LMacTCP_CloseResolver// ---------------------------------------------------------------------------//	DestructorLMacTCP_CloseResolver::~LMacTCP_CloseResolver(){}// ---------------------------------------------------------------------------//		¥ DoCleanup// ---------------------------------------------------------------------------voidLMacTCP_CloseResolver::DoCleanup(){	// Wait for the pending DNS operations to complete before calling	//	close resolver	while (LMacTCPDNSOperation::sMacTCPDNSPendingOperations != 0)		;	StMacTCPOperation::DeleteTCPParamBlockDeleteQueue();	StMacTCPUDPOperation::DeleteUDPParamBlockDeleteQueue();	LMacTCPDNSOperation::DeleteDNSOperationDeleteQueue();	::CloseResolver();}// ===========================================================================#pragma mark -LTCPParamBlockDeleteQueue::LTCPParamBlockDeleteQueue(){	StartRepeating();}LTCPParamBlockDeleteQueue::~LTCPParamBlockDeleteQueue(){}voidLTCPParamBlockDeleteQueue::SpendTime(const EventRecord& /* inMacEvent */){	if (!IsEmpty()) {		LInterruptSafeListMember*	p;		LInterruptSafeListIterator	iter(*this);		while (iter.Next(p)) {			delete p;		}	}}// ===========================================================================#pragma mark -LUDPParamBlockDeleteQueue::LUDPParamBlockDeleteQueue(){	StartRepeating();}LUDPParamBlockDeleteQueue::~LUDPParamBlockDeleteQueue(){}voidLUDPParamBlockDeleteQueue::SpendTime(const EventRecord& /* inMacEvent */){	if (!IsEmpty()) {		LInterruptSafeListMember*	p;		LInterruptSafeListIterator	iter(*this);		while (iter.Next(p)) {			delete p;		}	}}// ===========================================================================#pragma mark -LDNSOperationDeleteQueue::LDNSOperationDeleteQueue(){	StartRepeating();}LDNSOperationDeleteQueue::~LDNSOperationDeleteQueue(){}voidLDNSOperationDeleteQueue::SpendTime(const EventRecord& /* inMacEvent */){	if (!IsEmpty()) {		LInterruptSafeListMember*	p;		LInterruptSafeListIterator	iter(*this);		while (iter.Next(p)) {			LMacTCPDNSOperation * operation = (LMacTCPDNSOperation*)p;			delete operation;		}	}}PP_End_Namespace_PowerPlant