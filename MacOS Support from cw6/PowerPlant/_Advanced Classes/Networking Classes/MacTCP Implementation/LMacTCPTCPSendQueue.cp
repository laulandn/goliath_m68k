// ===========================================================================//	LMacTCPTCPSendQueue.cp		PowerPlant 2.1		©1996-1999 Metrowerks Inc.// ===========================================================================////	Queues data for asynchronous style data sending for MacTCP. Used primarily//	for OT style acked data transfers which are not native to MacTCP.#include <LMacTCPTCPSendQueue.h>#if PP_Target_Carbon		// MacTCP not supported. Remove this file from Carbon targets	#error "Carbon does not support MacTCP"#endifPP_Begin_Namespace_PowerPlant// ===========================================================================#pragma mark === LMacTCPTCPSendQueue ===// ---------------------------------------------------------------------------//		¥ LMacTCPTCPSendQueue// ---------------------------------------------------------------------------//	ConstructorLMacTCPTCPSendQueue::LMacTCPTCPSendQueue(						LMacTCPTCPEndpoint * inEndpoint)	: LSendQueue(inEndpoint){	mMacTCPEndpoint = inEndpoint;	mOperation = new StMacTCPTCPSendOperation(this, mMacTCPEndpoint->mTCPStream);}// ---------------------------------------------------------------------------//		¥ LMacTCPTCPSendQueue// ---------------------------------------------------------------------------//	DestructorLMacTCPTCPSendQueue::~LMacTCPTCPSendQueue(){	delete mOperation;	if (!mEndpointDead)		mMacTCPEndpoint->mSendQueue = nil;}// ---------------------------------------------------------------------------//		¥ NotifyRelease// ---------------------------------------------------------------------------//	Returns the size of the pending data in the queuevoidLMacTCPTCPSendQueue::NotifyRelease(LSendData* inData){	mMacTCPEndpoint->mMessageQueue->Append(new(*(mMacTCPEndpoint->mSharedPool))		LMemoryReleasedMsg(T_MEMORYRELEASED, kOTNoError, inData->mData, inData->mDataSize, mMacTCPEndpoint));}// ---------------------------------------------------------------------------//		¥ Int_InternalSend// ---------------------------------------------------------------------------//	Sends are chained via the completion routine//	NOTE: This routine *might* be called at interrupt timevoidLMacTCPTCPSendQueue::Int_InternalSend(){	if (mEndpointDead)		return;	mBusy = true;	switch (mMacTCPEndpoint->GetState()) {		case T_DATAXFER:		case T_INREL:			break;		default:			return;	}	mOperation->SetStream(mMacTCPEndpoint->mTCPStream);	STCPParamBlock& operationPB = mOperation->GetParamBlock();	operationPB.csParam.send.ulpTimeoutValue = 0;	operationPB.csParam.send.ulpTimeoutAction = 0;	operationPB.csParam.send.validityFlags = 0;	operationPB.csParam.send.pushFlag = 0;	operationPB.csParam.send.urgentFlag = 0;	operationPB.csParam.send.wdsPtr = (char*)mWDS;	TInterruptSafeListIterator<LSendData*> iter(mWaitingQueue);	LSendData* p;	UInt32 wdsSize = 0;	UInt32 wdsBytes = 0;	while (iter.Next(p)) {		LMacTCPSendData* data = (LMacTCPSendData*) p;		if (data->mDataSize + wdsBytes > 65535)			break;		//Remove from waiting queue		if (!mWaitingQueue.Remove(p))			break;		//Append to pending queue		mPendingQueue.Append(p);		operationPB.csParam.send.urgentFlag =						data->mExpedited || operationPB.csParam.send.urgentFlag;		mWDS[wdsSize].length = (UInt16) data->mDataSize;		mWDS[wdsSize++].ptr = (char*)data->mData;		if (wdsSize >= 4)			break;	}	mWDS[wdsSize].length = 0;	mOperation->Int_AsyncRun();	//resume the thread if blocked and memory restrictions lifted	if (mThread) {		if (WaitingDataSize() < GetBlockingDataSize()) {			LThread::ThreadAsynchronousResume(mThread);			mThread = nil;		}	}}// ===========================================================================#pragma mark -#pragma mark === StMacTCPTCPSendOperation ===// ---------------------------------------------------------------------------//		¥ Constructor// ---------------------------------------------------------------------------StMacTCPTCPSendOperation::StMacTCPTCPSendOperation(								LMacTCPTCPSendQueue * inSendQueue,								StreamPtr	inStreamPtr)	: StMacTCPOperation(TCPSend, inStreamPtr){	mMacTCPSendQueue = inSendQueue;}// ---------------------------------------------------------------------------//		¥ Destructor// ---------------------------------------------------------------------------StMacTCPTCPSendOperation::~StMacTCPTCPSendOperation(){}// ---------------------------------------------------------------------------//		¥ SetStream// ---------------------------------------------------------------------------voidStMacTCPTCPSendOperation::SetStream(StreamPtr	inStreamPtr){	mTCPParamBlock->tcpStream = inStreamPtr;}// ---------------------------------------------------------------------------//		¥ AsyncResume// ---------------------------------------------------------------------------//	NOTE: This routine *might* be called at interrupt timevoidStMacTCPTCPSendOperation::Int_AsyncResume(OSStatus	inResult){	mResult = inResult;	mMacTCPSendQueue->Int_SendComplete();}// ---------------------------------------------------------------------------//		¥ AbortOperation// ---------------------------------------------------------------------------voidStMacTCPTCPSendOperation::AbortOperation(){	Int_AsyncResume(Abort_Error);}// ---------------------------------------------------------------------------//		¥ Int_AsyncRun// ---------------------------------------------------------------------------// Attempt the operation. Check for immediate failure. This Run does not block a thread//	NOTE: This routine *might* be called at interrupt timevoidStMacTCPTCPSendOperation::Int_AsyncRun(){	mTCPParamBlock->csCode = TCPSend;	mTCPParamBlock->ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();	mTCPParamBlock->ioCompletion = GetCompletionProc();	OSErr result = ::PBControlAsync((ParmBlkPtr)mTCPParamBlock);	if (result)		::DebugStr("\p StMacTCPTCPSendOperation::Int_AsyncRun - PBControlAsync failed");}PP_End_Namespace_PowerPlant