/* *	WASTE Demo Project: *	Application Code * *	Copyright © 1993-2002 Marco Piovanelli *	All Rights Reserved * *	Original C Port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __WEDEMO__#include "WEDemo.h"#endifvoid ForgetHandle ( Handle * h ){	Handle theHandle;	if ( ( theHandle = * h ) != NULL )	{		* h = NULL ;		DisposeHandle ( theHandle ) ;	}}OSStatus CloneHandle ( Handle inSrcHandle, Handle * outDstHandle ){	Size			handleSize ;	OSStatus		err ;	if ( ! inSrcHandle || ! outDstHandle )	{		return paramErr ;	}	/* get source handle size */	handleSize = GetHandleSize ( inSrcHandle ) ;	/* allocate destination handle */	* outDstHandle = NewHandle ( handleSize ) ;	if ( ( err = MemError ( ) ) != noErr )	{		return err ;	}	/* copy handle contents */	BlockMoveData ( * inSrcHandle, ** outDstHandle, handleSize ) ;	return noErr ;}OSStatus CloneColorIcon ( CIconHandle inSrcIcon, CIconHandle * outDstIcon ){	Handle			clonedColors = NULL ;	Handle			clonedIconData = NULL ;	OSStatus		err ;	/* clone the color table */	if ( ( err = CloneHandle ( ( Handle ) ( * inSrcIcon ) -> iconPMap . pmTable, & clonedColors ) ) != noErr )	{		goto cleanup ;	}	/* clone the icon data */	if ( ( err = CloneHandle ( ( * inSrcIcon ) -> iconData, & clonedIconData ) ) != noErr )	{		goto cleanup ;	}	/* clone the icon itself */	if ( ( err = CloneHandle ( ( Handle ) inSrcIcon, ( Handle * ) outDstIcon ) ) != noErr )	{		goto cleanup ;	}	( ** outDstIcon ) -> iconPMap . pmTable = ( CTabHandle ) clonedColors ;	( ** outDstIcon ) -> iconData = clonedIconData ;cleanup :	if ( err != noErr )	{		ForgetHandle ( & clonedColors ) ;		ForgetHandle ( & clonedIconData ) ;		ForgetHandle ( ( Handle * ) outDstIcon ) ;	}	return err ;}void ReplaceParam ( Str255 ioBaseString, ConstStr255Param inParamString, UInt16 inParamIndex ){	int		baseLength = StrLength ( ioBaseString ) ;	int		paramLength = StrLength ( inParamString ) ;	int		baseIndex ;	inParamIndex += '0' ;	for ( baseIndex = 1 ; baseIndex < baseLength ; baseIndex ++ )	{		if ( ( ioBaseString [ baseIndex ] == '^' ) && ( ioBaseString [ baseIndex + 1 ] == inParamIndex ) )		{			/* sanity check: make sure there is enough room for the replacement string */			if ( baseLength + paramLength <= 255 + 2 )			{				/* make room for the replacement string */				BlockMoveData ( ioBaseString + baseIndex + 2, ioBaseString + baseIndex + paramLength, baseLength - baseIndex - 1 ) ;				/* insert the replacement string */				BlockMoveData ( inParamString + 1, ioBaseString + baseIndex, paramLength ) ;				/* adjust length byte */				ioBaseString [ 0 ] = baseLength + paramLength - 2 ;			}			break ;		}	}}void NumToVersionString ( UInt32 inVersion, Str15 outVersionString ){	static unsigned char	stages [ 3 ] = { 'd', 'a', 'b' } ;	unsigned char *			p = outVersionString ;	int						stage ;	/* special case: a zero version means "version not available" */	if ( inVersion == 0 )	{		* ++ p = 'n' ;		* ++ p = '/' ;		* ++ p = 'a' ;	}	else	{		/* major revision */		if ( inVersion & 0xF0000000 )		{			* ++ p = ( ( inVersion & 0xF0000000 ) >> 28 ) + '0' ;		}		* ++ p = ( ( inVersion & 0x0F000000 ) >> 24 ) + '0' ;		/* add a dot */		* ++ p = '.' ;		/* minor revision */		* ++ p = ( ( inVersion & 0x00F00000 ) >> 20 ) + '0' ;		if ( inVersion & 0x000F0000 )		{			* ++ p = '.' ;			* ++ p = ( ( inVersion & 0x000F0000 ) >> 16 ) + '0' ;		}		/* stage */		stage = ( ( inVersion & 0x0000FF00 ) >> 13 ) - 1 ;		if ( stage < 3 )		{			* ++ p = stages [ stage ] ;		/* pre-release (development, alpha or beta) */			/* revision level (this is a vanilla unsigned integer, it is NOT coded as BCD) */			inVersion &= 0x000000FF ;			if ( inVersion / 100 )			{				* ++ p = ( inVersion / 100 ) + '0' ;			}			inVersion %= 100 ;			if ( inVersion / 10 )			{				* ++ p = ( inVersion / 10 ) + '0' ;			}			inVersion %= 10 ;			* ++ p = inVersion + '0' ;		}	}	/* compute length byte */	* outVersionString = ( p - outVersionString ) ;}void ErrorAlert ( OSStatus inErrorCode ){	Str255		banner ;	Str255		explanation ;	Str255		errorString ;	SInt16		alertResult ;	GetIndString ( banner, kAlertStringsID, kIndexGenericErrorSummary ) ;	GetIndString ( explanation, kAlertStringsID, kIndexGenericErrorDescription ) ;	NumToString ( inErrorCode, errorString ) ;	ReplaceParam ( explanation, errorString, 0 ) ;	StandardAlert ( kAlertStopAlert, banner, explanation, NULL, & alertResult ) ;}static Boolean CheckVersion ( SInt16 inAlertStringIndex, UInt32 inInstalledVersion, UInt32 inRequiredVersion ){	Str255		banner ;	Str255		explanation ;	Str15		versionString ;	SInt16		alertResult ;	if ( inInstalledVersion < inRequiredVersion )	{		GetIndString ( banner, kAlertStringsID, inAlertStringIndex ) ;		GetIndString ( explanation, kAlertStringsID, inAlertStringIndex + 1 ) ;		NumToVersionString ( inInstalledVersion, versionString ) ;		ReplaceParam ( explanation, versionString, 0 ) ;		NumToVersionString ( inRequiredVersion, versionString ) ;		ReplaceParam ( explanation, versionString, 1 ) ;		StandardAlert ( kAlertStopAlert, banner, explanation, NULL, & alertResult ) ;		return true ;	}	return false ;}OSStatus InitializeMenus ( void ){	Handle				menuBar = NULL ;	MenuRef				menu ;	ItemCount			submenuCount = 0 ;	ItemCount			itemCount ;	ItemCount			itemIndex ;	MenuCommand			commandID ;	Str255				itemText ;	FMFontFamily		fontFamily ;	Fixed				fontSize ;	const MCEntry *		menuColorTableEntry ;	CIconHandle			templateIcon = NULL ;	CIconHandle			clonedIcon = NULL ;	RGBColor			textColor ;	WESelector			selector ;	SInt32				gestaltResponse ;	OSStatus			err ;	/* get the 'MBAR' resource */	menuBar = GetNewMBar ( kMenuBarID ) ;	if ( ( err = ResError ( ) ) != noErr )	{		goto cleanup ;	}	err = memFullErr ;	if ( ! menuBar )	{		goto cleanup ;	}	/* install the menu bar */	SetMenuBar ( menuBar ) ;	/* insert submenus into the hierarchical portion of the menu list */	if ( ( menu = GetMenu ( kMenuTextColor ) ) != NULL )	{		InsertMenu ( menu, kInsertHierarchicalMenu ) ;	}	if ( ( menu = GetMenu ( kMenuAlignment ) ) != NULL )	{		InsertMenu ( menu, kInsertHierarchicalMenu ) ;	}	/* create the Font menu */	if ( ( menu = GetMenuHandle ( kMenuFont ) ) != NULL )	{		if ( ( err = CreateStandardFontMenu ( menu, 0, kMenuFontFirstSubmenu, 0, & submenuCount ) ) != noErr )		{			goto cleanup ;		}		itemCount = CountMenuItems ( menu ) ;		for ( itemIndex = 1 ; itemIndex <= itemCount ; itemIndex ++ )		{			/* set the font family number for this menu item */			GetMenuItemText ( menu, itemIndex, itemText ) ;			fontFamily = FMGetFontFamilyFromName ( itemText ) ;			if ( ( err = SetMenuItemFontID ( menu, itemIndex, fontFamily ) ) != noErr )			{				goto cleanup ;			}			/* associate a kHICommandSetFont command to this menu item */			if ( ( err = SetMenuItemCommandID ( menu, itemIndex, weTagFontFamily ) ) != noErr )			{				goto cleanup ;			}			/* stash the font family number in a menu item property for WASTE */			if ( ( err = SetMenuItemProperty ( menu, itemIndex, kWASTECreator, weTagFontFamily, sizeof ( fontFamily ), & fontFamily ) ) != noErr )			{				goto cleanup ;			}		}	}	/* set up the Size menu */	if ( ( menu = GetMenuHandle ( kMenuSize ) ) != NULL )	{		itemCount = CountMenuItems ( menu ) ;		for ( itemIndex = 1 ; itemIndex <= itemCount ; itemIndex ++ )		{			/* look for items whose command ID is kHICommandSetFontSize */			if ( ( err = GetMenuItemCommandID ( menu, itemIndex, & commandID ) ) != noErr )			{				goto cleanup ;			}			if ( commandID == weTagFontSize )			{				/* extract font size from menu item text */				GetMenuItemText ( menu, itemIndex, itemText ) ;				itemText [ 0 ] -= 3 ;		/* strip off the leading " pt" at the end of the item text */				StringToNum ( itemText, & fontSize ) ;				fontSize <<= 16 ;			/* WASTE wants a 16:16 fixed-point value */				/* stash the font size in a menu item property for WASTE */				if ( ( err = SetMenuItemProperty ( menu, itemIndex, kWASTECreator, weTagFontSize, sizeof ( fontSize ), & fontSize ) ) != noErr )				{					goto cleanup ;				}			}		}	}	/* set up the Text Color menu */	if ( ( menu = GetMenuHandle ( kMenuTextColor ) ) != NULL )	{		/* load the template icon we'll use for color items */		templateIcon = GetCIcon ( kTemplateColorIconID ) ;		if ( ( err = ResError ( ) ) != noErr )		{			goto cleanup ;		}		itemCount = CountMenuItems ( menu ) ;		for ( itemIndex = 1 ; itemIndex <= itemCount ; itemIndex ++ )		{			/* look for items whose command ID is kHICommandSetTextColor */			if ( ( err = GetMenuItemCommandID ( menu, itemIndex, & commandID ) ) != noErr )			{				goto cleanup ;			}			if ( commandID == weTagTextColor )			{				/* extract text color from menu color tables */				if ( ( menuColorTableEntry = GetMCEntry ( kMenuTextColor, itemIndex ) ) != NULL )				{					/* stash the text color in a menu item property for WASTE */					textColor = menuColorTableEntry -> mctRGB2 ;					if ( ( err = SetMenuItemProperty ( menu, itemIndex, kWASTECreator, weTagTextColor, sizeof ( textColor ), & textColor ) ) != noErr )					{						goto cleanup ;					}					/* clone an icon from the template and munge its color table appropriately */					if ( ( err = CloneColorIcon ( templateIcon, & clonedIcon ) ) != noErr )					{						goto cleanup ;					}					( * ( * clonedIcon ) -> iconPMap . pmTable ) -> ctTable [ 0 ] . rgb = textColor ;					/* associate the color icon with this menu item */					if ( ( err = SetMenuItemIconHandle ( menu, itemIndex, kMenuColorIconType, ( Handle ) clonedIcon ) ) != noErr )					{						goto cleanup ;					}				}			}		}		/* delete all color information for this menu */		DeleteMCEntries ( kMenuTextColor, mctAllItems ) ;	}	/* set up the Alignment menu */	if ( ( menu = GetMenuHandle ( kMenuAlignment ) ) != NULL )	{		itemCount = CountMenuItems ( menu ) ;		for ( itemIndex = 1 ; itemIndex <= itemCount ; itemIndex ++ )		{			/* look for items whose command ID is kHICommandSetAlignment */			if ( ( err = GetMenuItemCommandID ( menu, itemIndex, & commandID ) ) != noErr )			{				goto cleanup ;			}			if ( commandID == weTagAlignment )			{				/* extract alignment selector from menu item refcon */				if ( ( err = GetMenuItemRefCon ( menu, itemIndex, & selector ) ) != noErr )				{					goto cleanup ;				}				/* stash the alignment selector in a menu item property for WASTE */				if ( ( err = SetMenuItemProperty ( menu, itemIndex, kWASTECreator, weTagAlignment, sizeof ( selector ), & selector ) ) != noErr )				{					goto cleanup ;				}			}		}	}	/* if we're running on a system with the Aqua user interface, */	/* remove the Quit item from the File menu, as a Quit item is */	/* automatically added for us to the Application menu */	if ( ( Gestalt ( gestaltMenuMgrAttr, & gestaltResponse ) == noErr ) && ( gestaltResponse & gestaltMenuMgrAquaLayoutMask ) )	{		if ( ( menu = GetMenuHandle ( kMenuFile ) ) != NULL )		{			/* assume the Quit item is the last item in the File menu and follows a separator line */			itemCount = CountMenuItems ( menu ) ;			if ( itemCount > 2 )			{				DeleteMenuItem ( menu, itemCount ) ;				DeleteMenuItem ( menu, itemCount - 1 ) ;			}		}	}	/* create the Window menu and insert it at the end of the menu bar */	if ( ( err = CreateStandardWindowMenu ( kNilOptions, & menu ) ) != noErr )	{		goto cleanup ;	}	InsertMenu ( menu, 0 ) ;	/* this application supports contextual menus */	InitContextualMenus ( ) ;	/* draw the menu bar */	DrawMenuBar ( ) ;	/* clear result code */	err = noErr ;cleanup :	if ( templateIcon )	{		DisposeCIcon ( templateIcon ) ;		templateIcon = NULL ;	}	ForgetHandle ( & menuBar ) ;	return err ;}OSStatus Initialize ( void ){	SInt32		systemVersion = 0 ;	SInt32		carbonLibVersion = 0 ;	OSStatus	err ;	/* make sure we're using a recent version of the system software */	if ( Gestalt ( gestaltSystemVersion, & systemVersion ) != noErr )	{		return -1 ;	}	systemVersion = ( systemVersion << 16 ) | 0x8000 ;	if ( systemVersion >= 0x10008000 )	{		/* Mac OS X */		if ( CheckVersion ( kIndexMacOSXTooOldSummary, systemVersion, kMinMacOSXVersion ) )		{			return -1 ;		}	}	else	{		/* Mac OS Classic */		if ( CheckVersion ( kIndexMacOSTooOldSummary, systemVersion, kMinMacOSClassicVersion ) )		{			return -1 ;		}		/* check CarbonLib version */		if ( Gestalt ( gestaltCarbonVersion, & carbonLibVersion ) != noErr )		{			return -1 ;		}		carbonLibVersion = ( carbonLibVersion << 16 ) | 0x8000 ;		if ( CheckVersion ( kIndexCarbonLibTooOldSummary, carbonLibVersion, kMinCarbonLibVersion ) )		{			return -1 ;		}	}	/* make sure we're using a recent version of WASTELib */	if ( CheckVersion ( kIndexWASTELibTooOldSummary, WEVersion ( ), kMinWASTEVersion ) )	{		return -1 ;	}	/* perform other initialization chores */	if ( ( err = InstallEventHandlers ( ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = InitializeMenus ( ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr;cleanup:	if ( err != noErr )	{		ErrorAlert ( err ) ;	}	return err ;}static OSStatus DoMouseMoved ( Point inMouseLocation, UInt32 inModifiers ){#pragma unused ( inModifiers )	WindowRef			window = NULL ;	OSStatus			err = eventNotHandledErr ;	/* is the cursor over the content area of a window? */	if ( FindWindow ( inMouseLocation, & window ) == inContent )	{		/* then let the window handle a kEventWindowCursorChange event */		goto cleanup ;	}	/* default to arrow cursor */	if ( ( err = SetThemeCursor ( kThemeArrowCursor ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}OSStatus SaveDocument	(		const FSRef *			inFolderRef,			/* folder where file should be saved to */		CFStringRef				inFileName,				/* name of file to create or overwrite */		Boolean					inReplacing,			/* if true, we're replacing an existing file */		OSType					inFileType,				/* file type */		Boolean					inStationery,			/* should we create a stationery pad? */		Document *				inDocument				/* document to save */	){	FSRef				newFile ;	OSStatus			err;	BlockZero ( & newFile, sizeof ( newFile ) ) ;	/* write the file */	if ( ( err = WriteFile ( inFolderRef, inFileName, inReplacing, inFileType, inDocument -> text, & newFile ) ) != noErr )	{		goto cleanup ;	}	if ( inStationery )	{		/* set the stationery bit on the file we just saved */		if ( ( err = FSSetIsStationery ( & newFile, true ) ) != noErr )		{			goto cleanup ;		}	}	else	{		/* reset the window title and proxy icon to reflect the new file's name and type */		if ( ( err = SetWindowTitleFromFile ( inDocument -> window, & newFile ) ) != noErr )		{			goto cleanup ;		}		/* remember new file */		ForgetHandle ( ( Handle * ) & inDocument -> fileAlias ) ;		if ( ( err = FSNewAlias ( NULL, & newFile, & inDocument -> fileAlias ) ) != noErr )		{			goto cleanup ;		}		/* set window proxy icon */		if ( ( err = SetWindowProxyAlias ( inDocument -> window, inDocument -> fileAlias ) ) != noErr )		{			goto cleanup ;		}		/* mark the window as clean */		if ( ( err = SetWindowModified ( inDocument -> window, false ) ) != noErr )		{			goto cleanup ;		}		/* this document is now "clean" (i.e., in sync with its on-disk version) -- remember the WASTE modification count */		inDocument -> cleanModCount = WEGetModCount ( inDocument -> text ) ;	}cleanup :	return err ;}OSStatus DoSave ( Document * inDocument, Boolean inCloseAfterSaving ){	FSRef				targetRef ;	FSRef				parentRef ;	CFStringRef			fileName = NULL ;	Boolean				wasChanged = false ;	OSStatus			err;	BlockZero ( & targetRef, sizeof ( targetRef ) ) ;	BlockZero ( & parentRef, sizeof ( parentRef ) ) ;	BlockZero ( & fileName, sizeof ( fileName ) ) ;	/* is there a file associated with this window? */	if ( inDocument -> fileAlias )	{		/* resolve alias */		if ( ( err = FSResolveAlias ( NULL, inDocument -> fileAlias, & targetRef, & wasChanged ) ) != noErr )		{			goto cleanup ;		}		/* get parent folder */		if ( ( err = FSGetCatalogInfo ( & targetRef, kFSCatInfoNone, NULL, NULL, NULL, & parentRef ) ) != noErr )		{			goto cleanup ;		}		/* get name */		if ( ( err = FSGetObjectNameAsCFString ( & targetRef, & fileName ) ) != noErr )		{			goto cleanup ;		}		/* save window */		if ( ( err = SaveDocument ( & parentRef, fileName, true, inDocument -> fileFormat, false, inDocument ) ) != noErr )		{			goto cleanup ;		}		/* close the document if necessary */		if ( inCloseAfterSaving )		{			DestroyDocument ( inDocument ) ;		}	}	else	{		/* if no file was previously associated with this window, or if the */		/* alias resolution failed, prompt the user for a new destination */		if ( ( err = DoSaveAs ( inDocument, inCloseAfterSaving ) ) != noErr )		{			goto cleanup ;		}	}	/* clear result code */	err = noErr ;cleanup :	if ( fileName )	{		CFRelease ( fileName ) ;		fileName = NULL ;	}	/* return result code */	return err ;}OSStatus DoQuit ( SavingOption inSavingOption ){	Document *			document ;	OSStatus			err ;	/* close all document windows */	while ( ( document = GetWindowDocument ( GetFrontWindowOfClass ( kDocumentWindowClass, false ) ) ) != NULL )	{		if ( ( err = DoClose ( kNavSaveChangesQuittingApplication, inSavingOption, document ) ) != noErr )		{			return err;		}	}	/* drop out of the event loop */	QuitApplicationEventLoop ( ) ;	return noErr ;}static OSStatus ProcessApplicationHICommand ( const HICommand * inHICommand ){	OSStatus			err ;	switch ( inHICommand -> commandID )	{		case kHICommandAbout :		{			err = DoAboutBox ( ) ;			break ;		}		case kHICommandNew :		{			err = CreateDocument ( NULL, NULL ) ;			break ;		}		case kHICommandOpen :		{			err = DoOpen ( ) ;			break ;		}		case kHICommandQuit :		{			err = DoQuit ( savingAsk ) ;			break ;		}		default :		{			err = eventNotHandledErr ;			break ;		}	}	/* return result code */	return err ;}static OSStatus UpdateApplicationHICommandStatus ( const HICommand * inHICommand ){	Boolean				enabled = false ;	OSStatus			err = noErr ;	switch ( inHICommand -> commandID )	{		case kHICommandAbout :		case kHICommandNew :		case kHICommandOpen :		case kHICommandQuit :		{			enabled = true ;			break ;		}		case kHICommandClose :		case kHICommandSave :		case kHICommandSaveAs :		case kHICommandPageSetup :		case kHICommandPrint :		case kHICommandUndo :		case kHICommandRedo :		case kHICommandCut :		case kHICommandCopy :		case kHICommandPaste :		case kHICommandClear :		case kHICommandSelectAll :		{			enabled = false ;			break ;		}		default :		{			err = eventNotHandledErr ;			break ;		}	}	if ( ( err == noErr ) && ( inHICommand -> attributes & kHICommandFromMenu ) && ( inHICommand -> menu . menuRef != NULL ) )	{		if ( enabled )		{			EnableMenuItem ( inHICommand -> menu . menuRef, inHICommand -> menu . menuItemIndex ) ;		}		else		{			DisableMenuItem ( inHICommand -> menu . menuRef, inHICommand -> menu . menuItemIndex ) ;		}	}	return err ;}static pascal OSStatus HandleMouseEvent ( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData ){#pragma unused ( inHandlerCallRef, inUserData )	Point				mouseLocation ;	UInt32				modifiers = 0 ;	OSStatus			err ;	/* get mouse location */	if ( ( err = GetEventParameter ( inEvent, kEventParamMouseLocation, typeQDPoint, NULL, sizeof ( mouseLocation ), NULL, & mouseLocation ) ) != noErr )	{		return err ;	}	/* get key modifiers */	if ( ( err = GetEventParameter ( inEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof ( modifiers ), NULL, & modifiers ) ) != noErr )	{		return err ;	}	switch ( GetEventKind ( inEvent ) )	{		case kEventMouseMoved :		{			err = DoMouseMoved ( mouseLocation, modifiers ) ;			break ;		}		default :		{			err = eventNotHandledErr ;			break ;		}	}	/* return result code */	return err ;}static pascal OSStatus HandleApplicationCommand ( EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void * inUserData ){#pragma unused ( inHandlerCallRef, inUserData )	HICommand			hiCommand ;	OSStatus			err ;	/* get HI command */	if ( ( err = GetEventParameter ( inEvent, kEventParamDirectObject, typeHICommand, NULL, sizeof ( hiCommand ), NULL, & hiCommand ) ) != noErr )	{		return err ;	}	switch ( GetEventKind ( inEvent ) )	{		case kEventCommandProcess :		{			err = ProcessApplicationHICommand ( & hiCommand ) ;			break ;		}		case kEventCommandUpdateStatus :		{			err = UpdateApplicationHICommandStatus ( & hiCommand ) ;			break ;		}		default :		{			err = eventNotHandledErr ;			break ;		}	}	/* return result code */	return err ;}static pascal OSErr CoerceAliasToFSRef	(		const AEDesc *		inFromDesc,		DescType			inToType,		SInt32				inHandlerRefcon,		AEDesc *			outToDesc	){#pragma unused ( inHandlerRefcon )	Handle			alias = 0 ;	Size			aliasSize ;	FSRef			fileRef ;	Boolean			wasChanged ;	OSStatus		err ;	/* sanity check: make sure inFromDesc is the expected type */	err = errAECoercionFail ;	if ( ( inFromDesc -> descriptorType != typeAlias ) || ( inFromDesc -> dataHandle == NULL ) )	{		goto cleanup ;	}	/* sanity check: make sure the type we're supposed to coerce to is the expected type */	if ( inToType != typeFSRef )	{		goto cleanup ;	}	/* get alias size */	aliasSize = AEGetDescDataSize ( inFromDesc ) ;	/* create a handle to hold the alias */	alias = NewHandle ( aliasSize ) ;	if ( ( err = MemError ( ) ) != noErr )	{		goto cleanup ;	}	/* copy the alias data into the handle */	HLock ( alias ) ;	err = AEGetDescData ( inFromDesc, * alias, aliasSize ) ;	HUnlock ( alias ) ;	if ( err != noErr )	{		goto cleanup ;	}	/* resolve the alias to an FSRef */	if ( ( err = FSResolveAlias ( 0, ( AliasHandle ) alias, & fileRef, & wasChanged ) ) != noErr )	{		goto cleanup ;	}	/* create an output descriptor for the FSRef */	if ( ( err = AECreateDesc ( typeFSRef, & fileRef, sizeof ( fileRef ), outToDesc ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	ForgetHandle ( & alias ) ;	/* return result code */	return err ;}static pascal OSErr CoerceFSSpecToFSRef	(		const AEDesc *		inFromDesc,		DescType			inToType,		SInt32				inHandlerRefcon,		AEDesc *			outToDesc	){#pragma unused ( inHandlerRefcon )	FSSpec			fileSpec ;	FSRef			fileRef ;	OSStatus		err ;	BlockZero ( & fileSpec, sizeof ( fileSpec ) ) ;	/* sanity check: make sure inFromDesc is the expected type */	err = errAECoercionFail ;	if ( ( inFromDesc -> descriptorType != typeFSS ) || ( inFromDesc -> dataHandle == NULL ) )	{		goto cleanup ;	}	/* sanity check: make sure the type we're supposed to coerce to is the expected type */	if ( inToType != typeFSRef )	{		goto cleanup ;	}	/* get FSSpec */	if ( ( err = AEGetDescData ( inFromDesc, & fileSpec, sizeof ( fileSpec ) ) ) != noErr )	{		goto cleanup ;	}	/* convert it to an FSRef */	if ( ( err = FSpMakeFSRef ( & fileSpec, & fileRef ) ) != noErr )	{		goto cleanup ;	}	/* create an output descriptor for the FSRef */	if ( ( err = AECreateDesc ( typeFSRef, & fileRef, sizeof ( fileRef ), outToDesc ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}OSStatus GotRequiredParams ( const AppleEvent * inAE ){	DescType				actualType = 0 ;	Size					actualSize = 0 ;	OSStatus				err ;	err = AEGetAttributePtr( inAE, keyMissedKeywordAttr, typeWildCard, & actualType, NULL, 0, & actualSize ) ;	return	( err == errAEDescNotFound ) ? noErr :			( err == noErr ) ? errAEParamMissed : err;}static Boolean IsFileOpen ( const FSRef * inFileRef, Document ** outDocument ){	WindowRef				window = NULL ;	Document *				document = NULL ;	FSRef					documentFile ;	Boolean					wasChanged = false ;	OSStatus				err ;	/* determine whether there is already an open document associated with the specified file */	for (	window = GetFrontWindowOfClass ( kDocumentWindowClass, false ) ;			window != NULL ;			window = GetNextWindowOfClass ( window, kDocumentWindowClass, false ) )	{		if ( ( ( document = GetWindowDocument ( window ) ) != NULL ) && ( document -> fileAlias != NULL ) )		{			if ( ( err = FSResolveAlias ( NULL, document -> fileAlias, & documentFile, & wasChanged ) ) == noErr )			{				if ( ( err = FSCompareFSRefs ( inFileRef, & documentFile ) ) == noErr )				{					* outDocument = document ;					return true ;				}			}		}	}	* outDocument = NULL ;	return false ;}static pascal OSErr	HandleOpenDocument ( const AppleEvent * inAE, AppleEvent * outReply, SInt32 inHandlerRefCon ){#pragma unused ( outReply )	Document *				document = NULL ;	AEDescList				docList ;	AEKeyword				keyword = 0 ;	DescType				actualType = 0 ;	Size					actualSize = 0 ;	SInt32					docCount = 0 ;	SInt32					docIndex ;	FSRef					fileRef ;	OSStatus				err ;	AEInitializeDescInline ( & docList ) ;	/* extract direct parameter from the Apple event */	if ( ( err = AEGetParamDesc ( inAE, keyDirectObject, typeAEList, & docList ) ) != noErr )	{		goto cleanup ;	}	/* perform the recommended check for additional required parameters */	if ( ( err = GotRequiredParams ( inAE ) ) != noErr )	{		goto cleanup ;	}	/* count the items in the list of aliases */	if ( ( err = AECountItems ( & docList, & docCount ) ) != noErr )	{		goto cleanup ;	}	for ( docIndex = 1; docIndex <= docCount; docIndex ++ )	{		/* coerce the nth alias to a file system reference */		if ( ( err = AEGetNthPtr ( & docList, docIndex, typeFSRef, & keyword, & actualType, & fileRef, sizeof ( fileRef ), & actualSize ) ) != noErr )		{			goto cleanup ;		}		/* is this file already open? */		if ( IsFileOpen ( & fileRef, & document ) )		{			/* bring the corresponding window to the front (and maximize it if necessary) */			SelectWindow ( document -> window ) ;			if ( ( err = CollapseWindow ( document -> window, false ) ) != noErr )			{				goto cleanup ;			}			/* reset the window title, just in case the file name has changed since we last checked */			if ( ( err = SetWindowTitleFromFile ( document -> window, & fileRef ) ) != noErr )			{				goto cleanup ;			}		}		else		{			/* open the specified file */			if ( ( err = CreateDocument ( & fileRef, & document ) ) != noErr )			{				goto cleanup ;			}		}		if ( inHandlerRefCon == kDoPrint )		{			/* print it */			if ( ( err = DoPrint ( document ) ) != noErr )			{				goto cleanup ;			}		}	}cleanup :	AEDisposeDesc ( & docList ) ;	return err ;}static pascal OSErr	HandleOpenApplication ( const AppleEvent * inAE, AppleEvent * outReply, SInt32 inHandlerRefCon ){#pragma unused ( outReply, inHandlerRefCon )	WindowRef		window ;	OSStatus		err ;	/* perform the recommended check for additional required parameters */	if ( ( err = GotRequiredParams ( inAE ) ) != noErr )	{		goto cleanup ;	}	/* see whether we already have a window open */	if ( ( window = GetFrontWindowOfClass ( kDocumentWindowClass, false ) ) != NULL )	{		SelectWindow ( window ) ;		err = CollapseWindow ( window, false ) ;	}	else	{		/* create a new window from scratch */		err = CreateDocument ( NULL, NULL ) ;	}cleanup :	return err ;}static pascal OSErr	HandleQuitApplication ( const AppleEvent * inAE, AppleEvent * outReply, SInt32 inHandlerRefCon ){#pragma unused ( outReply, inHandlerRefCon )	SavingOption	saving = savingAsk ;	AEKeyword		optKey = 0 ;	DescType		actualType = 0 ;	Size			actualSize = 0 ;	OSStatus		err ;	/* extract optional save options */	if ( ( err = AEGetParamPtr ( inAE, keyAESaveOptions, typeEnumerated, & actualType, & optKey, sizeof ( optKey ), & actualSize ) ) == noErr )	{		if ( optKey == kAEYes )		{			saving = savingYes;		}		else if (optKey == kAENo )		{			saving = savingNo;		}		else if ( optKey != kAEAsk )		{			err = paramErr;	/* for want of a better code */			goto cleanup ;		}	}	/* perform the recommended check for additional required parameters */	if ( ( err = GotRequiredParams ( inAE ) ) != noErr )	{		goto cleanup ;	}	/* actually do the quit stuff */	err = DoQuit ( saving ) ;cleanup :	return err ;}OSStatus InstallEventHandlers ( void ){	const EventTypeSpec			mouseEventTypes [ ] =	{		{ kEventClassMouse,		kEventMouseMoved }	} ;	const EventTypeSpec			commandEventTypes [ ] =	{		{ kEventClassCommand,	kEventCommandProcess },		{ kEventClassCommand,	kEventCommandUpdateStatus }	} ;	OSStatus					err ;	/* install Carbon event handlers for mouse events */	if ( ( err = InstallApplicationEventHandler ( NewEventHandlerUPP ( HandleMouseEvent ),		GetEventTypeCount ( mouseEventTypes ), mouseEventTypes, NULL, NULL ) ) != noErr )	{		goto cleanup ;	}	/* install Carbon event handlers for command events */	if ( ( err = InstallApplicationEventHandler ( NewEventHandlerUPP ( HandleApplicationCommand ),		GetEventTypeCount ( commandEventTypes ), commandEventTypes, NULL, NULL ) ) != noErr )	{		goto cleanup ;	}	/* install Apple event handlers for the Required Suite */	if ( ( err = AEInstallEventHandler ( kCoreEventClass, kAEOpenApplication, NewAEEventHandlerUPP ( HandleOpenApplication ), 0, false ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEInstallEventHandler ( kCoreEventClass, kAEReopenApplication, NewAEEventHandlerUPP ( HandleOpenApplication ), 0, false ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEInstallEventHandler ( kCoreEventClass, kAEOpenDocuments, NewAEEventHandlerUPP ( HandleOpenDocument ), kDoOpen, false ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEInstallEventHandler ( kCoreEventClass, kAEPrintDocuments, NewAEEventHandlerUPP ( HandleOpenDocument ), kDoPrint, false ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEInstallEventHandler ( kCoreEventClass, kAEQuitApplication, NewAEEventHandlerUPP ( HandleQuitApplication ), 0, false ) ) != noErr )	{		goto cleanup ;	}	/* install Apple event handlers for a subset of the Standard Suite */	if ( ( err = InstallCoreHandlers ( ) ) != noErr )	{		goto cleanup ;	}	/* install Apple event handlers for inline input */	if ( ( err = WEInstallTSMHandlers ( ) ) != noErr )	{		goto cleanup ;	}	/* install Apple event coercion handlers */	if ( ( err = AEInstallCoercionHandler ( typeAlias, typeFSRef, NewAECoerceDescUPP ( CoerceAliasToFSRef ), 0, true, false ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEInstallCoercionHandler ( typeFSS, typeFSRef, NewAECoerceDescUPP ( CoerceFSSpecToFSRef ), 0, true, false ) ) != noErr )	{		goto cleanup ;	}cleanup :	return err ;}