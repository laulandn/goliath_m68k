// ===========================================================================//	LMacTCPListenQueue.cp		PowerPlant 2.1		©1996-2000 Metrowerks Inc.// ===========================================================================//	Creates and maintains pending param blocks for "Passive Open" connections.////	IMPLEMENTATION DETAILS of MacTCP classes. DO NOT USE THESE CLASSES DIRECTLY!#include <LMacTCPListenQueue.h>#if PP_Target_Carbon		// MacTCP not supported. Remove this file from Carbon targets	#error "Carbon does not support MacTCP"#endifPP_Begin_Namespace_PowerPlant#define kMemBlockSize	3	//# of operations to create each time we run out// ===========================================================================#pragma mark === LMacTCPListenQueue ===// ---------------------------------------------------------------------------//	¥ LMacTCPListenQueue					Constructor// ---------------------------------------------------------------------------LMacTCPListenQueue::LMacTCPListenQueue(	UInt32				inListenQueueSize,	LMacTCPTCPEndpoint&	inEndpoint){	mEndpoint = &inEndpoint;	mFree			= 0;	mCompleted		= 0;	mOperationCount = 0;	AllocateMoreOperations();	//To start, allocate at least kMemBlockSize	for (SInt32 i = 0; i < inListenQueueSize; i++) {		StartListener();	}}// ---------------------------------------------------------------------------//	¥ LMacTCPListenQueue					Destructor// ---------------------------------------------------------------------------LMacTCPListenQueue::~LMacTCPListenQueue(){	LListenQueueElem*	nextElem;	OSErr err;	TInterruptSafeListIterator<LListenQueueElem*>	runningIter(mRunningList);	while (runningIter.Next(nextElem))	{		STCPParamBlock currBlock = nextElem->mOperation->GetParamBlock();		currBlock.csCode = TCPStatus;		::PBControlSync((ParmBlkPtr)&currBlock);		currBlock.csCode = TCPAbort;		::PBControlSync((ParmBlkPtr)&currBlock);		currBlock.csCode = TCPRelease;		err = ::PBControlSync((ParmBlkPtr)&currBlock);		if (err == noErr) {			::DisposePtr(currBlock.csParam.create.rcvBuff);		}		delete nextElem;	}	// Delete the list elements	TInterruptSafeListIterator<LListenQueueElem*>	completedIter(mCompletedList);	while (completedIter.Next(nextElem)) {		delete nextElem;	};	TInterruptSafeListIterator<LListenQueueElem*>	freeIter(mFreeList);	while (freeIter.Next(nextElem)) {		delete nextElem;	}	// Delete the paramblocks	for (SInt32 i = 0; i < mOperationCount; i++) {		delete mOperationPool[i];	}}// ---------------------------------------------------------------------------//		¥ StartListener// ---------------------------------------------------------------------------//	Creates a new listener... A.K.A. PassiveOpen in MacTCPvoidLMacTCPListenQueue::StartListener(){	Ptr rcvBuff = ::NewPtr((SInt32) mEndpoint->mReceiveBufferSize);	ThrowIfMemFail_(rcvBuff);	TCPiopb	tempPB;	tempPB.csCode = TCPCreate;	tempPB.ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();	tempPB.csParam.create.rcvBuff = rcvBuff;	tempPB.csParam.create.rcvBuffLen = mEndpoint->mReceiveBufferSize;	tempPB.csParam.create.notifyProc = LMacTCPTCPEndpoint::sTCPNotifyUPP;	tempPB.csParam.create.userDataPtr = (char*)mEndpoint;	ThrowIfError_(::PBControlSync((ParmBlkPtr)&tempPB));	StMacTCPListenOperation* operation = GetUnusedOperation();	STCPParamBlock& operationPB = operation->GetParamBlock();	operation->SetStream(tempPB.tcpStream);	operation->SetBuffer(rcvBuff);	operationPB.csParam.open.ulpTimeoutValue = 0;	operationPB.csParam.open.ulpTimeoutAction = 1;	operationPB.csParam.open.validityFlags = (SInt8) 0xC0;	operationPB.csParam.open.commandTimeoutValue = 0;	operationPB.csParam.open.remoteHost = 0;	operationPB.csParam.open.remotePort = 0;	operationPB.csParam.open.localHost = 0;	operationPB.csParam.open.localPort = mEndpoint->mLocalAddress->GetHostPort();	operationPB.csParam.open.tosFlags = 0;	operationPB.csParam.open.precedence = 0;	operationPB.csParam.open.dontFrag = 0;	operationPB.csParam.open.timeToLive = 0;	operationPB.csParam.open.security = 0;	operationPB.csParam.open.optionCnt = 0;	operation->AsyncRun();	LListenQueueElem * newElem = new LListenQueueElem(operation);	mRunningList.Append(newElem);}// ---------------------------------------------------------------------------//		¥ Int_IncomingConnection// ---------------------------------------------------------------------------// Find which of our outstanding listens was used and remove it from//	the list of running listens////	Note: Called at interrupt timevoidLMacTCPListenQueue::Int_IncomingConnection(StMacTCPListenOperation * inOperation){	LListenQueueElem*	nextElem;	TInterruptSafeListIterator<LListenQueueElem*>	iter(mRunningList);	while (iter.Next(nextElem)) {		StMacTCPListenOperation* currOp = nextElem->mOperation;		if (currOp == inOperation) {			mRunningList.Remove(nextElem);			StoreCompletedOperation(nextElem);			break;		}	}	mEndpoint->mMessageQueue->Append(new(*(mEndpoint->mSharedPool))		LNetMessage(T_LISTEN, 0, mEndpoint));}// ---------------------------------------------------------------------------//		¥ GetALocalAddress// ---------------------------------------------------------------------------//	Check list of pending listen pBlocks for an available address/port number.voidLMacTCPListenQueue::GetALocalAddress(LInternetAddress& outAddress){	LListenQueueElem*	nextElem;	TInterruptSafeListIterator<LListenQueueElem*>	iter(mRunningList);	while (iter.Next(nextElem))	{		STCPParamBlock currBlock = nextElem->mOperation->GetParamBlock();		if (currBlock.csParam.open.localHost)	//quick check to make sure the passiveopen is complete		{			outAddress.SetIPAddress(currBlock.csParam.open.localHost);			outAddress.SetHostPort(currBlock.csParam.open.localPort);			break;		}	}}// ---------------------------------------------------------------------------//		¥ AllocateMoreOperations// ---------------------------------------------------------------------------//voidLMacTCPListenQueue::AllocateMoreOperations(){	while(mFree < kMemBlockSize)	{		ThrowIf_(mOperationCount >= kBufferSize);	//This should never happen		StMacTCPListenOperation* newOperation = new StMacTCPListenOperation(this);		LListenQueueElem * newElem = new LListenQueueElem(newOperation);		mFreeList.Append(newElem);		mOperationPool[mOperationCount++] = newOperation;		mFree++;	}}// ---------------------------------------------------------------------------//		¥ GetUnusedOperation// ---------------------------------------------------------------------------//	Pulls an operation off of the unused queue to be used in a device manager callStMacTCPListenOperation*LMacTCPListenQueue::GetUnusedOperation(){	//Allocate more if we are out	if (mFree == 0)		AllocateMoreOperations();	TInterruptSafeListIterator<LListenQueueElem*>	iter(mFreeList);	LListenQueueElem*	nextElem;	iter.Next(nextElem);	StMacTCPListenOperation* retOperation = nextElem->mOperation;	mFree--;	delete nextElem;	return retOperation;}// ---------------------------------------------------------------------------//		¥ RecycleFreeOperation// ---------------------------------------------------------------------------//  Puts a parameter block back onto the unused queue to be picked up and//		used by someone elsevoidLMacTCPListenQueue::RecycleFreeOperation(StMacTCPListenOperation* inOperation){	LListenQueueElem * newElem = new LListenQueueElem(inOperation);	mFreeList.Append(newElem);	mFree++;}// ---------------------------------------------------------------------------//		¥ GetCompletedOperation// ---------------------------------------------------------------------------//  Pulls a parameter block off of the completed queue for processing by the callerStMacTCPListenOperation*LMacTCPListenQueue::GetCompletedOperation(){	if (mCompletedList.IsEmpty()) {		return nil;	}	TInterruptSafeListIterator<LListenQueueElem*>	iter(mCompletedList);	LListenQueueElem*	nextElem;	iter.Next(nextElem);	mCompleted--;	StMacTCPListenOperation* returnOp = nextElem->mOperation;	delete nextElem;	return returnOp;}// ---------------------------------------------------------------------------//		¥ StoreCompletedOperation// ---------------------------------------------------------------------------//	 Queues a parameter block onto the completed queue.  This is normally called//		from completion routines at interrupt time.voidLMacTCPListenQueue::StoreCompletedOperation(LListenQueueElem * newElem){	mCompletedList.Append(newElem);	mCompleted++;}// ===========================================================================#pragma mark -#pragma mark === StMacTCPListenOperation ===// ---------------------------------------------------------------------------//		¥ Constructor// ---------------------------------------------------------------------------StMacTCPListenOperation::StMacTCPListenOperation(								LMacTCPListenQueue * inListenQueue,								StreamPtr	inStreamPtr)	: StMacTCPOperation(TCPPassiveOpen, inStreamPtr){	mMacTCPListenQueue = inListenQueue;}// ---------------------------------------------------------------------------//		¥ Destructor// ---------------------------------------------------------------------------StMacTCPListenOperation::~StMacTCPListenOperation(){}// ---------------------------------------------------------------------------//		¥ SetStream// ---------------------------------------------------------------------------voidStMacTCPListenOperation::SetStream(StreamPtr	inStreamPtr){	mTCPParamBlock->tcpStream = inStreamPtr;}// ---------------------------------------------------------------------------//		¥ SetBuffer// ---------------------------------------------------------------------------voidStMacTCPListenOperation::SetBuffer(Ptr	inRcvBuff){	mReceiveBuffer = inRcvBuff;}// ---------------------------------------------------------------------------//		¥ Int_AsyncResume// ---------------------------------------------------------------------------//	NOTE: This routine *might* be called at interrupt timevoidStMacTCPListenOperation::Int_AsyncResume(OSStatus	inResult){	mResult = inResult;	if (mThread != nil) {		mMacTCPListenQueue->Int_IncomingConnection(this);	}	else {		::DebugStr("\pStMacTCPListenOperation::AsyncResume - thread is nil");	}}// ---------------------------------------------------------------------------//		¥ AbortOperation// ---------------------------------------------------------------------------voidStMacTCPListenOperation::AbortOperation(){	Int_AsyncResume(Abort_Error);}// ---------------------------------------------------------------------------//		¥ AsyncRun// ---------------------------------------------------------------------------// Attempt the operation. Check for immediate failure.//	This Run method does NOT block a threadvoidStMacTCPListenOperation::AsyncRun(){	mTCPParamBlock->csCode = TCPPassiveOpen;	mTCPParamBlock->ioCRefNum = UMacTCPSupport::GetMacTCPRefNum();	mTCPParamBlock->ioCompletion = GetCompletionProc();	ThrowIfError_(::PBControlAsync((ParmBlkPtr)mTCPParamBlock));}PP_End_Namespace_PowerPlant