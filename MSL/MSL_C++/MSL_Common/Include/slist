/*  Metrowerks Standard Library  *//*  $Date: 2000/06/09 19:26:23 $  *  $Revision: 1.2.4.4 $  *  $NoKeywords: $  * *		Copyright © 1995-1999 Metrowerks, Inc. *		All rights reserved. *//** **  slist **//* *	WARNING * *	slist is a non-standard header and container. * * *    slist has not yet been approved by the ANSI/ISO Standards *    Committee; therefore, we are supplying this class as largely *    specified by the Silicon Graphics, Inc. (SGI) , Standard   *    Template Library (STL).  For further information, refer to *          <http://www.sgi.com/Technology/STL/Slist.html>  * *    The implementation herein belongs to Metrowerks, Inc., and *    is protected by copyright.  Those parts of the interface *    unique to SGI's specification are supplied by SGI, and are *    likewise protected by copyright. * *		Copyright © 1996-1999  *		Silicon Graphics Computer Systems, Inc.  * */#ifndef _SLIST#define _SLIST #include <mslconfig>#include <memory>#include <limits>#include <stdexcept>#include <iterator>#include <algorithm>#ifndef RC_INVOKED#pragma options align=native#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import on#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#if _MSL_FORCE_ENUMS_ALWAYS_INT		#pragma enumsalwaysint on	#else		#pragma enumsalwaysint off	#endif#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#if _MSL_FORCE_ENABLE_BOOL_SUPPORT		#pragma bool on	#else		#pragma bool off	#endif#endif#ifndef _MSL_NO_CPP_NAMESPACE	namespace Metrowerks {#else	#ifndef Metrowerks		#define Metrowerks	#endif#endiftemplate <class T, class Allocator = _STD::allocator<T> >class slist{	#ifndef _MSL_NO_MEMBER_TEMPLATE		template <bool b> struct chooser {};	#endifpublic:	//  types:	typedef typename Allocator::reference         reference;	typedef typename Allocator::const_reference   const_reference;	class                                         iterator;	class                                         const_iterator;	typedef typename Allocator::size_type         size_type;	typedef typename Allocator::difference_type   difference_type;	typedef T                                     value_type;	typedef Allocator                             allocator_type;	typedef typename Allocator::pointer           pointer;	typedef typename Allocator::const_pointer     const_pointer;private:	struct node;	struct node_base	{		node* next_;	};	struct node		: public node_base	{		value_type data_;	private:		node();	};	typedef _MSL_REBIND (node)                     node_allocator_type;public:	class iterator		: public _STD::iterator<_STD::forward_iterator_tag, T, difference_type, pointer, reference>	{	public:		iterator() {}		reference operator * () const {return node_->data_;}		pointer operator -> () const {return &node_->data_;}		iterator& operator ++ () {node_ = node_->next_; return *this;}		iterator operator ++ (int) {iterator tmp(*this); node_ = node_->next_; return tmp;}		friend bool operator ==(iterator x, iterator y) {return static_cast<bool>(x.node_ == y.node_);}		friend bool operator !=(iterator x, iterator y) {return static_cast<bool>(x.node_ != y.node_);}	private:		node* node_;		iterator(node* node) : node_(node) {}		friend class slist;		friend class slist::const_iterator;	};	class const_iterator		: public _STD::iterator<_STD::forward_iterator_tag, T, difference_type, const_pointer, const_reference>	{	public:		const_iterator() {}		const_iterator(slist::iterator x) : node_(x.node_) {}		const_reference operator * () const {return node_->data_;}		const_pointer operator -> () const {return &node_->data_;}		const_iterator& operator ++ () {node_ = node_->next_; return *this;}		const_iterator operator ++ (int) {const_iterator tmp(*this); node_ = node_->next_; return tmp;}		friend bool operator ==(const_iterator x, const_iterator y)			{return static_cast<bool>(x.node_ == y.node_);}		friend bool operator !=(const_iterator x, const_iterator y)			{return static_cast<bool>(x.node_ != y.node_);}	private:		const node* node_;		const_iterator(const node* node) : node_(node) {}		friend class slist;	};	//  lib.slist.cons construct/copy/destroy:	explicit slist(const Allocator& = Allocator());	explicit slist(size_type n);	slist(size_type n, const T& value, const Allocator& = Allocator());#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			slist(InputIterator first, InputIterator last, const Allocator& a = Allocator());	#else		template <class InputIterator>			slist(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: alloc_(a, 0),				  node_alloc_(node_allocator_type(a))			{				node_base& tail = node_alloc_.m_;				tail.prev_ = tail.next_ = (node*)&tail;				choose_init(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif#else	slist(const_iterator first, const_iterator last, const Allocator& a = Allocator());	slist(const value_type* first, const value_type* last, const Allocator& a = Allocator());#endif	slist(const slist& x);	~slist();	slist& operator=(const slist& x);#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator> void assign(InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void			assign(InputIterator first, InputIterator last)			{				choose_assign(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif#else	void assign(const_iterator first, const_iterator last);	void assign(const value_type* first, const value_type* last);#endif	void assign(size_type n, const T& t);	allocator_type get_allocator() const;	//  iterators:	iterator               begin();	const_iterator         begin() const;	iterator               end();	const_iterator         end() const;	iterator               last_node();      // returns --end() (constant time)	const_iterator         last_node() const;	iterator previous(iterator x);           // returns --x (linear time)	const_iterator previous(const_iterator x);	//  lib.slist.capacity capacity:	bool      empty() const;	size_type size() const;	size_type max_size() const;	void      resize(size_type sz);	void      resize(size_type sz, const value_type& value);	//  element access:	reference       front();	const_reference front() const;	//  lib.slist.modifiers modifiers:	void push_front(const T& x);	void pop_front();	void push_back(const T& x);	// there is no pop_back	iterator insert(iterator position, const T& x);  // linear time!	void     insert(iterator position, size_type n, const T& x);  // linear time!#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>  // linear time!			void insert(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void insert(iterator position, InputIterator first, InputIterator last)			{				insert_after(previous(position), first, last);			}	#endif#else	void insert(iterator position, const_iterator first, const_iterator last);	void insert(iterator position, const value_type* first, const value_type* last);#endif	// constant time versions of insert, inserts stuff after position	// end() can be used as the node before begin()	iterator insert_after(iterator position, const T& x);	void     insert_after(iterator position, size_type n, const T& x);#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void insert_after(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void insert_after(iterator position, InputIterator first, InputIterator last)			{				do_insert_after(position, first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif#else	void insert_after(iterator position, const_iterator first, const_iterator last);	void insert_after(iterator position, const value_type* first, const value_type* last);#endif	iterator erase(iterator position);  // linear time!	iterator erase(iterator position, iterator last);  // linear time!	// constant time versions of erase	// end() can be used as the node before begin()	iterator erase_after(iterator position); // erase (position, position+1], return position	iterator erase_after(iterator position, iterator last); // erase (position, last], return position	void     swap(slist& x);	void     clear();	//  lib.slist.ops slist operations:	void splice(iterator position, slist& x);  // linear time!	void splice(iterator position, slist& x, iterator i);  // linear time!	void splice(iterator position, slist& x, iterator first, iterator last);  // linear time!	// constant time versions of splice, splices stuff after position	// end() can be used as the node before begin()	void splice_after(iterator position, slist& x);	void splice_after(iterator position, slist& x, iterator i); // splices (i, i+1]	void splice_after(iterator position, slist& x, iterator first, iterator last);  // splices (first, last]	void remove(const T& value);#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Predicate> void remove_if(Predicate pred);	#else		template <class Predicate>			void			remove_if(Predicate pred)			{				iterator e = end();				iterator p1 = e;				for (iterator i = begin(); i != e; ++i)				{					if (pred(*i))					{						iterator j = i;						iterator p2 = j;						for (++j; j != e; ++j)						{							if (!pred(*j))								break;							p2 = j;						}						erase_after(p1, p2);						i = j;						if (i == e)							break;					}				}				p1 = i;			}	#endif#endif	void unique();#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);	#else		template <class BinaryPredicate>			void			unique(BinaryPredicate binary_pred)			{				iterator e = end();				for (iterator i = begin(); i != e;)				{					iterator j = i;					iterator p = j;					for (++j; j != e; ++j)					{						if (!binary_pred(*i, *j))							break;						p = j;					}					if (i != p)						erase_after(i, p);					++i;				}			}	#endif#endif	void merge(slist& x);#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Compare> void merge(slist& x, Compare comp);	#else		template <class Compare>			void			merge(slist& x, Compare comp)			{				if (this == &x)					return;				if (size() > max_size() - x.size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("slist::merge length error");					#else						_STD::__msl_error("slist::merge length error\n");					#endif				iterator first1 = begin();				iterator last1 = end();				iterator first2 = x.begin();				iterator last2 = x.end();				node* pfirst1 = last1.node_;				node* pfirst2 = last2.node_;				for (; first1 != last1 && first2 != last2; ++first1)				{					if (comp(*first2, *first1))					{						iterator j = first2;						size_type count = 1;						node* pj = j.node_;						for (++j; j != last2; ++j, ++count)						{							if (!comp(*j, *first1))								break;							pj = j.node_;						}						// splice_after(pfirst1, x, pfirst2, pj) but with pj-pfirst2 stored in count						if (x.back_ == pj)							x.back_ = pfirst2;						remove_nodes(pfirst2, pj);						insert_nodes(pfirst1, first2.node_, pj);						if (back_ == pfirst1)							back_ = pj;						x.alloc_.m_ -= count;						alloc_.m_ += count;						first2 = j;					}					pfirst1 = first1.node_;				}				if (first2 != last2)					splice_after(last_node(), x);			}	#endif#endif	void sort();#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Compare> void sort(Compare comp);	#else		template <class Compare>		void		sort(Compare comp)		{			switch (size())			{			case 0:			case 1:				break;			case 2:			{				iterator i = begin();				iterator j = i;				++j;				if (comp(*j, *i))				{	// reverse()					node_alloc_.m_.next_->next_ = (node*)&node_alloc_.m_;					back_->next_ = node_alloc_.m_.next_;					node_alloc_.m_.next_ = back_;					back_ = node_alloc_.m_.next_->next_;				}			}				break;			default:			{				iterator i = begin();				size_type lower_size = size() / 2;				_STD::advance(i, lower_size - 1);				slist upper_half;				// upper_half.splice_after(upper_half.last_node(), *this, i, last_node());				node* s1 = i.node_;				node* s2 = s1->next_;				node* s3 = back_;				back_ = s1;				remove_nodes(s1, s3);				insert_nodes(&upper_half.node_alloc_.m_, s2, s3);				upper_half.back_ = s3;				upper_half.alloc_.m_ = alloc_.m_ - lower_size;				alloc_.m_ = lower_size;				sort(comp);				upper_half.sort(comp);				merge(upper_half, comp);				break;			}			}		}	#endif#endif	void reverse();private:	_STD::_EmptyMemberOpt<Allocator, size_type> alloc_;  // alloc_.m_ is size_	_STD::_EmptyMemberOpt<node_allocator_type, node_base> node_alloc_;  // node_alloc_.m_ is tail pseudo node	                                                              // node_alloc_.m_.next_ is first node	node* back_;                                  #ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void choose_init(InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_init(InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void choose_assign(InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_assign(InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag);		template <class ForwardIterator>			void do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag);		template <class RandomAccessIterator>			void do_assign(RandomAccessIterator first, RandomAccessIterator last, _STD::random_access_iterator_tag);		template <class InputIterator>			void do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<false>);	#else		template <class InputIterator>			void			choose_init(InputIterator first, InputIterator last, chooser<true>)			{				size_type n = static_cast<size_type>(first);				if (n > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("slist::construction length error");					#else						_STD::__msl_error("slist::construction length error\n");					#endif				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					for (; n > 0; --n)						push_front(static_cast<value_type>(last));				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					clear();					throw;				}				#endif			}		template <class InputIterator>			void			choose_init(InputIterator first, InputIterator last, chooser<false>)			{				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					for (; first != last; ++first)						push_back(*first);				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					clear();					throw;				}				#endif			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<true>)			{				assign(static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<false>)			{				do_assign(first, last, _STD::iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag)			{				iterator i = begin();				iterator p;				for (; first != last && i != end(); ++first, ++i)				{					*i = *first;					p = i;				}				if (i == end())					insert_after(last_node(), first, last);				else					erase_after(p, last_node());			}		template <class ForwardIterator>			void			do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)			{				ForwardIterator f = first;				for (size_type c = size(); c != 0 && f != last; --c)					++f;				slist temp(f, last, alloc_);				if (size() > max_size() - temp.size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("slist::assign length error");					#else						_STD::__msl_error("slist::assign length error\n");					#endif				iterator p = end();				for (iterator i = begin(); first != f; ++i, ++first)				{						*i = *first;					p = i;				}				if (temp.size() > 0)					splice_after(last_node(), temp);				else					erase_after(p, last_node());			}		template <class RandomAccessIterator>			void			do_assign(RandomAccessIterator first, RandomAccessIterator last, _STD::random_access_iterator_tag)			{				RandomAccessIterator f = first + _STD::min(size(), size_type(last - first));				if (last - first > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("slist::assign length error");					#else						_STD::__msl_error("slist::assign length error\n");					#endif				slist temp(f, last, alloc_);				iterator p = end();				for (iterator i = begin(); first != f; ++i, ++first)				{						*i = *first;					p = i;				}				if (temp.size() > 0)					splice_after(last_node(), temp);				else					erase_after(p, last_node());			}		template <class InputIterator>			inline			void			do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<true>)			{				insert_after(position, static_cast<size_type>(first), static_cast<value_type>(last));			}		template <class InputIterator>			void			do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<false>)			{				slist temp(first, last, alloc_);				splice_after(position, temp);			}	#endif#endif	static void remove_nodes(node_base* first, node_base* last);	static void insert_nodes(node_base* here, node_base* first, node_base* last);};template <class T, class Allocator>booloperator==(const slist<T, Allocator>& x, const slist<T, Allocator>& y);template <class T, class Allocator>booloperator< (const slist<T, Allocator>& x, const slist<T, Allocator>& y);template <class T, class Allocator>booloperator!=(const slist<T, Allocator>& x, const slist<T, Allocator>& y);template <class T, class Allocator>booloperator> (const slist<T, Allocator>& x, const slist<T, Allocator>& y);template <class T, class Allocator>booloperator>=(const slist<T, Allocator>& x, const slist<T, Allocator>& y);template <class T, class Allocator>booloperator<=(const slist<T, Allocator>& x, const slist<T, Allocator>& y);// specialized algorithms:template <class T, class Allocator>voidswap(slist<T, Allocator>& x, slist<T, Allocator>& y);// Implementation slisttemplate <class T, class Allocator>slist<T, Allocator>::slist(const Allocator& a)	: alloc_(a, 0)#ifndef _MSL_NO_MEMBER_TEMPLATE	, node_alloc_(node_allocator_type(a))#endif{	node_base& tail = node_alloc_.m_;	tail.next_ = back_ = (node*)&tail;}template <class T, class Allocator>slist<T, Allocator>::slist(size_type n)	: alloc_(Allocator(), 0)#ifndef _MSL_NO_MEMBER_TEMPLATE	, node_alloc_(node_allocator_type(alloc_))#endif{	if (n > max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("slist::construction length error");		#else			_STD::__msl_error("slist::construction length error\n");		#endif	node_base& tail = node_alloc_.m_;	tail.next_ = back_ = (node*)&tail;	#ifndef _MSL_NO_EXCEPTIONS	try	{	#endif		T value(T());		for (; n > 0; --n)			push_front(value);	#ifndef _MSL_NO_EXCEPTIONS	}	catch (...)	{		clear();		throw;	}	#endif}template <class T, class Allocator>slist<T, Allocator>::slist(size_type n, const value_type& value, const Allocator& a)	: alloc_(a, 0)#ifndef _MSL_NO_MEMBER_TEMPLATE	, node_alloc_(node_allocator_type(a))#endif{	if (n > max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("slist::construction length error");		#else			_STD::__msl_error("slist::construction length error\n");		#endif	node_base& tail = node_alloc_.m_;	tail.next_ = back_ = (node*)&tail;	#ifndef _MSL_NO_EXCEPTIONS	try	{	#endif		for (; n > 0; --n)			push_front(value);	#ifndef _MSL_NO_EXCEPTIONS	}	catch (...)	{		clear();		throw;	}	#endif}#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class T, class Allocator>		template <class InputIterator>		slist<T, Allocator>::slist(InputIterator first, InputIterator last, const Allocator& a)			: alloc_(a, 0),			  node_alloc_(node_allocator_type(a))		{			node_base& tail = node_alloc_.m_;			tail.next_ = back_ = (node*)&tail;			choose_init(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());		}	#endif#else	template <class T, class Allocator>	slist<T, Allocator>::slist(const_iterator first, const_iterator last, const Allocator& a)		: alloc_(a, 0)	{		node_base& tail = node_alloc_.m_;		tail.next_ = back_ = (node*)&tail;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (first != last)				push_front(*first);			iterator i = begin();			for (++first; first != last; ++first)				i = insert_after(i, *first);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}	template <class T, class Allocator>	slist<T, Allocator>::slist(const value_type* first, const value_type* last, const Allocator& a)		: alloc_(a, 0)	{		node_base& tail = node_alloc_.m_;		tail.next_ = back_ = (node*)&tail;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			if (first != last)				push_front(*first);			iterator i = begin();			for (++first; first != last; ++first)				i = insert_after(i, *first);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}#endiftemplate <class T, class Allocator>slist<T, Allocator>::slist(const slist& x)	: alloc_(x.alloc_, 0),	  node_alloc_(x.node_alloc_){	node_base& tail = node_alloc_.m_;	tail.next_ = back_ = (node*)&tail;	const_iterator e = x.end();	#ifndef _MSL_NO_EXCEPTIONS	try	{	#endif		for (const_iterator i = x.begin(); i != e; ++i)			push_back(*i);	#ifndef _MSL_NO_EXCEPTIONS	}	catch (...)	{		clear();		throw;	}	#endif}template <class T, class Allocator>inlineslist<T, Allocator>::~slist(){	clear();}template <class T, class Allocator>inlineslist<T, Allocator>&slist<T, Allocator>::operator=(const slist& x){	if (this != &x)		assign(x.begin(), x.end());	return *this;}#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class T, class Allocator>		template <class InputIterator>		inline		void		slist<T, Allocator>::assign(InputIterator first, InputIterator last)		{			choose_assign(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());		}	#endif#else	template <class T, class Allocator>	void	slist<T, Allocator>::assign(const_iterator first, const_iterator last)	{		const_iterator f = first;		for (size_type c = size(); c != 0 && f != last; --c)			++f;		slist temp(f, last, alloc_);		if (size() > max_size() - temp.size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::assign length error");			#else				_STD::__msl_error("slist::assign length error\n");			#endif		iterator i = begin();		iterator p = i;		for (; first != f; ++first, ++i)		{			*i = *first;			p = i;		}		if (temp.size() > 0)			splice_after(p, temp);		else			erase_after(p, end());	}	template <class T, class Allocator>	void	slist<T, Allocator>::assign(const value_type* first, const value_type* last)	{		const value_type* f = first;		for (size_type c = size(); c != 0 && f != last; --c)			++f;		slist temp(f, last, alloc_);		if (size() > max_size() - temp.size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::assign length error");			#else				_STD::__msl_error("slist::assign length error\n");			#endif		iterator i = begin();		iterator p = i;		for (; first != f; ++first, ++i)		{			*i = *first;			p = i;		}		if (temp.size() > 0)			splice_after(p, temp);		else			erase_after(p, end());	}#endiftemplate <class T, class Allocator>voidslist<T, Allocator>::assign(size_type n, const T& t){	if (n > max_size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("slist::assign length error");		#else			_STD::__msl_error("slist::assign length error\n");		#endif	if (n > size())	{		slist temp(n - size(), t, alloc_);		iterator i;		for (i = begin(); i != end(); ++i)			*i = t;		splice_after(last_node(), temp);	}	else	{		iterator p = end();		for (iterator i = begin(); n != 0; --n, ++i)		{			*i = t;			p = i;		}		erase_after(p, last_node());	}}template <class T, class Allocator>inlinetypename slist<T, Allocator>::allocator_typeslist<T, Allocator>::get_allocator() const{	return alloc_;}template <class T, class Allocator>inlinetypename slist<T, Allocator>::iteratorslist<T, Allocator>::begin(){	return iterator(node_alloc_.m_.next_);}template <class T, class Allocator>inlinetypename slist<T, Allocator>::const_iteratorslist<T, Allocator>::begin() const{	return const_iterator(node_alloc_.m_.next_);}template <class T, class Allocator>inlinetypename slist<T, Allocator>::iteratorslist<T, Allocator>::end(){	return iterator((node*)&node_alloc_.m_);}template <class T, class Allocator>inlinetypename slist<T, Allocator>::const_iteratorslist<T, Allocator>::end() const{	return const_iterator((node*)&node_alloc_.m_);}template <class T, class Allocator>inlinetypename slist<T, Allocator>::iteratorslist<T, Allocator>::last_node(){	return back_;}template <class T, class Allocator>inlinetypename slist<T, Allocator>::const_iteratorslist<T, Allocator>::last_node() const{	return back_;}template <class T, class Allocator>inlinetypename slist<T, Allocator>::iteratorslist<T, Allocator>::previous(iterator x){	iterator p = end();	for (iterator i = begin(); i != x; ++i)		p = i;	return p;}template <class T, class Allocator>inlinetypename slist<T, Allocator>::const_iteratorslist<T, Allocator>::previous(const_iterator x){	const_iterator p = end();	for (const_iterator i = begin(); i != x; ++i)		p = i;	return p;}template <class T, class Allocator>inlineboolslist<T, Allocator>::empty() const{	return alloc_.m_ == 0;}template <class T, class Allocator>inlinetypename slist<T, Allocator>::size_typeslist<T, Allocator>::size() const{	return alloc_.m_;}template <class T, class Allocator>inlinetypename slist<T, Allocator>::size_typeslist<T, Allocator>::max_size() const{	return (size_type)_STD::numeric_limits<difference_type>::max();}template <class T, class Allocator>voidslist<T, Allocator>::resize(size_type sz){	if (sz == 0)		clear();	else if (sz > size())		insert_after(last_node(), sz-size(), T());	else if (sz < size())	{		iterator i = begin();		_STD::advance(i, --sz);		erase_after(i, last_node());	}}template <class T, class Allocator>voidslist<T, Allocator>::resize(size_type sz, const value_type& value){	if (sz == 0)		clear();	else if (sz > size())		insert_after(last_node(), sz-size(), value);	else if (sz < size())	{		iterator i = begin();		_STD::advance(i, --sz);		erase_after(i, last_node());	}}template <class T, class Allocator>inlinetypename slist<T, Allocator>::referenceslist<T, Allocator>::front(){	return node_alloc_.m_.next_->data_;}template <class T, class Allocator>inlinetypename slist<T, Allocator>::const_referenceslist<T, Allocator>::front() const{	return node_alloc_.m_.next_->data_;}template <class T, class Allocator>inlinevoidslist<T, Allocator>::push_front(const T& x){	insert_after(end(), x);}template <class T, class Allocator>inlinevoidslist<T, Allocator>::pop_front(){	erase_after(end());}template <class T, class Allocator>inlinevoidslist<T, Allocator>::push_back(const T& x){	insert_after(last_node(), x);}template <class T, class Allocator>inlinetypename slist<T, Allocator>::iteratorslist<T, Allocator>::insert(iterator position, const T& x){	return insert_after(previous(position), x);}template <class T, class Allocator>inlinevoidslist<T, Allocator>::insert(iterator position, size_type n, const T& x){	insert_after(previous(position), n, x);}#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class T, class Allocator>		template <class InputIterator>		inline		void		slist<T, Allocator>::insert(iterator position, InputIterator first, InputIterator last)		{			insert_after(previous(position), first, last);		}	#endif#else	template <class T, class Allocator>	inline	void	slist<T, Allocator>::insert(iterator position, const_iterator first, const_iterator last)	{		insert_after(previous(position), first, last);	}	template <class T, class Allocator>	inline	void	slist<T, Allocator>::insert(iterator position, const value_type* first, const value_type* last)	{		insert_after(previous(position), first, last);	}#endiftemplate <class T, class Allocator>typename slist<T, Allocator>::iteratorslist<T, Allocator>::insert_after(iterator position, const T& x){	if (size() > max_size() - 1)		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("slist::insert_after length error");		#else			_STD::__msl_error("slist::insert_after length error\n");		#endif	node* newnode = node_alloc_.allocate(1);	#ifndef _MSL_NO_EXCEPTIONS	try	{	#endif		alloc_.construct(&newnode->data_, x);	#ifndef _MSL_NO_EXCEPTIONS	}	catch (...)	{		node_alloc_.deallocate(newnode, 1);		throw;	}	#endif	insert_nodes(position.node_, newnode, newnode);	if (back_ == position.node_)		back_ = newnode;	++alloc_.m_;	return newnode;}template <class T, class Allocator>voidslist<T, Allocator>::insert_after(iterator position, size_type n, const T& x){	slist temp(n, x, alloc_);	splice_after(position, temp);}#ifndef _MSL_NO_MEMBER_TEMPLATE	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class T, class Allocator>		template <class InputIterator>		inline		void		slist<T, Allocator>::insert_after(iterator position, InputIterator first, InputIterator last)		{			do_insert_after(position, first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());		}	#endif#else	template <class T, class Allocator>	void	slist<T, Allocator>::insert_after(iterator position, const_iterator first, const_iterator last)	{		slist temp(first, last, alloc_);		splice_after(position, temp);	}	template <class T, class Allocator>	void	slist<T, Allocator>::insert_after(iterator position, const value_type* first, const value_type* last)	{		slist temp(first, last, alloc_);		splice_after(position, temp);	}#endiftemplate <class T, class Allocator>inlinetypename slist<T, Allocator>::iteratorslist<T, Allocator>::erase(iterator position){	return ++erase_after(previous(position));}template <class T, class Allocator>typename slist<T, Allocator>::iteratorslist<T, Allocator>::erase(iterator position, iterator last){	iterator i = previous(position);	iterator j = i;	iterator k = j;	for (++k; k != last; k++)		j = k;	erase_after(i, j);	return last;}// erase (position, position+1]// return positiontemplate <class T, class Allocator>typename slist<T, Allocator>::iteratorslist<T, Allocator>::erase_after(iterator position){	node* oldnode = position.node_->next_;	if (back_ == oldnode)		back_ = position.node_;	remove_nodes(position.node_, oldnode);	alloc_.destroy(&oldnode->data_);	node_alloc_.deallocate(oldnode, 1);	--alloc_.m_;	return position;}// erase (position, last]// return positiontemplate <class T, class Allocator>typename slist<T, Allocator>::iteratorslist<T, Allocator>::erase_after(iterator position, iterator last){	if (position == last)		return position;	if (back_ == last.node_)		back_ = position.node_;	iterator i = position;	++i;	remove_nodes(position.node_, last.node_);	++last;	while (i != last)	{		alloc_.destroy(&*i);		node* t = i.node_;		++i;		node_alloc_.deallocate(t, 1);		--alloc_.m_;	}	return position;}template <class T, class Allocator>voidslist<T, Allocator>::swap(slist& x){	if (this != &x)	{		_STD::swap(alloc_, x.alloc_);		_STD::swap(node_alloc_, x.node_alloc_);		_STD::swap(back_, x.back_);		node_base& tail = node_alloc_.m_;		if (size() > 0)			back_->next_ = (node*)&tail;		else			back_ = tail.next_ = (node*)&tail;		node_base& x_tail = x.node_alloc_.m_;		if (x.size() > 0)			x.back_->next_ = (node*)&x_tail;		else			x.back_ = x_tail.next_ = (node*)&x_tail;	}}template <class T, class Allocator>voidslist<T, Allocator>::clear(){	if (alloc_.m_ == 0)		return;	iterator e = end();	for (iterator i = begin(); i != e;)	{		alloc_.destroy(&*i);		node* t = i.node_;		++i;		node_alloc_.deallocate(t, 1);	}	alloc_.m_ = 0;	node_base& tail = node_alloc_.m_;	back_ = tail.next_ = (node*)&tail;}template <class T, class Allocator>inlinevoidslist<T, Allocator>::splice(iterator position, slist& x){	splice_after(previous(position), x);}template <class T, class Allocator>inlinevoidslist<T, Allocator>::splice(iterator position, slist& x, iterator i){	splice_after(previous(position), x, x.previous(i));}template <class T, class Allocator>inlinevoidslist<T, Allocator>::splice(iterator position, slist& x, iterator first, iterator last){	splice_after(previous(position), x, x.previous(first), x.previous(last));}template <class T, class Allocator>voidslist<T, Allocator>::splice_after(iterator position, slist& x){	if (x.size() > 0)	{		if (size() > max_size() - x.size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::splice_after length error");			#else				_STD::__msl_error("slist::splice_after length error\n");			#endif		node_base& x_tail = x.node_alloc_.m_;		node_base* s1 = x_tail.next_;		node_base* s2 = x.back_;		x.back_ = x_tail.next_ = (node*)&x_tail;		alloc_.m_ += x.alloc_.m_;		x.alloc_.m_ = 0;		insert_nodes(position.node_, s1, s2);		if (back_ == position.node_)			back_ = (node*)s2;	}}template <class T, class Allocator>voidslist<T, Allocator>::splice_after(iterator position, slist& x, iterator i){	if (size() > max_size() - 1)		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("slist::splice length error");		#else			_STD::__msl_error("slist::splice length error\n");		#endif	node* p = position.node_;	node* s1 = i.node_;	node* s2 = s1->next_;	if (s1 == p || s2 == p)		return;	if (x.back_ == s2)		x.back_ = s1;	remove_nodes(s1, s2);	--x.alloc_.m_;	insert_nodes(p, s2, s2);	if (back_ == p)		back_ = s2;	++alloc_.m_;}template <class T, class Allocator>voidslist<T, Allocator>::splice_after(iterator position, slist& x, iterator first, iterator last){	if (first == last)		return;	if (this != &x)	{		size_type delta = (size_type)_STD::distance(first, last);		if (size() > max_size() - delta)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::splice length error");			#else				_STD::__msl_error("slist::splice length error\n");			#endif		x.alloc_.m_ -= delta;		alloc_.m_ += delta;	}	node* s1 = first.node_;	node* s2 = s1->next_;	node* s3 = last.node_;	if (x.back_ == s3)		x.back_ = s1;	remove_nodes(s1, s3);	insert_nodes(position.node_, s2, s3);	if (back_ == position.node_)		back_ = s3;}template <class T, class Allocator>voidslist<T, Allocator>::remove(const T& value){	iterator e = end();	iterator p1 = e;	for (iterator i = begin(); i != e; ++i)	{		if (*i == value)		{			iterator j = i;			iterator p2 = j;			for (++j; j != e; ++j)			{				if (!(*j == value))					break;				p2 = j;			}			erase_after(p1, p2);			i = j;			if (i == e)				break;		}		p1 = i;	}}#ifndef _MSL_NO_MEMBER_TEMPLATE#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class Predicate>	void	slist<T, Allocator>::remove_if(Predicate pred)	{		iterator e = end();		iterator p1 = e;		for (iterator i = begin(); i != e; ++i)		{			if (pred(*i))			{				iterator j = i;				iterator p2 = j;				for (++j; j != e; ++j)				{					if (!pred(*j))						break;					p2 = j;				}				erase_after(p1, p2);				i = j;				if (i == e)					break;			}		}		p1 = i;	}#endif#endiftemplate <class T, class Allocator>voidslist<T, Allocator>::unique(){	iterator e = end();	for (iterator i = begin(); i != e;)	{		iterator j = i;		iterator p = j;		for (++j; j != e; ++j)		{			if (!(*i == *j))				break;			p = j;		}		if (i != p)			erase_after(i, p);		++i;	}}#ifndef _MSL_NO_MEMBER_TEMPLATE#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class BinaryPredicate>	void	slist<T, Allocator>::unique(BinaryPredicate binary_pred)	{		iterator e = end();		for (iterator i = begin(); i != e;)		{			iterator j = i;			iterator p = j;			for (++j; j != e; ++j)			{				if (!binary_pred(*i, *j))					break;				p = j;			}			if (i != p)				erase_after(i, p);			++i;		}	}#endif#endiftemplate <class T, class Allocator>voidslist<T, Allocator>::merge(slist& x){	if (this == &x)		return;	if (size() > max_size() - x.size())		#ifndef _MSL_NO_EXCEPTIONS			throw _STD::length_error("slist::merge length error");		#else			_STD::__msl_error("slist::merge length error\n");		#endif	iterator first1 = begin();	iterator last1 = end();	iterator first2 = x.begin();	iterator last2 = x.end();	node* pfirst1 = last1.node_;	node* pfirst2 = last2.node_;	for (; first1 != last1 && first2 != last2; ++first1)	{		if (*first2 < *first1)		{			iterator j = first2;			size_type count = 1;			node* pj = j.node_;			for (++j; j != last2; ++j, ++count)			{				if (!(*j < *first1))					break;				pj = j.node_;			}			// splice_after(pfirst1, x, pfirst2, pj) but with pj-pfirst2 stored in count			if (x.back_ == pj)				x.back_ = pfirst2;			remove_nodes(pfirst2, pj);			insert_nodes(pfirst1, first2.node_, pj);			if (back_ == pfirst1)				back_ = pj;			x.alloc_.m_ -= count;			alloc_.m_ += count;			first2 = j;		}		pfirst1 = first1.node_;	}	if (first2 != last2)		splice_after(last_node(), x);}#ifndef _MSL_NO_MEMBER_TEMPLATE#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class Compare>	void	slist<T, Allocator>::merge(slist& x, Compare comp)	{		if (this == &x)			return;		if (size() > max_size() - x.size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::merge length error");			#else				_STD::__msl_error("slist::merge length error\n");			#endif		iterator first1 = begin();		iterator last1 = end();		iterator first2 = x.begin();		iterator last2 = x.end();		node* pfirst1 = last1.node_;		node* pfirst2 = last2.node_;		for (; first1 != last1 && first2 != last2; ++first1)		{			if (comp(*first2, *first1))			{				iterator j = first2;				size_type count = 1;				node* pj = j.node_;				for (++j; j != last2; ++j, ++count)				{					if (!comp(*j, *first1))						break;					pj = j.node_;				}				// splice_after(pfirst1, x, pfirst2, pj) but with pj-pfirst2 stored in count				if (x.back_ == pj)					x.back_ = pfirst2;				remove_nodes(pfirst2, pj);				insert_nodes(pfirst1, first2.node_, pj);				if (back_ == pfirst1)					back_ = pj;				x.alloc_.m_ -= count;				alloc_.m_ += count;				first2 = j;			}			pfirst1 = first1.node_;		}		if (first2 != last2)			splice_after(last_node(), x);	}#endif#endiftemplate <class T, class Allocator>voidslist<T, Allocator>::sort(){	switch (size())	{	case 0:	case 1:		break;	case 2:	{		iterator i = begin();		iterator j = i;		++j;		if (*j < *i)		{	// reverse()			node_alloc_.m_.next_->next_ = (node*)&node_alloc_.m_;			back_->next_ = node_alloc_.m_.next_;			node_alloc_.m_.next_ = back_;			back_ = node_alloc_.m_.next_->next_;		}	}		break;	default:	{		iterator i = begin();		size_type lower_size = size() / 2;		_STD::advance(i, lower_size - 1);		slist upper_half;		// upper_half.splice_after(upper_half.last_node(), *this, i, last_node());		node* s1 = i.node_;		node* s2 = s1->next_;		node* s3 = back_;		back_ = s1;		remove_nodes(s1, s3);		insert_nodes(&upper_half.node_alloc_.m_, s2, s3);		upper_half.back_ = s3;		upper_half.alloc_.m_ = alloc_.m_ - lower_size;		alloc_.m_ = lower_size;		sort();		upper_half.sort();		merge(upper_half);		break;	}	}}#ifndef _MSL_NO_MEMBER_TEMPLATE#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class Compare>	void	slist<T, Allocator>::sort(Compare comp)	{		switch (size())		{		case 0:		case 1:			break;		case 2:		{			iterator i = begin();			iterator j = i;			++j;			if (comp(*j, *i))			{	// reverse()				node_alloc_.m_.next_->next_ = (node*)&node_alloc_.m_;				back_->next_ = node_alloc_.m_.next_;				node_alloc_.m_.next_ = back_;				back_ = node_alloc_.m_.next_->next_;			}		}			break;		default:		{			iterator i = begin();			size_type lower_size = size() / 2;			_STD::advance(i, lower_size - 1);			slist upper_half;			// upper_half.splice_after(upper_half.last_node(), *this, i, last_node());			node* s1 = i.node_;			node* s2 = s1->next_;			node* s3 = back_;			back_ = s1;			remove_nodes(s1, s3);			insert_nodes(&upper_half.node_alloc_.m_, s2, s3);			upper_half.back_ = s3;			upper_half.alloc_.m_ = alloc_.m_ - lower_size;			alloc_.m_ = lower_size;			sort(comp);			upper_half.sort(comp);			merge(upper_half, comp);			break;		}		}	}#endif#endiftemplate <class T, class Allocator>voidslist<T, Allocator>::reverse(){	if (size() < 2)		return;	node* np = (node*)&node_alloc_.m_;	node* n = np->next_;	back_ = n;	while (true)	{		node* nn = n->next_;		n->next_ = np;		if (n == (node*)&node_alloc_.m_)			break;		np = n;		n = nn;	}}#ifndef _MSL_NO_MEMBER_TEMPLATE#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class InputIterator>	void	slist<T, Allocator>::choose_init(InputIterator first, InputIterator last, chooser<true>)	{		size_type n = static_cast<size_type>(first);		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::construction length error");			#else				_STD::__msl_error("slist::construction length error\n");			#endif		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			for (; n > 0; --n)				push_front(static_cast<value_type>(last));		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}	template <class T, class Allocator>	template <class InputIterator>	void	slist<T, Allocator>::choose_init(InputIterator first, InputIterator last, chooser<false>)	{		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			for (; first != last; ++first)				push_back(*first);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	slist<T, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<true>)	{		assign(static_cast<size_type>(first), static_cast<value_type>(last));	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	slist<T, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<false>)	{		do_assign(first, last, _STD::iterator_traits<InputIterator>::iterator_category());	}	template <class T, class Allocator>	template <class InputIterator>	void	slist<T, Allocator>::do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag)	{		iterator i = begin();		iterator p;		for (; first != last && i != end(); ++first, ++i)		{			*i = *first;			p = i;		}		if (i == end())			insert_after(last_node(), first, last);		else			erase_after(p, last_node());	}	template <class T, class Allocator>	template <class ForwardIterator>	void	slist<T, Allocator>::do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)	{		ForwardIterator f = first;		for (size_type c = size(); c != 0 && f != last; --c)			++f;		slist temp(f, last, alloc_);		if (size() > max_size() - temp.size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::assign length error");			#else				_STD::__msl_error("slist::assign length error\n");			#endif		iterator p = end();		for (iterator i = begin(); first != f; ++i, ++first)		{				*i = *first;			p = i;		}		if (temp.size() > 0)			splice_after(last_node(), temp);		else			erase_after(p, last_node());	}	template <class T, class Allocator>	template <class RandomAccessIterator>	void	slist<T, Allocator>::do_assign(RandomAccessIterator first, RandomAccessIterator last, _STD::random_access_iterator_tag)	{		RandomAccessIterator f = first + _STD::min(size(), size_type(last - first));		if (last - first > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::assign length error");			#else				_STD::__msl_error("slist::assign length error\n");			#endif		slist temp(f, last, alloc_);		iterator p = end();		for (iterator i = begin(); first != f; ++i, ++first)		{				*i = *first;			p = i;		}		if (temp.size() > 0)			splice_after(last_node(), temp);		else			erase_after(p, last_node());	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	slist<T, Allocator>::do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<true>)	{		insert_after(position, static_cast<size_type>(first), static_cast<value_type>(last));	}	template <class T, class Allocator>	template <class InputIterator>	void	slist<T, Allocator>::do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<false>)	{		slist temp(first, last, alloc_);		splice_after(position, temp);	}#endif#endif// range is (first, last] NOT [first, last), first == end() ok to remove begin()template <class T, class Allocator>inlinevoidslist<T, Allocator>::remove_nodes(node_base* first, node_base* last){	first->next_ = last->next_;}// range is [first, last] NOT [first, last), nodes inserted AFTER here, here != end()template <class T, class Allocator>inlinevoidslist<T, Allocator>::insert_nodes(node_base* here, node_base* first, node_base* last){	last->next_ = here->next_;	here->next_ = (node*)first;}template <class T, class Allocator>inlinebooloperator==(const slist<T, Allocator>& x, const slist<T, Allocator>& y){	return static_cast<bool>(x.size() == y.size() && _STD::equal(x.begin(), x.end(), y.begin()));}template <class T, class Allocator>inlinebooloperator!=(const slist<T, Allocator>& x, const slist<T, Allocator>& y){	return static_cast<bool>(!(x == y));}template <class T, class Allocator>inlinebooloperator< (const slist<T, Allocator>& x, const slist<T, Allocator>& y){	return _STD::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());}template <class T, class Allocator>inlinebooloperator> (const slist<T, Allocator>& x, const slist<T, Allocator>& y){	return y < x;}template <class T, class Allocator>inlinebooloperator>=(const slist<T, Allocator>& x, const slist<T, Allocator>& y){	return static_cast<bool>(!(x < y));}template <class T, class Allocator>inlinebooloperator<=(const slist<T, Allocator>& x, const slist<T, Allocator>& y){	return static_cast<bool>(!(y < x));}// specialized algorithms:template <class T, class Allocator>inlinevoidswap(slist<T, Allocator>& x, slist<T, Allocator>& y){	x.swap(y);}#if !defined(_MSL_NO_PARTIAL_SPECIALIZATION) && !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_Inhibit_Container_Optimization)	// Specialize for T* to save on code bloat	// hh 990825 changed void* to const void*	// const void*	template <class Allocator>	class slist<const void*, Allocator>	{		template <bool b> struct chooser {};	public:		//  types:		typedef typename Allocator::reference         reference;		typedef typename Allocator::const_reference   const_reference;		class                                         iterator;		class                                         const_iterator;		typedef typename Allocator::size_type         size_type;		typedef typename Allocator::difference_type   difference_type;		typedef const void*                           value_type;		typedef Allocator                             allocator_type;		typedef typename Allocator::pointer           pointer;		typedef typename Allocator::const_pointer     const_pointer;	private:		struct node;		struct node_base		{			node* next_;		};		struct node			: public node_base		{			value_type data_;		};		typedef typename Allocator::rebind<node>::other node_allocator_type;	public:		class iterator			: public _STD::iterator<_STD::forward_iterator_tag, value_type, difference_type, pointer, reference>		{		public:			iterator() {}			reference operator * () const {return node_->data_;}			pointer operator -> () const {return &node_->data_;}			iterator& operator ++ () {node_ = node_->next_; return *this;}			iterator operator ++ (int) {iterator tmp(*this); node_ = node_->next_; return tmp;}			friend bool operator ==(iterator x, iterator y) {return static_cast<bool>(x.node_ == y.node_);}			friend bool operator !=(iterator x, iterator y) {return static_cast<bool>(x.node_ != y.node_);}		private:			node* node_;			iterator(node* node) : node_(node) {}			friend class slist;			friend class slist::const_iterator;		};		class const_iterator			: public _STD::iterator<_STD::forward_iterator_tag, value_type, difference_type, const_pointer, const_reference>		{		public:			const_iterator() {}			const_iterator(slist::iterator x) : node_(x.node_) {}			const_reference operator * () const {return node_->data_;}			const_pointer operator -> () const {return &node_->data_;}			const_iterator& operator ++ () {node_ = node_->next_; return *this;}			const_iterator operator ++ (int) {const_iterator tmp(*this); node_ = node_->next_; return tmp;}			friend bool operator ==(const_iterator x, const_iterator y)				{return static_cast<bool>(x.node_ == y.node_);}			friend bool operator !=(const_iterator x, const_iterator y)				{return static_cast<bool>(x.node_ != y.node_);}		private:			const node* node_;			const_iterator(const node* node) : node_(node) {}			friend class slist;		};		//  lib.slist.cons construct/copy/destroy:		explicit slist(const Allocator& = Allocator());		explicit slist(size_type n);		slist(size_type n, const value_type& value, const Allocator& = Allocator());	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			slist(InputIterator first, InputIterator last, const Allocator& a = Allocator());	#else		template <class InputIterator>			slist(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: alloc_(a, 0),				  node_alloc_(node_allocator_type(a))			{				node_base& tail = node_alloc_.m_;				tail.prev_ = tail.next_ = (node*)&tail;				choose_init(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif		slist(const slist& x);		~slist();		slist& operator=(const slist& x);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator> void assign(InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void			assign(InputIterator first, InputIterator last)			{				choose_assign(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif		void assign(size_type n, const value_type& t);		allocator_type get_allocator() const;		//  iterators:		iterator               begin();		const_iterator         begin() const;		iterator               end();		const_iterator         end() const;		iterator               last_node();      // returns --end() (constant time)		const_iterator         last_node() const;		iterator previous(iterator x);           // returns --x (linear time)		const_iterator previous(const_iterator x);		//  lib.slist.capacity capacity:		bool      empty() const;		size_type size() const;		size_type max_size() const;		void      resize(size_type sz);		void      resize(size_type sz, const value_type& value);		//  element access:		reference       front();		const_reference front() const;		//  lib.slist.modifiers modifiers:		void push_front(const value_type& x);		void pop_front();		void push_back(const value_type& x);		// there is no pop_back		iterator insert(iterator position, const value_type& x);  // linear time!		void     insert(iterator position, size_type n, const value_type& x);  // linear time!	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>  // linear time!			void insert(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void insert(iterator position, InputIterator first, InputIterator last)			{				insert_after(previous(position), first, last);			}	#endif		// constant time versions of insert, inserts stuff after position		// end() can be used as the node before begin()		iterator insert_after(iterator position, const value_type& x);		void     insert_after(iterator position, size_type n, const value_type& x);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void insert_after(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void insert_after(iterator position, InputIterator first, InputIterator last)			{				do_insert_after(position, first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());			}	#endif		iterator erase(iterator position);  // linear time!		iterator erase(iterator position, iterator last);  // linear time!		// constant time versions of erase		// end() can be used as the node before begin()		iterator erase_after(iterator position); // erase (position, position+1], return position		iterator erase_after(iterator position, iterator last); // erase (position, last], return position		void     swap(slist& x);		void     clear();		//  lib.slist.ops slist operations:		void splice(iterator position, slist& x);  // linear time!		void splice(iterator position, slist& x, iterator i);  // linear time!		void splice(iterator position, slist& x, iterator first, iterator last);  // linear time!		// constant time versions of splice, splices stuff after position		// end() can be used as the node before begin()		void splice_after(iterator position, slist& x);		void splice_after(iterator position, slist& x, iterator i); // splices (i, i+1]		void splice_after(iterator position, slist& x, iterator first, iterator last);  // splices (first, last]		void remove(const value_type& value);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Predicate> void remove_if(Predicate pred);	#else		template <class Predicate>			void			remove_if(Predicate pred)			{				iterator e = end();				iterator p1 = e;				for (iterator i = begin(); i != e; ++i)				{					if (pred(*i))					{						iterator j = i;						iterator p2 = j;						for (++j; j != e; ++j)						{							if (!pred(*j))								break;							p2 = j;						}						erase_after(p1, p2);						i = j;						if (i == e)							break;					}				}				p1 = i;			}	#endif		void unique();	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);	#else		template <class BinaryPredicate>			void			unique(BinaryPredicate binary_pred)			{				iterator e = end();				for (iterator i = begin(); i != e;)				{					iterator j = i;					iterator p = j;					for (++j; j != e; ++j)					{						if (!binary_pred(*i, *j))							break;						p = j;					}					if (i != p)						erase_after(i, p);					++i;				}			}	#endif		void merge(slist& x);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Compare> void merge(slist& x, Compare comp);	#else		template <class Compare>			void			merge(slist& x, Compare comp)			{				if (this == &x)					return;				if (size() > max_size() - x.size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("slist::merge length error");					#else						_STD::__msl_error("slist::merge length error\n");					#endif				iterator first1 = begin();				iterator last1 = end();				iterator first2 = x.begin();				iterator last2 = x.end();				node* pfirst1 = last1.node_;				node* pfirst2 = last2.node_;				for (; first1 != last1 && first2 != last2; ++first1)				{					if (comp(*first2, *first1))					{						iterator j = first2;						size_type count = 1;						node* pj = j.node_;						for (++j; j != last2; ++j, ++count)						{							if (!comp(*j, *first1))								break;							pj = j.node_;						}						// splice_after(pfirst1, x, pfirst2, pj) but with pj-pfirst2 stored in count						if (x.back_ == pj)							x.back_ = pfirst2;						remove_nodes(pfirst2, pj);						insert_nodes(pfirst1, first2.node_, pj);						if (back_ == pfirst1)							back_ = pj;						x.alloc_.m_ -= count;						alloc_.m_ += count;						first2 = j;					}					pfirst1 = first1.node_;				}				if (first2 != last2)					splice_after(last_node(), x);			}	#endif		void sort();	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Compare> void sort(Compare comp);	#else		template <class Compare>		void		sort(Compare comp)		{			switch (size())			{			case 0:			case 1:				break;			case 2:			{				iterator i = begin();				iterator j = i;				++j;				if (comp(*j, *i))				{	// reverse()					node_alloc_.m_.next_->next_ = (node*)&node_alloc_.m_;					back_->next_ = node_alloc_.m_.next_;					node_alloc_.m_.next_ = back_;					back_ = node_alloc_.m_.next_->next_;				}			}				break;			default:			{				iterator i = begin();				size_type lower_size = size() / 2;				_STD::advance(i, lower_size - 1);				slist upper_half;				// upper_half.splice_after(upper_half.last_node(), *this, i, last_node());				node* s1 = i.node_;				node* s2 = s1->next_;				node* s3 = back_;				back_ = s1;				remove_nodes(s1, s3);				insert_nodes(&upper_half.node_alloc_.m_, s2, s3);				upper_half.back_ = s3;				upper_half.alloc_.m_ = alloc_.m_ - lower_size;				alloc_.m_ = lower_size;				sort(comp);				upper_half.sort(comp);				merge(upper_half, comp);				break;			}			}		}	#endif		void reverse();	private:		_STD::_EmptyMemberOpt<Allocator, size_type> alloc_;  // alloc_.m_ is size_		_STD::_EmptyMemberOpt<node_allocator_type, node_base> node_alloc_;  // node_alloc_.m_ is tail pseudo node		                                                              // node_alloc_.m_.next_ is first node		node* back_;                                  	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void choose_init(InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_init(InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void choose_assign(InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void choose_assign(InputIterator first, InputIterator last, chooser<false>);		template <class InputIterator>			void do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag);		template <class ForwardIterator>			void do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag);		template <class RandomAccessIterator>			void do_assign(RandomAccessIterator first, RandomAccessIterator last, _STD::random_access_iterator_tag);		template <class InputIterator>			void do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<true>);		template <class InputIterator>			void do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<false>);	#else		template <class InputIterator>			void			choose_init(InputIterator first, InputIterator last, chooser<true>)			{				size_type n = static_cast<size_type>(first);				if (n > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("slist::construction length error");					#else						_STD::__msl_error("slist::construction length error\n");					#endif				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					for (; n > 0; --n)						push_front(static_cast<value_type>(last));				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					clear();					throw;				}				#endif			}		template <class InputIterator>			void			choose_init(InputIterator first, InputIterator last, chooser<false>)			{				#ifndef _MSL_NO_EXCEPTIONS				try				{				#endif					for (; first != last; ++first)						push_back(*first);				#ifndef _MSL_NO_EXCEPTIONS				}				catch (...)				{					clear();					throw;				}				#endif			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<true>)			{				assign(static_cast<size_type>(first), reinterpret_cast<value_type>(last));			}		template <class InputIterator>			inline			void			choose_assign(InputIterator first, InputIterator last, chooser<false>)			{				do_assign(first, last, _STD::iterator_traits<InputIterator>::iterator_category());			}		template <class InputIterator>			void			do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag)			{				iterator i = begin();				iterator p;				for (; first != last && i != end(); ++first, ++i)				{					*i = *first;					p = i;				}				if (i == end())					insert_after(last_node(), first, last);				else					erase_after(p, last_node());			}		template <class ForwardIterator>			void			do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)			{				ForwardIterator f = first;				for (size_type c = size(); c != 0 && f != last; --c)					++f;				slist temp(f, last, alloc_);				if (size() > max_size() - temp.size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("slist::assign length error");					#else						_STD::__msl_error("slist::assign length error\n");					#endif				iterator p = end();				for (iterator i = begin(); first != f; ++i, ++first)				{						*i = *first;					p = i;				}				if (temp.size() > 0)					splice_after(last_node(), temp);				else					erase_after(p, last_node());			}		template <class RandomAccessIterator>			void			do_assign(RandomAccessIterator first, RandomAccessIterator last, _STD::random_access_iterator_tag)			{				RandomAccessIterator f = first + _STD::min(size(), size_type(last - first));				if (last - first > max_size())					#ifndef _MSL_NO_EXCEPTIONS						throw _STD::length_error("slist::assign length error");					#else						_STD::__msl_error("slist::assign length error\n");					#endif				slist temp(f, last, alloc_);				iterator p = end();				for (iterator i = begin(); first != f; ++i, ++first)				{						*i = *first;					p = i;				}				if (temp.size() > 0)					splice_after(last_node(), temp);				else					erase_after(p, last_node());			}		template <class InputIterator>			inline			void			do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<true>)			{				insert_after(position, static_cast<size_type>(first), reinterpret_cast<value_type>(last));			}		template <class InputIterator>			void			do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<false>)			{				slist temp(first, last, alloc_);				splice_after(position, temp);			}	#endif		static void remove_nodes(node_base* first, node_base* last);		static void insert_nodes(node_base* here, node_base* first, node_base* last);	};	// Implementation slist<const void*>	template <class Allocator>	slist<const void*, Allocator>::slist(const Allocator& a)		: alloc_(a, 0)	#ifndef _MSL_NO_MEMBER_TEMPLATE		, node_alloc_(node_allocator_type(a))	#endif	{		node_base& tail = node_alloc_.m_;		tail.next_ = back_ = (node*)&tail;	}	template <class Allocator>	slist<const void*, Allocator>::slist(size_type n)		: alloc_(Allocator(), 0)	#ifndef _MSL_NO_MEMBER_TEMPLATE		, node_alloc_(node_allocator_type(alloc_))	#endif	{		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::construction length error");			#else				_STD::__msl_error("slist::construction length error\n");			#endif		node_base& tail = node_alloc_.m_;		tail.next_ = back_ = (node*)&tail;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			value_type value(value_type());			for (; n > 0; --n)				push_front(value);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}	template <class Allocator>	slist<const void*, Allocator>::slist(size_type n, const value_type& value, const Allocator& a)		: alloc_(a, 0)	#ifndef _MSL_NO_MEMBER_TEMPLATE		, node_alloc_(node_allocator_type(a))	#endif	{		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::construction length error");			#else				_STD::__msl_error("slist::construction length error\n");			#endif		node_base& tail = node_alloc_.m_;		tail.next_ = back_ = (node*)&tail;		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			for (; n > 0; --n)				push_front(value);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class InputIterator>	slist<const void*, Allocator>::slist(InputIterator first, InputIterator last, const Allocator& a)		: alloc_(a, 0),		  node_alloc_(node_allocator_type(a))	{		node_base& tail = node_alloc_.m_;		tail.next_ = back_ = (node*)&tail;		choose_init(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());	}#endif	template <class Allocator>	slist<const void*, Allocator>::slist(const slist& x)		: alloc_(x.alloc_, 0),		  node_alloc_(x.node_alloc_)	{		node_base& tail = node_alloc_.m_;		tail.next_ = back_ = (node*)&tail;		const_iterator e = x.end();		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			for (const_iterator i = x.begin(); i != e; ++i)				push_back(*i);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}	template <class Allocator>	inline	slist<const void*, Allocator>::~slist()	{		clear();	}	template <class Allocator>	inline	slist<const void*, Allocator>&	slist<const void*, Allocator>::operator=(const slist& x)	{		if (this != &x)			assign(x.begin(), x.end());		return *this;	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class InputIterator>	inline	void	slist<const void*, Allocator>::assign(InputIterator first, InputIterator last)	{		choose_assign(first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());	}#endif	template <class Allocator>	void	slist<const void*, Allocator>::assign(size_type n, const value_type& t)	{		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::assign length error");			#else				_STD::__msl_error("slist::assign length error\n");			#endif		if (n > size())		{			slist temp(n - size(), t, alloc_);			iterator i;			for (i = begin(); i != end(); ++i)				*i = t;			splice_after(last_node(), temp);		}		else		{			iterator p = end();			for (iterator i = begin(); n != 0; --n, ++i)			{				*i = t;				p = i;			}			erase_after(p, last_node());		}	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::allocator_type	slist<const void*, Allocator>::get_allocator() const	{		return alloc_;	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::begin()	{		return iterator(node_alloc_.m_.next_);	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::const_iterator	slist<const void*, Allocator>::begin() const	{		return const_iterator(node_alloc_.m_.next_);	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::end()	{		return iterator((node*)&node_alloc_.m_);	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::const_iterator	slist<const void*, Allocator>::end() const	{		return const_iterator((node*)&node_alloc_.m_);	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::last_node()	{		return back_;	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::const_iterator	slist<const void*, Allocator>::last_node() const	{		return back_;	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::previous(iterator x)	{		iterator p = end();		for (iterator i = begin(); i != x; ++i)			p = i;		return p;	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::const_iterator	slist<const void*, Allocator>::previous(const_iterator x)	{		const_iterator p = end();		for (const_iterator i = begin(); i != x; ++i)			p = i;		return p;	}	template <class Allocator>	inline	bool	slist<const void*, Allocator>::empty() const	{		return alloc_.m_ == 0;	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::size_type	slist<const void*, Allocator>::size() const	{		return alloc_.m_;	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::size_type	slist<const void*, Allocator>::max_size() const	{		return (size_type)_STD::numeric_limits<difference_type>::max();	}	template <class Allocator>	inline	void	slist<const void*, Allocator>::resize(size_type sz)	{		resize(sz, value_type());	}	template <class Allocator>	void	slist<const void*, Allocator>::resize(size_type sz, const value_type& value)	{		if (sz == 0)			clear();		else if (sz > size())			insert_after(last_node(), sz-size(), value);		else if (sz < size())		{			iterator i = begin();			_STD::advance(i, --sz);			erase_after(i, last_node());		}	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::reference	slist<const void*, Allocator>::front()	{		return node_alloc_.m_.next_->data_;	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::const_reference	slist<const void*, Allocator>::front() const	{		return node_alloc_.m_.next_->data_;	}	template <class Allocator>	inline	void	slist<const void*, Allocator>::push_front(const value_type& x)	{		insert_after(end(), x);	}	template <class Allocator>	inline	void	slist<const void*, Allocator>::pop_front()	{		erase_after(end());	}	template <class Allocator>	inline	void	slist<const void*, Allocator>::push_back(const value_type& x)	{		insert_after(last_node(), x);	}	template <class Allocator>	inline	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::insert(iterator position, const value_type& x)	{		return insert_after(previous(position), x);	}	template <class Allocator>	inline	void	slist<const void*, Allocator>::insert(iterator position, size_type n, const value_type& x)	{		insert_after(previous(position), n, x);	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class InputIterator>	inline	void	slist<const void*, Allocator>::insert(iterator position, InputIterator first, InputIterator last)	{		insert_after(previous(position), first, last);	}#endif	template <class Allocator>	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::insert_after(iterator position, const value_type& x)	{		if (size() > max_size() - 1)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::insert_after length error");			#else				_STD::__msl_error("slist::insert_after length error\n");			#endif		node* newnode = node_alloc_.allocate(1);		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			alloc_.construct(&newnode->data_, x);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			node_alloc_.deallocate(newnode, 1);			throw;		}		#endif		insert_nodes(position.node_, newnode, newnode);		if (back_ == position.node_)			back_ = newnode;		++alloc_.m_;		return newnode;	}	template <class Allocator>	void	slist<const void*, Allocator>::insert_after(iterator position, size_type n, const value_type& x)	{		slist temp(n, x, alloc_);		splice_after(position, temp);	}	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Allocator>		template <class InputIterator>		inline		void		slist<const void*, Allocator>::insert_after(iterator position, InputIterator first, InputIterator last)		{			do_insert_after(position, first, last, chooser<_STD::numeric_limits<InputIterator>::is_integer>());		}	#endif	template <class Allocator>	inline	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::erase(iterator position)	{		return ++erase_after(previous(position));	}	template <class Allocator>	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::erase(iterator position, iterator last)	{		iterator i = previous(position);		iterator j = i;		iterator k = j;		for (++k; k != last; k++)			j = k;		erase_after(i, j);		return last;	}	// erase (position, position+1]	// return position	template <class Allocator>	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::erase_after(iterator position)	{		node* oldnode = position.node_->next_;		if (back_ == oldnode)			back_ = position.node_;		remove_nodes(position.node_, oldnode);		alloc_.destroy(&oldnode->data_);		node_alloc_.deallocate(oldnode, 1);		--alloc_.m_;		return position;	}	// erase (position, last]	// return position	template <class Allocator>	typename slist<const void*, Allocator>::iterator	slist<const void*, Allocator>::erase_after(iterator position, iterator last)	{		if (position == last)			return position;		if (back_ == last.node_)			back_ = position.node_;		iterator i = position;		++i;		remove_nodes(position.node_, last.node_);		++last;		while (i != last)		{			alloc_.destroy(&*i);			node* t = i.node_;			++i;			node_alloc_.deallocate(t, 1);			--alloc_.m_;		}		return position;	}	template <class Allocator>	void	slist<const void*, Allocator>::swap(slist& x)	{		if (this != &x)		{			_STD::swap(alloc_, x.alloc_);			_STD::swap(node_alloc_, x.node_alloc_);			_STD::swap(back_, x.back_);			node_base& tail = node_alloc_.m_;			if (size() > 0)				back_->next_ = (node*)&tail;			else				back_ = tail.next_ = (node*)&tail;			node_base& x_tail = x.node_alloc_.m_;			if (x.size() > 0)				x.back_->next_ = (node*)&x_tail;			else				x.back_ = x_tail.next_ = (node*)&x_tail;		}	}	template <class Allocator>	void	slist<const void*, Allocator>::clear()	{		if (alloc_.m_ == 0)			return;		iterator e = end();		for (iterator i = begin(); i != e;)		{			alloc_.destroy(&*i);			node* t = i.node_;			++i;			node_alloc_.deallocate(t, 1);		}		alloc_.m_ = 0;		node_base& tail = node_alloc_.m_;		back_ = tail.next_ = (node*)&tail;	}	template <class Allocator>	inline	void	slist<const void*, Allocator>::splice(iterator position, slist& x)	{		splice_after(previous(position), x);	}	template <class Allocator>	inline	void	slist<const void*, Allocator>::splice(iterator position, slist& x, iterator i)	{		splice_after(previous(position), x, x.previous(i));	}	template <class Allocator>	inline	void	slist<const void*, Allocator>::splice(iterator position, slist& x, iterator first, iterator last)	{		splice_after(previous(position), x, x.previous(first), x.previous(last));	}	template <class Allocator>	void	slist<const void*, Allocator>::splice_after(iterator position, slist& x)	{		if (x.size() > 0)		{			if (size() > max_size() - x.size())				#ifndef _MSL_NO_EXCEPTIONS					throw _STD::length_error("slist::splice_after length error");				#else					_STD::__msl_error("slist::splice_after length error\n");				#endif			node_base& x_tail = x.node_alloc_.m_;			node_base* s1 = x_tail.next_;			node_base* s2 = x.back_;			x.back_ = x_tail.next_ = (node*)&x_tail;			alloc_.m_ += x.alloc_.m_;			x.alloc_.m_ = 0;			insert_nodes(position.node_, s1, s2);			if (back_ == position.node_)				back_ = (node*)s2;		}	}	template <class Allocator>	void	slist<const void*, Allocator>::splice_after(iterator position, slist& x, iterator i)	{		if (size() > max_size() - 1)			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::splice length error");			#else				_STD::__msl_error("slist::splice length error\n");			#endif		node* p = position.node_;		node* s1 = i.node_;		node* s2 = s1->next_;		if (s1 == p || s2 == p)			return;		if (x.back_ == s2)			x.back_ = s1;		remove_nodes(s1, s2);		--x.alloc_.m_;		insert_nodes(p, s2, s2);		if (back_ == p)			back_ = s2;		++alloc_.m_;	}	template <class Allocator>	void	slist<const void*, Allocator>::splice_after(iterator position, slist& x, iterator first, iterator last)	{		if (first == last)			return;		if (this != &x)		{			size_type delta = (size_type)_STD::distance(first, last);			if (size() > max_size() - delta)				#ifndef _MSL_NO_EXCEPTIONS					throw _STD::length_error("slist::splice length error");				#else					_STD::__msl_error("slist::splice length error\n");				#endif			x.alloc_.m_ -= delta;			alloc_.m_ += delta;		}		node* s1 = first.node_;		node* s2 = s1->next_;		node* s3 = last.node_;		if (x.back_ == s3)			x.back_ = s1;		remove_nodes(s1, s3);		insert_nodes(position.node_, s2, s3);		if (back_ == position.node_)			back_ = s3;	}	template <class Allocator>	void	slist<const void*, Allocator>::remove(const value_type& value)	{		iterator e = end();		iterator p1 = e;		for (iterator i = begin(); i != e; ++i)		{			if (*i == value)			{				iterator j = i;				iterator p2 = j;				for (++j; j != e; ++j)				{					if (!(*j == value))						break;					p2 = j;				}				erase_after(p1, p2);				i = j;				if (i == e)					break;			}			p1 = i;		}	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class Predicate>	void	slist<const void*, Allocator>::remove_if(Predicate pred)	{		iterator e = end();		iterator p1 = e;		for (iterator i = begin(); i != e; ++i)		{			if (pred(*i))			{				iterator j = i;				iterator p2 = j;				for (++j; j != e; ++j)				{					if (!pred(*j))						break;					p2 = j;				}				erase_after(p1, p2);				i = j;				if (i == e)					break;			}		}		p1 = i;	}#endif	template <class Allocator>	void	slist<const void*, Allocator>::unique()	{		iterator e = end();		for (iterator i = begin(); i != e;)		{			iterator j = i;			iterator p = j;			for (++j; j != e; ++j)			{				if (!(*i == *j))					break;				p = j;			}			if (i != p)				erase_after(i, p);			++i;		}	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class BinaryPredicate>	void	slist<const void*, Allocator>::unique(BinaryPredicate binary_pred)	{		iterator e = end();		for (iterator i = begin(); i != e;)		{			iterator j = i;			iterator p = j;			for (++j; j != e; ++j)			{				if (!binary_pred(*i, *j))					break;				p = j;			}			if (i != p)				erase_after(i, p);			++i;		}	}#endif	template <class Allocator>	void	slist<const void*, Allocator>::merge(slist& x)	{		if (this == &x)			return;		if (size() > max_size() - x.size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::merge length error");			#else				_STD::__msl_error("slist::merge length error\n");			#endif		iterator first1 = begin();		iterator last1 = end();		iterator first2 = x.begin();		iterator last2 = x.end();		node* pfirst1 = last1.node_;		node* pfirst2 = last2.node_;		for (; first1 != last1 && first2 != last2; ++first1)		{			if (*first2 < *first1)			{				iterator j = first2;				size_type count = 1;				node* pj = j.node_;				for (++j; j != last2; ++j, ++count)				{					if (!(*j < *first1))						break;					pj = j.node_;				}				// splice_after(pfirst1, x, pfirst2, pj) but with pj-pfirst2 stored in count				if (x.back_ == pj)					x.back_ = pfirst2;				remove_nodes(pfirst2, pj);				insert_nodes(pfirst1, first2.node_, pj);				if (back_ == pfirst1)					back_ = pj;				x.alloc_.m_ -= count;				alloc_.m_ += count;				first2 = j;			}			pfirst1 = first1.node_;		}		if (first2 != last2)			splice_after(last_node(), x);	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class Compare>	void	slist<const void*, Allocator>::merge(slist& x, Compare comp)	{		if (this == &x)			return;		if (size() > max_size() - x.size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::merge length error");			#else				_STD::__msl_error("slist::merge length error\n");			#endif		iterator first1 = begin();		iterator last1 = end();		iterator first2 = x.begin();		iterator last2 = x.end();		node* pfirst1 = last1.node_;		node* pfirst2 = last2.node_;		for (; first1 != last1 && first2 != last2; ++first1)		{			if (comp(*first2, *first1))			{				iterator j = first2;				size_type count = 1;				node* pj = j.node_;				for (++j; j != last2; ++j, ++count)				{					if (!comp(*j, *first1))						break;					pj = j.node_;				}				// splice_after(pfirst1, x, pfirst2, pj) but with pj-pfirst2 stored in count				if (x.back_ == pj)					x.back_ = pfirst2;				remove_nodes(pfirst2, pj);				insert_nodes(pfirst1, first2.node_, pj);				if (back_ == pfirst1)					back_ = pj;				x.alloc_.m_ -= count;				alloc_.m_ += count;				first2 = j;			}			pfirst1 = first1.node_;		}		if (first2 != last2)			splice_after(last_node(), x);	}#endif	template <class Allocator>	void	slist<const void*, Allocator>::sort()	{		switch (size())		{		case 0:		case 1:			break;		case 2:		{			iterator i = begin();			iterator j = i;			++j;			if (*j < *i)			{	// reverse()				node_alloc_.m_.next_->next_ = (node*)&node_alloc_.m_;				back_->next_ = node_alloc_.m_.next_;				node_alloc_.m_.next_ = back_;				back_ = node_alloc_.m_.next_->next_;			}		}			break;		default:		{			iterator i = begin();			size_type lower_size = size() / 2;			_STD::advance(i, lower_size - 1);			slist upper_half;			// upper_half.splice_after(upper_half.last_node(), *this, i, last_node());			node* s1 = i.node_;			node* s2 = s1->next_;			node* s3 = back_;			back_ = s1;			remove_nodes(s1, s3);			insert_nodes(&upper_half.node_alloc_.m_, s2, s3);			upper_half.back_ = s3;			upper_half.alloc_.m_ = alloc_.m_ - lower_size;			alloc_.m_ = lower_size;			sort();			upper_half.sort();			merge(upper_half);			break;		}		}	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class Compare>	void	slist<const void*, Allocator>::sort(Compare comp)	{		switch (size())		{		case 0:		case 1:			break;		case 2:		{			iterator i = begin();			iterator j = i;			++j;			if (comp(*j, *i))			{	// reverse()				node_alloc_.m_.next_->next_ = (node*)&node_alloc_.m_;				back_->next_ = node_alloc_.m_.next_;				node_alloc_.m_.next_ = back_;				back_ = node_alloc_.m_.next_->next_;			}		}			break;		default:		{			iterator i = begin();			size_type lower_size = size() / 2;			_STD::advance(i, lower_size - 1);			slist upper_half;			// upper_half.splice_after(upper_half.last_node(), *this, i, last_node());			node* s1 = i.node_;			node* s2 = s1->next_;			node* s3 = back_;			back_ = s1;			remove_nodes(s1, s3);			insert_nodes(&upper_half.node_alloc_.m_, s2, s3);			upper_half.back_ = s3;			upper_half.alloc_.m_ = alloc_.m_ - lower_size;			alloc_.m_ = lower_size;			sort(comp);			upper_half.sort(comp);			merge(upper_half, comp);			break;		}		}	}#endif	template <class Allocator>	void	slist<const void*, Allocator>::reverse()	{		if (size() < 2)			return;		node* np = (node*)&node_alloc_.m_;		node* n = np->next_;		back_ = n;		while (true)		{			node* nn = n->next_;			n->next_ = np;			if (n == (node*)&node_alloc_.m_)				break;			np = n;			n = nn;		}	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class Allocator>	template <class InputIterator>	void	slist<const void*, Allocator>::choose_init(InputIterator first, InputIterator last, chooser<true>)	{		size_type n = static_cast<size_type>(first);		if (n > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::construction length error");			#else				_STD::__msl_error("slist::construction length error\n");			#endif		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			for (; n > 0; --n)				push_front(reinterpret_cast<value_type>(last));		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}	template <class Allocator>	template <class InputIterator>	void	slist<const void*, Allocator>::choose_init(InputIterator first, InputIterator last, chooser<false>)	{		#ifndef _MSL_NO_EXCEPTIONS		try		{		#endif			for (; first != last; ++first)				push_back(*first);		#ifndef _MSL_NO_EXCEPTIONS		}		catch (...)		{			clear();			throw;		}		#endif	}	template <class Allocator>	template <class InputIterator>	inline	void	slist<const void*, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<true>)	{		assign(static_cast<size_type>(first), reinterpret_cast<value_type>(last));	}	template <class Allocator>	template <class InputIterator>	inline	void	slist<const void*, Allocator>::choose_assign(InputIterator first, InputIterator last, chooser<false>)	{		do_assign(first, last, _STD::iterator_traits<InputIterator>::iterator_category());	}	template <class Allocator>	template <class InputIterator>	void	slist<const void*, Allocator>::do_assign(InputIterator first, InputIterator last, _STD::input_iterator_tag)	{		iterator i = begin();		iterator p;		for (; first != last && i != end(); ++first, ++i)		{			*i = *first;			p = i;		}		if (i == end())			insert_after(last_node(), first, last);		else			erase_after(p, last_node());	}	template <class Allocator>	template <class ForwardIterator>	void	slist<const void*, Allocator>::do_assign(ForwardIterator first, ForwardIterator last, _STD::forward_iterator_tag)	{		ForwardIterator f = first;		for (size_type c = size(); c != 0 && f != last; --c)			++f;		slist temp(f, last, alloc_);		if (size() > max_size() - temp.size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::assign length error");			#else				_STD::__msl_error("slist::assign length error\n");			#endif		iterator p = end();		for (iterator i = begin(); first != f; ++i, ++first)		{				*i = *first;			p = i;		}		if (temp.size() > 0)			splice_after(last_node(), temp);		else			erase_after(p, last_node());	}	template <class Allocator>	template <class RandomAccessIterator>	void	slist<const void*, Allocator>::do_assign(RandomAccessIterator first, RandomAccessIterator last, _STD::random_access_iterator_tag)	{		RandomAccessIterator f = first + _STD::min(size(), size_type(last - first));		if (last - first > max_size())			#ifndef _MSL_NO_EXCEPTIONS				throw _STD::length_error("slist::assign length error");			#else				_STD::__msl_error("slist::assign length error\n");			#endif		slist temp(f, last, alloc_);		iterator p = end();		for (iterator i = begin(); first != f; ++i, ++first)		{				*i = *first;			p = i;		}		if (temp.size() > 0)			splice_after(last_node(), temp);		else			erase_after(p, last_node());	}	template <class Allocator>	template <class InputIterator>	inline	void	slist<const void*, Allocator>::do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<true>)	{		insert_after(position, static_cast<size_type>(first), reinterpret_cast<value_type>(last));	}	template <class Allocator>	template <class InputIterator>	void	slist<const void*, Allocator>::do_insert_after(iterator position, InputIterator first, InputIterator last, chooser<false>)	{		slist temp(first, last, alloc_);		splice_after(position, temp);	}#endif	// range is (first, last] NOT [first, last), first == end() ok to remove begin()	template <class Allocator>	inline	void	slist<const void*, Allocator>::remove_nodes(node_base* first, node_base* last)	{		first->next_ = last->next_;	}	// range is [first, last] NOT [first, last), nodes inserted AFTER here, here != end()	template <class Allocator>	inline	void	slist<const void*, Allocator>::insert_nodes(node_base* here, node_base* first, node_base* last)	{		last->next_ = here->next_;		here->next_ = (node*)first;	}	template <class Allocator>	inline	bool	operator==(const slist<const void*, Allocator>& x, const slist<const void*, Allocator>& y)	{		return static_cast<bool>(x.size() == y.size() && _STD::equal(x.begin(), x.end(), y.begin()));	}	template <class Allocator>	inline	bool	operator!=(const slist<const void*, Allocator>& x, const slist<const void*, Allocator>& y)	{		return static_cast<bool>(!(x == y));	}	template <class Allocator>	inline	bool	operator< (const slist<const void*, Allocator>& x, const slist<const void*, Allocator>& y)	{		return _STD::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());	}	template <class Allocator>	inline	bool	operator> (const slist<const void*, Allocator>& x, const slist<const void*, Allocator>& y)	{		return y < x;	}	template <class Allocator>	inline	bool	operator>=(const slist<const void*, Allocator>& x, const slist<const void*, Allocator>& y)	{		return static_cast<bool>(!(x < y));	}	template <class Allocator>	inline	bool	operator<=(const slist<const void*, Allocator>& x, const slist<const void*, Allocator>& y)	{		return static_cast<bool>(!(y < x));	}	// specialized algorithms:	template <class Allocator>	inline	void	swap(slist<const void*, Allocator>& x, slist<const void*, Allocator>& y)	{		x.swap(y);	}	// T*	template <class T, class Allocator>	class slist<T*, Allocator>		: private slist<const void*, Allocator::rebind<const void*>::other>	{		typedef slist<const void*, Allocator::rebind<const void*>::other> base;		typedef base::allocator_type base_allocator;	public:		//  types:		typedef typename Allocator::reference         reference;		typedef typename Allocator::const_reference   const_reference;		class                                         iterator;		class                                         const_iterator;		typedef typename Allocator::size_type         size_type;		typedef typename Allocator::difference_type   difference_type;		typedef T*                                    value_type;		typedef Allocator                             allocator_type;		typedef typename Allocator::pointer           pointer;		typedef typename Allocator::const_pointer     const_pointer;	public:		class iterator			: public _STD::iterator<_STD::bidirectional_iterator_tag, value_type, difference_type, pointer, reference>		{		public:			iterator() {}			explicit iterator(const base::iterator& i) : i_(i) {}			operator base::iterator() const {return i_;}			reference operator * () const {return reference(*i_);}			pointer operator -> () const {return pointer(i_.operator->());}			iterator& operator ++ () {++i_; return *this;}			iterator operator ++ (int) {iterator tmp(*this); ++i_; return tmp;}			iterator& operator -- () {--i_; return *this;}			iterator operator -- (int) {iterator tmp(*this); --i_; return tmp;}			friend bool operator ==(const iterator& x, const iterator& y) {return x.i_ == y.i_;}			friend bool operator !=(const iterator& x, const iterator& y) {return x.i_ != y.i_;}		private:			base::iterator i_;			friend class slist::const_iterator;		};		class const_iterator			: public _STD::iterator<_STD::bidirectional_iterator_tag, value_type, difference_type, const_pointer, const_reference>		{		public:			const_iterator() {}			const_iterator(const slist::iterator& x) : i_(x.i_) {}			explicit const_iterator(const base::const_iterator& i) : i_(i) {}			operator base::const_iterator() const {return i_;}			const_reference operator * () const {return const_reference(*i_);}			const_pointer operator -> () const {return const_pointer(i_.operator->());}			const_iterator& operator ++ () {++i_; return *this;}			const_iterator operator ++ (int) {const_iterator tmp(*this); ++i_; return tmp;}			const_iterator& operator -- () {--i_; return *this;}			const_iterator operator -- (int) {const_iterator tmp(*this); --i_; return tmp;}			friend bool operator ==(const const_iterator& x, const const_iterator& y) {return x.i_ == y.i_;}			friend bool operator !=(const const_iterator& x, const const_iterator& y) {return x.i_ != y.i_;}		private:			base::const_iterator i_;		};		//  lib.slist.cons construct/copy/destroy:		explicit slist(const Allocator& = Allocator());		explicit slist(size_type n);		slist(size_type n, const value_type& value, const Allocator& = Allocator());	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			slist(InputIterator first, InputIterator last, const Allocator& a = Allocator());		template <class InputIterator> void assign(InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			slist(InputIterator first, InputIterator last, const Allocator& a = Allocator())				: base(_STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),				       _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last), base_allocator(a))			{			}		template <class InputIterator>			inline			void			assign(InputIterator first, InputIterator last)			{				base::assign(_STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),				             _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));			}	#endif		void assign(size_type n, const value_type& t);		allocator_type get_allocator() const;		//  iterators:		iterator               begin();		const_iterator         begin() const;		iterator               end();		const_iterator         end() const;		iterator               last_node();      // returns --end() (constant time)		const_iterator         last_node() const;		iterator previous(iterator x);           // returns --x (linear time)		const_iterator previous(const_iterator x);		//  lib.slist.capacity capacity:		bool      empty() const;		size_type size() const;		size_type max_size() const;		void      resize(size_type sz);		void      resize(size_type sz, const value_type& value);		//  element access:		reference       front();		const_reference front() const;		//  lib.slist.modifiers modifiers:		void push_front(const value_type& x);		void pop_front();		void push_back(const value_type& x);		// there is no pop_back		iterator insert(iterator position, const value_type& x);  // linear time!		void     insert(iterator position, size_type n, const value_type& x);  // linear time!	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>  // linear time!			void insert(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void insert(iterator position, InputIterator first, InputIterator last)			{				base::insert(position, _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),				                       _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));			}	#endif		// constant time versions of insert, inserts stuff after position		// end() can be used as the node before begin()		iterator insert_after(iterator position, const value_type& x);		void     insert_after(iterator position, size_type n, const value_type& x);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class InputIterator>			void insert_after(iterator position, InputIterator first, InputIterator last);	#else		template <class InputIterator>			inline			void insert_after(iterator position, InputIterator first, InputIterator last)			{				base::insert_after(position, _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),				                             _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));			}	#endif		iterator erase(iterator position);  // linear time!		iterator erase(iterator position, iterator last);  // linear time!		// constant time versions of erase		// end() can be used as the node before begin()		iterator erase_after(iterator position); // erase (position, position+1], return position		iterator erase_after(iterator position, iterator last); // erase (position, last], return position		void     swap(slist& x);		void     clear();		//  lib.slist.ops slist operations:		void splice(iterator position, slist& x);  // linear time!		void splice(iterator position, slist& x, iterator i);  // linear time!		void splice(iterator position, slist& x, iterator first, iterator last);  // linear time!		// constant time versions of splice, splices stuff after position		// end() can be used as the node before begin()		void splice_after(iterator position, slist& x);		void splice_after(iterator position, slist& x, iterator i); // splices (i, i+1]		void splice_after(iterator position, slist& x, iterator first, iterator last);  // splices (first, last]		void remove(const value_type& value);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Predicate> void remove_if(Predicate pred);	#else		template <class Predicate>			inline			void			remove_if(Predicate pred)			{				base::remove_if(unary_convert<Predicate>(pred));			}	#endif		void unique();	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class BinaryPredicate> void unique(BinaryPredicate binary_pred);	#else		template <class BinaryPredicate>			inline			void			unique(BinaryPredicate binary_pred)			{				base::unique(binary_convert<BinaryPredicate>(binary_pred));			}	#endif		void merge(slist& x);	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Compare> void merge(slist& x, Compare comp);	#else		template <class Compare>			inline			void			merge(slist& x, Compare comp)			{				base::merge((base&)x, binary_convert<Compare>(comp));			}	#endif		void sort();	#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE		template <class Compare> void sort(Compare comp);	#else		template <class Compare>			inline			void			sort(Compare comp)			{				base::sort(binary_convert<Compare>(comp));			}	#endif		void reverse();	private:		template <class Compare>		class unary_convert		{		public:			unary_convert(Compare comp) : comp_(comp) {}			bool operator() (const void* x) {return comp_((T*)x);}		private:			Compare comp_;		};		template <class Compare>		class binary_convert		{		public:			binary_convert(Compare comp) : comp_(comp) {}			bool operator() (const void* x, const void* y) {return comp_((T*)x, (T*)y);}		private:			Compare comp_;		};	};	// Implementation slist<T*>	template <class T, class Allocator>	inline	slist<T*, Allocator>::slist(const Allocator& a)		: base(base_allocator(a))	{	}	template <class T, class Allocator>	inline	slist<T*, Allocator>::slist(size_type n)		: base(n)	{	}	template <class T, class Allocator>	inline	slist<T*, Allocator>::slist(size_type n, const value_type& value, const Allocator& a)		: base(n, value, base_allocator(a))	{	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class InputIterator>	inline	slist<T*, Allocator>::slist(InputIterator first, InputIterator last, const Allocator& a)		: base(_STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),		       _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last), base_allocator(a))	{	}	template <class T, class Allocator>	template <class InputIterator>	inline	void	slist<T*, Allocator>::assign(InputIterator first, InputIterator last)	{		base::assign(_STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),		             _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));	}#endif	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::assign(size_type n, const value_type& t)	{		base::assign(n, t);	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::allocator_type	slist<T*, Allocator>::get_allocator() const	{		return base::get_allocator();	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::begin()	{		return iterator(base::begin());	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::const_iterator	slist<T*, Allocator>::begin() const	{		return const_iterator(base::begin());	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::end()	{		return iterator(base::end());	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::const_iterator	slist<T*, Allocator>::end() const	{		return const_iterator(base::end());	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::last_node()	{		return iterator(base::last_node());	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::const_iterator	slist<T*, Allocator>::last_node() const	{		return const_iterator(base::last_node());	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::previous(iterator x)	{		return iterator(base::previous(x));	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::const_iterator	slist<T*, Allocator>::previous(const_iterator x)	{		return const_iterator(base::previous(x));	}	template <class T, class Allocator>	inline	bool	slist<T*, Allocator>::empty() const	{		return base::empty();	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::size_type	slist<T*, Allocator>::size() const	{		return  base::size();	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::size_type	slist<T*, Allocator>::max_size() const	{		return  base::max_size();	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::resize(size_type sz)	{		base::resize(sz);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::resize(size_type sz, const value_type& value)	{		base::resize(sz, value);	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::reference	slist<T*, Allocator>::front()	{		return reference(base::front());	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::const_reference	slist<T*, Allocator>::front() const	{		return const_reference(base::front());	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::push_front(const value_type& x)	{		base::push_front(x);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::pop_front()	{		base::pop_front();	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::push_back(const value_type& x)	{		base::push_back(x);	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::insert(iterator position, const value_type& x)	{		return iterator(base::insert(position, x));	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::insert(iterator position, size_type n, const value_type& x)	{		base::insert(position, n, x);	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class InputIterator>	inline	void	slist<T*, Allocator>::insert(iterator position, InputIterator first, InputIterator last)	{		base::insert(position, _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),		                       _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));	}#endif	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::insert_after(iterator position, const value_type& x)	{		return iterator(base::insert_after(position, x));	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::insert_after(iterator position, size_type n, const value_type& x)	{		base::insert_after(position, n, x);	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class InputIterator>	inline	void	slist<T*, Allocator>::insert_after(iterator position, InputIterator first, InputIterator last)	{		base::insert_after(position, _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(first),		                             _STD::__convert_iterator<_STD::__implicit_convert<pointer, InputIterator> >(last));	}#endif	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::erase(iterator position)	{		return iterator(base::erase(position));	}	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::erase(iterator position, iterator last)	{		return iterator(base::erase(position, last));	}	// erase (position, position+1]	// return position	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::erase_after(iterator position)	{		return iterator(base::erase_after(position));	}	// erase (position, last]	// return position	template <class T, class Allocator>	inline	typename slist<T*, Allocator>::iterator	slist<T*, Allocator>::erase_after(iterator position, iterator last)	{		return iterator(base::erase_after(position, last));	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::swap(slist& x)	{		base::swap((base&)x);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::clear()	{		base::clear();	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::splice(iterator position, slist& x)	{		base::splice(position, (base&)x);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::splice(iterator position, slist& x, iterator i)	{		base::splice(position, (base&)x, i);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::splice(iterator position, slist& x, iterator first, iterator last)	{		base::splice(position, (base&)x, first, last);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::splice_after(iterator position, slist& x)	{		base::splice_after(position, (base&)x);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::splice_after(iterator position, slist& x, iterator i)	{		base::splice_after(position, (base&)x, i);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::splice_after(iterator position, slist& x, iterator first, iterator last)	{		base::splice_after(position, (base&)x, first, last);	}	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::remove(const value_type& value)	{		base::remove(value);	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class Predicate>	inline	void	slist<T*, Allocator>::remove_if(Predicate pred)	{		base::remove_if(unary_convert<Predicate>(pred));	}#endif	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::unique()	{		base::unique();	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class BinaryPredicate>	inline	void	slist<T*, Allocator>::unique(BinaryPredicate binary_pred)	{		base::unique(binary_convert<BinaryPredicate>(binary_pred));	}#endif	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::merge(slist& x)	{		base::merge((base&)x);	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class Compare>	inline	void	slist<T*, Allocator>::merge(slist& x, Compare comp)	{		base::merge((base&)x, binary_convert<Compare>(comp));	}#endif	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::sort()	{		base::sort();	}#ifndef _MSL_MUST_INLINE_MEMBER_TEMPLATE	template <class T, class Allocator>	template <class Compare>	inline	void	slist<T*, Allocator>::sort(Compare comp)	{		base::sort(binary_convert<Compare>(comp));	}#endif	template <class T, class Allocator>	inline	void	slist<T*, Allocator>::reverse()	{		base::reverse();	}	template <class T, class Allocator>	inline	bool	operator==(const slist<T*, Allocator>& x, const slist<T*, Allocator>& y)	{		return static_cast<bool>(x.size() == y.size() && _STD::equal(x.begin(), x.end(), y.begin()));	}	template <class T, class Allocator>	inline	bool	operator!=(const slist<T*, Allocator>& x, const slist<T*, Allocator>& y)	{		return static_cast<bool>(!(x == y));	}	template <class T, class Allocator>	inline	bool	operator< (const slist<T*, Allocator>& x, const slist<T*, Allocator>& y)	{		return _STD::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());	}	template <class T, class Allocator>	inline	bool	operator> (const slist<T*, Allocator>& x, const slist<T*, Allocator>& y)	{		return y < x;	}	template <class T, class Allocator>	inline	bool	operator>=(const slist<T*, Allocator>& x, const slist<T*, Allocator>& y)	{		return static_cast<bool>(!(x < y));	}	template <class T, class Allocator>	inline	bool	operator<=(const slist<T*, Allocator>& x, const slist<T*, Allocator>& y)	{		return static_cast<bool>(!(y < x));	}	// specialized algorithms:	template <class T, class Allocator>	inline	void	swap(slist<T*, Allocator>& x, slist<T*, Allocator>& y)	{		x.swap(y);	}#endif // !defined(_MSL_NO_PARTIAL_SPECIALIZATION) && !defined(_MSL_NO_MEMBER_TEMPLATE) && !defined(_Inhibit_Container_Optimization)#ifndef _MSL_NO_CPP_NAMESPACE	} // namespace Metrowerks#endif#ifdef _MSL_FORCE_ENUMS_ALWAYS_INT	#pragma enumsalwaysint reset#endif#ifdef _MSL_FORCE_ENABLE_BOOL_SUPPORT	#pragma bool reset#endif#if defined(__CFM68K__) && !defined(__USING_STATIC_LIBS__)	#pragma import reset#endif#pragma options align=reset#endif // RC_INVOKED#endif // _SLIST// hh 990629 Rewrote// hh 990825 changed void* to const void*// hh 991116 Fixed pointer conversion bug in T* specialization by introducing __convert_iterator// hh 000129 Moved into namespace Metrowerks