// ===========================================================================//	UDrawingUtils.cp			PowerPlant 2.1		©1993-2000 Metrowerks Inc.// ===========================================================================#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <UDrawingUtils.h>#include <LString.h>#include <Events.h>#include <FixMath.h>#include <Gestalt.h>#include <LowMem.h>PP_Begin_Namespace_PowerPlant// ===========================================================================// ¥ UDrawingUtils											   UDrawingUtils ¥// ===========================================================================// ---------------------------------------------------------------------------//	¥ IsColorGrafPort// ---------------------------------------------------------------------------//	Return whether a Toolbox GrafPort supports colorboolUDrawingUtils::IsColorGrafPort(	GrafPtr		inMacPort){#if ACCESSOR_CALLS_ARE_FUNCTIONS	return ::IsPortColor(inMacPort);#else								// Highest 2 bits of rowBytes are								//   set for a Color GrafPort	return ((inMacPort->portBits.rowBytes & 0xC000) == 0xC000);#endif}// ---------------------------------------------------------------------------//	¥ GetPortPixelDepth// ---------------------------------------------------------------------------//	Return the number of bits per pixel for a GrafPortSInt16UDrawingUtils::GetPortPixelDepth(	GrafPtr		inMacPort){#if ACCESSOR_CALLS_ARE_FUNCTIONS	return ::GetPixDepth( ::GetPortPixMap(inMacPort) );#else	SInt16	depth = 1;			// Black & white is 1 bit per pixel	if (IsColorGrafPort(inMacPort)) {								// Get depth from PixMapHandle of color port		depth = (**((reinterpret_cast<CGrafPtr>(inMacPort))->portPixMap)).pixelSize;	}	return depth;#endif}// ---------------------------------------------------------------------------//	¥ IsActiveScreenDevice// ---------------------------------------------------------------------------//	Return whether a GDevice represents an active screenboolUDrawingUtils::IsActiveScreenDevice(	GDHandle	inDevice){	return (::TestDeviceAttribute(inDevice, screenDevice) &&			::TestDeviceAttribute(inDevice, screenActive));}// ---------------------------------------------------------------------------//	¥ DeviceSupportsColor// ---------------------------------------------------------------------------//	Return whether a GDevice supports colorboolUDrawingUtils::DeviceSupportsColor(	GDHandle	inDevice){	return ::TestDeviceAttribute(inDevice, gdDevType);}// ---------------------------------------------------------------------------//	¥ SetHiliteModeOn// ---------------------------------------------------------------------------//	Turn on the QuickDraw hilite mode so that the next draw of an inverted//	shape occurs in hilite modevoidUDrawingUtils::SetHiliteModeOn(){	LMSetHiliteMode((UInt8) (LMGetHiliteMode() & (~(1 << hiliteBit))));}#pragma mark -// ===========================================================================// ¥ StColorDrawLoop										 StColorDrawLoop ¥// ===========================================================================//	Class for coordinating drawing in an area which may span multiple//	devices (monitors) with different bit depths.////	How to use://		You will usually create an StColorDrawLoop on the stack inside//		a function which draws. This implementation is not dependent//		on PowerPlant Panes, so you can use this class with any drawing//		code.////		The constructor takes a Rect in the local coordinates of the//		current port.////		The NextDepth(SInt16 depth) function passes back the depth of the//		next device and returns true. After reaching the last device,//		the depth is zero and the function returns false. You would normally//		call NextDepth() as the condition in a "while" loop.////		When NextDepth() returns with a valid depth, it has already set//		the clipping region to the intersection of the specified Rect, the//		current device, and the original clipping region. Therefore, you can//		just draw "everything" and rely on the clipping region to properly//		restrict the drawing. If you need access to the current device,//		you can call the GetCurrentDevice() member function.////		The destructor restores the clipping region to what it was when//		the constructor was called.////	Example:////		The body of a DrawSelf() function would look something like this:////		Rect	frame;//		if (CalcLocalFrameRect(frame)) {//			StDeviceLoop	theLoop(frame);//			SInt16			depth;//			while (theLoop.NextDepth(depth)) {//				switch (depth) {////					case 1:		// Black & white//						break;////					case 4:		// 16 colors//						break;////					case 8:		// 256 colors//						break;////					case 16:	// Thousands of colors//						break;////					case 32:	// Millions of colors//						break;//				}//			}//		}////		You would add the appropriate drawing code to each depth case.StColorDrawLoop::StColorDrawLoop(	const Rect	&inLocalRect){	mGlobalRect = inLocalRect;			// Convert to Global coords	::LocalToGlobal(&topLeft(mGlobalRect));	::LocalToGlobal(&botRight(mGlobalRect));	mCurrentDevice = nil;}StColorDrawLoop::~StColorDrawLoop(){}boolStColorDrawLoop::NextDepth(	SInt16	&outDepth){	outDepth = 0;	if (mCurrentDevice == nil) {		// First call. Start at beginning										//   of GDevice list.		mCurrentDevice = ::GetDeviceList();	} else {							// Subsequent call		mCurrentDevice = ::GetNextDevice(mCurrentDevice);	}	while (mCurrentDevice != nil) {			// Find active screen device that intersects our			// target rectangle		if (UDrawingUtils::IsActiveScreenDevice(mCurrentDevice)) {			Rect	deviceRect = (**mCurrentDevice).gdRect;			Rect	intersection;			if (::SectRect(&mGlobalRect, &deviceRect, &intersection)) {					// Set clipping region to the intersection of the target					// rectangle, the screen rectangle, and the original					// clipping region				::GlobalToLocal(&topLeft(intersection));				::GlobalToLocal(&botRight(intersection));				mClipState.ClipToIntersection(intersection);				outDepth = (**((**mCurrentDevice).gdPMap)).pixelSize;				break;				// Exit device loop			}		}		mCurrentDevice = ::GetNextDevice(mCurrentDevice);	}	return (mCurrentDevice != nil);}#pragma mark -// ===========================================================================// ¥ StDeviceLoop												StDeviceLoop ¥// ===========================================================================//	Subclass of StColorDrawLoop that works with both Color and old-style//	Black and White QuickDraw.StDeviceLoop::StDeviceLoop(	const Rect	&inLocalRect)		: StColorDrawLoop(inLocalRect){										// Check if machine has ColorQD	SInt32		qdVersion = gestaltOriginalQD;	::Gestalt(gestaltQuickdrawVersion, &qdVersion);	mHasOldQD = (qdVersion == gestaltOriginalQD);	mOldQDPending = true;}StDeviceLoop::~StDeviceLoop(){}boolStDeviceLoop::NextDepth(	SInt16	&outDepth){	outDepth = 0;	if (mHasOldQD) {					// No ColorQD, so there can only		if (mOldQDPending) {			//   be 1-bit pixel depth			Rect	localRect = mGlobalRect;			::GlobalToLocal(&topLeft(localRect));			::GlobalToLocal(&botRight(localRect));			::ClipRect(&localRect);			outDepth = 1;			mOldQDPending = false;			return true;		}		return false;	}										// ColorQD exists, so call										//   inherited function	return StColorDrawLoop::NextDepth(outDepth);}#pragma mark -// ===========================================================================// ¥ UMarchingAnts											   UMarchingAnts ¥// ===========================================================================//	Utility functions for drawing marching ants, which is typically used//	for an animated selection marquee.////	Typically, you will use this class within a Pane that is also a//	Periodical. For example, assuming your class maintains a Rect called//	mSelRect that stores the current selection rectangle:////	void CMyPaneWithSelection::SpendTime(const EventRecor&)//	{//		FocusDraw();//		StColorState::Normalize();	// Draw in black and white////			// Animate selection if this Pane is active and enough//			// time has passed for the next march to occur////		if (IsActive() && UMarchingAnts::BeginMarch()) {//			::MacFrameRect(&mSelRect);//			UMarchingAnts::EndMarch();//		}//	}////	Ants appear to march because the UMarchingAnts class stores a pen pattern//	that it rotates between successive calls.Pattern	UMarchingAnts::sAntsPattern = {0xF8, 0xF1, 0xE3, 0xC7,								  	   0x8F, 0x1F, 0x3E, 0x7C};UInt32	UMarchingAnts::sNextAntMarchTime = 0;const SInt16		interval_AntMarch = 3;BooleanUMarchingAnts::BeginMarch(){	Boolean	marching = (::TickCount() >= sNextAntMarchTime);	if (marching) {		UseAntsPattern();	}	return marching;}voidUMarchingAnts::EndMarch(){	sNextAntMarchTime = ::TickCount() + interval_AntMarch;	unsigned char	lastRow = sAntsPattern.pat[7];	for (SInt16 i = 7; i > 0; i--) {		sAntsPattern.pat[i] = sAntsPattern.pat[i - 1];	}	sAntsPattern.pat[0] = lastRow;}voidUMarchingAnts::UseAntsPattern(){	::PenNormal();	::PenPat(&sAntsPattern);}#pragma mark -// ===========================================================================// ¥ LMarchingAnts											   LMarchingAnts ¥// ===========================================================================//	Utility class for drawing marching ants, which is typically used for an//	animated selection marquee.////	This class is similar to UMarchingAnts, except that this class stores//	its data in member variables rather than static class variables.//	Therefore, you can have multiple instances of LMarchingAnts, whereas//	a program can only use UMarchingAnts for one thing at a time.LMarchingAnts::LMarchingAnts(	UInt32		inMarchInterval){	mMarchInterval		= inMarchInterval;	mNextAntMarchTime	= 0;								// Ants Pattern is a diagonal stripe	mAntsPattern.pat[0]	= 0xF8;		//  1 1 1 1 1 0 0 0	mAntsPattern.pat[1]	= 0xF1;		//  1 1 1 1 0 0 0 1	mAntsPattern.pat[2]	= 0xE3;		//  1 1 1 0 0 0 1 1	mAntsPattern.pat[3]	= 0xC7;		//  1 1 0 0 0 1 1 1	mAntsPattern.pat[4]	= 0x8F;		//	1 0 0 0 1 1 1 1	mAntsPattern.pat[5]	= 0x1F;		//	0 0 0 1 1 1 1 1	mAntsPattern.pat[6]	= 0x3E;		//	0 0 1 1 1 1 1 0	mAntsPattern.pat[7]	= 0x7C;		//	0 1 1 1 1 1 0 0}LMarchingAnts::~LMarchingAnts(){}BooleanLMarchingAnts::BeginMarch(){	Boolean	marching = (::TickCount() >= mNextAntMarchTime);	if (marching) {		UseAntsPattern();	}	return marching;}voidLMarchingAnts::EndMarch(){	mNextAntMarchTime = ::TickCount() + mMarchInterval;		// Rotate bytes of Pattern to move the ants	unsigned char	lastRow = mAntsPattern.pat[7];	for (SInt16 i = 7; i > 0; i--) {		mAntsPattern.pat[i] = mAntsPattern.pat[i - 1];	}	mAntsPattern.pat[0] = lastRow;}voidLMarchingAnts::UseAntsPattern(){	::PenNormal();	::PenPat(&mAntsPattern);}#pragma mark -// ===========================================================================// ¥ UTextDrawing												UTextDrawing ¥// ===========================================================================//	Utility functions for drawing text// ---------------------------------------------------------------------------//	¥ DrawWithJustification											  [static]// ---------------------------------------------------------------------------//	Draw justified text within a rectangle////	This is a "better" version of the Toolbox TextBox() routine that does//	not erase before it draws.voidUTextDrawing::DrawWithJustification(	Ptr				inText,	SInt32			inLength,	const Rect&		inRect,	SInt16			inJustification,	bool			inFirstLeading)		// Add leading above first line?{	FontInfo	fontInfo;				// Determine vertical line spacing	::GetFontInfo(&fontInfo);			//   based on font characteristics	SInt16 lineHeight = (SInt16) (fontInfo.ascent + fontInfo.descent + fontInfo.leading);	SInt16 lineBase   = (SInt16) (inRect.top + fontInfo.ascent);	if (inFirstLeading) {		lineBase += fontInfo.leading;	}										// Get pixel width of a line a text										//   in both int and fixed format	SInt16		intWidth   = (SInt16) (inRect.right - inRect.left);	Fixed		fixedWidth = ::Long2Fix(intWidth);										// Get text justification option	SInt16	justification = GetActualJustification(inJustification);	StClipRgnState	saveClip;			// Draw within input rectangle	saveClip.ClipToIntersection(inRect);	SInt32	textLeft = inLength;	Ptr		textEnd  = inText + inLength;	while ((inText < textEnd) && (lineBase <= inRect.bottom)) {			// IM:Text 5-50 states that the StyledLineBreak call			// only handles widths up to the [maximum short] integer			// range. So we limit things accordingly.		SInt32	textLen = textLeft;		if (textLen > max_Int16) {			textLen = max_Int16;		}		SInt32	lineBytes = textLen;		Fixed	wrapWidth = fixedWidth;			// StyledLineBreak will pass back the number of bytes			// of text that we should draw on this line		StyledLineBreakCode lineBreak = ::StyledLineBreak(											inText, textLen,											0, textLen, 0,											&wrapWidth, &lineBytes);										// Determine location to start text										//   line based on justification		if ( (justification == teFlushLeft) ||			 (justification == teJustLeft) ) {										// Text at left edge			::MoveTo(inRect.left, lineBase);		} else {						// Center or right justified										// Determine length of text without										//   spaces			SInt32	blackSpace = ::VisibleLength(inText, lineBytes);			SInt16	visWidth   = ::TextWidth(inText, 0, (SInt16) blackSpace);			if (justification == teFlushRight) {										// Text extends to right edge				::MoveTo((SInt16) (inRect.right - visWidth), lineBase);			} else {					// Horizontally centered text				::MoveTo((SInt16) (inRect.left + (intWidth - visWidth) / 2),							lineBase);			}		}										// Draw one line of text		::MacDrawText(inText, 0, (SInt16) lineBytes);		lineBase += lineHeight;			// Move down for next line		inText   += lineBytes;			// Move to first char of next line		textLeft -= lineBytes;			// Decrement bytes of text remaining	}}// ---------------------------------------------------------------------------//	¥ DrawTruncatedWithJust											  [static]// ---------------------------------------------------------------------------//	Draw justified text within a rectangle that can optionally also be// 	truncated if the text is longer than the rect width////	This is similar to the function above except that it can only handle//	drawing text on a single line, there is no support for line wrappingvoidUTextDrawing::DrawTruncatedWithJust(	ConstStringPtr	inString,  	const Rect&		inRect,  	SInt16			inJustification,	bool			inTruncateString,  	bool	 		inPreferOutline,  	TruncCode		inTruncWhere){	LStr255		localString = inString;	// Copy string because truncation										//  will change the string										// Set the width of the text box	Rect 	localBox = inRect;	SInt16	boxWidth = (SInt16) (localBox.right - localBox.left);										// TrueType or BitMap preferred?	::SetOutlinePreferred(inPreferOutline);										// Check if the string is too wide	SInt16	widthOfString = ::StringWidth(localString);	if (inTruncateString && (widthOfString > boxWidth)) {										// Truncate string		::TruncString(boxWidth, localString, inTruncWhere);		widthOfString = ::StringWidth(localString);	}		// If the width of the string is less than the text box,		// then set the justification. Otherwise it draw the text		// at starting at the left edge of the box.	if (widthOfString < boxWidth) {		switch (GetActualJustification(inJustification)) {			case teCenter:				localBox.left += (SInt16) ((boxWidth - widthOfString) / 2);				break;			case teFlushRight:				localBox.left += (SInt16) (boxWidth - widthOfString);				break;		}	}										// Finally, draw the string	FontInfo 	theFontInfo;	::GetFontInfo(&theFontInfo);	::MoveTo(localBox.left, (SInt16) (localBox.top + theFontInfo.ascent));	::DrawString(localString);}// ---------------------------------------------------------------------------//	¥ DimTextColor													  [static]// ---------------------------------------------------------------------------voidUTextDrawing::DimTextColor(	RGBColor&	ioColor){	ioColor.red   = (UInt16) ((ioColor.red   + 65535) >> 1);	ioColor.green = (UInt16) ((ioColor.green + 65535) >> 1);	ioColor.blue  = (UInt16) ((ioColor.blue  + 65535) >> 1);}PP_End_Namespace_PowerPlant