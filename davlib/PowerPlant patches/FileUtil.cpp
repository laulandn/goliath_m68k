/*	FileUtil.cpp	Copyright (C) 2000 i-drive.com (email: opensource@mail.idrive.com)	This library is free software; you can redistribute it and/or	modify it under the terms of version 2.1 of the GNU Lesser General	Public License as published by the Free Software Foundation.	This library is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU	Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public	License along with this library; if not, write to the Free Software	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA*/#include "FileUtil.h"using namespace std;bool MakeNewFSSpec (FSSpec& newSpec, short vRefNum, long parID, const string& rawName, bool saveSuffix){   	int					fileExtra = 0;   	string				name;   	OSErr				err = noErr;	string				head;	string				suffix;	bool				result = false;   	   	newSpec.vRefNum = vRefNum;   	newSpec.parID = parID;	if (saveSuffix)		SplitName (rawName, head, suffix);	else		head = rawName;		   	for (fileExtra = 0; fileExtra < 99; fileExtra++)   	{		MakeNewName (head, suffix, name, fileExtra, 31);				newSpec.name[0] = name.size();		BlockMoveData (name.c_str(), newSpec.name+1, newSpec.name[0]);				err = CheckFile (newSpec);		if (err == fnfErr)		{			result = true;			break;		}		else if (err != noErr)			break;   	};end:	if (result == false)	{		newSpec.vRefNum = 0;		newSpec.parID = 0;		newSpec.name[0] = 0;	}   	return true;}void SplitName (const string& name, string& head, string& suffix){	string::size_type	suffixpos = name.find ('.');	if (suffixpos != string::npos && suffixpos != 0 && suffixpos + 4 <= name.size())	{		suffix.assign (name, suffixpos, string::npos);		head.assign (name, 0, suffixpos);	}	else	{		head = name;		suffix.clear();	}}void MakeNewName (const string& name, const string& suffix, string& newName, UInt32 index, UInt32 maxLen){	char extra [12];	int extraSize = 0;   	int totalSize;		if (index != 0)		extraSize = sprintf (extra, " %d", index);			totalSize = name.size() + extraSize + suffix.size();	if (totalSize > maxLen)	{		if (extraSize + suffix.size() > maxLen)		{			newName.clear();			return;		}		else			newName.assign (name, 0, maxLen - extraSize - suffix.size());	}	else		newName.assign (name);			newName.append (extra, extraSize);	newName.append (suffix);}OSErr CheckFile (const FSSpec &fs){	CInfoPBRec pb;	OSErr err;		pb.hFileInfo.ioNamePtr = (unsigned char*)fs.name;	pb.hFileInfo.ioVRefNum = fs.vRefNum;	pb.hFileInfo.ioDirID = fs.parID;	pb.hFileInfo.ioFVersNum = 0;	pb.hFileInfo.ioFDirIndex = 0;	err = PBGetCatInfoSync(&pb);		return err;}