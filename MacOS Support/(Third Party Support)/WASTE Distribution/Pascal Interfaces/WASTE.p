UNIT WASTE;{ Pascal interface to the WASTE text engine }{ version 2.1a8 (May 2002) }{ Copyright © 1993-2002 Marco Piovanelli }{ All Rights Reserved }{ <http://www.merzwaren.com/waste/> }{ <mailto:waste@merzwaren.com> }INTERFACE	USES		ConditionalMacros,		MacTypes,		MixedMode,		QuickdrawText,		Quickdraw,		Scrap,		Script,		TextUtils,		TextEdit,		Drag,		CarbonEvents,		LongCoords;{$PUSH}{$ALIGN MAC68K}{$LibExport+}	CONST{ result codes }		weCantUndoErr					= -10015;			{ undo buffer is clear (= errAECantUndo) }		weEmptySelectionErr				= -10013;			{ empty selection range (= errAENoUserSelection) }		weUnknownObjectTypeErr			= -9478;			{ specified object type is not registered }		weObjectNotFoundErr				= -9477;			{ no object found at specified offset }		weReadOnlyErr					= -9476;			{ cannot modify instance }		weTextNotFoundErr				= -9474;			{ search string not found }		weInvalidTextEncodingErr		= -9473;			{ specified text encoding is invalid or unsupported }		weDuplicateAttributeErr			= -9472;			{ one of the attribute selectors was specified more than once }		weInvalidAttributeSizeErr		= -9471;			{ attribute value size is invalid }		weReadOnlyAttributeErr			= -9470;			{ attribute is read-only }		weOddByteCountErr				= -9469;			{ expected an even number of bytes }		weHandlerNotFoundErr			= -1717;			{ couldn't find specified handler (= errAEHandlerNotFound) }		weNotHandledErr					= -1708;			{ please use default behavior (= errAEEventNotHandled) }		weNewerVersionErr				= -1706;			{ version of formatting scrap is too new (= errAENewerVersion) }		weCorruptDataErr				= -1702;			{ malformed formatting scrap (= errAECorruptData) }		weProtocolErr					= -603;				{ improper call order (= protocolErr) }		weUndefinedSelectorErr			= -50;				{ unknown selector (= paramErr) }{ alignment styles }		weFlushLeft						= -2;				{ flush left }		weFlushRight					= -1;				{ flush right }		weFlushDefault					= 0;				{ flush according to system direction }		weCenter						= 1;				{ centered }		weJustify						= 2;				{ fully justified }{ primary line direction }		weDirDefault					= 1;				{ according to system direction }		weDirRightToLeft				= -1;				{ force right-to-left }		weDirLeftToRight				= 0;				{ force left-to-right }{ values for the inMode parameter in WESetStyle and the ioMode parameter in WEContinuousStyle }		weDoFont 						= $0001;			{ set font family number }		weDoFace 						= $0002;			{ set Quickdraw styles }		weDoSize 						= $0004;			{ set type size }		weDoColor 						= $0008;			{ set color }		weDoAll 						= weDoFont + weDoFace + weDoSize + weDoColor;		weDoAddSize 					= $0010;			{ adjust type size }		weDoToggleFace 					= $0020;			{ turn a style off if it's continuous over the selection }		weDoReplaceFace 				= $0040;			{ replace existing styles outright }		weDoPreserveScript				= $0080;			{ don't change scripts when applying a font change }		weDoExtractSubscript 			= $0100;			{ extract subscripts when applying a font change }		weDoFaceMask 					= $0200;			{ set Quickdraw styles using mask field }{ values for the inMode parameter in WESetRuler and the ioMode parameter in WEContinuousRuler }		weDoDirection					= $00000001;		weDoAlignment					= $00000002;		weDoLeftIndent					= $00000004;		weDoRightIndent					= $00000008;		weDoFirstLineIndent				= $00000010;		weDoLineSpacing					= $00000020;		weDoSpaceBefore					= $00000040;		weDoSpaceAfter					= $00000080;		weDoBottomBorderStyle			= $00000400;{ values for the outEdge parameter in WEGetOffset etc. }		kLeadingEdge					= -1;				{ point is on the leading edge of a glyph }		kTrailingEdge					= 0;				{ point is on the trailing edge of a glyph }		kObjectEdge						= 2;				{ point is in the middle of an embedded object }{ values for the inFeature parameter in WEFeatureFlag }		weFAutoScroll 					= 0;				{ automatically scroll the selection range into view }		weFAutoIdle						= 1;				{ automatically blink the caret (Carbon only) }		weFOutlineHilite 				= 2;				{ frame selection when deactivated }		weFReadOnly 					= 5;				{ disallow modifications }		weFUndo 						= 6;				{ support WEUndo }		weFIntCutAndPaste 				= 7;				{ use intelligent cut-and-paste rules }		weFDragAndDrop 					= 8;				{ support drag-and-drop text editing }		weFInhibitRecal 				= 9;				{ don't recalculate line starts and don't redraw text }		weFUseTempMem 					= 10;				{ use temporary memory for main data structures }		weFDrawOffscreen 				= 11;				{ draw text offscreen for smoother visual results }		weFInhibitRedraw 				= 12;				{ don't redraw text }		weFMonoStyled					= 13;				{ disallow style changes }		weFMultipleUndo					= 14;				{ enable multiple undo/redo }		weFLeftMarginClick				= 16;				{ enable single-click selection of lines }		weFNoKeyboardSync				= 29;				{ disable automatic font/keyboard synchronization }		weFInhibitICSupport				= 30;				{ don't process command-clicks with Internet Config }		weFInhibitColor 				= 31;				{ draw in black & white only }{ values for the inOptions parameter in WENew }		weDoAutoScroll 					= $00000001;		weDoAutoIdle					= $00000002;		weDoOutlineHilite 				= $00000004;		weDoReadOnly 					= $00000020;		weDoUndo 						= $00000040;		weDoIntCutAndPaste 				= $00000080;		weDoDragAndDrop 				= $00000100;		weDoInhibitRecal 				= $00000200;		weDoUseTempMem 					= $00000400;		weDoDrawOffscreen 				= $00000800;		weDoInhibitRedraw				= $00001000;		weDoMonoStyled					= $00002000;		weDoMultipleUndo				= $00004000;		weDoLeftMarginClick				= $00010000;		weDoNoKeyboardSync				= $20000000;		weDoInhibitICSupport			= $40000000;		weDoInhibitColor				= $80000000;{ values for the inAction parameter in WEFeatureFlag }		weBitToggle 					= -2;				{ toggles the specified feature }		weBitTest 						= -1;				{ returns the current setting of the specified feature }		weBitClear 						= 0;				{ disables the specified feature }		weBitSet 						= 1;				{ enables the specified feature }{ values for the inCase parameter in WEChangeCase }		weLowerCase 					= 0;				{ lowercase text }		weUpperCase 					= 1;				{ uppercase text }{ additional values for the WETSMHiliteStyle data type }{ the basic values for this can be found in <AERegistry.h>: kRawText, kSelectedRawText, etc. }		weRedWigglyUnderline			= 29303;			{ ('rw') red wiggly underline commonly used to mark misspelled words }		weGreenWigglyUnderline			= 26487;			{ ('gw') green wiggly underline commonly used to mark syntax/grammar errors }		weOrangeWigglyUnderline			= 28535;			{ ('ow') orange wiggly underline }{ values for the inMatchOptions parameter in WEFind }		weFindWholeWords				= $00000001;		{ match whole words only }		weFindCaseInsensitive			= $00000002;		{ ignore case differences }		weFindDiacriticalInsensitive	= $00000004;		{ ignore diacritical marks }{ values for the inPutOptions parameter in WEPut }		wePutIntCutAndPaste				= $00000001;		{ apply intelligent cut & paste rules }		wePutAddToTypingSequence		= $00000002;		{ add text to existing typing sequence instead of pushing a new action }		wePutDetectUnicodeBOM			= $00000200;		{ detect Unicode byte-order mark }{ values for the inStreamOptions parameter in WEStreamRange }		weStreamDestinationKindMask		= $000000FF;		{ the low byte in inStreamOptions is passed on to }															{ the inDestinationKind parameter of object streaming handlers }															{ (valid option for the kTypeSoup and kTypeStyleScrap flavor types) }		weStreamIncludeObjects			= $00000100;		{ include descriptions of embedded objects }															{ (valid option for the kTypeStyleScrap flavor type) }{ values for the inCopyOptions parameters in WECopyToScrap }		weCopyPromiseFlavors			= $00000001;		{ install a promise keeper but don't actually copy data to scrap just yet }{ values for the inGetOptions parameter in WEGetTextRangeAsUnicode }		weGetAddUnicodeBOM				= $00000200;		{ prepend a Unicode byte-order mark to the text stream }		weGetLittleEndian				= $00000400;		{ use little-endian (Intel) byte-order }{ values for the inSaveOptions parameter in WESave }		weSaveAddResources				= $00000001;		{ save formatting resources to the resource fork }		weSaveCompatibilityResources	= $00000002;		{ save additional resources (styl, FISH, SOUP) for compatibility with TextEdit and WASTE 1.x }		weSaveLittleEndian				= $00000004;		{ use little-endian (Intel) byte-order (only significant for 'utxt' files) }{ WASTE creator }{ Pass this value in the propertyCreator parameter of SetMenuItemProperty to set values of attributes to be processed by WASTE. }{ For example, if you have a Font menu, call SetMenuItemProperty passing kWASTECreator in propertyCreator, weTagFontFamily in }{ propertyTag, and the correct font family number in properyData. Later, when the user selects an item in the Font menu, you }{ can call WEProcessHICommand and WASTE will extract the correct attribute tag and value and change the selection accordingly. }		kWASTECreator					= 'OEDE';{ selectors for WESetAttributes, WEGetAttributes, WEMatchAttributes, etc. }{ character-level attributes: font, size, colors, basic styles }		weTagFontFamily					= 'font';			{ font family number (FMFontFamily) }		weTagFontSize					= 'ptsz';			{ font size (Fixed) }		weTagPlain						= 'plan';			{ plain text (Boolean) }		weTagBold						= 'bold';			{ bold (Boolean) }		weTagItalic						= 'ital';			{ italic (Boolean) }		weTagUnderline					= 'undl';			{ underline (Boolean) }		weTagOutline					= 'outl';			{ outline (Boolean) }		weTagShadow						= 'shad';			{ shadow (Boolean) }		weTagCondensed					= 'cond';			{ condensed (Boolean) }		weTagExtended					= 'pexp';			{ extended (Boolean) }		weTagStrikethrough				= 'strk';			{ strikethrough (Boolean) }		weTagAllCaps					= 'alcp';			{ all caps (Boolean) }		weTagAllLowercase				= 'lowc';			{ all lowercase (Boolean) }		weTagHidden						= 'hidn';			{ hidden (Boolean) }		weTagTextColor					= 'colr';			{ text color (RGBColor) }		weTagBackgroundColor			= 'pbcl';			{ background color (RGBColor) }		weTagTransferMode				= 'pptm';			{ QuickDraw text transfer mode (SInt16) }		weTagVerticalShift				= 'xshf';			{ vertical shift (Fixed) }		weTagLanguage					= 'lang';			{ language tag (TEXT) }{ character-level attributes: additional styles -- these are used for RTF roundtripping but not currently rendered }		weTagUnderlineStyle				= 'unds';			{ underline style (enumeration; can be one of deft/word/dubl/thck/etc.) }		weTagSmallCaps					= 'smcp';			{ small caps (Boolean) }		weTagDoubleStrikethrough		= 'dstr';			{ double strikethrough (Boolean) }		weTagEmbossed					= 'embo';			{ embossed (Boolean) }		weTagEngraved					= 'engr';			{ engraved (Boolean) }{ paragraph-level attributes: alignment, direction, line spacing, indents, tabs and borders }		weTagAlignment					= 'pjst';			{ alignment (enumeration; can be one of deft/left/cent/rght/full) }		weTagDirection					= 'LDIR';			{ primary line direction (enumeration; can be one of deft/L->R/R->L) }		weTagLineSpacing				= 'ledg';			{ line spacing (WELineSpacing) }		weTagLeftIndent					= 'lein';			{ left indent (Fixed) }		weTagRightIndent				= 'riin';			{ right indent (Fixed) }		weTagFirstLineIndent			= 'fidt';			{ first line indent (Fixed) }		weTagSpaceBefore				= 'spbe';			{ space before (Fixed) }		weTagSpaceAfter					= 'spaf';			{ space after (Fixed) }		weTagTabList					= 'tabs';			{ tab list (WETabList) }		weTagBottomBorderStyle			= 'BBRD';			{ bottom border style (enumeration; can be one of NONE/SLDL/DTDL/THKL) }{ paragraph-level attributes: pagination control and other flags -- for future use }		weTagKeepTogether				= 'keep'; 			{ keep lines together on the same page (Boolean) }		weTagKeepWithNext				= 'kepn'; 			{ keep this paragraph with the next one on the same page (Boolean) }		weTagPageBreakBefore			= 'pbrb'; 			{ this paragraph starts a new page (Boolean) }		weTagWidowOrphanOverride		= 'wdov'; 			{ override document-wide widow/orphan control (Boolean) }		weTagWidowOrphanControl			= 'wido'; 			{ enable or disable widow/orphan control for this paragraph only (Boolean) }		weTagNoLineNumbering			= '!ln#'; 			{ disable document-wide line number for this paragraph only (Boolean) }		weTagNoHyphenation				= '!hyp'; 			{ disable automatic hyphenation for this paragraph only (Boolean) }		weTagParagraphUserData			= 'pusr'; 			{ user-defined data (SInt32) }{ the following meta-selectors are only valid in calls to WESetAttributes/WESetOneAttribute }		weTagForceFontFamily			= 'ffnt';			{ like weTagFontFamily, but may change text encoding }		weTagAddFontSize				= '+siz';			{ like weTagFontSize, but value is added rather than replaced }		weTagAddVerticalShift			= '+shf';			{ like weTagVerticalShift, but value is added rather than replaced }		weTagAddLeftIndent				= '+lei';			{ like weTagLeftIndent, but value is added rather than replaced }		weTagAddRightIndent				= '+rii';			{ like weTagRightIndent, but value is added rather than replaced }		weTagAddFirstLineIndent			= '+fid';			{ like weTagFirstLineIndent, but value is added rather than replaced }		weTagAddSpaceBefore				= '+spb';			{ like weTagSpaceBefore, but value is added rather than replaced }		weTagAddSpaceAfter				= '+spa';			{ like weTagSpaceAfter, but value is added rather than replaced }		weTagAddLineSpacing				= '+led';			{ add this to line spacing (Fixed) }{ selectors for read-only selectors, only valid in calls to WEGetAttributes/WEGetOneAttribute }		weTagTextEncoding				= 'ptxe';			{ text encoding }		weTagQDStyles					= 'qdst';			{ QuickDraw styles (Style) }		weTagTETextStyle				= 'tets';			{ TextEdit-compatible TextStyle record }		weTagRunDirection				= 'rdir';			{ true if character at specified offset belongs to a right-to-left script (Boolean) }{ underline style selectors (use in conjunction with weTagUnderlineStyle) }		weTagUnderlineDefault			= 'deft';		weTagUnderlineWord				= 'word';		weTagUnderlineDouble			= 'dubl';		weTagUnderlineThick				= 'thck';		weTagUnderlineDash				= '-   ';		weTagUnderlineDot				= '.   ';		weTagUnderlineDotDash			= '.-  ';		weTagUnderlineDotDotDash		= '..- ';		weTagUnderlineWave				= 'wave';{ alignment selectors (use in conjunction with weTagAlignment) }		weTagAlignmentDefault			= 'deft';		weTagAlignmentLeft				= 'left';		weTagAlignmentCenter			= 'cent';		weTagAlignmentRight				= 'rght';		weTagAlignmentFull				= 'full';		weTagAlignmentDecimal			= 'decm';{ direction selectors (use in conjunction with weTagDirection) }		weTagDirectionDefault			= 'deft';		weTagDirectionLeftToRight		= 'L->R';		weTagDirectionRightToLeft		= 'R->L';{ tab leader selectors (use in conjunction with weTagTabList) }		weTagLeaderNone					= 'NONE';		weTagLeaderDots					= 'DOTS';		weTagLeaderHyphens				= 'HYPH';		weTagLeaderUnderline			= 'UNDL';		weTagLeaderThickLine			= 'THKL';		weTagLeaderEqualSigns			= '=   ';{ border style selectors (use in conjunction with weTagBottomBorderStyle) }		weTagBorderStyleNone			= 'NONE';		weTagBorderStyleThin			= 'SLDL';		weTagBorderStyleDotted			= 'DTDL';		weTagBorderStyleThick			= 'THKL';{ line spacing mode selectors (possible values of the mode field of a WELineSpacing structure) }		weTagLineSpacingAbsolute		= 'abso';			{ use specified value }		weTagLineSpacingAtLeast			= 'atle';			{ use specified value or height of tallest character, whichever is greater }		weTagLineSpacingRelative		= 'rele';			{ multiple of natural height (0.0 = single spacing; 1.0 = double spacing; etc.) }{ commonly used values for the line spacing attribute (these are only significant when mode == weTagLineSpacingRelative) }		weLineSpacingSingle				= $00000000;		weLineSpacingOneAndHalf			= $00008000;		weLineSpacingDouble				= $00010000;{ values for WEGetInfo and WESetInfo selector parameter }		weAutoScrollDelay				= 'ausd';			{ for use by the click loop callback (in ticks; Carbon only) }		weBusyProc						= 'busy';			{ callback invoked during lengthy operations }		weBusyInterval					= 'bzin';			{ minimum interval between calls to the busy proc (in ticks) }		weCharByteHook 					= 'cbyt';			{ CharByte hook }		weCharToPixelHook 				= 'c2p ';			{ CharToPixel hook }		weCharTypeHook 					= 'ctyp';			{ CharType hook }		weClickLoop 					= 'clik';			{ click loop callback }		weCurrentDrag 					= 'drag';			{ drag currently being tracked from WEClick }		weDrawTextHook 					= 'draw';			{ text drawing hook }		weDrawTSMHiliteHook				= 'dtsm';			{ hook for drawing Text Services Manager underlines }		weEraseHook						= 'eras';			{ background erasing hook }		weFontFamilyToNameHook			= 'ff2n';			{ hook for mapping font family numbers to font names }		weFontNameToFamilyHook			= 'fn2f';			{ hook for mapping font names to font family numbers }		weFluxProc						= 'flux';			{ flux callback }		weHiliteDropAreaHook 			= 'hidr';			{ drop area highlighting hook }		weLineBreakHook 				= 'lbrk';			{ line breaking hook }		wePixelToCharHook 				= 'p2c ';			{ PixelToChar hook }		wePort 							= 'port';			{ graphics port }		wePreTrackDragHook				= 'ptrk';			{ pre-TrackDrag hook }		weRefCon 						= 'refc';			{ reference constant for use by application }		weScrollProc 					= 'scrl';			{ scroll callback }		weText 							= 'text';			{ handle to the raw text }		weTranslateDragHook 			= 'xdrg';			{ drag translation callback }		weTranslucencyThreshold			= 'tluc';			{ area threshold for translucent drags }		weTSMDocumentID 				= 'tsmd';			{ Text Services Manager document ID }		weTSMPreUpdate 					= 'pre ';			{ Text Services Manager pre-update callback }		weTSMPostUpdate 				= 'post';			{ Text Services Manager post-update callback }		weUndoProc						= 'undo';			{ undo notification proc }		weURLHint 						= 'urlh';			{ URL hint string for Internet Config }		weWordBreakHook 				= 'wbrk';			{ word breaking hook }{ values for the inHandlerSelector parameter in WEInstallObjectHandler }		weNewHandler 					= 'new ';			{ new handler }		weDisposeHandler 				= 'free';			{ dispose handler }		weDrawHandler 					= 'draw';			{ draw handler }		weClickHandler 					= 'clik';			{ click handler }		weStreamHandler 				= 'strm';			{ stream handler }		weHoverHandler					= 'hovr';			{ hover handler }{ selectors for the inRequestedType parameter in WEStreamRange }		kTypeText						= 'TEXT';			{ raw text }		kTypeStyles						= 'styl';			{ TextEdit-compatibile style scrap }		kTypeSoup						= 'SOUP';			{ "soup" of embedded objects }		kTypeFontTable					= 'FISH';			{ font table }		kTypeParaFormat					= 'WEpf';			{ WASTE 2.0 paragraph formatting }		kTypeRulerScrap					= 'WEru';			{ WASTE 2.0 ruler table }		kTypeCharFormat					= 'WEcf';			{ WASTE 2.0 character formatting }		kTypeStyleScrap					= 'WEst';			{ WASTE 2.0 style table }		kTypeUnicodeText				= 'utxt';			{ raw text in UTF-16 Unicode }		kTypeUTF8Text					= 'UTF8';			{ raw text in UTF-8 Unicode }		kTypeStyledText					= 'STXT';			{ AppleScript-style styled text }		kTypeRTF						= 'RTF ';			{ RTF (Rich Text Format) }		kTypeRTFD						= 'RTFD';			{ RTF with external attachments }{ action kinds }		weAKNone 						= 0;				{ null action }		weAKUnspecified 				= 1;				{ action of unspecified nature }		weAKTyping 						= 2;				{ some text has been typed in }		weAKCut 						= 3;				{ the selection range has been cut }		weAKPaste 						= 4;				{ something has been pasted }		weAKClear 						= 5;				{ the selection range has been deleted }		weAKDrag 						= 6;				{ drag and drop operation }		weAKSetStyle 					= 7;				{ some style has been applied to a text range }		weAKSetRuler					= 8;				{ some ruler has been applied to a text range }		weAKBackspace					= 9;				{ text deleted by backspace }		weAKFwdDelete					= 10;				{ text deleted by forward delete }		weAKCaseChange					= 11;				{ case transformation }		weAKObjectChange				= 12;				{ an embedded object was resized }										{ values above 1023 are free for use by client applications }{ undo events passed to undo callback }		weUndoNewAction					= 0;				{ a new action is about to be pushed onto the undo or redo stack }		weUndoNewSubAction				= 1;				{ a new action is about to be added to an open sequence }		weUndoBeginSequence				= 2;				{ an action sequence is starting }{ standard destination kinds passed to object streaming handlers }		weToScrap						= 0;				{ called from WECopy to copy object to the desk scrap }		weToDrag						= 1;				{ called from WEClick to copy object to a drag }		weToSoup						= 2;				{ called to create a private SOUP for internal use (e.g., for undo/redo) }										{ values above 127 are free for use by client applications }{ mouse actions passed to object "hover" handlers }		weMouseEnter					= 0;				{ mouse has entered object frame }		weMouseWithin					= 1;				{ mouse is still within object frame }		weMouseLeave					= 2;				{ mouse has exited object frame }{ busy actions passed to busy callback }		weBusyRecalBreaks				= 0;				{ busy recalculating line breaks }{ document property tag (these are currently only used by the RTF I/O module) }		weCreatorDocumentInfo			= 'Info';			{ creator for the following property tags }		weTagDocumentTitle				= 'Titl';		weTagDocumentSubject			= 'Subj';		weTagDocumentAuthor				= 'Auth';		weTagDocumentManager			= 'Mngr';		weTagDocumentCompany			= 'Cmpy';		weTagDocumentCategory			= 'Ctgy';		weTagDocumentKeywords			= 'Keyw';		weTagDocumentComments			= 'Cmnt';		weTagDocumentOperator			= 'Oper';		weTagDocumentBaseAddress		= 'Hlnk';		weTagPageInfo					= 'Page';		weTagMacPrintRecord				= 'PRec';{ kCurrentSelection is a meta-value that can be passed to some calls, }{ like WEStreamRange and WEGetHiliteRgn, to signify "use current selection range" }		kCurrentSelection			= -1;{ kNullStyle is a meta-value that can be passed to WEGetAttributes / WEGetOneAttribute }{ to retrieve the "null" style (the style that would be applied to the next typed character) }		kNullStyle					= -2;{ kMaxTabCount is the maximum number of tabs that can be set for each paragraph }		kMaxTabCount				= 20;{ kMaxLanguageTagSize is the maximum length of a language tag }		kMaxLanguageTagSize			= 32;	TYPE{ WASTE data types }		WEReference = Ptr;		WEObjectReference = Ptr;		WEPrintSession = Ptr;		WEActionReference = Ptr;		WESoupHandle = Handle;		WEFontTableHandle = Handle;		WEActionKind = INTEGER;		WEAlignment = SignedByte;		WEDirection = INTEGER;		WEEdge = SignedByte;		WEStyleMode = UNSIGNEDWORD;		WERulerMode = UNSIGNEDLONG;		WESelector = FourCharCode;		WETSMHiliteStyle = INTEGER;{ array and pointer-to-array types for attribute selector calls (Pascal only) }		WESelectorArray = ARRAY[0..0] OF WESelector;		WESelectorArrayPtr = ^WESelectorArray;		WEValueArray = ARRAY[0..0] OF Ptr;		WEValueArrayPtr = ^WEValueArray;		WEValueSizeArray = ARRAY[0..0] OF ByteCount;		WEValueSizeArrayPtr = ^WEValueSizeArray;		WEBooleanArray = ARRAY[0..0] OF BOOLEAN;		WEBooleanArrayPtr = ^WEBooleanArray;{ array and pointer-to-array types for WEPut and WECopyToScrap (Pascal only) }		WEFlavorArray = ARRAY[0..0] OF FlavorType;		WEFlavorArrayPtr = ^WEFlavorArray;		WEHandleArray = ARRAY[0..0] OF Handle;		WEHandleArrayPtr = ^WEHandleArray;		WERunInfo = RECORD				runStart: LONGINT;					{ byte offset to first character of style run }				runEnd: LONGINT;					{ byte offset past last character of style run }				runHeight: INTEGER;					{ line height (ascent + descent + leading) }				runAscent: INTEGER;					{ font ascent }				runStyle: TextStyle;				{ text attributes }				runObject: WEObjectReference;		{ either NIL or reference to embedded object }			END;  { WERunInfo }		WERuler = RECORD				alignment: SignedByte;				{ alignment }				direction: SignedByte;				{ primary line direction }				reserved1: UNSIGNEDBYTE;			{ reserved for future use }				bottomBorderStyle: UNSIGNEDBYTE;	{ bottom border style }				leftIndent: Fixed;					{ left margin (in fixed points) }				rightIndent: Fixed;					{ right margin (in fixed points) }				firstLineIndent: Fixed;				{ first line indent (in fixed points) }				lineSpacing: Fixed;					{ space between lines (0.0 = normal; 1.0 = double; etc.) }				spaceBefore: Fixed;					{ space before paragraph (in fixed points) }				spaceAfter: Fixed;					{ space after paragraph (in fixed points) }				reserved2: ARRAY[1..57] OF LONGINT;	{ reserved for future use }			END;  { WERuler }		WEParaInfo = RECORD				paraStart: LONGINT;					{ byte offset to first character of paragraph run }				paraEnd: LONGINT;					{ byte offset to last character of paragraph run }				paraRuler: WERuler;					{ ruler associated with this paragraph run }			END;  { WEParaInfo }		WEPrintOptions = RECORD				pageRect: Rect;						{ destination rectangle for printing }				firstPageOffset: INTEGER;			{ pixel height of area to be left blank at top of first page }				reserved: ARRAY[0..26] OF INTEGER;	{ reserved for future use: set to zero! }			END;  { WEPrintOptions }{ the first parameter to a 'new' embedded object handler is declared as a (Point *) for compatibility }{ with older versions of WASTE, but is really a (WEObjectPlacement *) starting from WASTE 2.1a5 }{ if the value of the objectBaseline field is set to a nonzero value, WASTE will place the bottom }{ of the bounding rectangle of the object below (negative value) or above (positive value) the text baseline }		WEObjectPlacement = RECORD				objectHeight: INTEGER;				{ height of embedded object }				objectWidth: INTEGER;				{ width of embedded object }				objectBaseline: INTEGER;			{ baseline (intrinsic vertical shift) of embedded object }			END;  { WEObjectPlacement }		WEObjectPlacementPtr = ^WEObjectPlacement;{ WELineSpacing is used in conjunction with the weTagLineSpacing attribute }		WELineSpacing = RECORD				mode: WESelector;					{ one of weTagLineSpacingRelative (default), weTagLineSpacingAbsolute or weTagLineSpacingAtLeast }				value: Fixed;						{ absolute line height or multiplier (0.0 = auto) }			END;  { WELineSpacing }{ WETab describes a single tab stop in a paragraph }		WETab = RECORD				tabIndent: Fixed;					{ indent from the left side of the destination rectangle }				tabAlignment: WESelector;			{ alignment (left, center, right or decimal); only left currently supported }				tabLeader: WESelector;				{ leader }			END;  { WETab }{ WETabList describes the array of tabs associated with a paragraph }		WETabList = RECORD				tabCount: ItemCount;				{ actual number of valid tabs in this structure (0 to kMaxTabCount) }				tabArray: ARRAY[0..kMaxTabCount - 1] OF WETab;			END;{ WASTE callbacks: prototypes }		WEClickLoopProcPtr = FUNCTION (			inWE: WEReference): BOOLEAN;		WEScrollProcPtr = PROCEDURE (			inWE: WEReference);		WETSMPreUpdateProcPtr = PROCEDURE (		inWE: WEReference);		WETSMPostUpdateProcPtr = PROCEDURE (	inWE: WEReference;												inFixLength: LONGINT;												inInputAreaStart: LONGINT;												inInputAreaEnd: LONGINT;												inPinRangeStart: LONGINT;												inPinRangeEnd: LONGINT);		WEPreTrackDragProcPtr = FUNCTION (		inDrag: DragRef;												inWE: WEReference): OSErr;		WETranslateDragProcPtr = FUNCTION (		inDrag: DragRef;												inDragItem: DragItemRef;												inRequestedType: FlavorType;												outData: Handle;												inDropOffset: LONGINT;												inWE: WEReference): OSErr;		WEHiliteDropAreaProcPtr = FUNCTION (	inDrag: DragRef;												inHiliteFlag: BOOLEAN;												inWE: WEReference): OSErr;		WEFontIDToNameProcPtr = FUNCTION (		inFontID: INTEGER;												VAR ioFontName: Str255): OSErr;		WEFontNameToIDProcPtr = FUNCTION (		CONST inFontName: Str255;												inOldFontID: INTEGER;												VAR outNewFontID: INTEGER): OSErr;		WEBusyProcPtr = FUNCTION (				inBusyAction: INTEGER;												CONST inPercentDone: Float32;												inWE: WEReference): OSErr;		WEDrawTextProcPtr = PROCEDURE (			inTextPtr: Ptr;												inTextLength: LONGINT;												inSlop: Fixed;												inStyleRunPosition: JustStyleCode;												inWE: WEReference);		WEDrawTSMHiliteProcPtr = PROCEDURE (	CONST inSegmentRect: Rect;												inHiliteStyle: WETSMHiliteStyle;												inWE: WEReference);		WEPixelToCharProcPtr = FUNCTION (		inTextPtr: Ptr;												inTextLength: LONGINT;												inSlop: Fixed;												VAR ioPixelWidth: Fixed;												VAR outEdge: WEEdge;												inStyleRunPosition: JustStyleCode;												inHorizontalPosition: Fixed;												inWE: WEReference): LONGINT;		WECharToPixelProcPtr = FUNCTION (		inTextPtr: Ptr;												inTextLength: LONGINT;												inSlop: Fixed;												inOffset: LONGINT;												inDirection: INTEGER;												inStyleRunPosition: JustStyleCode;												inHorizontalOffset: INTEGER;												inWE: WEReference): INTEGER;		WELineBreakProcPtr = FUNCTION (			inTextPtr: Ptr;												inTextLength: LONGINT;												inTextStart: LONGINT;												inTextEnd: LONGINT;												VAR ioTextWidth: Fixed;												VAR ioTextOffset: LONGINT;												inWE: WEReference): StyledLineBreakCode;		WEWordBreakProcPtr = PROCEDURE (		inTextPtr: Ptr;												inTextLength: INTEGER;												inOffset: INTEGER;												inEdge: WEEdge;												VAR outBreakOffsets: OffsetTable;												inScript: ScriptCode;												inWE: WEReference);		WECharByteProcPtr = FUNCTION (			inTextPtr: Ptr;												inTextOffset: INTEGER;												inScript: ScriptCode;												inWE: WEReference): INTEGER;		WECharTypeProcPtr = FUNCTION (			inTextPtr: Ptr;												inTextOffset: INTEGER;												inScript: ScriptCode;												inWE: WEReference): INTEGER;		WEEraseProcPtr = PROCEDURE (			CONST inDirtyRect: Rect;												inWE: WEReference);		WEFluxProcPtr = PROCEDURE (				inOffset: LONGINT;												inDelta: LONGINT;												inWE: WEReference);		WENewObjectProcPtr = FUNCTION (			VAR outNaturalObjectSize: Point;												inObject: WEObjectReference): OSErr;		WEDisposeObjectProcPtr = FUNCTION (		inObject: WEObjectReference): OSErr;		WEDrawObjectProcPtr = FUNCTION (		CONST inDestRect: Rect;												inObject: WEObjectReference): OSErr;		WEClickObjectProcPtr = FUNCTION (		inHitPoint: Point;												inModifiers: EventModifiers;												inClickTime: UNSIGNEDLONG;												inObject: WEObjectReference): BOOLEAN;		WEStreamObjectProcPtr = FUNCTION (		inDestinationKind: INTEGER;												VAR outStreamedFlavorType: FlavorType;												outStreamedData: Handle;												inObject: WEObjectReference): OSErr;		WEHoverObjectProcPtr = FUNCTION (		inMouseAction: INTEGER;												inMouseLoc: Point;												inMouseRgn: RgnHandle;												inObject: WEObjectReference): OSErr;		WEUndoProcPtr = FUNCTION (				inUndoEvent: INTEGER;												inAction: WEActionReference): OSErr;{ WASTE callbacks: UPP types }		WEClickLoopUPP = UniversalProcPtr;		WEScrollUPP = UniversalProcPtr;		WETSMPreUpdateUPP = UniversalProcPtr;		WETSMPostUpdateUPP = UniversalProcPtr;		WEPreTrackDragUPP = UniversalProcPtr;		WETranslateDragUPP = UniversalProcPtr;		WEHiliteDropAreaUPP = UniversalProcPtr;		WEFontIDToNameUPP = UniversalProcPtr;		WEFontNameToIDUPP = UniversalProcPtr;		WEBusyUPP = UniversalProcPtr;		WEDrawTextUPP = UniversalProcPtr;		WEDrawTSMHiliteUPP = UniversalProcPtr;		WEPixelToCharUPP = UniversalProcPtr;		WECharToPixelUPP = UniversalProcPtr;		WELineBreakUPP = UniversalProcPtr;		WEWordBreakUPP = UniversalProcPtr;		WECharByteUPP = UniversalProcPtr;		WECharTypeUPP = UniversalProcPtr;		WEEraseUPP = UniversalProcPtr;		WEFluxUPP = UniversalProcPtr;		WENewObjectUPP = UniversalProcPtr;		WEDisposeObjectUPP = UniversalProcPtr;		WEDrawObjectUPP = UniversalProcPtr;		WEClickObjectUPP = UniversalProcPtr;		WEStreamObjectUPP = UniversalProcPtr;		WEHoverObjectUPP = UniversalProcPtr;		WEUndoUPP = UniversalProcPtr;{ WASTE PUBLIC CALLS }{ getting the shared library version number }	FUNCTION WEVersion: UNSIGNEDLONG;{ creating UPPs for callback functions }	FUNCTION NewWEClickLoopUPP (			inUserRoutine: WEClickLoopProcPtr): WEClickLoopUPP;	FUNCTION NewWEScrollUPP (				inUserRoutine: WEScrollProcPtr): WEScrollUPP;	FUNCTION NewWETSMPreUpdateUPP (			inUserRoutine: WETSMPreUpdateProcPtr): WETSMPreUpdateUPP;	FUNCTION NewWETSMPostUpdateUPP (		inUserRoutine: WETSMPostUpdateProcPtr): WETSMPostUpdateUPP;	FUNCTION NewWEPreTrackDragUPP (			inUserRoutine: WEPreTrackDragProcPtr): WEPreTrackDragUPP;	FUNCTION NewWETranslateDragUPP (		inUserRoutine: WETranslateDragProcPtr): WETranslateDragUPP;	FUNCTION NewWEHiliteDropAreaUPP (		inUserRoutine: WEHiliteDropAreaProcPtr): WEHiliteDropAreaUPP;	FUNCTION NewWEFontIDToNameUPP (			inUserRoutine: WEFontIDToNameProcPtr): WEFontIDToNameUPP;	FUNCTION NewWEFontNameToIDUPP (			inUserRoutine: WEFontNameToIDProcPtr): WEFontNameToIDUPP;	FUNCTION NewWEBusyUPP (					inUserRoutine: WEBusyProcPtr): WEBusyUPP;	FUNCTION NewWEDrawTextUPP (				inUserRoutine: WEDrawTextProcPtr): WEDrawTextUPP;	FUNCTION NewWEDrawTSMHiliteUPP (		inUserRoutine: WEDrawTSMHiliteProcPtr): WEDrawTSMHiliteUPP;	FUNCTION NewWEPixelToCharUPP (			inUserRoutine: WEPixelToCharProcPtr): WEPixelToCharUPP;	FUNCTION NewWECharToPixelUPP (			inUserRoutine: WECharToPixelProcPtr): WECharToPixelUPP;	FUNCTION NewWELineBreakUPP (			inUserRoutine: WELineBreakProcPtr): WELineBreakUPP;	FUNCTION NewWEWordBreakUPP (			inUserRoutine: WEWordBreakProcPtr): WEWordBreakUPP;	FUNCTION NewWECharByteUPP (				inUserRoutine: WECharByteProcPtr): WECharByteUPP;	FUNCTION NewWECharTypeUPP (				inUserRoutine: WECharTypeProcPtr): WECharTypeUPP;	FUNCTION NewWEEraseUPP (				inUserRoutine: WEEraseProcPtr): WEEraseUPP;	FUNCTION NewWEFluxUPP (					inUserRoutine: WEFluxProcPtr): WEFluxUPP;	FUNCTION NewWENewObjectUPP (			inUserRoutine: WENewObjectProcPtr): WENewObjectUPP;	FUNCTION NewWEDisposeObjectUPP (		inUserRoutine: WEDisposeObjectProcPtr): WEDisposeObjectUPP;	FUNCTION NewWEDrawObjectUPP (			inUserRoutine: WEDrawObjectProcPtr): WEDrawObjectUPP;	FUNCTION NewWEClickObjectUPP (			inUserRoutine: WEClickObjectProcPtr): WEClickObjectUPP;	FUNCTION NewWEStreamObjectUPP (			inUserRoutine: WEStreamObjectProcPtr): WEStreamObjectUPP;		FUNCTION NewWEHoverObjectUPP (			inUserRoutine: WEHoverObjectProcPtr): WEHoverObjectUPP;	FUNCTION NewWEUndoUPP (					inUserRoutine: WEUndoProcPtr): WEUndoUPP;{ destroying UPPs for callback functions }	PROCEDURE DisposeWEClickLoopUPP (		inUPP: WEClickLoopUPP);	PROCEDURE DisposeWEScrollUPP (			inUPP: WEScrollUPP);	PROCEDURE DisposeWETSMPreUpdateUPP (	inUPP: WETSMPreUpdateUPP);	PROCEDURE DisposeWETSMPostUpdateUPP (	inUPP: WETSMPostUpdateUPP);	PROCEDURE DisposeWEPreTrackDragUPP (	inUPP: WEPreTrackDragUPP);	PROCEDURE DisposeWETranslateDragUPP (	inUPP: WETranslateDragUPP);	PROCEDURE DisposeWEHiliteDropAreaUPP (	inUPP: WEHiliteDropAreaUPP);	PROCEDURE DisposeWEFontIDToNameUPP (	inUPP: WEFontIDToNameUPP);	PROCEDURE DisposeWEFontNameToIDUPP (	inUPP: WEFontNameToIDUPP);		PROCEDURE DisposeWEBusyUPP (			inUPP: WEBusyUPP);	PROCEDURE DisposeWEDrawTextUPP (		inUPP: WEDrawTextUPP);	PROCEDURE DisposeWEDrawTSMHiliteUPP (	inUPP: WEDrawTSMHiliteUPP);	PROCEDURE DisposeWEPixelToCharUPP (		inUPP: WEPixelToCharUPP);	PROCEDURE DisposeWECharToPixelUPP (		inUPP: WECharToPixelUPP);	PROCEDURE DisposeWELineBreakUPP (		inUPP: WELineBreakUPP);	PROCEDURE DisposeWEWordBreakUPP (		inUPP: WEWordBreakUPP);	PROCEDURE DisposeWECharByteUPP (		inUPP: WECharByteUPP);	PROCEDURE DisposeWECharTypeUPP (		inUPP: WECharTypeUPP);	PROCEDURE DisposeWEEraseUPP (			inUPP: WEEraseUPP);	PROCEDURE DisposeWEFluxUPP (			inUPP: WEFluxUPP);	PROCEDURE DisposeWENewObjectUPP (		inUPP: WENewObjectUPP);	PROCEDURE DisposeWEDisposeObjectUPP (	inUPP: WEDisposeObjectUPP);	PROCEDURE DisposeWEDrawObjectUPP (		inUPP: WEDrawObjectUPP);	PROCEDURE DisposeWEClickObjectUPP (		inUPP: WEClickObjectUPP);	PROCEDURE DisposeWEStreamObjectUPP (	inUPP: WEStreamObjectUPP);	PROCEDURE DisposeWEHoverObjectUPP (		inUPP: WEHoverObjectUPP);	PROCEDURE DisposeWEUndoUPP (			inUPP: WEUndoUPP);{ invoking WASTE callback functions through UPPs }	FUNCTION InvokeWEClickLoopUPP (			inWE: WEReference;											inUPP: WEClickLoopUPP): BOOLEAN;	PROCEDURE InvokeWEScrollUPP (			inWE: WEReference;											inUPP: WEScrollUPP);	PROCEDURE InvokeWETSMPreUpdateUPP (		inWE: WEReference;											inUPP: WETSMPreUpdateUPP);	PROCEDURE InvokeWETSMPostUpdateUPP (	inWE: WEReference;											inFixLength: LONGINT;											inInputAreaStart: LONGINT;											inInputAreaEnd: LONGINT;											inPinRangeStart: LONGINT;											inPinRangeEnd: LONGINT;											inUPP: WETSMPostUpdateUPP);	FUNCTION InvokeWEPreTrackDragUPP (		inDrag: DragRef;											inWE: WEReference;											inUPP: WEPreTrackDragUPP): OSErr;	FUNCTION InvokeWETranslateDragUPP (		inDrag: DragRef;											inDragItem: DragItemRef;											inRequestedType: FlavorType;											outData: Handle;											inDropOffset: LONGINT;											inWE: WEReference;											inUPP: WETranslateDragUPP): OSErr;	FUNCTION InvokeWEHiliteDropAreaUPP (	inDrag: DragRef;											inHiliteFlag: BOOLEAN;											inWE: WEReference;											inUPP: WEHiliteDropAreaUPP): OSErr;	FUNCTION InvokeWEFontIDToNameUPP (		inFontID: INTEGER;											VAR ioFontName: Str255;											inUPP: WEFontIDToNameUPP): OSErr;	FUNCTION InvokeWEFontNameToIDUPP (		CONST inFontName: Str255;											inOldFontID: INTEGER;											VAR outNewFontID: INTEGER;											inUPP: WEFontNameToIDUPP): OSErr;	FUNCTION InvokeWEBusyUPP (				inBusyAction: INTEGER;											CONST inPercentDone: Float32;											inWE: WEReference;											inUPP: WEBusyUPP): OSErr;	PROCEDURE InvokeWEDrawTextUPP (			inTextPtr: Ptr;											inTextLength: LONGINT;											inSlop: Fixed;											inStyleRunPosition: JustStyleCode;											inWE: WEReference;											inUPP: WEDrawTextUPP);	PROCEDURE InvokeWEDrawTSMHiliteUPP (	CONST inSegmentRect: Rect;											inHiliteStyle: WETSMHiliteStyle;											inWE: WEReference;											inUPP: WEDrawTSMHiliteUPP);	FUNCTION InvokeWEPixelToCharUPP (		inTextPtr: Ptr;											inTextLength: LONGINT;											inSlop: Fixed;											VAR ioPixelWidth: Fixed;											VAR outEdge: SignedByte;											inStyleRunPosition: JustStyleCode;											inHorizontalPosition: Fixed;											inWE: WEReference;											inUPP: WEPixelToCharUPP): LONGINT;	FUNCTION InvokeWECharToPixelUPP (		inTextPtr: Ptr;											inTextLength: LONGINT;											inSlop: Fixed;											inOffset: LONGINT;											inDirection: INTEGER;											inStyleRunPosition: JustStyleCode;											inHorizontalPosition: INTEGER;											inWE: WEReference;											inUPP: WECharToPixelUPP): INTEGER;	FUNCTION InvokeWELineBreakUPP (			inTextPtr: Ptr;											inTextLength: LONGINT;											inTextStart: LONGINT;											inTextEnd: LONGINT;											VAR ioTextWidth: Fixed;											VAR ioTextOffset: LONGINT;											inWE: WEReference;											inUPP: WELineBreakUPP): StyledLineBreakCode;	PROCEDURE InvokeWEWordBreakUPP (		inTextPtr: Ptr;											inTextLength: INTEGER;											inOffset: INTEGER;											inEdge: SignedByte;											VAR outBreakOffsets: OffsetTable;											inScript: ScriptCode;											inWE: WEReference;											inUPP: WEWordBreakUPP);	FUNCTION InvokeWECharByteUPP (			inTextPtr: Ptr;											inTextOffset: INTEGER;											inScript: ScriptCode;											inWE: WEReference;											inUPP: WECharByteUPP): INTEGER;	FUNCTION InvokeWECharTypeUPP (			inTextPtr: Ptr;											inTextOffset: INTEGER;											inScript: ScriptCode;											inWE: WEReference;											inUPP: WECharTypeUPP): INTEGER;	PROCEDURE InvokeWEEraseUPP (			CONST inDirtyRect: Rect;											inWE: WEReference;											inUPP: WEEraseUPP);	PROCEDURE InvokeWEFluxUPP (				inOffset: LONGINT;											inDelta: LONGINT;											inWE: WEReference;											inUPP: WEFluxUPP);	FUNCTION InvokeWENewObjectUPP (			VAR outNaturalObjectSize: Point;											inObject: WEObjectReference;											inUPP: WENewObjectUPP): OSErr;	FUNCTION InvokeWEDisposeObjectUPP (		inObject: WEObjectReference;											inUPP: WEDisposeObjectUPP): OSErr;	FUNCTION InvokeWEDrawObjectUPP (		CONST inDestRect: Rect;											inObject: WEObjectReference;											inUPP: WEDrawObjectUPP): OSErr;	FUNCTION InvokeWEClickObjectUPP (		inHitPoint: Point;											inModifiers: EventModifiers;											inClickTime: UNSIGNEDLONG;											inObject: WEObjectReference;											inUPP: WEClickObjectUPP): BOOLEAN;	FUNCTION InvokeWEStreamObjectUPP (		inDestinationKind: INTEGER;											VAR outStreamedFlavorType: FlavorType;											outStreamedData: Handle;											inObject: WEObjectReference;											inUPP: WEStreamObjectUPP): OSErr;	FUNCTION InvokeWEHoverObjectUPP (		inMouseAction: INTEGER;											inMouseLoc: Point;											inMouseRgn: RgnHandle;											inObject: WEObjectReference;											inUPP: WEHoverObjectUPP): OSErr;	FUNCTION InvokeWEUndoUPP (				inUndoEvent: INTEGER;											inAction: WEActionReference;											inUPP: WEUndoUPP): OSErr;{ creation and destruction }	FUNCTION WENew (						CONST inDestRect: LongRect;											CONST inViewRect: LongRect;											inOptions: OptionBits;											VAR outWE: WEReference): OSErr;	PROCEDURE WEDispose (					inWE: WEReference);{ getting variables }	FUNCTION WEGetText (					inWE: WEReference): Handle;	FUNCTION WEGetChar (					inOffset: LONGINT;											inWE: WEReference): CHAR;	FUNCTION WEGetTextLength (				inWE: WEReference): LONGINT;	PROCEDURE WEGetSelection (				VAR outSelStart: LONGINT;											VAR outSelEnd: LONGINT;											inWE: WEReference);	FUNCTION WEGetSelectionAnchor (			inWE: WEReference): LONGINT;	PROCEDURE WEGetDestRect (				VAR outDestRect: LongRect;											inWE: WEReference);	PROCEDURE WEGetViewRect (				VAR outViewRect: LongRect;											inWE: WEReference);	FUNCTION WEIsActive (					inWE: WEReference): BOOLEAN;	FUNCTION WEGetClickCount (				inWE: WEReference): INTEGER;	FUNCTION WEGetDefaultTabWidth (			inWE: WEReference): Fixed;	PROCEDURE WESetDefaultTabWidth (		inDefaultTabWidth: Fixed;											inWE: WEReference);{ setting variables }	PROCEDURE WESetSelection (				inSelStart: LONGINT;											inSelEnd: LONGINT;											inWE: WEReference);	PROCEDURE WESetDestRect (				CONST inDestRect: LongRect;											inWE: WEReference);	PROCEDURE WESetViewRect (				CONST inViewRect: LongRect;											inWE: WEReference);{ getting style attributes }	FUNCTION WEGetAttributes (				inOffset: LONGINT;											inAttributeCount: ItemCount;											inAttributeSelectors: WESelectorArrayPtr;											outAttributeValues: WEValueArrayPtr;											inAttributeValueSize: WEValueSizeArrayPtr;											inWE: WEReference): OSErr;	FUNCTION WEGetOneAttribute (			inOffset: LONGINT;											inAttributeSelector: WESelector;											outAttributeValue: Ptr;											inAttributeValueSize: ByteCount;											inWE: WEReference): OSErr;{ determining which style attributes are continuous over the selection range }	FUNCTION WEContinuousStyle (			VAR ioMode: WEStyleMode;											VAR outTextStyle: TextStyle;											inWE: WEReference): BOOLEAN;{ determining which paragraph attributes are continuous over the selection range }	FUNCTION WEContinuousRuler (			VAR ioMode: WERulerMode;											VAR outRuler: WERuler;											inWE: WEReference): BOOLEAN;{ matching attributes over a text range against an arbitrary set of values }	FUNCTION WEMatchAttributes (			inRangeStart: LONGINT;											inRangeEnd: LONGINT;											inAttributeSelector: WESelector;											inAttributeValueSize: ByteCount;											inArraySize: ItemCount;											inValueArray: Ptr;											outWhichValuesArePresent: WEBooleanArrayPtr;											VAR outIsContinuous: BOOLEAN;											inWE: WEReference): OSErr;{ low-level access to style run information }	FUNCTION WECountRuns (					inWE: WEReference): LONGINT;	FUNCTION WEOffsetToRun (				inOffset: LONGINT;											inWE: WEReference): LONGINT;	PROCEDURE WEGetRunRange (				inStyleRunIndex: LONGINT;											VAR outStyleRunStart: LONGINT;											VAR outStyleRunEnd: LONGINT;											inWE: WEReference);	PROCEDURE WEGetRunInfo (				inOffset: LONGINT;											VAR outRunInfo: WERunInfo;											inWE: WEReference);	PROCEDURE WEGetIndRunInfo (				inStyleRunIndex: LONGINT;											VAR outRunInfo: WERunInfo;											inWE: WEReference);	FUNCTION WEGetRunDirection (			inOffset: LONGINT;											inWE: WEReference): BOOLEAN;{ low-level access to paragraph run information }	FUNCTION WECountParaRuns (				inWE: WEReference): LONGINT;	FUNCTION WEOffsetToParaRun (			inOffset: LONGINT;											inWE: WEReference): LONGINT;	PROCEDURE WEGetParaRunRange (			inParagraphRunIndex: LONGINT;											VAR outParagraphRunStart: LONGINT;											VAR ourParagraphRunEnd: LONGINT;											inWE: WEReference);	PROCEDURE WEGetParaInfo (				inOffset: LONGINT;											VAR outParagraphRunInfo: WEParaInfo;											inWE: WEReference);	PROCEDURE WEGetIndParaInfo (			inParagraphRunIndex: LONGINT;											VAR outParagraphRunInfo: WEParaInfo;											inWE: WEReference);{ access to line layout information }	FUNCTION WECountLines (					inWE: WEReference): LONGINT;	FUNCTION WEOffsetToLine (				inOffset: LONGINT;											inWE: WEReference): LONGINT;	PROCEDURE WEGetLineRange (				inLineIndex: LONGINT;											VAR outLineStart: LONGINT;											VAR outLineEnd: LONGINT;											inWE: WEReference);	FUNCTION WEGetHeight (					inStartLine: LONGINT;											inEndLine: LONGINT;											inWE: WEReference): LONGINT;	FUNCTION WEGetLineAscent (				inLineIndex: LONGINT;											inWE: WEReference): INTEGER;{ converting byte offsets to screen positions and vice versa }	FUNCTION WEGetOffset (					CONST inPoint: LongPt;											VAR outEdge: SignedByte;											inWE: WEReference): LONGINT;	PROCEDURE WEGetPoint (					inOffset: LONGINT;											inDirection: INTEGER;											VAR outPoint: LongPt;											VAR outLineHeight: INTEGER;											inWE: WEReference);{ finding words, lines and paragraphs }	PROCEDURE WEFindWord (					inOffset: LONGINT;											inEdge: WEEdge;											VAR outWordStart: LONGINT;											VAR outWordEnd: LONGINT;											inWE: WEReference);	PROCEDURE WEFindLine (					inOffset: LONGINT;											inEdge: SignedByte;											VAR outLineStart: LONGINT;											VAR outLineEnd: LONGINT;											inWE: WEReference);	PROCEDURE WEFindParagraph (				inOffset: LONGINT;											inEdge: WEEdge;											VAR outParagraphStart: LONGINT;											VAR outParagraphEnd: LONGINT;											inWE: WEReference);{ matching strings }	FUNCTION WEFind (						inKey: Ptr;											inKeyLength: LONGINT;											inKeyEncoding: TextEncoding;											inMatchOptions: OptionBits;											inRangeStart: LONGINT;											inRangeEnd: LONGINT;											VAR outMatchStart: LONGINT;											VAR outMatchEnd: LONGINT;											inWE: WEReference): OSErr;{ making a copy of a text range }	FUNCTION WEStreamRange (				inRangeStart: LONGINT;											inRangeEnd: LONGINT;											inRequestedType: FlavorType;											inStreamOptions: OptionBits;											outData: Handle;											inWE: WEReference): OSErr;	FUNCTION WECopyRange (					inRangeStart: LONGINT;											inRangeEnd: LONGINT;											outText: Handle;											outStyles: StScrpHandle;											outSoup: WESoupHandle;											inWE: WEReference): OSErr;	FUNCTION WEGetTextRangeAsUnicode (		inRangeStart: LONGINT;											inRangeEnd: LONGINT;											outUnicodeText: Handle;											ioCharFormat: Handle;											ioParaFormat: Handle;											inUnicodeVariant: TextEncodingVariant;											inTransformationFormat: TextEncodingFormat;											inGetOptions: OptionBits;											inWE: WEReference): OSErr;{ getting and setting the alignment style }	FUNCTION WEGetAlignment (				inWE: WEReference): WEAlignment;	PROCEDURE WESetAlignment (				inAlignment: WEAlignment;											inWE: WEReference);{ getting and setting the primary line direction }	FUNCTION WEGetDirection (				inWE: WEReference): WEDirection;	PROCEDURE WESetDirection (				inDirection: WEDirection;											inWE: WEReference);{ recalculating line breaks, drawing and scrolling }	FUNCTION WECalText (					inWE: WEReference): OSErr;	PROCEDURE WEUpdate (					inUpdateRgn: RgnHandle;											inWE: WEReference);	PROCEDURE WEScroll (					inHorizontalOffset: LONGINT;											inVerticalOffset: LONGINT;											inWE: WEReference);	PROCEDURE WEPinScroll (					inHorizontalOffset: LONGINT;											inVerticalOffset: LONGINT;											inWE: WEReference);	PROCEDURE WESelView (					inWE: WEReference);{ handling activate/deactivate events }	PROCEDURE WEActivate (					inWE: WEReference);	PROCEDURE WEDeactivate (				inWE: WEReference);{ handling key-down events }	PROCEDURE WEKey (						inKey: CHAR;											inModifiers: EventModifiers;											inWE: WEReference);{ handling mouse-down events and mouse tracking }	PROCEDURE WEClick (						inHitPoint: Point;											inModifiers: EventModifiers;											inClickTime: UNSIGNEDLONG;											inWE: WEReference);{ processing HI commands (Carbon only) }	FUNCTION WEProcessHICommand (			CONST inHICommand: HICommand;											inWE: WEReference): OSStatus;{ adjusting the cursor shape }	FUNCTION WEAdjustCursor (				inMouseLoc: Point;											ioMouseRgn: RgnHandle;											inWE: WEReference): BOOLEAN;{ blinking the caret (not needed in Carbon if you set the weFAutoIdle flag) }	PROCEDURE WEIdle (						VAR outMaxSleep: LONGINT;											inWE: WEReference);{ modifying the text and the styles }	FUNCTION WEInsert (						inTextPtr: Ptr;											inTextLength: LONGINT;											inStyles: StScrpHandle;											inSoup: WESoupHandle;											inWE: WEReference): OSErr;	FUNCTION WEInsertFormattedText (		inTextPtr: Ptr;											inTextLength: LONGINT;											inStyles: StScrpHandle;											inSoup: WESoupHandle;											inParaFormat: Handle;											inRulerScrap: Handle;											inWE: WEReference): OSErr;	FUNCTION WEPut (						inRangeStart: LONGINT;											inRangeEnd: LONGINT;											inTextPtr: Ptr;											inTextLength: LONGINT;											inTextEncoding: TextEncoding;											inPutOptions: OptionBits;											inFlavorCount: ItemCount;											inFlavorTypes: WEFlavorArrayPtr;											inFlavorHandles: WEHandleArrayPtr;											inWE: WEReference): OSErr;	FUNCTION WEDelete (						inWE: WEReference): OSErr;	FUNCTION WEUseText (					inText: Handle;											inWE: WEReference): OSErr;	FUNCTION WEChangeCase (					inCase: INTEGER;											inWE: WEReference): OSErr;{ modifying text attributes }	FUNCTION WESetAttributes (				inRangeStart: LONGINT;											inRangeEnd: LONGINT;											inAttributeCount: ItemCount;											inAttributeSelectors: WESelectorArrayPtr;											inAttributeValues: WEValueArrayPtr;											inAttributeValueSizes: WEValueSizeArrayPtr;											inWE: WEReference): OSErr;	FUNCTION WESetOneAttribute (			inRangeStart: LONGINT;											inRangeEnd: LONGINT;											inAttributeSelector: WESelector;											inAttributeValue: Ptr;											inAttributeValueSize: ByteCount;											inWE: WEReference): OSErr;	FUNCTION WESetStyle (					inMode: WEStyleMode;											CONST inTextStyle: TextStyle;											inWE: WEReference): OSErr;	FUNCTION WESetRuler (					inMode: WERulerMode;											CONST inRuler: WERuler;											inWE: WEReference): OSErr;	FUNCTION WEUseStyleScrap (				inStyles: StScrpHandle;											inWE: WEReference): OSErr;{ undo }	FUNCTION WEUndo (						inWE: WEReference): OSErr;	FUNCTION WERedo (						inWE: WEReference): OSErr;	PROCEDURE WEClearUndo (					inWE: WEReference);	FUNCTION WEGetUndoInfo (				VAR outRedoFlag: BOOLEAN;											inWE: WEReference): WEActionKind;	FUNCTION WEGetIndUndoInfo (				inUndoLevel: LONGINT;											inWE: WEReference): WEActionKind;	FUNCTION WEIsTyping (					inWE: WEReference): BOOLEAN;	FUNCTION WEBeginAction (				inWE: WEReference): OSErr;	FUNCTION WEEndAction (					inActionKind: WEActionKind;											inWE: WEReference): OSErr;{ undo action accessors }	FUNCTION WEGetActionKind (				inAction: WEActionReference): WEActionKind;	FUNCTION WEActionIsRedo (				inAction: WEActionReference): Boolean;	FUNCTION WEGetActionOwner (				inAction: WEActionReference): WEReference;{ keeping track of changes }	FUNCTION WEGetModCount (				inWE: WEReference): UNSIGNEDLONG;	PROCEDURE WEResetModCount (				inWE: WEReference);{ embedded objects }	FUNCTION WEInstallObjectHandler (		inObjectType: FlavorType;											inHandlerSelector: WESelector;											inHandler: UniversalProcPtr;											inWE: WEReference): OSErr;	FUNCTION WEInstallStandardObjectHandlers ( inObjectType: FlavorType;											inWE: WEReference): OSErr;	FUNCTION WERemoveObjectHandler (		inObjectType: FlavorType;											inHandlerSelector: WESelector;											inHandler: UniversalProcPtr;											inWE: WEReference): OSErr;	FUNCTION WERemoveStandardObjectHandlers ( inObjectType: FlavorType;											inWE: WEReference): OSErr;	FUNCTION WEGetObjectHandler (			inObjectType: FlavorType;											inHandlerSelector: WESelector;											VAR outHandler: UniversalProcPtr;											inWE: WEReference): OSErr;	FUNCTION WEInsertObject (				inObjectType: FlavorType;											inObjectDataHandle: Handle;											inObjectSize: Point;											inWE: WEReference): OSErr;	FUNCTION WEGetSelectedObject (			VAR outObject: WEObjectReference;											inWE: WEReference): OSErr;	FUNCTION WEGetObjectAtOffset (			inOffset: LONGINT;											VAR outObject: WEObjectReference;											inWE: WEReference): OSErr;	FUNCTION WEFindNextObject (				inOffset: LONGINT;											VAR outObject: WEObjectReference;											inWE: WEReference): LONGINT;	FUNCTION WEFindPreviousObject (			inOffset: LONGINT;											VAR outObject: WEObjectReference;											inWE: WEReference): LONGINT;	FUNCTION WEUseSoup (					inSoup: WESoupHandle;											inWE: WEReference): OSErr;{ accessing embedded object attributes }	FUNCTION WEGetObjectType (				inObject: WEObjectReference): FlavorType;	FUNCTION WEGetObjectDataHandle (		inObject: WEObjectReference): Handle;	FUNCTION WEGetObjectOwner (				inObject: WEObjectReference): WEReference;	FUNCTION WEGetObjectOffset (			inObject: WEObjectReference): LONGINT;	FUNCTION WEGetObjectSize (				inObject: WEObjectReference): Point;	FUNCTION WESetObjectSize (				inObject: WEObjectReference;											inObjectSize: Point): OSErr;	FUNCTION WEGetObjectFrame (				inObject: WEObjectReference;											VAR outObjectFrame: LongRect): OSErr;	FUNCTION WEGetObjectRefCon (			inObject: WEObjectReference): LONGINT;	PROCEDURE WESetObjectRefCon (			inObject: WEObjectReference;											inRefCon: LONGINT);	FUNCTION WEGetObjectProperty (			inObject: WEObjectReference;											inPropertyCreator: OSType;											inPropertyTag: OSType;											inPropertySize: ByteCount;											VAR outActualSize: ByteCount;											outPropertyBuffer: UNIV Ptr): OSStatus;	FUNCTION WESetObjectProperty (			inObject: WEObjectReference;											inPropertyCreator: OSType;											inPropertyTag: OSType;											inPropertySize: ByteCount;											inPropertyBuffer: UNIV Ptr): OSStatus;	FUNCTION WERemoveObjectProperty (		inObject: WEObjectReference;											inPropertyCreator: OSType;											inPropertyTag: OSType): OSStatus;{ Clipboard operations }	FUNCTION WECut (						inWE: WEReference): OSErr;	FUNCTION WECopy (						inWE: WEReference): OSErr;	FUNCTION WECopyToScrap (				inScrap: ScrapRef;											inScrapFlavors: WEFlavorArrayPtr;											inCopyOptions: OptionBits;											inWE: WEReference): OSStatus;	FUNCTION WEPaste (						inWE: WEReference): OSErr;	FUNCTION WEPasteFromScrap (				inScrap: ScrapRef;											inPasteOptions: OptionBits;											inWE: WEReference): OSStatus;	FUNCTION WECanPaste (					inWE: WEReference): BOOLEAN;{ Drag Manager support }	FUNCTION WEGetHiliteRgn (				inRangeStart: LONGINT;											inRangeEnd: LONGINT;											inWE: WEReference): RgnHandle;	FUNCTION WETrackDrag (					inMessage: DragTrackingMessage;											inDrag: DragRef;											inWE: WEReference): OSErr;	FUNCTION WEReceiveDrag (				inDrag: DragRef;											inWE: WEReference): OSErr;	FUNCTION WECanAcceptDrag (				inDrag: DragRef;											inWE: WEReference): BOOLEAN;	FUNCTION WEDraggedToTrash (				inDrag: DragRef): BOOLEAN;{ font tables }	FUNCTION WEBuildFontTable (				outFontTable: WEFontTableHandle;											inFontIDToNameProc: WEFontIDToNameUPP;											inWE: WEReference): OSErr;	FUNCTION WEUpdateFontTable (			ioFontTable: WEFontTableHandle;											inFontNameToIDProc: WEFontNameToIDUPP;											VAR outWasChanged: BOOLEAN): OSErr;	FUNCTION WEUpdateStyleScrap (			ioStyles: StScrpHandle;											inFontTable: WEFontTableHandle): OSErr;{ Script Manager utilities }	FUNCTION WECharByte (					inOffset: LONGINT;											inWE: WEReference): INTEGER;	FUNCTION WECharType (					inOffset: LONGINT;											inWE: WEReference): INTEGER;{ Text Services Manager support }	FUNCTION WEInstallTSMHandlers: OSErr;	FUNCTION WERemoveTSMHandlers: OSErr;	FUNCTION WEHandleTSMEvent (				CONST inAppleEvent: AppleEvent;											VAR ioReply: AppleEvent): OSErr;	PROCEDURE WEStopInlineSession (			inWE: WEReference);	FUNCTION WESetTSMHilite (				inRangeStart: LONGINT;											inRangeEnd: LONGINT;											inTSMHiliteStyle: WETSMHiliteStyle;											inWE: WEReference): OSStatus;{ printing support }	FUNCTION WENewPrintSession (			CONST inPrintOptions: WEPrintOptions;											inWE: WEReference;											VAR outPrintSession: WEPrintSession): OSErr;	PROCEDURE WEDisposePrintSession (		inPrintSession: WEPrintSession);	FUNCTION WECountPages (					inPrintSession: WEPrintSession): LONGINT;	FUNCTION WEGetPageHeight (				inPageIndex: LONGINT;											inPrintSession: WEPrintSession): LONGINT;	FUNCTION WEPrintPage (					inPageIndex: LONGINT;											inPrintPort: GrafPtr;											inPageRect: RectPtr;											inPrintSession: WEPrintSession): OSErr;{ filing (Mac OS 9.1 and later) }	FUNCTION WESave (						inRangeStart: LONGINT;											inRangeEnd: LONGINT;											inFileFormat: OSType;											inTextEncoding: TextEncoding;											inSaveOptions: OptionBits;											inWE: WEReference): OSStatus;	FUNCTION WELoad (						inRangeStart: LONGINT;											inRangeEnd: LONGINT;											VAR ioFileFormat: OSType;											VAR ioTextEncoding: TextEncoding;											VAR ioLoadOptions: OptionBits;											inWE: WEReference): OSStatus;{ additional features }	FUNCTION WEFeatureFlag (				inFeature: INTEGER;											inAction: INTEGER;											inWE: WEReference): INTEGER;	FUNCTION WEGetInfo (					inSelector: WESelector;											outInfo: UNIV Ptr;											inWE: WEReference): OSErr;	FUNCTION WESetInfo (					inSelector: WESelector;											inInfo: UNIV Ptr;											inWE: WEReference): OSErr;{ getting and setting user-defined info }	FUNCTION WEGetUserInfo (				inUserTag: WESelector;											VAR outUserInfo: LONGINT;											inWE: WEReference): OSErr;	FUNCTION WESetUserInfo (				inUserTag: WESelector;											inUserInfo: LONGINT;											inWE: WEReference): OSErr;	FUNCTION WERemoveUserInfo (				inUserTag: WESelector;											inWE: WEReference): OSErr;	FUNCTION WEGetProperty (				inPropertyCreator: OSType;											inPropertyTag: OSType;											inPropertySize: ByteCount;											VAR outActualSize: ByteCount;											outPropertyBuffer: UNIV Ptr;											inWE: WEReference): OSStatus;	FUNCTION WESetProperty (				inPropertyCreator: OSType;											inPropertyTag: OSType;											inPropertySize: ByteCount;											inPropertyBuffer: UNIV Ptr;											inWE: WEReference): OSStatus;	FUNCTION WERemoveProperty (				inPropertyCreator: OSType;											inPropertyTag: OSType;											inWE: WEReference): OSStatus;{ long coordinates utility routines }	PROCEDURE WELongPointToPoint (			CONST inLongPoint: LongPt;											VAR outPoint: Point);	PROCEDURE WEPointToLongPoint (			inPoint: Point;											VAR outLongPoint: LongPt);	PROCEDURE WESetLongRect (				VAR outLongRect: LongRect;											inLeft: LONGINT;											inTop: LONGINT;											inRight: LONGINT;											inBottom: LONGINT);	PROCEDURE WELongRectToRect (			CONST inLongRect: LongRect;											VAR outRect: Rect);	PROCEDURE WERectToLongRect (			CONST inRect: Rect;											VAR outLongRect: LongRect);	PROCEDURE WEOffsetLongRect (			VAR ioLongRect: LongRect;											inHorizontalOffset: LONGINT;											inVerticalOffset: LONGINT);	FUNCTION WELongPointInLongRect (		CONST inLongPoint: LongPt;											CONST inLongRect: LongRect): BOOLEAN;{$ALIGN RESET}{$POP}IMPLEMENTATIONEND.