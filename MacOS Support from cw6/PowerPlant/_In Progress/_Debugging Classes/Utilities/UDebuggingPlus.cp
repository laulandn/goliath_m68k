// ===========================================================================//	UDebuggingPlus.cp			PowerPlant 2.1		©1997-1999 Metrowerks Inc.// ===========================================================================//	Original Author: John C. Daub////	Utility functions for debugging.////	Based upon UDebugging.cp, this file acts as a replacement implementation//	for UDebugging.cp (they both implement the UDebugging class and share//	the same header file)... akin to how UDesktop.cp and UFloatingDesktop.cp//	work. Ensure that EITHER UDebugging.cp and "PP DebugAlerts.rsrc" OR//	UDebuggingPlus.cp and "PP Debug Support.rsrc" are in your project.////	The traditional UDebugging.cp and "PP DebugAlerts.rsrc" display the//	nature of the signal/throw, filename, line number... and then only//	the ability to acknowledge and dismiss the dialog. This isn't always//	enough functionality.////	This version offers some additional flexibility in the signal/throw//	dialogs (coupled with the new versions of those 'ALRT' resources in//	"PP Debug Support.rsrc"). In addition to the original functionality:////		Continue	-	(default, same as "OK" in the original). Just//						acknowledge the dialog and continue along.////		Quit		-	Terminate the application immediately (through ETS).////		Debugger	-	Breaks into a debugger, if one is installed, else//						terminates.////		Quiet		-	Sets gDebugSignal or gDebugThrow to debugAction_Nothing.//						Good for situations where a great many dialogs might//						be raised and you wish to quiet the dialogs (and you//						can't get to the LDebugMenuAttachment since you are//						in a modal dialog!). You can reset gDebugSignal/Throw//						through LDebugMenuAttachment.////		Log			-	Appends the debugging information into a log file//						via LDebugStream//#ifdef PowerPlant_PCH	#include PowerPlant_PCH#endif#include <UDebugUtils.h>#include <LDebugStream.h>#include <Dialogs.h>#include <Processes.h>PP_Begin_Namespace_PowerPlant	// Global variables for specifying the action to take for	// a Throw and a SignalEDebugAction	UDebugging::gDebugThrow		= debugAction_Nothing;EDebugAction	UDebugging::gDebugSignal	= debugAction_Nothing;	// The debug alertsconst	ResIDT	ALRT_ThrowAt				=	251;const	ResIDT	ALRT_SignalAt				=	252;// The item numbers in the debug alerts. Signal and Throw dialogs// share the same numbersconst	SInt16	ALRT_ThrowAtContinue		=	1;const	SInt16	ALRT_ThrowAtQuit			=	4;const	SInt16	ALRT_ThrowAtDebugger		=	5;const	SInt16	ALRT_ThrowAtQuiet			=	6;const	SInt16	ALRT_ThrowAtLog				=	7;namespace UDebugging {	unsigned char*	LoadPStrFromCStr(							Str255			outPStr,							const char*		inCStr);}// ---------------------------------------------------------------------------//	¥ DebugThrow// ---------------------------------------------------------------------------voidUDebugging::DebugThrow(	ExceptionCode		inErr,	ConstStringPtr		inFile,	long				inLine){	unsigned char	errStr[16];	::NumToString(inErr, errStr);	if (gDebugThrow == debugAction_Alert) {		AlertThrowAt(errStr, inFile, inLine);	} else if (gDebugThrow == debugAction_Debugger) {		::DebugStr(errStr);	}	Throw_Err(inErr);}// ---------------------------------------------------------------------------//	¥ DebugThrow// ---------------------------------------------------------------------------voidUDebugging::DebugThrow(	ExceptionCode		inErr,	const char*			inFile,	long				inLine){	unsigned char	errStr[16];	::NumToString(inErr, errStr);	if (gDebugThrow == debugAction_Alert) {		AlertThrowAt(errStr, inFile, inLine);	} else if (gDebugThrow == debugAction_Debugger) {		::DebugStr(errStr);	}	Throw_Err(inErr);}#pragma mark -// ---------------------------------------------------------------------------//	¥ LoadPStrFromCStr// ---------------------------------------------------------------------------//	Copy contents of a C string into a Pascal string////	Returns a pointer to the Pascal stringunsigned char*UDebugging::LoadPStrFromCStr(	Str255			outPStr,	const char*		inCStr){		// Find length of C string by searching for the terminating		// null character. However, don't bother to look past 255		// characters, since that's all that a Pascal string can hold.	unsigned char	strLength = 0;	while ((strLength < 255) && (inCStr[strLength] != '\0')) {		strLength += 1;	}	outPStr[0] = strLength;	::BlockMoveData(inCStr, outPStr + 1, strLength);	return outPStr;}#pragma mark -// ---------------------------------------------------------------------------//	¥ AlertThrowAt// ---------------------------------------------------------------------------//	Display an Alert Box when a Throw occursvoidUDebugging::AlertThrowAt(	ConstStringPtr		inError,		// Pascal string	ConstStringPtr		inFile,			// Pascal string	long				inLine){	Str15	lineStr;	::NumToString(inLine, lineStr);	::ParamText(inError, inFile, lineStr, Str_Empty);	SInt16	button = ::StopAlert(ALRT_ThrowAt, nil);	switch (button) {		case ALRT_ThrowAtContinue:			break;		case ALRT_ThrowAtQuit:			::ExitToShell();			break;		case ALRT_ThrowAtDebugger:				// Perform the explicit check here as calling				// UDebugUtils::Debugger() could create a looping problem				// if no debugger is installed.			if (UDebugUtils::IsADebuggerRunning()) {				::Debugger();			} else {				::ExitToShell();			}			break;		case ALRT_ThrowAtQuiet:			gDebugThrow = debugAction_Nothing;			break;		case ALRT_ThrowAtLog: {			LDebugStream dbgStream(flushLocation_File, false, true);			dbgStream	<< StringLiteral_("EXCEPTION THROWN -")						<< StringLiteral_(" ERROR: ") << inError						<< StringLiteral_(", FILE: ") << inFile						<< StringLiteral_(", LINE: ") << inLine						<< StringLiteral_("\r\r");			dbgStream.Flush();			break;		}	}}// ---------------------------------------------------------------------------//	¥ AlertThrowAt// ---------------------------------------------------------------------------//	Display an Alert Box when a Throw occursvoidUDebugging::AlertThrowAt(	ConstStringPtr		inError,		// Pascal string	const char*			inFile,			// C string	long				inLine){	Str255	fileStr;	AlertThrowAt(inError, LoadPStrFromCStr(fileStr, inFile), inLine);}#pragma mark -// ---------------------------------------------------------------------------//	¥ AlertSignalAt// ---------------------------------------------------------------------------//	Display an Alert Box when a Signal occursvoidUDebugging::AlertSignalAt(	ConstStringPtr		inTestStr,		// Pascal string	ConstStringPtr		inFile,			// Pascal string	long				inLine){	Str15	lineStr;	::NumToString(inLine, lineStr);	::ParamText(inTestStr, inFile, lineStr, Str_Empty);	SInt16 button = ::CautionAlert(ALRT_SignalAt, nil);	switch (button) {		case ALRT_ThrowAtContinue:			break;		case ALRT_ThrowAtQuit:			::ExitToShell();			break;		case ALRT_ThrowAtDebugger:				// Perform the explicit check here as calling				// UDebugUtils::Debugger() could create a looping problem				// if no debugger is installed.			if (UDebugUtils::IsADebuggerRunning()) {				::Debugger();			} else {				::ExitToShell();			}			break;		case ALRT_ThrowAtQuiet:			gDebugSignal = debugAction_Nothing;			break;		case ALRT_ThrowAtLog: {			LDebugStream dbgStream(flushLocation_File, false, true);			dbgStream	<< StringLiteral_("SIGNAL RAISED -")						<< StringLiteral_(" CONDITION: ")	<< inTestStr						<< StringLiteral_(", FILE: ")		<< inFile						<< StringLiteral_(", LINE: ")		<< inLine						<< StringLiteral_("\r\r");			dbgStream.Flush();			break;		}	}}// ---------------------------------------------------------------------------//	¥ AlertSignalAt// ---------------------------------------------------------------------------//	Display an Alert Box when a Signal occursvoidUDebugging::AlertSignalAt(	ConstStringPtr		inTestStr,		// Pascal string	const char*			inFile,			// C string	long				inLine){	Str255	fileStr;	AlertSignalAt(inTestStr,				  LoadPStrFromCStr(fileStr, inFile),				  inLine);}// ---------------------------------------------------------------------------//	¥ AlertSignalAt// ---------------------------------------------------------------------------//	Display an Alert Box when a Signal occursvoidUDebugging::AlertSignalAt(	const char*			inTestStr,		// C string	ConstStringPtr		inFile,			// Pascal string	long				inLine){	Str255	testStr;	AlertSignalAt(LoadPStrFromCStr(testStr, inTestStr),				  inFile,				  inLine);}// ---------------------------------------------------------------------------//	¥ AlertSignalAt// ---------------------------------------------------------------------------//	Display an Alert Box when a Signal occursvoidUDebugging::AlertSignalAt(	const char*			inTestStr,		// C string	const char*			inFile,			// C string	long				inLine){	Str255	testStr;	Str255	fileStr;	AlertSignalAt(LoadPStrFromCStr(testStr, inTestStr),				  LoadPStrFromCStr(fileStr, inFile),				  inLine);}PP_End_Namespace_PowerPlant