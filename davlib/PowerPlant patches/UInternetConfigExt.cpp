/*	UInternetConfigExt.cpp	Copyright (C) 2000 i-drive.com (email: opensource@mail.idrive.com)	This library is free software; you can redistribute it and/or	modify it under the terms of version 2.1 of the GNU Lesser General	Public License as published by the Free Software Foundation.	This library is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU	Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public	License along with this library; if not, write to the Free Software	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA*/#include <UInternetConfigExt.h>using namespace std;map<const string, UInternetConfigExt::CMacType>* UInternetConfigExt::sMimeMacMap = NULL;#if 0map<const UInternetConfigExt::CMacType, string>* UInternetConfigExt::sMacMimeMap = NULL;#endifbool UInternetConfigExt::PP_GetProxy (string& server, SInt32& port){	if (!PP_ICAvailable())		return false;			OSErr		err;	bool		result = false;	Boolean		UsesProxy = false;	long		size;	ICAttr		attr;	char		buffer[257];	// null-terminated pascal string	char		*colon;			size = sizeof (Boolean);	err = ICGetPref (sICInstance, kICUseHTTPProxy, &attr, (Ptr)&UsesProxy, &size);		if (err) goto end;	if (!UsesProxy)		goto end;	size = sizeof (buffer) - 2;	err = ICGetPref (sICInstance, kICHTTPProxyHost, &attr, buffer, &size);				if (err) goto end;	buffer [((unsigned char*)buffer)[0] + 1] = 0;		colon = strrchr (buffer, ':');	port = colon ? atoi (colon+1) : 0;	server.assign (&buffer[1], colon ? colon - buffer - 1 : ((unsigned char*)buffer)[0]);	result = true;	end:	if (!result)		server.clear();	return result;}bool UInternetConfigExt::MapMIMEtoMac (const string& MIMEType, OSType &type, OSType& creator){	if (!PP_ICAvailable())		return false;	GetMimeMap ();	if (sMimeMacMap == NULL)		return false;			map<const string, CMacType>::const_iterator iter = sMimeMacMap->find(MIMEType);		if (iter == sMimeMacMap->end())		return false;			type = iter->second.mType;	creator = iter->second.mCreator;		return true;}string UInternetConfigExt::MapToMIME (OSType fType, OSType fCreator, ConstStr255Param filename){	OSStatus	err;	ICMapEntry	entry;	string		s;		err = PP_ICMapTypeCreator(fType, fCreator, filename, entry);	if (err == noErr)		return string ((char*)entry.MIMEType + 1, entry.MIMEType[0]);			if (filename[0] != 0)	{		err = PP_ICMapFilename (filename, entry);		if (err == noErr && entry.MIMEType[0] > 0)			return string ((char*)entry.MIMEType + 1, entry.MIMEType[0]);	}// Add this just in case, since RealPlayer tends to wreak havoc on the Internet Config file.	if (filename[0] >= 4 && strncmp ((char*)filename + 1 + filename[0] - 4, ".mp3", 4) == 0)		return ("audio/x-mp3");			return ("application/octet-stream");}void UInternetConfigExt::MapToMacType (const string& mimeType, const string& fileName, OSType &fType, OSType &fCreator){	ICMapEntry	entry;	bool hasMime = !mimeType.empty();		fType = '????';	fCreator = '????';			if (mimeType.empty() || mimeType == "application/octet-stream" || MapMIMEtoMac (mimeType, fType, fCreator) == false)	{		Str255	pName;		long start = max (0L, (long)fileName.size() - 255L);		pName [0] = fileName.size() - start;		BlockMoveData (fileName.c_str() + start, pName + 1, pName [0]);				OSStatus icErr = PP_ICMapFilename (pName,  entry);		if (noErr == icErr)		{			fCreator = entry.fileCreator;			fType = entry.fileType;		}	}}#if 0bool UInternetConfigExt::MapMactoMIME (OSType type, OSType creator, string& MIMEType){	if (!PP_ICAvailable())		return false;	GetMimeMap ();	if (sMimeMacMap == NULL)		return false;	map<const CMacType, string>::const_iterator iter;	// Try to find an exact match	iter = sMacMimeMap->find (CMacType(type, creator));// Try to find a match by type only	if (iter != sMacMimeMap->end())		iter = sMacMimeMap->find (CMacType(type, 0));	if (iter != sMacMimeMap->end())		return false;			MIMEType = iter->second;	return true;}#endifvoid UInternetConfigExt::GetMimeMap (void){	OSErr	err = noErr;	Handle	entriesH = NULL;	bool	rebuild;	if (!PP_ICAvailable())		return;	try	{		rebuild = PP_SeedHasChanged();	}	catch (...)	{		return;	}	if (sMimeMacMap != NULL && !rebuild)		return;	if (sMimeMacMap == NULL)		sMimeMacMap = new map<const string, CMacType>;#if 0	if (sMacMimeMap == NULL)		sMacMimeMap = new map<const CMacType, string>;#endif	entriesH = NewHandle (0);	err = PP_ICFindPrefHandle (kICMapping, entriesH);				if (err) goto end;	MoveHHi (entriesH);	HLock (entriesH);	const	ICMapEntry *entry = (ICMapEntry*) *entriesH;	const	ICMapEntry *end = (ICMapEntry*) (*entriesH + GetHandleSize (entriesH));		for (; entry < end; entry = (ICMapEntry*)((char*)entry + getUShort (&entry->totalLength)))	{					long flags = getULong (&entry->flags);				OSType fileType = getULong (&entry->fileType);		OSType creator = getULong (&entry->fileCreator);				const UInt8* mimePtr = getMimePtr (entry);				if (mimePtr[0] == 0)			continue;				string mime ((char*)mimePtr + 1, mimePtr[0]);		const CMacType macType (fileType, creator);		const CMacType genericMacType (fileType);				if (!(flags & kICMapNotIncomingMask))		{			if (sMimeMacMap->find (mime) == sMimeMacMap->end())				 (*sMimeMacMap)[mime] = macType;		}#if 0		if (!(flags & kICMapNotOutgoingMask))		{			if (sMacMimeMap->find (genericMacType) == sMacMimeMap->end())				 (*sMacMimeMap)[genericMacType] = mime;			(*sMacMimeMap)[macType] = mime;		}#endif	}	end:	if (entriesH)		DisposeHandle (entriesH);}unsigned short UInternetConfigExt::getUShort (const void* src){	unsigned char* srcPtr = (unsigned char*)src;	return (srcPtr[0]<<8) | (srcPtr[1]);}unsigned long UInternetConfigExt::getULong (const void* src){	unsigned char* srcPtr = (unsigned char*)src;	return (srcPtr[0]<<24) | (srcPtr[1]<<16) | (srcPtr[2]<<8) | (srcPtr[3]);}const UInt8* UInternetConfigExt::getMimePtr (const ICMapEntry *src){	const UInt8* ptr = (UInt8*) src;	const UInt8* end = ptr + getUShort (&src->totalLength);		ptr += getUShort (&src->fixedLength);	if (ptr > end)	return NULL;	// Step past fixed part	ptr += *ptr + 1;						if (ptr > end)	return NULL;	// Step past extension	ptr += *ptr + 1;						if (ptr > end)	return NULL;	// Step past creator_app	ptr += *ptr + 1;						if (ptr > end)	return NULL;	// Step past post_app		return ptr;}