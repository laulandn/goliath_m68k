/* *	WASTE Demo Project: *	About Box * *	Copyright © 1993-2000 Marco Piovanelli *	All Rights Reserved * *	C port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __WEDEMO__#include "WEDemo.h"#endif#ifndef __ICONS__#include <Icons.h>#endifenum{	kItemScrollPane = 1 ,	kItemWholePane = 2 ,	kItemIcon = 3} ;enum { kScrollStep = 1 } ;enum { kScrollDelay = 2 } ;static pascal void DrawBox ( DialogRef inDialog, SInt16 inItem ){	Rect		textRect ;	Rect		globalRect ;	SInt16		screenDepth = 1 ;	WEReference we = ( WEReference ) GetWRefCon ( GetDialogWindow ( inDialog ) ) ;	//	get text pane rect	GetDialogItemRect ( inDialog, inItem, & textRect ) ;	//	determine screen depth	globalRect = textRect ;	LocalToGlobal ( ( Point * ) & globalRect ) ;	LocalToGlobal ( ( Point * ) & globalRect + 1 ) ;	screenDepth = ( * ( * GetMaxDevice ( & globalRect ) ) -> gdPMap ) -> pixelSize ;	//	draw a border around the scrolling pane (only if enough colors are available)	if ( screenDepth >= 8 )	{		RGBColor white = { 0xFFFF, 0xFFFF, 0xFFFF } ;		RGBColor gray = { 0xAAAA, 0xAAAA, 0xAAAA } ;		RGBColor saveColor ;		GetForeColor ( & saveColor ) ;		InsetRect ( & textRect, -3, -3 ) ;		MoveTo ( textRect . right, textRect . top ) ;		RGBForeColor ( & white ) ;		Line ( 0, textRect . bottom - textRect . top ) ;		Line ( textRect . left - textRect . right, 0 ) ;		RGBForeColor ( & gray ) ;		Line ( 0, textRect . top - textRect . bottom ) ;		Line ( textRect . right - textRect . left, 0 ) ;		InsetRect ( & textRect, 1, 1 ) ;		MoveTo ( textRect . right, textRect . top ) ;		RGBForeColor ( & gray ) ;		Line ( 0, textRect . bottom - textRect . top ) ;		Line ( textRect . left - textRect . right, 0 ) ;		RGBForeColor ( & white ) ;		Line ( 0, textRect . top - textRect . bottom ) ;		Line ( textRect . right - textRect . left, 0 ) ;		RGBForeColor ( & saveColor ) ;	}	//	redraw the text	WEUpdate ( nil, we ) ;}static pascal void DrawBigIcon ( DialogRef inDialog, SInt16 inItem ){	Rect iconRect ;	GetDialogItemRect ( inDialog, inItem, & iconRect ) ;	PlotIconID ( & iconRect, kAlignAbsoluteCenter, kTransformNone, 130 ) ;}void DoAboutBox ( SInt16 dialogID ){	static const unsigned char		placeholderString [ ] = "\p^0" ;	DialogRef						aboutBox = nil ;	WEReference						we = nil ;	WESelector						alignment ;	SInt16							itemHit = 0 ;	Handle							hText ;	Handle							hStyles ;	GrafPtr							savePort ;	LongRect						viewRect ;	LongRect						destRect ;	SInt32							scrollRange ;	SInt32							i ;	UInt32							ticks ;	SInt32							versionOffset ;	Str15							versionString ;	Rect							r ;	static UserItemUPP				sBoxDrawer = nil ;	static UserItemUPP				sIconDrawer = nil ;	if ( sBoxDrawer == nil )	{		sBoxDrawer = NewUserItemProc ( DrawBox ) ;		sIconDrawer = NewUserItemProc ( DrawBigIcon ) ;	}	//	load the dialog	aboutBox = GetNewDialog ( dialogID, nil, kFirstWindowOfClass ) ;	if ( aboutBox == nil )	{		goto cleanup ;	}	//	set up the port	GetPort ( & savePort ) ;	SetPortDialogPort ( aboutBox ) ;	//	get the scrolling pane rect	GetDialogItemRect ( aboutBox, kItemScrollPane, & r ) ;	//	create a WASTE instance for scrolling the text	WERectToLongRect ( & r, & viewRect ) ;	if ( WENew ( & viewRect, & viewRect, 0, & we ) != noErr )	{		goto cleanup ;	}	//	save reference to the WASTE instance in dialog ref con	SetWRefCon ( GetDialogWindow ( aboutBox ), ( SInt32 ) we ) ;	//	set the alignment style to center	alignment = weTagAlignmentCenter ;	WESetOneAttribute ( kCurrentSelection, kCurrentSelection, weTagAlignment,		& alignment, sizeof ( alignment ), we ) ;	//	load the styled text and insert it into the WASTE instance	hText = GetResource ( kTypeText, dialogID ) ;	if ( hText == nil )	{		goto cleanup ;	}	hStyles = GetResource ( kTypeStyles, dialogID ) ;	//	insert the styled text	HLock ( hText ) ;	WEInsert ( * hText, GetHandleSize ( hText ), ( StScrpHandle ) hStyles, nil, we ) ;	HUnlock ( hText ) ;	//	find the offset to the version placeholder (^0)	if ( ( versionOffset = Munger ( hText, 0, placeholderString + 1,		StrLength ( placeholderString ), nil, 0 ) ) >= 0 )	{		//	replace the placeholder with the version string describing		//	the version of WASTELib we're currently using		NumToVersionString ( WEVersion ( ), versionString ) ;		WESetSelection ( versionOffset, versionOffset + StrLength ( placeholderString ), we ) ;		WEInsert ( versionString + 1, StrLength ( versionString ), nil, nil, we ) ;	}	//	make the instance read-only	WEFeatureFlag ( weFReadOnly, weBitSet, we ) ;	//	calculate scroll range	WEGetDestRect ( & destRect, we ) ;	scrollRange = ( destRect . bottom - destRect . top ) - ( viewRect . bottom - viewRect . top ) ;	//	install drawing callbacks	SetDialogItemProc ( aboutBox, kItemScrollPane, sBoxDrawer ) ;	SetDialogItemProc ( aboutBox, kItemIcon, sIconDrawer ) ;	//	show the dialog	ShowWindow ( GetDialogWindow ( aboutBox ) ) ;	//	wait for a click in the picture	ModalDialog ( GetMyStandardDialogFilter ( ), & itemHit ) ;	if ( itemHit == kItemScrollPane )	{		//	start scrolling sequence		for ( i = 0 ; i < scrollRange ; i += kScrollStep )		{			//	scroll the text downward			WEScroll ( 0, - kScrollStep, we ) ;			//	wait some ticks			ticks = TickCount ( ) + kScrollDelay ;			do			{				EventRecord event ;				if ( WaitNextEvent ( mDownMask + keyDownMask, & event, 0, nil ) )				{					i = scrollRange ;					break ;				}			} while ( TickCount ( ) < ticks ) ;		}	}cleanup :	if ( we != nil )	{		WEDispose ( we ) ;	}	if ( aboutBox != nil )	{		DisposeDialog ( aboutBox ) ;		SetPort ( savePort ) ;	}}