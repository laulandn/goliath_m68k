/* *	WASTE Demo Project: *	Navigation Dialogs * *	Copyright © 1993-2002 Marco Piovanelli *	All Rights Reserved * *	Original C Port by John C. Daub * *	<mailto:waste@merzwaren.com> *	<http://www.merzwaren.com/waste/> */#ifndef __WEDEMO__#include "WEDemo.h"#endif/* numbers for custom dialog items in our Save dialog box */enum{	kItemFormatPopup			=	1,	kItemStationeryCheckbox		=	2} ;/* menu items in the format popup menu */enum{	kItemTextFormat				=	1,	kItemUnicodeTextFormat		=	2,	kItemRTF					=	3} ;/* user structure passed to the NavEventFilter callback */typedef struct NavCallbackData{	Document *					document ;	NavEventUPP					eventProc ;	/* the following fields are only used in the Save As dialog */	ControlRef					formatPopup ;	ControlRef					stationeryCheckbox ;	OSType						fileFormat ;	ResID						extraItemsID ;	SInt16						numItems ;	Boolean						isStationery ;	Boolean						closeAfterSaving ;} NavCallbackData ;static OSStatus InitCustomItems ( NavDialogRef inNavDialog, DialogRef inDialog, NavCallbackData * ioCD ){	Handle						extraItems ;	SInt16						popupValue ;	OSStatus					err ;	/* get the DITL resource containing the extra items */	if ( ( extraItems = GetResource ( kTypeDialogItemList, ioCD -> extraItemsID ) ) == NULL )	{		return memFullErr ;	}	DetachResource ( extraItems ) ;	/* add it to the nav dialog control list */	err = NavCustomControl ( inNavDialog, kNavCtlAddControlList, extraItems ) ;	DisposeHandle ( extraItems ) ;	if ( err != noErr )	{		return err ;	}	/* count existing dialog items */	if ( ( err = NavCustomControl ( inNavDialog, kNavCtlGetFirstControlID, & ioCD -> numItems ) ) != noErr )	{		return err ;	}	/* get handles to our custom controls */	if ( ( err = GetDialogItemAsControl ( inDialog, ioCD -> numItems + kItemFormatPopup, & ioCD -> formatPopup ) ) != noErr )	{		return err ;	}	if ( ( err = GetDialogItemAsControl ( inDialog, ioCD -> numItems + kItemStationeryCheckbox, & ioCD -> stationeryCheckbox ) ) != noErr )	{		return err ;	}	/* set up the format popup */	switch ( ioCD -> fileFormat )	{		case kTypeText :			popupValue = 1 ;	break ;		case kTypeUnicodeText :		popupValue = 2 ;	break ;		case kTypeRTF :				popupValue = 3 ;	break ;		default :					return paramErr ;	}	SetControlValue ( ioCD -> formatPopup, popupValue ) ;	return noErr ;}static void HandleClickOnCustomItem ( DialogItemIndex inItemHit, NavCallbackData * ioCD ){	switch ( inItemHit )	{		case kItemFormatPopup :		{			if ( ioCD -> formatPopup )			{				switch ( GetControlValue ( ioCD -> formatPopup ) )				{					case kItemTextFormat :					{						ioCD -> fileFormat = kTypeText ;						break ;					}					case kItemUnicodeTextFormat :					{						ioCD -> fileFormat = kTypeUnicodeText ;						break ;					}					case kItemRTF :					{						ioCD -> fileFormat = kTypeRTF ;						break ;					}				}			}			break ;		}		case kItemStationeryCheckbox :		{			if ( ioCD -> stationeryCheckbox )			{				ioCD -> isStationery = 1 - ioCD -> isStationery ;				SetControlValue ( ioCD -> stationeryCheckbox, ioCD -> isStationery ) ;			}			break ;		}	}}static OSStatus CompleteOpen ( NavDialogRef inNavDialog ){	const ProcessSerialNumber		thisApp = { 0, kCurrentProcess } ;	NavReplyRecord					reply ;	AEDesc							targetDesc ;	AppleEvent						openEvent ;	AppleEvent						replyEvent ;	OSStatus						err ;	BlockZero ( & reply, sizeof ( reply ) ) ;	AEInitializeDescInline ( & targetDesc ) ;	AEInitializeDescInline ( & openEvent ) ;	AEInitializeDescInline ( & replyEvent ) ;	/* get the reply record */	if ( ( err = NavDialogGetReply ( inNavDialog, & reply ) ) != noErr )	{		goto cleanup ;	}	/* make sure the reply is valid */	err = userCanceledErr ;	if ( ! reply . validRecord )	{		goto cleanup ;	}	/* build an open Apple event */	if ( ( err = AECreateDesc ( typeProcessSerialNumber, & thisApp, sizeof ( thisApp ), & targetDesc ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AECreateAppleEvent ( kCoreEventClass, kAEOpenDocuments, & targetDesc, kAutoGenerateReturnID, kAnyTransactionID, & openEvent ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = AEPutParamDesc ( & openEvent, keyDirectObject, & reply . selection ) ) != noErr )	{		goto cleanup ;	}	/* send it */	if ( ( err = AESend ( & openEvent, & replyEvent, kAENoReply | kAEAlwaysInteract, kAENormalPriority, kAEDefaultTimeout, NULL, NULL ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	NavDisposeReply ( & reply ) ;	/* return result code */	return err ;}static OSStatus CompleteSaveAs ( NavDialogRef inNavDialog, NavCallbackData * ioCD ){	NavReplyRecord					reply ;	FSRef							folderRef ;	CFStringRef						fileName = NULL ;	AEKeyword						keyword = 0 ;	DescType						actualType = 0 ;	Size							actualSize = 0 ;	OSStatus						err ;	BlockZero ( & reply, sizeof ( reply ) ) ;	/* get the reply record */	if ( ( err = NavDialogGetReply ( inNavDialog, & reply ) ) != noErr )	{		goto cleanup ;	}	/* make sure the reply is valid */	err = userCanceledErr ;	if ( ! reply . validRecord )	{		goto cleanup ;	}	/* get save file name */	fileName = NavDialogGetSaveFileName ( inNavDialog ) ;	/* get save file location */	if ( ( err = AEGetNthPtr ( & reply . selection, 1, typeFSRef, & keyword, & actualType, & folderRef, sizeof ( folderRef ), & actualSize ) ) != noErr )	{		goto cleanup ;	}	/* save the window to the selected file */	if ( ( err = SaveDocument ( & folderRef, fileName, reply . replacing, ioCD -> fileFormat, ioCD -> isStationery, ioCD -> document ) ) != noErr )	{		goto cleanup ;	}	/* notify Navigation Services we're done with the file */	if ( ( err = NavCompleteSave ( & reply, kNavTranslateInPlace ) ) != noErr )	{		goto cleanup ;	}	/* close the document if necessary */	if ( ioCD -> closeAfterSaving )	{		DestroyDocument ( ioCD -> document ) ;	}	/* clear result code */	err = noErr ;cleanup :	NavDisposeReply ( & reply ) ;	/* return result code */	return err ;}static OSStatus DismissNavDialog ( NavDialogRef inNavDialog, NavCallbackData * ioCD ){	NavUserAction					userAction = NavDialogGetUserAction ( inNavDialog ) ;	OSStatus						err ;	switch ( userAction )	{		case kNavUserActionOpen :		{			if ( ( err = CompleteOpen ( inNavDialog ) ) != noErr )			{				goto cleanup ;			}			break ;		}		case kNavUserActionSaveAs :		{			if ( ( err = CompleteSaveAs ( inNavDialog, ioCD ) ) != noErr )			{				goto cleanup ;			}			break ;		}		case kNavUserActionSaveChanges :		{			if ( ( err = DoSave ( ioCD -> document, true ) ) != noErr )			{				goto cleanup ;			}			break ;		}		case kNavUserActionDontSaveChanges :		{			DestroyDocument ( ioCD -> document ) ;			break ;		}	}	/* clear result code */	err = noErr ;cleanup :	NavDialogDispose ( inNavDialog ) ;	DisposeNavEventUPP ( ioCD -> eventProc ) ;	free ( ioCD ) ;	/* return result code */	return err ;}static pascal void NavEventFilter	(		NavEventCallbackMessage		inSelector,		NavCBRec *					inPB,		void *						inUserData	){	NavCallbackData *				cd = ( NavCallbackData * ) inUserData ;	switch ( inSelector )	{		case kNavCBEvent :		{			const EventRecord * 	event = inPB -> eventData . eventDataParms . event ;			/* intercept clicks in our custom items, if any */			if ( cd && cd -> extraItemsID && ( event -> what == mouseDown ) )			{				HandleClickOnCustomItem ( inPB -> eventData . itemHit - cd -> numItems, cd ) ;			}			break ;		}		case kNavCBCustomize :		{			if ( cd && cd -> extraItemsID )			{				/* get some room for the extra items */				if ( ( inPB -> customRect . right == 0 ) && ( inPB -> customRect . bottom == 0 ) )				{					inPB -> customRect . right = inPB -> customRect . left + 240 ;					inPB -> customRect . bottom = inPB -> customRect . top + 30 ;				}			}			break ;		}		case kNavCBStart :		{			if ( cd && cd -> extraItemsID )			{				/* add custom items to the dialog */				InitCustomItems ( inPB -> context, GetDialogFromWindow ( inPB -> window ), cd ) ;			}			break ;		}		case kNavCBUserAction :		{			if ( cd )			{				DismissNavDialog ( inPB -> context, cd ) ;			}			break ;		}	}}static OSStatus CreateNavTypeList	(		OSType					inApplicationSignature,		UInt16					inNumTypes,		const OSType *			inSFTypeList,		NavTypeListHandle *		outNavTypeList	){	OSStatus	err ;	/* allocate the type list handle */	* outNavTypeList = ( NavTypeListHandle ) NewHandleClear ( ( sizeof ( NavTypeList ) - sizeof ( OSType ) ) +		( inNumTypes * sizeof ( OSType ) ) ) ;	if ( ( err = MemError ( ) ) != noErr )	{		return err ;	}	/* fill it in */	( ** outNavTypeList ) -> componentSignature = inApplicationSignature ;	( ** outNavTypeList ) -> osTypeCount = inNumTypes ;	BlockMoveData ( inSFTypeList, ( ** outNavTypeList ) -> osType, inNumTypes * sizeof ( OSType ) ) ;	return noErr ;}OSStatus DoOpen ( void ){	const OSType					openableTypes [ ] = { kTypeText, kTypeUnicodeText, kTypeRTF } ;	NavDialogRef					dialog = NULL ;	NavCallbackData *				cd = NULL ;	NavTypeListHandle				typeList = NULL ;	NavDialogCreationOptions		options ;	OSStatus						err ;	BlockZero ( & options, sizeof ( options ) ) ;	/* allocate space for the callback data */	err = memFullErr ;	if ( ( cd = ( NavCallbackData * ) malloc ( sizeof ( * cd ) ) ) == NULL )	{		goto cleanup ;	}	BlockZero ( cd, sizeof ( * cd ) ) ;	/* allocate type list handle */	if ( ( err = CreateNavTypeList ( sigWASTE, sizeof ( openableTypes ) / sizeof ( openableTypes [ 0 ] ), openableTypes, & typeList ) ) != noErr )	{		goto cleanup ;	}	/* init dialog options */	if ( ( err = NavGetDefaultDialogCreationOptions ( & options ) ) != noErr )	{		goto cleanup ;	}	options . modality = kWindowModalityNone ;	options . optionFlags |= ( kNavSelectAllReadableItem | kNavSupportPackages ) ;	/* create event UPP */	err = memFullErr ;	if ( ( cd -> eventProc = NewNavEventUPP ( NavEventFilter ) ) == NULL )	{		goto cleanup ;	}	/* create the dialog */	if ( ( err = NavCreateGetFileDialog ( & options, typeList, cd -> eventProc, NULL, NULL, cd, & dialog ) ) != noErr )	{		goto cleanup ;	}	/* run it */	if ( ( err = NavDialogRun ( dialog ) ) != noErr )	{		goto cleanup ;	}cleanup :	if ( err != noErr )	{		if ( dialog != NULL )		{			NavDialogDispose ( dialog ) ;			dialog = NULL ;		}		if ( cd != NULL )		{			if ( cd -> eventProc != NULL )			{				DisposeNavEventUPP ( cd -> eventProc ) ;				cd -> eventProc = NULL ;			}			free ( cd ) ;			cd = NULL ;		}	}	ForgetHandle ( ( Handle * ) & typeList ) ;	return err;}OSStatus DoSaveAs ( Document * inDocument, Boolean inCloseAfterSaving ){	NavDialogRef					dialog = NULL ;	NavCallbackData *				cd = NULL ;	NavDialogCreationOptions		options ;	OSStatus						err ;	BlockZero ( & options, sizeof ( options ) ) ;	/* allocate space for the callback data */	err = memFullErr ;	if ( ( cd = ( NavCallbackData * ) malloc ( sizeof ( * cd ) ) ) == NULL )	{		goto cleanup ;	}	BlockZero ( cd, sizeof ( * cd ) ) ;	/* init callback data */	cd -> document = inDocument ;	cd -> fileFormat = inDocument -> fileFormat ;	cd -> extraItemsID = kDITLSaveAsExtras ;	cd -> closeAfterSaving = inCloseAfterSaving ;	/* init dialog options */	if ( ( err = NavGetDefaultDialogCreationOptions ( & options ) ) != noErr )	{		goto cleanup ;	}	options . optionFlags |= kNavNoTypePopup ;	if ( ( err = CopyWindowTitleAsCFString ( inDocument -> window, & options . windowTitle ) ) != noErr )	{		goto cleanup ;	}	options . modality = kWindowModalityWindowModal ;	options . parentWindow = inDocument -> window ;	/* create event UPP */	err = memFullErr ;	if ( ( cd -> eventProc = NewNavEventUPP ( NavEventFilter ) ) == NULL )	{		goto cleanup ;	}	/* create the dialog */	if ( ( err = NavCreatePutFileDialog ( & options, kTypeText, sigWASTE, cd -> eventProc, cd, & dialog ) ) != noErr )	{		goto cleanup ;	}	/* do the dialog */	if ( ( err = NavDialogRun ( dialog ) ) != noErr )	{		goto cleanup ;	}cleanup :	if ( err != noErr )	{		if ( dialog != NULL )		{			NavDialogDispose ( dialog ) ;			dialog = NULL ;		}		if ( cd != NULL )		{			if ( cd -> eventProc != NULL )			{				DisposeNavEventUPP ( cd -> eventProc ) ;				cd -> eventProc = NULL ;			}			free ( cd ) ;			cd = NULL ;		}	}	return err;}static OSStatus DoAskSaveChanges ( NavAskSaveChangesAction inAction, Document * inDocument ){	NavDialogRef					dialog = NULL ;	NavCallbackData *				cd = NULL ;	NavDialogCreationOptions		options ;	OSStatus						err ;	BlockZero ( & options, sizeof ( options ) ) ;	/* allocate space for the callback data */	err = memFullErr ;	if ( ( cd = ( NavCallbackData * ) malloc ( sizeof ( * cd ) ) ) == NULL )	{		goto cleanup ;	}	BlockZero ( cd, sizeof ( * cd ) ) ;	/* init callback data */	cd -> document = inDocument ;	/* set up dialog options for NavCreateAskSaveChangesDialog */	if ( ( err = NavGetDefaultDialogCreationOptions ( & options ) ) != noErr )	{		goto cleanup ;	}	if ( ( err = CopyWindowTitleAsCFString ( inDocument -> window, & options . saveFileName ) ) != noErr )	{		goto cleanup ;	}	options . clientName = CFSTR ( "WASTE Demo" ) ;	options . modality = kWindowModalityWindowModal ;	options . parentWindow = inDocument -> window ;	/* create event UPP */	err = memFullErr ;	if ( ( cd -> eventProc = NewNavEventUPP ( NavEventFilter ) ) == NULL )	{		goto cleanup ;	}	/* create the Ask Save Changes dialog */	if ( ( err = NavCreateAskSaveChangesDialog ( & options, inAction , cd -> eventProc, cd, & dialog ) ) != noErr )	{		goto cleanup ;	}	/* run the dialog */	if ( ( err = NavDialogRun ( dialog ) ) != noErr )	{		goto cleanup ;	}	/* clear result code */	err = noErr ;cleanup :	if ( err != noErr )	{		if ( dialog != NULL )		{			NavDialogDispose ( dialog ) ;			dialog = NULL ;		}		if ( cd != NULL )		{			if ( cd -> eventProc != NULL )			{				DisposeNavEventUPP ( cd -> eventProc ) ;				cd -> eventProc = NULL ;			}			free ( cd ) ;			cd = NULL ;		}	}	/* return result code */	return err ;}OSStatus DoClose ( NavAskSaveChangesAction inAction, SavingOption inSavingOption, Document * inDocument ){	OSStatus						err ;	/* is this document dirty? */	if ( WEGetModCount ( inDocument -> text ) != inDocument -> cleanModCount )	{		/* do we have to ask the user whether to save changes? */		if ( inSavingOption == savingAsk )		{			/* run the Ask Save Changes dialog */			err = DoAskSaveChanges ( inAction, inDocument ) ;			goto cleanup ;		}		else if ( inSavingOption == savingYes )		{			err = DoSave ( inDocument, true ) ;			goto cleanup ;		}	}	/* destroy the document */	DestroyDocument ( inDocument ) ;	/* clear result code */	err = noErr ;cleanup :	/* return result code */	return err ;}