// ===========================================================================//	UAnimateCursor.cp			PowerPlant 2.1		©1997-1999 Metrowerks Inc.// ===========================================================================//	Original Author: John C. Daub////	A set of utility classes to handle cursor animation (e.g. spinning//	cursors).#ifdef PowerPlant_PCH#include PowerPlant_PCH#endif#include <UAnimateCursor.h>#include <UCursor.h>#include <UDrawingState.h>#include <UMemoryMgr.h>PP_Begin_Namespace_PowerPlant#pragma mark === UAnimateCursor ===//----------------------------------------------------------------------------//	¥ UAnimateCursor//----------------------------------------------------------------------------// Basic class for animating a cursor. Doesn't do much by itself, but can// be utilized as a base for an "auto-animated" cursor (e.g.// UPeriodicalCursor), or provides "manual" control over cursor animation.//// A typical way this can be used is "for the life" of when you need it.// If you have a specialized cursor that you need for only a certain period of// time, create the object, Resume and Suspend as needed. But if you had// a cursor (e.g. a wait cursor) that might typically crop up a lot in// need/use throughout the course of your application, create the cursor object// at app startup, then just suspend/resume the cursor as needed... can save// on speed, time, heap fragmentation issues.. and is a lot easier to boot.//----------------------------------------------------------------------------//	¥ UAnimateCursor							[public]//----------------------------------------------------------------------------//	Parameterized constructor.////	Input the ResIDT of an 'acur' resource (which will contain the ResIDT's//	of the 'CURS' resources), a tick interval (i.e. how many ticks must//	at least pass before we show the next 'CURS' in the chain), and an//	initial delay (in ticks, and specifies how long after creation we wait//	before we actually start showing the cursor). Apple recommends an//	initial delay of 2 seconds, so we default to that value.UAnimateCursor::UAnimateCursor(	ResIDT		inAcurID,	UInt32		inTickInterval,	UInt32		inInitialDelay ){	mAcurID = inAcurID;	mTickInterval = inTickInterval;	mInitialDelay = inInitialDelay;	mCursorTableH = nil;	InitAnimCursor();}//----------------------------------------------------------------------------//	¥ ~UAnimateCursor							[public, virtual]//----------------------------------------------------------------------------//	DestructorUAnimateCursor::~UAnimateCursor(){	Suspend();	if ( mCursorTableH != nil ) {		::HUnlock(mCursorTableH);		::DisposeHandle(mCursorTableH);	}}//----------------------------------------------------------------------------//	¥ InitAnimCursor							[protected, virtual]//----------------------------------------------------------------------------//	(Almost) private initializervoidUAnimateCursor::InitAnimCursor(){	// get the 'acur' resource	StResource theAcurH( FOUR_CHAR_CODE('acur'), mAcurID );	// parse the 'acur' resource, loading the cursors into memory.	// we'll walk the resource, parsing it manually to get the	// information out of it.	// we also store the actual Cursor itself in our Handle. Makes	// things a wee faster, more memory efficient, and safer	{		// get the number of cursors		mNumCursors = *((SInt16 *)*((Handle)theAcurH));		SignalIf_(mNumCursors <= 0 );		// allocate memory		mCursorTableH = ::NewHandle( (Size) sizeof(Cursor) * mNumCursors );		ThrowIfMemFail_(mCursorTableH);		// and dereference the pointer once, for ease of walking		StHandleLocker tableLock(mCursorTableH);		Ptr theTableP = *mCursorTableH;		// lock the acur handle so we can dereference the pointer and		// walk it.		StHandleLocker acurLock(theAcurH);		Ptr theAcurP = *theAcurH;		theAcurP += sizeof(SInt16); // skip the count		theAcurP += sizeof(SInt16); // skip the frame counter		SInt16 theID;		CursHandle theCursH;		for ( SInt16 i = 1; i <= mNumCursors; ++i ) {			// grab the cursor ID			theID = *(SInt16*)theAcurP;			// load the cursor			theCursH = ::MacGetCursor( theID );			ThrowIfResFail_(theCursH);			// copy the Cursor into our table			::BlockMoveData( &(**theCursH), theTableP, sizeof(Cursor) );			// release the cursor			::ReleaseResource((Handle)theCursH);			// and up the pointers			theAcurP += sizeof(SInt32);			theTableP += sizeof(Cursor);		} // end for	}	// get ready to go...	::MacShowCursor();	mLastTick = ::TickCount();	mStartTick = mLastTick;	mNextFrameIndex = 1;	// and you must call Resume() to actually start animating}//----------------------------------------------------------------------------//	¥ Tick								[public, virtual]//----------------------------------------------------------------------------// Call this to "animate" to the next framevoidUAnimateCursor::Tick(){	// time to tick?	UInt32 theTick = ::TickCount();	if ( ((theTick < (mInitialDelay + mStartTick))) ||		(theTick < (mLastTick + mTickInterval)) )		return; // sure isn't.	// dereference the Handle for easier manipulation	StHandleLocker lock(mCursorTableH);	Ptr theTableP = *mCursorTableH;	// walk the pointer to point to our cursor	theTableP += (mNextFrameIndex - 1) * sizeof(Cursor);	// and set the cursor as such	::MacSetCursor( (CursPtr)theTableP );	// and get ready to display the next cursor	if ( mNextFrameIndex >= mNumCursors ) {		mNextFrameIndex = 1;	} else {		mNextFrameIndex += 1;	}	mLastTick = ::TickCount();}//----------------------------------------------------------------------------//	¥ Suspend							[public, virtual]//----------------------------------------------------------------------------//	Stops the cursor from animating. Doesn't destroy it, just temporarily//	suspends animation.voidUAnimateCursor::Suspend(	ResIDT		inNewCursorID ){	// set the cursor to something	UCursor::SetTheCursor( inNewCursorID );	UCursor::SetInAnimatedCursor(false);}//----------------------------------------------------------------------------//	¥ Resume							[public, virtual]//----------------------------------------------------------------------------//	If you stopped the animation (via Suspend), call this to resume//	animation. Also, when the UAnimateCursor object is first created,//	it does not start animating immediately. You must call this routine//	to start the animation.voidUAnimateCursor::Resume(){	// reset everything	Reset();	UCursor::SetInAnimatedCursor(true);}//----------------------------------------------------------------------------//	¥ Reset									[public, virtual]//----------------------------------------------------------------------------//	Reset back to initial valuesvoidUAnimateCursor::Reset(){	mLastTick = ::TickCount();	mNextFrameIndex = 1;}#pragma mark === UPeriodicalCursor ===//----------------------------------------------------------------------------//	¥ UPeriodicalCursor//----------------------------------------------------------------------------//	This is an automated instance of UAnimateCursor. Instead of you//	"ticking" on your own, this object will handle it itself via//	PowerPlant's periodical mechanisms. You can utilize this as either//	a repeater or idler.//----------------------------------------------------------------------------//	¥ UPeriodicalCursor							[public]//----------------------------------------------------------------------------//	Parameterized constructor.////	Takes the same input parameters as the associated UAnimateCursor, but//	also a Boolean if this should be a repeater or idler (is repeater by//	default).UPeriodicalCursor::UPeriodicalCursor(	ResIDT		inAcurID,	UInt32		inTickInterval,	UInt32		inInitialDelay,	Boolean		inIsRepeater )		: UAnimateCursor( inAcurID, inTickInterval, inInitialDelay ){	mIsRepeater = inIsRepeater;}//----------------------------------------------------------------------------//	¥ ~UPeriodicalCursor							[public, virtual]//----------------------------------------------------------------------------//	DestructorUPeriodicalCursor::~UPeriodicalCursor(){	// nothing}//----------------------------------------------------------------------------//	¥ Suspend										[public, virtual]//----------------------------------------------------------------------------//	Call this to temporarily stop the cursor animationvoidUPeriodicalCursor::Suspend(	ResIDT	inNewCursorID ){	if ( mIsRepeater ) {		StopRepeating();	} else {		StopIdling();	}	UAnimateCursor::Suspend( inNewCursorID );}//----------------------------------------------------------------------------//	¥ Resume										[public, virtual]//----------------------------------------------------------------------------//	Call this to restart cursor animation (after a call to Suspend), and to//	start cursor animation the first time after creating the object.voidUPeriodicalCursor::Resume(){	UAnimateCursor::Resume();	if ( mIsRepeater ) {		StartRepeating();	} else {		StartIdling();	}}//----------------------------------------------------------------------------//	¥ SpendTime										[protected, virtual]//----------------------------------------------------------------------------//	Using the LPeriodical mechanisms, this is what automates the cursor//	animation.voidUPeriodicalCursor::SpendTime(	const EventRecord&	/* inMacEvent */){	Tick();}PP_End_Namespace_PowerPlant