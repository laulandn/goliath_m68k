/* ================================================================================================== * CDAVLibUtils.cpp														    *    Goliath - a Finder like application that implements WebDAV *    Copyright (C) 1999-2000  Thomas Bednarz * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com * =========================================================================== */ #include "CDAVLibUtils.h"#include <DAVTypes.h>#include <stdio.h>const char* DAVLib_maj_ver = "1";const char* DAVLib_min_ver = "9";const char* DAVLib_point_ver = "0";char *urlhexchars = "0123456789ABCDEF";unsigned char URLAcceptableChars[96] ={/* 0 1 2 3 4 5 6 7 8 9 A B C D E F */	0,0,0,0,0,0,0,0,0,0,7,6,0,7,7,4,		/* 2x	!"#$%&'()*+,-./*/	7,7,7,7,7,7,7,7,7,7,0,0,0,0,0,0,		/* 3x  0123456789:;<=>?*/	7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,		/* 4x  @ABCDEFGHIJKLMNO*/	7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,7,		/* 5X  PQRSTUVWXYZ[\]^_*/	0,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,		/* 6x  `abcdefghijklmno*/	7,7,7,7,7,7,7,7,7,7,7,0,0,0,0,0			/* 7X  pqrstuvwxyz{\}~	DEL */};const char	kBase64FillChar = '=';static std::string kBase64Alphabet =	"ABCDEFGHIJKLMNOPQRSTUVWXYZ"										"abcdefghijklmnopqrstuvwxyz"		                        		"0123456789+/";char ConvertHex(char inChar);char ConvertHex(char inChar) {	return  inChar >= '0' && inChar <= '9' ?  inChar - '0' 		: inChar >= 'A' && inChar <= 'F'? inChar - 'A' + 10		: inChar - 'a' + 10;}// ---------------------------------------------------------------------------//		¥ _beginXMLDAVBody()// ---------------------------------------------------------------------------//void CXMLStringUtils::beginXMLDAVBody(std::string &msgBody) {	msgBody.append(DAVTypes::XML_PI);}// ---------------------------------------------------------------------------//		¥ _beginXMLDAVBody()// ---------------------------------------------------------------------------//void CXMLStringUtils::beginXMLDAVBody(LDynamicBuffer &msgBody) {	msgBody.ConcatenateBuffer(DAVTypes::XML_PI);}// ---------------------------------------------------------------------------//		¥ _startElement()// ---------------------------------------------------------------------------//void CXMLStringUtils::startElement(std::string &str, const char* elemname) {	str+='<';	str.append(elemname);	str+='>';}// ---------------------------------------------------------------------------//		¥ _startElement()// ---------------------------------------------------------------------------//void CXMLStringUtils::startElement(LDynamicBuffer &str, const char* elemname) {	str.ConcatenateBuffer("<");	str.ConcatenateBuffer(elemname);	str.ConcatenateBuffer(">");}// ---------------------------------------------------------------------------//		¥ _startElement()// ---------------------------------------------------------------------------//void CXMLStringUtils::startElementWithDAVNS(std::string &str, const char* elemname) {	str+='<';	str.append(elemname);	str.append(" xmlns=\"DAV:\">");}// ---------------------------------------------------------------------------//		¥ startElementWithOtherNS()// ---------------------------------------------------------------------------//void CXMLStringUtils::startElementWithOtherNS(std::string &str, const char* elemname, const char* xmlnamespace) {   str+='<';   str.append(elemname);   str.append(" xmlns=\"");   str.append(xmlnamespace);   str.append("\">");}// ---------------------------------------------------------------------------//		¥ _startElement()// ---------------------------------------------------------------------------//void CXMLStringUtils::startElementWithDAVNS(LDynamicBuffer &str, const char* elemname) {	str.ConcatenateBuffer("<");	str.ConcatenateBuffer(elemname);	str.ConcatenateBuffer(" xmlns=\"DAV:\">");}// ---------------------------------------------------------------------------//		¥ startElementWithOtherNS()// ---------------------------------------------------------------------------//void CXMLStringUtils::startElementWithOtherNS(LDynamicBuffer &str, const char* elemname, const char* xmlnamespace) {   str.ConcatenateBuffer("<");   str.ConcatenateBuffer(elemname);   str.ConcatenateBuffer(" xmlns=\"");   str.ConcatenateBuffer(xmlnamespace);   str.ConcatenateBuffer("\">");}// ---------------------------------------------------------------------------//		¥ _endElement()// ---------------------------------------------------------------------------//void CXMLStringUtils::endElement(std::string &str, const char* elemname) {	str+='<';	str+='/';	str.append(elemname);	str+='>';}// ---------------------------------------------------------------------------//		¥ _endElement()// ---------------------------------------------------------------------------//void CXMLStringUtils::endElement(LDynamicBuffer &str, const char* elemname) {	str.ConcatenateBuffer("<");	str.ConcatenateBuffer("/");	str.ConcatenateBuffer(elemname);	str.ConcatenateBuffer(">");}// ---------------------------------------------------------------------------//		¥ _addEmptyElement()// ---------------------------------------------------------------------------//void CXMLStringUtils::addEmptyElement(std::string &str, const char* elemname) {	str+='<';	str.append(elemname);	str+='/';	str+='>';}// ---------------------------------------------------------------------------//		¥ _addEmptyElement()// ---------------------------------------------------------------------------//void CXMLStringUtils::addEmptyElement(LDynamicBuffer &str, const char* elemname) {	str.ConcatenateBuffer("<");	str.ConcatenateBuffer(elemname);	str.ConcatenateBuffer("/");	str.ConcatenateBuffer(">");}// ---------------------------------------------------------------------------//		¥ filterXMLContent()// ---------------------------------------------------------------------------//void CXMLStringUtils::filterXMLContent(std::string& outData, std::string inData) {	for (int i=0; i<inData.size(); i++) {	   char tmp = inData[i];	   if ('<' == tmp) {	      outData += "&lt;";	   } else if ('>' == tmp) {	      outData += "&gt;";	   	   } else if ('&' == tmp) {	      outData += "&amp;";	   	   	   } else if ('\'' == tmp) {	      outData += "&apos;";	   	   	   	   } else if ('"' == tmp) {	      outData += "&quot;";	   	   	   	   } else {	      outData += tmp;	   }	}}// ---------------------------------------------------------------------------//		¥ URLEncodeString// ---------------------------------------------------------------------------//  /* RFC2396 spake: * "Data must be escaped if it does not have a representation  * using an unreserved character". *//* Lookup table: character classes from 2396. (This is overkill) */#define SP 0   /* space    = <US-ASCII coded character 20 hexadecimal>                 */#define CO 0   /* control  = <US-ASCII coded characters 00-1F and 7F hexadecimal>      */#define DE 0   /* delims   = "<" | ">" | "#" | "%" | <">                               */#define UW 0   /* unwise   = "{" | "}" | "|" | "\" | "^" | "[" | "]" | "`"             */#define MA 1   /* mark     = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"       */#define AN 2   /* alphanum = alpha | digit                                             */#define RE 2   /* reserved = ";" | "/" | "?" | ":" | "@" | "&" | "=" | "+" | "$" | "," */static const char uri_chars[128] = {/*                +2      +4      +6      +8     +10     +12     +14     *//*   0 */ CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO,/*  16 */ CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO, CO,/*  32 */ SP, MA, DE, DE, RE, DE, RE, MA, MA, MA, MA, RE, RE, MA, MA, RE,/*  48 */ AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, RE, RE, DE, RE, DE, RE,/*  64 */ RE, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN,/*  80 */ AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, UW, UW, UW, UW, MA,/*  96 */ UW, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN,/* 112 */ AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, AN, UW, UW, UW, MA, CO };#define ESCAPE(ch) (((const signed char)(ch) < 0 || \		uri_chars[(unsigned int)(ch)] == 0))#undef SP#undef CO#undef DE#undef UW#undef MA#undef AN#undef RE// ---------------------------------------------------------------------------//		¥ URLEncodeString// ---------------------------------------------------------------------------//  adds "%00" encoding to URLSstd::string CHTTPStringUtils::URLEncodeString(const std::string& inResource) {    /* An escaped character is "%xx", i.e., two MORE     * characters than the original string */    std::string ret;    for (std::string::const_iterator iter = inResource.begin(); iter != inResource.end(); iter++) {	if (ESCAPE(*iter)) {	    char buf[]="xx";	    sprintf(buf, "%%%02x", (unsigned char) *iter);	    ret += buf;	} else {	    ret += *iter;	}    }    return ret;}// ---------------------------------------------------------------------------//		¥ URLDencodeString// ---------------------------------------------------------------------------//	removes "%00" encoding from URLSLStr255 CHTTPStringUtils::URLDecodeString(LStr255& inResource){   LStr255 outDecoded;   unsigned char p, q;   int i=1, sz=inResource.Length() ;   while (i <=sz) {      p = inResource[i];          if (p == '%') {         i++;         if (i<sz) {            p=inResource[i];             q=ConvertHex(p) * 16;            i++;         }         if (i<sz) {            p=inResource[i];             q = q + ConvertHex(p);            outDecoded+=q;         }		} else {		    outDecoded+=p; 		}		i++;    }   return outDecoded;}// ---------------------------------------------------------------------------//		¥ URLDencodeString// ---------------------------------------------------------------------------//	removes "%00" encoding from URLSstd::string CHTTPStringUtils::URLDecodeString(std::string &inResource){	std::string outDecoded;	unsigned char p, q;	int sz = inResource.size();	for (int i=0; i < sz; i++)	{		p = inResource[i];		if (p == '%')		{			i++;			if (i<sz)			{				p=inResource[i]; 				q=ConvertHex(p) * 16;				i++;			}			if (i<sz)			{				p=inResource[i]; 				q = q + ConvertHex(p);				outDecoded+=q;			}		}		else			outDecoded += p; 	}	return outDecoded;}// ---------------------------------------------------------------------------//		¥ Encode// ---------------------------------------------------------------------------//	void CBase64StringUtils::Encode(const std::string& inData, std::string& outEncodedData) {    std::string::size_type  i;    std::string::value_type	c;	std::string::size_type  len = inData.length();    for (i = 0; i < len; ++i) {        c = (inData[i] >> 2) & 0x3f;        outEncodedData.append(1, kBase64Alphabet[c]);        c = (inData[i] << 4) & 0x3f;        if (++i < len)            c |= (inData[i] >> 4) & 0x0f;        outEncodedData.append(1, kBase64Alphabet[c]);        if (i < len) {            c = (inData[i] << 2) & 0x3f;            if (++i < len)                c |= (inData[i] >> 6) & 0x03;            outEncodedData.append(1, kBase64Alphabet[c]);        } else {            i++;            outEncodedData.append(1, kBase64FillChar);        }        if (i < len) {            c = inData[i] & 0x3f;            outEncodedData.append(1, kBase64Alphabet[c]);        }  else {            outEncodedData.append(1, kBase64FillChar);        }    }}// ---------------------------------------------------------------------------//		¥ Decode// ---------------------------------------------------------------------------//	void CBase64StringUtils::Decode(const std::string& inEncodedData, std::string& outDecodedData) {	std::string::size_type  i;    std::string::value_type	c;    std::string::value_type	c1;    std::string::size_type  len = inEncodedData.length();        for (i = 0; i < len; ++i) {        c = (char) kBase64Alphabet.find(inEncodedData[i]);        ++i;        c1 = (char) kBase64Alphabet.find(inEncodedData[i]);        c = (c << 2) | ((c1 >> 4) & 0x3);        outDecodedData.append(1, c);        if (++i < len) {            c = inEncodedData[i];            if (kBase64FillChar == c)                break;            c = (char) kBase64Alphabet.find(c);            c1 = ((c1 << 4) & 0xf0) | ((c >> 2) & 0xf);            outDecodedData.append(1, c1);        }        if (++i < len) {            c1 = inEncodedData[i];            if (kBase64FillChar == c1)                break;            c1 = (char) kBase64Alphabet.find(c1);            c = ((c << 6) & 0xc0) | c1;            outDecodedData.append(1, c);        }    }}// ---------------------------------------------------------------------------//		¥ GetURIParent// ---------------------------------------------------------------------------//	Boolean CURLStringUtils::GetURIParent(const PP_STD::string &inOrigHREF, PP_STD::string &outParentHREF){	PP_STD::string::size_type strEnd = inOrigHREF.size();	if (strEnd == 0)		return false;			strEnd--;			if (inOrigHREF [strEnd-1] == '/') 		strEnd--; 	UInt8 idx = inOrigHREF.rfind('/', strEnd);		if (idx == 0) 		return false;			outParentHREF = inOrigHREF.substr(0, idx);	return true;}// ---------------------------------------------------------------------------//		¥ GetDAVLibMajorVersion// ---------------------------------------------------------------------------//	Boolean CURLStringUtils::GetURINodeName(const std::string &inOrigHREF, std::string &outNodeHREF) {	std::string::size_type pos = inOrigHREF.rfind('/');	if (std::string::npos == pos) {	   return false;	}	outNodeHREF=inOrigHREF.substr(pos+1, inOrigHREF.size()-(pos+1));	return true;}// ---------------------------------------------------------------------------//		¥ GetDAVLibMajorVersion// ---------------------------------------------------------------------------//	const char* GetDAVLibMajorVersion() {   return DAVLib_maj_ver;}// ---------------------------------------------------------------------------//		¥ GetDAVLibMinorVersion// ---------------------------------------------------------------------------//	const char* GetDAVLibMinorVersion() {   return DAVLib_min_ver;}// ---------------------------------------------------------------------------//		¥ GetDAVLibMinorVersion// ---------------------------------------------------------------------------//	void GetDAVLibVersionDisplayString(std::string &outString) {	outString+=DAVLib_maj_ver;	outString+=".";	outString+=DAVLib_min_ver;	if (NULL != DAVLib_point_ver) {		outString+=".";		outString+=DAVLib_point_ver;	}			}