/*  Metrowerks Standard Library  *//*  $Date: 2000/06/27 14:52:22 $  *  $Revision: 1.3.10.5 $  *  $NoKeywords: $  * *		Copyright © 1995-2000 Metrowerks, Inc. *		All rights reserved. *//* *	File:		unistd.c * *	Content:	Interface file to standard UNIX-style entry points ... * *	NB:			This file implements some UNIX low level support.  These functions *				are not guaranteed to be 100% conformant. * */#include <console.h>#include <errno.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <unistd.h>#include <Errors.h>#include <Files.h>#include <LowMem.h>#include <Processes.h>#include <TextUtils.h>  /*  971010 MW-mm  */#include <MacTypes.h>	/*  990421 */#include <Devices.h> #include "abort_exit.h"/* local typedefs */typedef struct LaunchStruct {	StringPtr	name;	short		memUse;	char		LC[2];	long		extBlocLen;	short		fFlags;	long		launchFlags;} LaunchStruct;/* local globals */static OSErr error;static short savedWD;/* function prototypes for externally defined functions */extern int	__system7present();extern int	__ctopstring(const char *cstring, Str255 pstring);/* *	pascal short LaunchApp(struct LaunchStruct *) * *		Launch an application under System 6. */#if __MC68K__ && !__CFM68K__static pascal short LaunchApp(LaunchStruct *launchStruct) = { 0x205F, 0xA9F2, 0x3E80 };#endif/* *	static long getdirname(Str255 s, short vrefnum, long dirnum) * *		Returns the current directory's name and it's parent's DirID. */static long getdirname(Str255 s, short vrefnum, long dirnum){	CInfoPBRec pb;	pb.dirInfo.ioNamePtr = s;	pb.dirInfo.ioVRefNum = vrefnum;	pb.dirInfo.ioFDirIndex = -1;	pb.dirInfo.ioDrDirID = dirnum;	PBGetCatInfoSync(&pb);	return(pb.dirInfo.ioDrParID);}/* *	static short catdirname(char *buf, int size, short vrefnum, long dirnum) * *		Recursive call to return the full path to a directory. */static void _catdirname(char *buf, int size, short vrefnum, long dirnum){	Str255			dirname;	if (dirnum == 2)		return;	_catdirname(buf, size, vrefnum, getdirname(dirname, vrefnum, dirnum));	if (error || (buf[0] + dirname[0] + 2 > size))		return;	memcpy(&buf[buf[0] + 1], &dirname[1], dirname[0]);	buf[0] = buf[0] + dirname[0];	buf[buf[0] + 1] = ':';	buf[0] += 1;}/* *	int chdir(const char *path) * *		Changes the current working directory (actually changes lowmem globals *		SFSaveDisk and CurDirStore which are used by open to open a file). */int _chdir(const char * path){/*	HFileInfo		cpb;	HVolumeParam	vpb; */	WDPBRec			wdpb;	Str255			ppath;	OSErr			err = -1;	if (path) {		/* convert the c string into a pascal string */		if (__ctopstring(path, ppath) != noErr) return (-1);			if (ppath[ppath[0]] != ':')			ppath[++ppath[0]] = ':';		wdpb.ioNamePtr = ppath;		wdpb.ioVRefNum = 0;		wdpb.ioWDDirID = 0;		err = PBHSetVolSync(&wdpb);	}	/* if we reach here we have an error */	if (err != noErr)		errno = err;	return (err == noErr ? 0 : -1);}/* *	int close(int fildes) *	 *		Closes a file stream. */int _close(int fildes){	HParamBlockRec	pb;	FCBPBRec		fcb;	OSErr			err;	if (fildes >= 0 && fildes <= 2)	{		return 0;	}	/*	Get volume refnum ... */	fcb.ioFCBIndx = 0;	fcb.ioRefNum = fildes;	fcb.ioNamePtr = NULL;	err = PBGetFCBInfoSync(&fcb);	if (err == noErr) {		pb.fileParam.ioVRefNum = fcb.ioVRefNum;		pb.fileParam.ioFRefNum = fildes;			err = PBCloseSync((ParmBlkPtr)&pb);		if (err == noErr) {			pb.volumeParam.ioNamePtr = NULL;			pb.volumeParam.ioVRefNum = fcb.ioVRefNum;			PBFlushVolSync((ParmBlkPtr)&pb);		}	}	if (err != noErr)		errno = err;	return (err == noErr ? 0 : -1);}/* *	char *cuserid(char *string) * *		Returns the user's name associated with the current process (owner name from *		Sharing Setup CP). */char * _cuserid(char * string){	char			*name = getlogin();	if (name != NULL && string != NULL)		strcpy(string, name);	return (name == NULL ? NULL : string == NULL ? name : string);}/* *	int exec(const char *path, ...) * *		Launchs an application and then quits the current app. */int _exec(const char * path, ...){	Str255			ppath;	OSErr			err = -1;	if (path) {		/* convert the c string into a pascal string */		if (__ctopstring(path, ppath) != noErr) return (-1);			/* under system 7 or greater use the LaunchApplication call */		if (__system7present()) {			LaunchParamBlockRec lpb;			FSSpec spec;				err = FSMakeFSSpec(0,0,ppath,&spec);			if (err == noErr) {				memset(&lpb, '\0', sizeof(LaunchParamBlockRec));					lpb.launchBlockID = extendedBlock;				lpb.launchEPBLength = extendedBlockLen;				lpb.launchControlFlags = launchContinue + launchNoFileFlags;				lpb.launchAppSpec = &spec;					err = LaunchApplication(&lpb);			}		}	#if __MC68K__ && !__CFM68K__		/* only possible way to get here is under 6.0.x on a 68K mac */		else {			static LaunchStruct launchStruct;				memset(&launchStruct, '\0', sizeof(LaunchStruct));			launchStruct.name = ppath;			err = LaunchApp(&launchStruct);		}	#endif			if (err == noErr)			exit(0);	}	/* if we reach here we have an error */	errno = err;	return (-1);}/* *	char *getcwd(char *buf, int size) * *		Returns the path to the current directory. */char * _getcwd(char * buf, int size){	short			vrefnum;	long			dirid;	HVolumeParam	vpb;	WDPBRec			wdpb;	int				i,j;	error = -1;	if (size > 0 && buf) {		buf[0] = '\0';		wdpb.ioNamePtr = NULL;		error = PBHGetVolSync(&wdpb);		vrefnum = wdpb.ioWDVRefNum;		dirid = wdpb.ioWDDirID;		if (error == noErr) {			vpb.ioVolIndex = 0;			vpb.ioNamePtr = (StringPtr)buf;			vpb.ioVRefNum = vrefnum;	/* JWW - vrefnum goes here, not at ioVolIndex */				error = PBHGetVInfoSync((HParmBlkPtr)&vpb);			if (error == noErr) {				buf[buf[0] + 1] = ':';				buf[0] += 1;				if (dirid != 2) {					error = noErr;					_catdirname(buf, size, vrefnum, dirid);				}			}		}	}	if (error == noErr) {	/* convert into a C string */		for (i = buf[0], j = 0; j < i; j++)			buf[j] = buf[j+1];		buf[i] = '\0';	}	if (error != noErr)		errno = error;	return (error == noErr ? buf : NULL);}/* *	char *getlogin(void) * *		Returns the current user's login name (owner name from Sharing Setup CP). */char * _getlogin(void){	static char		login[32];			/* need static data */	short			savemap;	StringHandle	h;	OSErr			err;	#if !TARGET_API_MAC_CARBON	savemap = LMGetCurMap();	LMSetCurMap(0);						/* search only in the system file's resources */#endif /* !TARGET_API_MAC_CARBON */	h = GetString(-16096);				/* the sharing setup's owner name */	err = ResError();#if !TARGET_API_MAC_CARBON	LMSetCurMap(savemap);#else	#pragma unused(savemap)	#endif /* !TARGET_API_MAC_CARBON */	if (h && err == noErr) {		HLock((Handle)h);		sprintf(login, "%#.*s", 31, *h);		HUnlock((Handle)h);	}	if (err != noErr)		errno = err;	return (login[0] ? login : NULL);}/* *	int isatty(int fildes) * *		Determines is a filestream is going to the console window. */int _isatty(int fildes){	if (fildes >=0 && fildes <= 2)		return 1;	else		return 0;}/* *	long lseek(int fildes, long offset,int whence) *	 *		Seek in a file (fildes is the MacOS refnum). */long _lseek(int fildes, long offset,int whence){	IOParam			pb;	OSErr			err;	long            startpos;         /* mm 960910 */	long            eofpos;           /* mm 960910 */			if (fildes >= 0 && fildes <= 2) return -1;	pb.ioRefNum = fildes;	PBGetFPosSync((ParmBlkPtr) &pb);  /* mm 960910 */	startpos = pb.ioPosOffset;        /* mm 960910 */	pb.ioPosOffset = offset;	switch (whence) {		case SEEK_SET:									/* from start of file */			pb.ioPosMode = fsFromStart;			break;		case SEEK_CUR:									/* from current marker */			pb.ioPosMode = fsFromMark;			break;		case SEEK_END:									/* from EOF marker */			pb.ioPosMode = fsFromLEOF;			break;	}	err = PBSetFPosSync((ParmBlkPtr) &pb);	if (err == eofErr) {		pb.ioRefNum = fildes;		switch (whence) {			case SEEK_SET:								/* from start of file */				pb.ioMisc = (Ptr) offset;				break;			case SEEK_CUR:								/* from current marker */				err = PBGetFPosSync((ParmBlkPtr) &pb);				if (err == noErr) {					pb.ioRefNum    = fildes;					eofpos         = pb.ioPosOffset;    /* mm 960910 */					pb.ioPosOffset = startpos;          /* mm 960910 */					pb.ioMisc      = (Ptr) (pb.ioPosOffset + offset);				}				break;			case SEEK_END:								/* from EOF marker */				err = PBGetEOFSync((ParmBlkPtr) &pb);				if (err == noErr) {					pb.ioRefNum = fildes;					pb.ioMisc = (Ptr) (pb.ioMisc + offset);				}				break;		}		err = PBSetEOFSync((ParmBlkPtr) &pb);		if (err == noErr) {			/* retry to lseek */			pb.ioRefNum = fildes;			pb.ioPosOffset = offset;			switch (whence) {				case SEEK_SET:							/* from start of file */					pb.ioPosMode = fsFromStart;					break;				case SEEK_CUR:							/* from current marker */					pb.ioPosMode = fsFromMark;					pb.ioPosOffset = offset - eofpos + startpos; /* mm 960910 */					break;				case SEEK_END:							/* from EOF marker */					pb.ioPosMode = fsFromMark;          /* mm 980423 */					/*pb.ioPosMode = fsFromLEOF;*/					break;			}			err = PBSetFPosSync((ParmBlkPtr) &pb);		}	}	if (err != noErr)		errno = err;	return (err == noErr ?  pb.ioPosOffset : -1);}/* *	int read(int fildes, void *buf, size_t count) *	 *		Read from a file (fildes is the file's MacOS refnum). *  Note: POSIX standard defines return value as of type ssize_t but says may be used instead     */int _read(int fildes, void * buf, size_t count)				/* mm 000607  */{	IOParam			pb;	OSErr			err;	if ((fildes == 0)) {#if __A5__ || __POWERPC__ || __CFM68K__		if (InstallConsole(fildes) == 0) {			__console_exit = RemoveConsole;			fflush(stdout);			return ReadCharsFromConsole((char *)buf, count);		} else			return -1;#else		return -1;#endif	}	pb.ioRefNum = fildes;	pb.ioBuffer = (char *)buf;	pb.ioReqCount = count;	pb.ioPosMode = fsAtMark;	pb.ioPosOffset = NULL;	err = PBReadSync((ParmBlkPtr) &pb);	if (err != noErr && err != eofErr)		errno = err;	return (err != noErr && err != eofErr) ? -1 : pb.ioActCount;}/* *	int rmdir(const char *path) * *		Removes a directory (must be empty). */int _rmdir(const char * path){	HFileParam		fpb;	Str255			ppath;	OSErr			err = -1;	if (path) {		/* convert the c string into a pascal string */		if (__ctopstring(path, ppath) != noErr) return (-1);		fpb.ioNamePtr = ppath;		fpb.ioVRefNum = 0;		fpb.ioDirID = 0L;		err = PBHDeleteSync((HParmBlkPtr)&fpb);	}	if (err != noErr)		errno = err;	return (err == noErr ? 0 : -1);}/* *	unsigned int sleep(unsigned int seconds) * *		Pauses program execution for seconds seconds. */unsigned int _sleep(unsigned int seconds){	unsigned long			finalTick;                 /* mm 971006 */	Delay(seconds * 60UL, &finalTick);	return (0);}/* *	char *ttyname(int fildes) * *		Returns the name of the associated terminal or NULL if none. */char * _ttyname(int fildes){	if (fildes >=0 && fildes <= 2)		return __ttyname((long)fildes);	else		return NULL;}/* *	int unlink(const char *path) *	 *		Unlink (i.e. delete) a file. */int _unlink(const char * path){	Str255			pname;	HFileParam		pb;	/* ra 990612 UI 3.2 */	OSErr			err;	char  *p = (char *) path, *p1 = (char *) pname + 1;		while (*p) *p1++ = *p++; *p1 = 0x00; *pname = p1 - ((char *) pname) -1;	pb.ioNamePtr = pname;	pb.ioVRefNum = 0;	pb.ioFVersNum = 0;	pb.ioDirID = 0L;	/* jd 980923 - uncertain if this is correct */	err = PBHDeleteSync((HParmBlkPtr) &pb);	/* ra 990612 UI 3.2 */	if (err != noErr)		errno = err;	return (err == noErr ? 0 : -1);}/* *	int write(int fildes, const void *buf, size_t count) *	 *		Write to a file (fildes is the file's MacOS refnum). *  Note: POSIX standard defines return value as of type ssize_t but says may be used instead     */int _write(int fildes, const void *buf, size_t count)				/* mm 000607  */{	IOParam			pb;	OSErr			err;	if ((fildes == 1) || (fildes == 2)) {#if __A5__ || __POWERPC__ || __CFM68K__		if (InstallConsole(fildes) == 0) {			__console_exit = RemoveConsole;			fflush(stdin);			return WriteCharsToConsole((char *)buf, count);		} else			return -1;#else		return -1;#endif	}	pb.ioRefNum = fildes;	pb.ioBuffer = (char *)buf;	pb.ioReqCount = count;	pb.ioPosMode = fsAtMark;	pb.ioPosOffset = NULL;	pb.ioVRefNum = 0;	err = PBWriteSync((ParmBlkPtr) &pb);	if (err != noErr)		errno = err;	return (err == noErr ? pb.ioActCount : -1);}/* Change record *	12/10/95 JH	Modified to interface with new ANSI C library *	15/12/95 JH Added code to install RemoveConsole hook *	30/12/95 JH Removed uses of OLDROUTINENAMES *	12/02/96 JH Tossed __setup_exit calls *  mm 960910   Corrected lseek in accordance with BR7278 *	bkoz 970415 added ron l's code *  mm 971006   Changed declaration of final_tick from long to unsigned long to match new OSUtils.h *  mm 971010   Prefix files no longer required, so this must be found here now *  mm 980423   Corrected lseek when seeking beyond the EOF to extend the file MW 00445 * vss 990421	Update to 3.2 Universal Headers * jd 980923	Initialized pb.ioDirID in unlink for Carbon? *  cc 991108	added ra Carbon Changes done 990611 *  cc 991109   changed TARGET_CARBON to TARGET_API_MAC_CARBON *  cc 991115  	updated and deleted outdated comments * mm 000607    Changed definitions of read and write to accord with POSIX Standard. * JWW 000620   Fixed volume reference number placed in the wrong place inside _getcwd */