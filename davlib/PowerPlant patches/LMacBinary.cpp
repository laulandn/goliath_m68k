/*	LMacBinary.cpp	Copyright (C) 2000 i-drive.com (email: opensource@mail.idrive.com)	This library is free software; you can redistribute it and/or	modify it under the terms of version 2.1 of the GNU Lesser General	Public License.	This library is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU	Lesser General Public License for more details.	You should have received a copy of the GNU Lesser General Public	License along with this library; if not, write to the Free Software	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA*/using namespace std;#include <LMacBinary.h>#include <string.h>#include <Files.h>#include <algorithm>#include <FileUtil.h>static inline unsigned long RoundUpTo128 (unsigned long x){	return (x + 127) & (~127);}// Used by buggy MSIE encoderstatic inline unsigned long BadRoundUpTo128 (unsigned long x)	{	return x + (x & 127);}#pragma mark -// ---------------------------------------------------------------------------//	¥ LMacBinaryStream// ---------------------------------------------------------------------------LMacBinary::LMacBinary (void){	mValidHeader = false;	mFSSpec.vRefNum = 0;	mFSSpec.parID = 0;	mFSSpec.name[0] = 0;}#pragma mark -// ---------------------------------------------------------------------------//	¥ LMacBinaryEncoder								Constructor		  [public]// ---------------------------------------------------------------------------LMacBinaryEncoder::LMacBinaryEncoder (const FSSpec& inSourceFile){	mFSSpec.vRefNum = inSourceFile.vRefNum;	mFSSpec.parID = inSourceFile.parID;	BlockMoveData (inSourceFile.name, mFSSpec.name, inSourceFile.name[0] + 1);		mValidHeader = BuildHeader ();}LMacBinaryEncoder::~LMacBinaryEncoder (){}ExceptionCode LMacBinaryEncoder::GetBytes( void*		outBuffer,											SInt32&		ioByteCount){	SInt32				byteCount = 0;	SInt32				bytesToRead = ioByteCount;	SInt32				end;	OSErr				err = noErr;		while (bytesToRead)								// Read Header sections	{		if (mPosition < kMBHeaderSize)		{			const void *source;						if (mPosition < (end = sizeof (mMacBinaryHeader.h1)) )				source = (char*)&mMacBinaryHeader.h1;			else if (mPosition < (end = sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2)) )				source = (char*)&mMacBinaryHeader.h2 + mPosition - sizeof (mMacBinaryHeader.h1);			else if (mPosition < (end = sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2) + sizeof (mMacBinaryHeader.h3)) )				source = (char*)&mMacBinaryHeader.h3 + mPosition - (sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2));			else if (mPosition < (end = sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2) + sizeof (mMacBinaryHeader.h3) + sizeof (mMacBinaryHeader.h4)) )				source = (char*)&mMacBinaryHeader.h4 + mPosition - (sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2) + sizeof (mMacBinaryHeader.h3));							byteCount = min (bytesToRead, end - mPosition);			BlockMoveData (source, outBuffer, byteCount);			if (mPosition + byteCount == kMBHeaderSize)			{				if (mMacBinaryHeader.h2.mDataForkLen > 0)					mDataForkStream.Open (mFSSpec, false);				if (mMacBinaryHeader.h2.mResForkLen > 0)					mResourceForkStream.Open (mFSSpec, true);			}		}		else if (mPosition < mCommentOffset)		// Read from file		{			if (mPosition < (end = mDataForkOffset + mMacBinaryHeader.h2.mDataForkLen) )							// Read data fork			{				byteCount = min (bytesToRead, end - mPosition);				err = mDataForkStream.GetBytes (outBuffer, byteCount);					if (err) goto end;			}			else if (mPosition < (end = RoundUpTo128 (mDataForkOffset + mMacBinaryHeader.h2.mDataForkLen)) )		// Pad with zeros			{				byteCount = min (bytesToRead, end - mPosition);				memset (outBuffer, 0, bytesToRead);			}			else if (mPosition < (end = mResourceForkOffset + mMacBinaryHeader.h2.mResForkLen) )					// read resource fork			{				byteCount = min (bytesToRead, end - mPosition);				err = mResourceForkStream.GetBytes (outBuffer, byteCount);				if (err) goto end;			}			else if (mPosition < (end = RoundUpTo128 (mResourceForkOffset + mMacBinaryHeader.h2.mResForkLen)) )		// Pad with zeros			{				byteCount = min (bytesToRead, end - mPosition);				memset (outBuffer, 0, bytesToRead);			}		}		else if (mPosition < GetLength())			// Read comment		{			if (mPosition < (end = mCommentOffset + mMacBinaryHeader.h2.mCommentLength))							// Read comment			{				byteCount = min (bytesToRead, end - mPosition);				BlockMoveData (mComment.c_str() + mPosition - mCommentOffset, outBuffer, byteCount);			}			else																									// Pad with zeros			{				byteCount = min (bytesToRead, GetLength() - mPosition);				memset (outBuffer, 0, byteCount);			}		}		else			return eofErr;						mPosition += byteCount;		bytesToRead -= byteCount;		(char*)outBuffer += byteCount;	}	end:	ioByteCount -= bytesToRead;	return err;}SInt32 LMacBinaryEncoder::GetLength (void) const{	if (!mValidHeader)		return 0;	else		return RoundUpTo128 (mCommentOffset + mMacBinaryHeader.h2.mCommentLength);}bool LMacBinaryEncoder::BuildHeader (void){	CInfoPBRec	pb = {0};	HFileInfo	&info = pb.hFileInfo;	OSErr		err;	DTPBRec		dt = {0};	char		comment[200];		info.ioNamePtr = (unsigned char*)mFSSpec.name;	info.ioVRefNum = mFSSpec.vRefNum;	info.ioFVersNum = 0;	info.ioDirID = mFSSpec.parID;	info.ioFDirIndex = 0;	err = PBGetCatInfoSync (&pb);	if (err)		return false;	if (info.ioFlAttrib & ioDirMask/*kioFlAttribDirMask*/)		return false;			dt.ioCompletion = NULL;	dt.ioNamePtr = 0;	dt.ioVRefNum = mFSSpec.vRefNum;	err = PBDTGetPath (&dt);	dt.ioDTActCount = 0;		if (!err)	{		dt.ioNamePtr = (unsigned char*) mFSSpec.name;		dt.ioDTBuffer = comment;		dt.ioDirID = mFSSpec.parID;		PBDTGetCommentSync (&dt);		mComment.assign (comment, dt.ioDTActCount);	}		mMacBinaryHeader.h1.mOldVersion =				0;		mMacBinaryHeader.h2.mNameLength = 				mFSSpec.name[0];	BlockMoveData (&mFSSpec.name[1], &mMacBinaryHeader.h2.mName[0], mFSSpec.name[0]);	memset (mMacBinaryHeader.h2.mName + mFSSpec.name[0] + 1, 0, sizeof (mMacBinaryHeader.h2.mName) - mFSSpec.name[0] - 1);	mMacBinaryHeader.h2.mType =						info.ioFlFndrInfo.fdType;	mMacBinaryHeader.h2.mCreator =					info.ioFlFndrInfo.fdCreator;	mMacBinaryHeader.h2.mFinderFlags = (Byte)		((info.ioFlFndrInfo.fdFlags & (~kHasBeenInited)) >> 8);	mMacBinaryHeader.h2.mFiller1 =					0;	mMacBinaryHeader.h2.mPosition =					info.ioFlFndrInfo.fdLocation;	mMacBinaryHeader.h2.mFolderID =					0;	mMacBinaryHeader.h2.mProtected =				0;	mMacBinaryHeader.h2.mFiller2 =					0;	mMacBinaryHeader.h2.mDataForkLen =				info.ioFlLgLen;	mMacBinaryHeader.h2.mResForkLen =				info.ioFlRLgLen;	mMacBinaryHeader.h2.mCreationDate =				info.ioFlCrDat;	mMacBinaryHeader.h2.mModificationDate = 		info.ioFlMdDat;	mMacBinaryHeader.h2.mCommentLength =			dt.ioDTActCount;	mMacBinaryHeader.h2.mFinderFlags2 = (Byte)		(info.ioFlFndrInfo.fdFlags & 0x00FF);		mMacBinaryHeader.h3.mSignature =				'mBIN';	mMacBinaryHeader.h3.mScript =					info.ioFlXFndrInfo.fdScript;	mMacBinaryHeader.h3.mXFinderFlags =				info.ioFlXFndrInfo.fdXFlags;	mMacBinaryHeader.h3.mFiller3 =					0;	mMacBinaryHeader.h3.mFiller4 =					0;	mMacBinaryHeader.h3.mTotalFileSize =			0;	mMacBinaryHeader.h3.mSecondaryHeaderLength =	0;	mMacBinaryHeader.h3.mVersionNumber =			130;	mMacBinaryHeader.h3.mMinVersionNumber =			129;		mMacBinaryHeader.h4.mCRC =						mMacBinaryHeader.CalculateCRC();	mMacBinaryHeader.h4.mFiller5 =					0;	mDataForkOffset = kMBHeaderSize;	mResourceForkOffset = RoundUpTo128 (mDataForkOffset + mMacBinaryHeader.h2.mDataForkLen);	mCommentOffset =   RoundUpTo128 (mResourceForkOffset + mMacBinaryHeader.h2.mResForkLen);			return true;}#pragma mark -// ---------------------------------------------------------------------------//	¥ SMacBinaryHeader// ---------------------------------------------------------------------------//unsigned short SMacBinaryHeader::CalculateCRC (void){	unsigned short crc = 0;	int i;		for (i=0; i < sizeof (h1); i++)		crc = CrcCITTA (crc, ((char*)&h1) [i]);	for (i=0; i < sizeof (h2); i++)		crc = CrcCITTA (crc, ((char*)&h2) [i]);	for (i=0; i < sizeof (h3); i++)		crc = CrcCITTA (crc, ((char*)&h3) [i]);			return crc;}inline unsigned short SMacBinaryHeader::short_swap (unsigned short x){	return  (x<<8) | (x>>8) ;}// Code taken from source code posted at MacBinary web siteunsigned short SMacBinaryHeader::CrcCITTA (unsigned short crc, char v){	crc = short_swap (crc) ^ v;	crc = crc ^ ((crc & 0xFF) >> 4);	crc = crc ^ (short_swap (crc & 0xFF) << 4) ^ ((crc & 0xFF) << 5);	return crc;}#pragma mark -// ---------------------------------------------------------------------------//	¥ LMacBinaryDecoder						Constructor				  [public]// ---------------------------------------------------------------------------//LMacBinaryDecoder::LMacBinaryDecoder (void){	mSetFinderPosition = false;	mValidHeader = false;	mFSSpec.vRefNum = 0;	mFSSpec.parID = 0;	mFSSpec.name[0] = 0;}LMacBinaryDecoder::LMacBinaryDecoder (const FSSpec& inTargetDir, SInt32 totalSize, bool setFinderPosition){	SetSpec (inTargetDir, totalSize, setFinderPosition);}LMacBinaryDecoder::~LMacBinaryDecoder (){}void LMacBinaryDecoder::SetSpec (const FSSpec& inTargetDir, SInt32 totalSize, bool setFinderPosition){	mSetFinderPosition = setFinderPosition;		mFSSpec = inTargetDir;	BlockMoveData (inTargetDir.name, mFSSpec.name, inTargetDir.name[0] + 1);		mValidHeader = false;	mTotalSize = totalSize;}SInt32 LMacBinaryDecoder::GetLength (void) const{	if (!mValidHeader || mTotalSize < 0)		return 0;	return mTotalSize;}ExceptionCode LMacBinaryDecoder::PutBytes(	const void*		inBuffer,											SInt32&			ioByteCount){	SInt32		byteCount = 0;	SInt32		bytesToWrite = ioByteCount;	SInt32		end;	OSErr		err = noErr;		while (bytesToWrite)	{		if (mPosition < kMBHeaderSize)		{			void *dest;						if (mPosition < (end = sizeof (mMacBinaryHeader.h1)) )				dest = (char*)&mMacBinaryHeader.h1;			else if (mPosition < (end = sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2)) )				dest = (char*)&mMacBinaryHeader.h2 + mPosition - sizeof (mMacBinaryHeader.h1);			else if (mPosition < (end = sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2) + sizeof (mMacBinaryHeader.h3)) )				dest = (char*)&mMacBinaryHeader.h3 + mPosition - (sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2));			else if (mPosition < (end = sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2) + sizeof (mMacBinaryHeader.h3) + sizeof (mMacBinaryHeader.h4)) )				dest = (char*)&mMacBinaryHeader.h4 + mPosition - (sizeof (mMacBinaryHeader.h1) + sizeof (mMacBinaryHeader.h2) + sizeof (mMacBinaryHeader.h3));							byteCount = min (bytesToWrite, end - mPosition);			BlockMoveData (inBuffer, dest, byteCount);			if ((mPosition + byteCount) == kMBHeaderSize)	// Header is in, set things up for files			{				err = HeaderReceived ();												if (err) goto end;				if (mMacBinaryHeader.h2.mDataForkLen)					mDataForkStream.Open (mFSSpec, false);				if (mMacBinaryHeader.h2.mResForkLen)					mResourceForkStream.Open (mFSSpec, true);			}		}		else if (mPosition < mCommentOffset)		{			if (mPosition < (end = mDataForkOffset + mMacBinaryHeader.h2.mDataForkLen) )				// Write data fork			{				byteCount = min (bytesToWrite, end - mPosition);				err = mDataForkStream.PutBytes (inBuffer, byteCount);					if (err) goto end;			}			else if (mPosition < (end = mResourceForkOffset) )											// Skip pad zeros			{				byteCount = min (bytesToWrite, end - mPosition);			}			else if (mPosition < (end = mResourceForkOffset + mMacBinaryHeader.h2.mResForkLen) )		// Write resource fork			{				byteCount = min (bytesToWrite, end - mPosition);				err = mResourceForkStream.PutBytes (inBuffer, byteCount);				if (err) goto end;			}			else if (mPosition < (end = mCommentOffset) )												// Skip pad zeros			{				byteCount = min (bytesToWrite, end - mPosition);			}		}		else		{			if (mPosition < (end = mCommentOffset + mMacBinaryHeader.h2.mCommentLength))			{				byteCount = min (bytesToWrite, end - mPosition);				mComment.append ((char*)inBuffer, (unsigned long) byteCount);			}// Skip zeros, set info according to header			else				{				end = mTotalSize;				byteCount = min (bytesToWrite, end - mPosition);			}		}		mPosition += byteCount;		bytesToWrite -= byteCount;		((char*)inBuffer) += byteCount;		if ((mPosition >= mTotalSize) && (mValidHeader))		{			FinishFile ();			break;		}	}	end:	ioByteCount -= bytesToWrite;	return err;}ExceptionCode LMacBinaryDecoder::FinishFile (void){// Set finder info	CInfoPBRec			pb;	OSErr				err;	static const Point	zeroPt = {0};		mDataForkStream.Close();	mResourceForkStream.Close();		pb.hFileInfo.ioCompletion =						NULL;	pb.hFileInfo.ioVRefNum =						mFSSpec.vRefNum;	pb.hFileInfo.ioDirID =							mFSSpec.parID;	pb.hFileInfo.ioNamePtr =						mFSSpec.name;	pb.hFileInfo.ioFlFndrInfo.fdType =				mMacBinaryHeader.h2.mType;	pb.hFileInfo.ioFlFndrInfo.fdCreator =			mMacBinaryHeader.h2.mCreator;	pb.hFileInfo.ioFlFndrInfo.fdFlags = 			( (((short)mMacBinaryHeader.h2.mFinderFlags) << 8) | mMacBinaryHeader.h2.mFinderFlags2 );	pb.hFileInfo.ioFlFndrInfo.fdFlags &= ~kHasBeenInited;		if (mSetFinderPosition)		pb.hFileInfo.ioFlFndrInfo.fdLocation = 		mMacBinaryHeader.h2.mPosition;	else		pb.hFileInfo.ioFlFndrInfo.fdLocation =		zeroPt;	pb.hFileInfo.ioFlFndrInfo.fdFldr =				0;	pb.hFileInfo.ioFlCrDat =						mMacBinaryHeader.h2.mCreationDate;	pb.hFileInfo.ioFlMdDat = 						mMacBinaryHeader.h2.mModificationDate;	pb.hFileInfo.ioFlMdDat = 						mMacBinaryHeader.h2.mCreationDate;	pb.hFileInfo.ioFlXFndrInfo.fdIconID =			0;	pb.hFileInfo.ioFlXFndrInfo.fdReserved[0] =	pb.hFileInfo.ioFlXFndrInfo.fdReserved[1] =	pb.hFileInfo.ioFlXFndrInfo.fdReserved[2] =		0;	pb.hFileInfo.ioFlXFndrInfo.fdScript = 			mMacBinaryHeader.h3.mScript;	pb.hFileInfo.ioFlXFndrInfo.fdXFlags = 			mMacBinaryHeader.h3.mXFinderFlags;	pb.hFileInfo.ioFlXFndrInfo.fdComment =			0;	pb.hFileInfo.ioFlXFndrInfo.fdPutAway =			0;		err = PBSetCatInfoSync (&pb);				if (err) return err;	// Set comment	if (mComment.size())	{		DTPBRec	dt = {0};					dt.ioCompletion = NULL;		dt.ioNamePtr = 0;		dt.ioVRefNum = mFSSpec.vRefNum;		err = PBDTGetPath (&dt);				if (!err)		{			dt.ioCompletion = NULL;			dt.ioNamePtr = (unsigned char*) mFSSpec.name;			dt.ioDirID = mFSSpec.parID;			dt.ioDTBuffer = (char*) mComment.c_str();			dt.ioDTReqCount = mComment.size();			PBDTSetCommentSync (&dt);		}	}	return noErr;}ExceptionCode LMacBinaryDecoder::HeaderReceived (void){	OSErr	err = noErr;	bool	result;	SInt32	totalGoodSize;	SInt32	totalBadSize;			err = mMacBinaryHeader.h3.mVersionNumber <= 130 ? noErr : -1;							if (err) goto end;	err = mMacBinaryHeader.h2.mNameLength <= 63 ? noErr : -1;								if (err) goto end;			result = MakeNewFSSpec (mFSSpec, mFSSpec.vRefNum, mFSSpec.parID, string(mMacBinaryHeader.h2.mName, mMacBinaryHeader.h2.mNameLength), true);		if (result == false)		return bdNamErr;	mValidHeader = true;	mDataForkOffset = kMBHeaderSize;	/*	An ugly kludge to account for a bug with IE Macbinary encoding in uploads.	For some reason, IE (version 5.0 at least) uses the wrong formula to calculate 	the number of padding bytes. The way we check for that is by calculating the total	file size by both correct and incorrect methods and seeing which matches the real	size. Another way would be by checking the bytes following the data fork and use	some heuristics to look for the beginning of the resource fork. This would take	more work, but would eliminate the need for knowing the total file size in advance.*/	totalGoodSize = mDataForkOffset +						RoundUpTo128 (mMacBinaryHeader.h2.mDataForkLen) +						RoundUpTo128 (mMacBinaryHeader.h2.mResForkLen) + 						RoundUpTo128 (mMacBinaryHeader.h2.mCommentLength) +						RoundUpTo128 (mMacBinaryHeader.h3.mSecondaryHeaderLength);	totalBadSize = mDataForkOffset +						BadRoundUpTo128 (mMacBinaryHeader.h2.mDataForkLen) +						BadRoundUpTo128 (mMacBinaryHeader.h2.mResForkLen) + 						BadRoundUpTo128 (mMacBinaryHeader.h2.mCommentLength) +						BadRoundUpTo128 (mMacBinaryHeader.h3.mSecondaryHeaderLength);	if (mTotalSize)	{		if (mTotalSize == totalGoodSize)		{			mResourceForkOffset = RoundUpTo128 (mDataForkOffset + mMacBinaryHeader.h2.mDataForkLen);			mCommentOffset = RoundUpTo128 (mResourceForkOffset + mMacBinaryHeader.h2.mResForkLen);		}		else if (mTotalSize == totalBadSize )		{			mResourceForkOffset = BadRoundUpTo128 (mDataForkOffset + mMacBinaryHeader.h2.mDataForkLen);			mCommentOffset = BadRoundUpTo128 (mResourceForkOffset + mMacBinaryHeader.h2.mResForkLen);		}		else		{			err = -1;			goto end;		}	}	else {		mTotalSize = totalGoodSize;		mResourceForkOffset = RoundUpTo128 (mDataForkOffset + mMacBinaryHeader.h2.mDataForkLen);		mCommentOffset = RoundUpTo128 (mResourceForkOffset + mMacBinaryHeader.h2.mResForkLen);	}		if (mMacBinaryHeader.h2.mDataForkLen > 0)	{		err = ::FSpCreate (&mFSSpec, '????', '????', mMacBinaryHeader.h3.mScript);			if (err) goto end;	}	if (mMacBinaryHeader.h2.mResForkLen > 0)	{		::FSpCreateResFile (&mFSSpec, '????', '????', mMacBinaryHeader.h3.mScript);		err = ResError();																	if (err) goto end;	}end:	return err;}