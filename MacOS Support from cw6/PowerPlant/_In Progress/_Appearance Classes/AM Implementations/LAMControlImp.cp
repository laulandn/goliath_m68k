// ===========================================================================//	LAMControlImp.cp			PowerPlant 2.1		©1997-1999 Metrowerks Inc.// ===========================================================================#ifdef PowerPlant_PCH	#include PowerPlant_PCH#endif#include <LAMControlImp.h>#include <UAppearance.h>#include <UDrawingUtils.h>#include <UEnvironment.h>#include <UQDOperators.h>#include <UTextTraits.h>#include <UTBAccessors.h>#include <CustomTextColorCDEF.h>#include <MacWindows.h>PP_Begin_Namespace_PowerPlant// ---------------------------------------------------------------------------//	Class VariablesLAMControlImp*	LAMControlImp::sControlImpBeingDrawn = nil;static CustomTextColorUPP	sTextColorUPP = nil;// ---------------------------------------------------------------------------//	Function Prototypesstatic pascal voidCustomTextColorProc(	ControlHandle				inMacControlH,	ControlApplyTextColorPtr	inColorInfo);// ---------------------------------------------------------------------------//	¥ LAMControlImp					Stream/Default Constructor		  [public]// ---------------------------------------------------------------------------//	Do not access inStream. It may be nil. Read Stream data in Init()LAMControlImp::LAMControlImp(	LStream*	inStream)	: LStdControlImp(inStream){}// ---------------------------------------------------------------------------//	¥ MakeMacControl											   [protected]// ---------------------------------------------------------------------------voidLAMControlImp::MakeMacControl(	ConstStringPtr	inTitle,	SInt32			inRefCon){									// Set variant for using custom font									//   if we have Text Traits	SInt16	controlKind = mControlKind;	if (mTextTraitsID != 0) {		controlKind += kControlUsesOwningWindowsFontVariant;	}	Rect	frame;					// Get Frame in Local coordinates	if (!CalcLocalFrameRect(frame)) {			// Frame is outside of QuickDraw space. NewControl requires			// a rectangle in QuickDraw space, so we have to use an			// artificial location. The Control won't get drawn until			// its SuperView scrolls it into view.		SDimension16	frameSize;		mControlPane->GetFrameSize(frameSize);		::MacSetRect(&frame, 0, 0, frameSize.width, frameSize.height);	}	StFocusAndClipIfHidden	focus(mControlPane);			// Controls must be created within a Window. First			// try the port containing the ControlPane. If that's			// nil, the ControlPane hasn't been installed yet so			// we use the current port and make it the responsibility			// of the caller to set the port correctly.	WindowPtr		macWindowP = mControlPane->GetMacWindow();	if (macWindowP == nil) {		macWindowP = UQDGlobals::GetCurrentWindowPort();	}									// Check if there is a root control	ControlHandle	rootControl;	ControlHandle	textColorControl = nil;	OSErr	err = ::GetRootControl(macWindowP, &rootControl);	if (err == errNoRootControl) {			// There is no root control, so we must create one.			// This happens for the first AM control in a window.		err = ::CreateRootControl(macWindowP, &rootControl);		if (err == errControlsAlreadyExist) {			// This error (-30589) means that a Standard (old-style)			// Toolbox control was created in the window before the			// first Appearance Toolbox control. If you are mixing old			// and new style Toolbox controls in the same window, you			// must create a new style one first.			//			// If you are creating a window from a PPob resource, you			// can satisfy this requirement by opening the PPob in			// Constructor and choosing "Show Object Hierarchy" from			// the Layout menu. In the Hierarchy window, arrange the			// Panes via drag-and-drop so that an Appearance control			// is created before any old-style control.			//			// Note that LListBox and LScroller will create old-style			// scroll bar controls, and that the Appearance StaticText and			// EditText panes are not new-style controls (since they			// don't actually use a ControlHandle). Use LScrollerView			// in place of LScroller/LActiveScroller.			//			// If you are installing controls at runtime, create an			// Appearance control first, or call ::CreateRootControl()			// yourself before creating any Toolbox controls.			SignalStringLiteral_("Must create an Appearance control before "						 		 "creating an old-style control. See comments "								 "in the source file.");		}		ThrowIfOSErr_(err);			// On a system with Themes (PPC with Mac OS 8.5 or later),			// we need to create a custom control in order to set up			// the correct color for the text of controls embedded within			// other controls. For example, a checkbox within a placard.		textColorControl = MakeCustomTextColorControl(macWindowP, rootControl);	} else {				// Root control already exists. The custom text color				// control is the first subcontrol of the root.		#if TARGET_CPU_PPC			if (UEnvironment::HasFeature(env_HasAppearance11)) {				::GetIndexedSubControl(rootControl, 1, &textColorControl);			}		#endif	}			// Create Toolbox Control. During construction Panes are			// always invisible and disabled, so we pass "false" for			// the "visible" parameter to NewControl. Since NewControl			// always creates enabled controls, we then explicitly			// disable the control.	mMacControlH = ::NewControl(macWindowP, &frame, inTitle, false,								(SInt16) mControlPane->PeekValue(),								(SInt16) mControlPane->GetMinValue(),								(SInt16) mControlPane->GetMaxValue(),								controlKind, inRefCon);	ThrowIfNil_(mMacControlH);	::DeactivateControl(mMacControlH);			// Embed this control inside our special textColorControl			// which sets the proper Theme text color for drawing	if (textColorControl != nil) {		::EmbedControl(mMacControlH, textColorControl);	}	if (mTextTraitsID != 0) {		ResIDT	saveID = mTextTraitsID;		mTextTraitsID = 0;		SetTextTraitsID(saveID);	}}// ---------------------------------------------------------------------------//	¥ MakeCustomTextColorControl								   [protected]// ---------------------------------------------------------------------------//	Make control which let's us set up the text color for embedded controls////	On Systems with Appearance 1.1 (which includes all 68K machines),//		control is nil. It's not needed because Themes don't exist.////	On Classic PPC, we create a control using our custom CDEF. You must//		include CustomTextColorCDEF.rsrc in the project for Classic targets.////	On Carbon, we create a custom control which points to a function within//		this program. You must include CustomTextColorCDEF.cp in the project//		for Carbon targets.ControlHandleLAMControlImp::MakeCustomTextColorControl(	WindowPtr		inMacWindow,	ControlHandle	inRootControl){	ControlHandle	textColorControl = nil;#if TARGET_CPU_PPC						// CustomTextControl is PPC only	#if PP_Target_Classic				// For Classic we use a CDEF		#ifdef Debug_Signal			Handle	textColorCDEF =				::GetResource(kControlDefProcType, CDEF_CustomTextColor);			if (textColorCDEF == nil) {				SignalStringLiteral_("AM Control Imps requires CDEF 83. "									 "Add CustomTextColorCDEF.rsrc to your "									 "project");			}		#endif										// Custom control needed for AM 1.1		if (UEnvironment::HasFeature(env_HasAppearance11)) {			if (sTextColorUPP == nil) {				sTextColorUPP = NewCustomTextColorProc(CustomTextColorProc);			}				// Custom text color control must fit inside root control,				// yet be big enough to enclose all other controls.			Rect	rootRect;			::GetControlBounds(inRootControl, &rootRect);			::MacInsetRect(&rootRect, 1, 1);										// Refcon is a pointer to our										//   text color function			textColorControl = ::NewControl(inMacWindow, &rootRect,											Str_Empty, true, 0, 0, 0,											CDEFProc_CustomTextColor,											(SInt32) sTextColorUPP);		}	#elif PP_Target_Carbon			// For Carbon, the custom control code is just a function			// that's part of this program. You need to include the			// file CustomTextColorCDEF.cp in your project for Carbon			// targets.		Rect	rootRect;		::GetControlBounds(inRootControl, &rootRect);		::MacInsetRect(&rootRect, 1, 1);		ControlDefSpec	theSpec;		theSpec.defType = kControlDefProcPtr;		theSpec.u.defProc = NewControlDefUPP(CustomTextColorCDEFmain);		OSStatus	status = ::CreateCustomControl(inMacWindow, &rootRect,									&theSpec, nil, &textColorControl);		ThrowIfOSStatus_(status);										// Refcon is a pointer to our										//   text color function		::SetControlReference(textColorControl, (SInt32) CustomTextColorProc);		::SetControlVisibility(textColorControl, true, false);	#endif // PP_Target_Carbon#else // 68K CPU	#pragma unused(inMacWindow, inRootControl)#endif	return textColorControl;}// ---------------------------------------------------------------------------//	¥ ~LAMControlImp						Destructor				  [public]// ---------------------------------------------------------------------------LAMControlImp::~LAMControlImp(){}#pragma mark -// ---------------------------------------------------------------------------//	¥ SetDescriptor													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::SetDescriptor(	ConstStringPtr	inDescriptor){	sControlImpBeingDrawn = this;	LStdControlImp::SetDescriptor(inDescriptor);	sControlImpBeingDrawn = nil;}// ---------------------------------------------------------------------------//	¥ SetValue														  [public]// ---------------------------------------------------------------------------voidLAMControlImp::SetValue(	SInt32		inValue){	sControlImpBeingDrawn = this;	LStdControlImp::SetValue(inValue);	sControlImpBeingDrawn = nil;}// ---------------------------------------------------------------------------//	¥ SetMinValue													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::SetMinValue(	SInt32		inMinValue){	sControlImpBeingDrawn = this;	LStdControlImp::SetMinValue(inMinValue);	sControlImpBeingDrawn = nil;}// ---------------------------------------------------------------------------//	¥ SetMaxValue													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::SetMaxValue(	SInt32		inMaxValue){	sControlImpBeingDrawn = this;	LStdControlImp::SetMaxValue(inMaxValue);	sControlImpBeingDrawn = nil;}#pragma mark -// ---------------------------------------------------------------------------//	¥ TrackHotSpot													  [public]// ---------------------------------------------------------------------------BooleanLAMControlImp::TrackHotSpot(	SInt16		/* inHotSpot */,	Point		inPoint,	SInt16		inModifiers){		// HandleControlClick handles tracking and returns kControlNoPart		// if the mouse is released outside the HotSpot	sControlImpBeingDrawn = this;	SInt16	origValue = ::GetControlValue(mMacControlH);	Boolean	releasedInHotSpot =		::HandleControlClick( mMacControlH, inPoint,								(EventModifiers) inModifiers,								(ControlActionUPP) (-1) )									!= kControlNoPart;	sControlImpBeingDrawn = nil;		// Control Manager can change the value while tracking.		// If it did, we need to call SetValue() to update the		// class's copy of the value.	SInt16	currValue = ::GetControlValue(mMacControlH);	if (currValue != origValue) {		mControlPane->SetValue(currValue);	}	return releasedInHotSpot;}// ---------------------------------------------------------------------------//	¥ DrawSelf														  [public]// ---------------------------------------------------------------------------voidLAMControlImp::DrawSelf(){	sControlImpBeingDrawn = this;	::DrawControlInCurrentPort(mMacControlH);	sControlImpBeingDrawn = nil;}// ---------------------------------------------------------------------------//	¥ ShowSelf														  [public]// ---------------------------------------------------------------------------voidLAMControlImp::ShowSelf(){	::SetControlVisibility(mMacControlH, true, Refresh_No);}// ---------------------------------------------------------------------------//	¥ HideSelf														  [public]// ---------------------------------------------------------------------------voidLAMControlImp::HideSelf(){	::SetControlVisibility(mMacControlH, false, Refresh_No);}// ---------------------------------------------------------------------------//	¥ ActivateSelf													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::ActivateSelf(){		// Control Manager does not have separate active and enabled		// states. We call the Toolbox ActivateControl only if the		// PP Pane is both active and enabled.	if (mControlPane->GetEnabledState() == triState_On) {		// PP Panes don't usually draw when activating. Therefore,		// we suppress the automatic drawing done by the Control		// Manager and force a refresh so things will draw during		// the next update event.		mControlPane->FocusDraw();		StClipRgnState	dontDraw(nil);		::ActivateControl(mMacControlH);		RefreshControlPane();	}}// ---------------------------------------------------------------------------//	¥ DeactivateSelf												  [public]// ---------------------------------------------------------------------------voidLAMControlImp::DeactivateSelf(){		// Do nothing if Toolbox control is already inactive. This happens		// because the Toolbox does not have separate active and enabled		// states. If we deactivate and control that is disabled, this		// is a PP state change but not a Toolbox one.	if (::IsControlActive(mMacControlH)) {		// PP Panes don't usually draw when deactivating. Therefore,		// we suppress the automatic drawing done by the Control		// Manager and force a refresh so things will draw during		// the next update event.		mControlPane->FocusDraw();		StClipRgnState	dontDraw(nil);		::DeactivateControl(mMacControlH);		RefreshControlPane();	}}// ---------------------------------------------------------------------------//	¥ EnableSelf													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::EnableSelf(){		// Control Manager does not have separate active and enabled		// states. We call the Toolbox ActivateControl only if the		// PP Pane is both active and enabled.	if (mControlPane->GetActiveState() == triState_On) {		// PP Panes don't usually draw when deactivating. Therefore,		// we suppress the automatic drawing done by the Control		// Manager and force a refresh so things will draw during		// the next update event.		mControlPane->FocusDraw();		StClipRgnState	dontDraw(nil);		::ActivateControl(mMacControlH);		RefreshControlPane();	}}// ---------------------------------------------------------------------------//	¥ DisableSelf													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::DisableSelf(){	DeactivateSelf();}// ---------------------------------------------------------------------------//	¥ RefreshControlPane										   [protected]// ---------------------------------------------------------------------------//	Invalidate area covered by bounds of Toolbox control////	This differs from LPane::Refresh() in that we invalidate the entire//	frame of the Pane instead of just the revealed area. We need to do//	this to undo the automatic validation performed by the ControlManager//	in some cases.voidLAMControlImp::RefreshControlPane(){	if (IsControlVisible(mMacControlH)) {	// Only refresh if visible		Rect	refreshRect;		mControlPane->CalcPortFrameRect(refreshRect);		mControlPane->InvalPortRect(&refreshRect);	}}#pragma mark -// ---------------------------------------------------------------------------//	¥ SetDataTag													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::SetDataTag(	SInt16			inPartCode,	FourCharCode	inTag,	Size			inDataSize,	void*			inDataPtr){	StFocusAndClipIfHidden	focus(mControlPane);	// Control may draw	OSErr err = ::SetControlData(mMacControlH, inPartCode, inTag,						inDataSize, (Ptr) inDataPtr);	SignalIf_(err != noErr);				// Not setting data isn't fatal	mControlPane->Draw(nil);}// ---------------------------------------------------------------------------//	¥ GetDataTag													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::GetDataTag(	SInt16			inPartCode,	FourCharCode	inTag,	Size			inBufferSize,	void*			inBuffer,	Size*			outDataSize) const{	OSErr err = ::GetControlData(mMacControlH, inPartCode, inTag,					inBufferSize, (Ptr) inBuffer, outDataSize);	ThrowIfOSErr_(err);					// Most likely an invalid tag}// ---------------------------------------------------------------------------//	¥ SetTextTraitsID												  [public]// ---------------------------------------------------------------------------voidLAMControlImp::SetTextTraitsID(	ResIDT		inTextTraitsID){	if (mTextTraitsID != inTextTraitsID) {		mTextTraitsID = inTextTraitsID;		Refresh();		TextTraitsRecord	textTraits;		UTextTraits::LoadTextTraits(mTextTraitsID, textTraits);		ControlFontStyleRec	styleRec;		styleRec.flags	= kControlUseFontMask +							kControlUseFaceMask +							kControlUseSizeMask +							kControlUseModeMask +							kControlUseJustMask;		styleRec.font	= textTraits.fontNumber;		styleRec.size	= textTraits.size;		styleRec.style	= textTraits.style;		styleRec.mode	= textTraits.mode;		styleRec.just	= textTraits.justification;			// Black is the default color, so we only need to set the			// color if it isn't black.		if (textTraits.color != Color_Black) {			styleRec.flags	  += kControlUseForeColorMask;			styleRec.foreColor = textTraits.color;		}		SetFontStyle(styleRec);	}}// ---------------------------------------------------------------------------//	¥ SetFontStyle													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::SetFontStyle(	const ControlFontStyleRec&	inStyleRec){	OSErr err = ::SetControlFontStyle(mMacControlH, &inStyleRec);	ThrowIfOSErr_(err);}// ---------------------------------------------------------------------------//	¥ GetFontStyle													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::GetFontStyle(	ControlFontStyleRec&	outStyleRec) const{	OSErr err = ::GetControlData(mMacControlH, 0, kControlFontStyleTag,					sizeof(ControlFontStyleRec), (Ptr) &outStyleRec, nil);	ThrowIfOSErr_(err);}// ---------------------------------------------------------------------------//	¥ SetScrollViewSize												  [public]// ---------------------------------------------------------------------------//	Used only for scroll bars to set the size of the view being scrolled//	in order to implement proportional scroll bar thumbsvoidLAMControlImp::SetScrollViewSize(	SInt32		inViewSize){	UAppearance::SetControlViewSize(mMacControlH, inViewSize);}#pragma mark -// ---------------------------------------------------------------------------//	¥ Idle															  [public]// ---------------------------------------------------------------------------voidLAMControlImp::Idle(){	if (mControlPane->FocusExposed()) {		::SendControlMessage(mMacControlH, kControlMsgIdle, 0);	}}// ---------------------------------------------------------------------------//	¥ DoKeyPress													  [public]// ---------------------------------------------------------------------------//	Handle keyboard input in a control////	Returns the control part code that was hit by the key eventSInt16LAMControlImp::DoKeyPress(	const EventRecord&	inKeyEvent){	StFocusAndClipIfHidden	focus(mControlPane);	return  ::HandleControlKey(	mMacControlH,								(SInt16) (inKeyEvent.message & keyCodeMask),								(SInt16) (inKeyEvent.message & charCodeMask),								inKeyEvent.modifiers);}// ---------------------------------------------------------------------------//	¥ BeTarget														  [public]// ---------------------------------------------------------------------------voidLAMControlImp::BeTarget(	ControlFocusPart	inFocusPart){	if (inFocusPart != kControlFocusNoPart) {		StFocusAndClipIfHidden	focus(mControlPane);		::SetKeyboardFocus(::GetControlOwner(mMacControlH), mMacControlH,							inFocusPart);	}}// ---------------------------------------------------------------------------//	¥ DontBeTarget													  [public]// ---------------------------------------------------------------------------voidLAMControlImp::DontBeTarget(){	StFocusAndClipIfHidden	focus(mControlPane);	::SetKeyboardFocus(::GetControlOwner(mMacControlH), mMacControlH,						kControlFocusNoPart);}// ---------------------------------------------------------------------------//	¥ SetKeyboardFocusPart											  [public]// ---------------------------------------------------------------------------//	Set the keyboard focus to the specified part of the control.////	This function does not set the PowerPlant Target. The control should//	already be the Target beforehand. A typical use of this function is//	to move the focus within a multipart control in response to the tab key.////	Returns false if the part could not be focused. When passing//	kControlFocusNextPart or kControlFocusPrevPart, this means that the//	focus was at the end/start of the subparts. In which case, the focus//	should move to the next/previous Control or wrap around if there//	are no other Controls in the tab group.boolLAMControlImp::SetKeyboardFocusPart(	ControlFocusPart		inFocusPart){	StFocusAndClipIfHidden	focus(mControlPane);		// Call the CDEF directly. The high level routines such as		// SetKeyboardFocus() have unwanted side effects and don't		// give us the info we need about wrap around situations.	SInt32	result = ::SendControlMessage(mMacControlH, kControlMsgFocus, inFocusPart);	return (result != kControlFocusNoPart);}#pragma mark -// ---------------------------------------------------------------------------//	¥ ApplyTextColor// ---------------------------------------------------------------------------voidLAMControlImp::ApplyTextColor(	SInt16		inDepth,	bool		inHasColor,	bool		inIsActive){	TextTraitsRecord	textTraits;	UTextTraits::LoadTextTraits(mTextTraitsID, textTraits);	if (textTraits.color == Color_Black) {		mControlPane->GetEmbeddedTextColor(inDepth, inHasColor, inIsActive,											textTraits.color);	} else if (!IsActive() || !IsEnabled()) {		UTextDrawing::DimTextColor(textTraits.color);	}	::RGBForeColor(&textTraits.color);}// ---------------------------------------------------------------------------//	¥ CustomTextColorProc// ---------------------------------------------------------------------------static pascal voidCustomTextColorProc(	ControlHandle				/* inMacControlH */,	ControlApplyTextColorPtr	inColorInfo){	try {		if (LAMControlImp::sControlImpBeingDrawn != nil) {			LAMControlImp::sControlImpBeingDrawn->ApplyTextColor(						inColorInfo->depth,						inColorInfo->colorDevice,						inColorInfo->active);		}	}	catch (...) { }			// Don't propagate exception into Toolbox!}PP_End_Namespace_PowerPlant