/*  Metrowerks Standard Library  Version 4.0  1998 August 10  *//*  $Date: 1999/03/12 17:53:05 $  *  $Revision: 1.6 $  *  $NoKeywords: $  * *		Copyright © 1995-1998 Metrowerks, Inc. *		All rights reserved. */ /* *	string.win32.h */#ifndef _STRING_WIN32_H          /* hh 971206 */#define _STRING_WIN32_H#include <ansi_parms.h>          /* hh 971206 */#include <cstring>               /* hh 980122 */#ifdef __cplusplus          /* hh 971206 */	extern "C" {#endif// compute length of a zero terminated stringsize_t strlen(const char *s){	size_t	len = 0;	    asm    {		xor		eax, eax				// byte to scan for    	mov		edi, s					// get the string		mov		ecx, 0xffffffff			// max string length		    	    lab:		repne	scasb					// scan for that zero		    out:		neg		ecx						// length is -ecx+2		lea		len, -2[ecx]    }        return len;}// Copy a string up to the zero terminating bytechar * strcpy(char * dest, const char * src){    asm    {        mov		edi, dest				// get the dest        mov		esi, src				// get the source            lab:        lodsb							// move a byte        stosb		test	al, al					// was it zero		jne		lab						// loop if not    }        return dest;}// Copy a string up to the zero terminating byte or a max lenchar * strncpy(char * dest, const char * src, size_t max){    asm    {        mov		ecx, max				// get the max count        mov		edi, dest				// and the dest        mov		esi, src				// and the source		add		ecx, edi				// adress of last byte to move		jmp		test					// skip in case no bytes to move		align		           lab:        lodsb							// move a byte        stosb		test	al, al					// was it zero?		je		pad						// if so, pad the rest			test:		cmp		edi, ecx				// check for done		jb		lab						// and loop if more		jmp		end    // padding the string. ecx point to the end of the string,    // al is zero    		align    pad:		sub		ecx, edi				// get count to pad		rep		stosb					// and do it	end:    }        return dest;}// Concat one string to anotherchar * strcat(char * dest, const char * src){    asm    {        mov		edi, dest				// get dest pointer		xor		eax, eax		mov		esi, src				// get the source		                      mov		ecx, 0xffffffff			// scan to end of dest string        repne 	scasb		dec		edi			lab:		lodsb							// move a byte		stosb		test	al, al					// was it zero?		jne		lab						// loop if so    }        return dest;}// concat one string to another to a max lengthchar * strncat(char * dest, const char * src, size_t max){    asm     {		mov		edx, max				// get count		test	edx, edx				// get out quick if it is zero		je		done		mov		edi, dest				// get dest	    	mov		esi, src				// get source		mov		ecx, 0xffffffff			// max strlen		xor		eax, eax			repne	scasb					// scan to end of dest		dec		edi						// back up to the zero byte			copy:			lodsb							// move a byte		stosb		test	al, al					// was it 0		je		done					// time to quit				sub		edx, 1					// decrement count		jne		copy					// and loop if there is more						xor		eax, eax				// on fall through, append a 0		stosb			done:	    }        return dest;}// Compare to zero termianted stringint strcmp(const char * s1, const char *s2){	int result = 0;    asm    {    	mov		ecx, s1				// get str1    	mov		edx, s2				// and str2    lab:    	mov		al, [ecx]			// get a byte from str1    	cmp		al, [edx]			// compare it to str2    	jne		out					// if not equal we are done    	    	inc		ecx					// bump the pointers    	inc		edx    			test	al, al				// and check for end of string		jne		lab					// looping if not    	jmp		done				// return 0 if they are    	    	align    out:    	movzx	edx, byte ptr [edx]		movzx	eax, al    	sub		eax, edx		mov		result, eax			done:    }        return result;}// Compare two strings up to a max lenint strncmp(const char *s1, const char *s2, size_t n){	int result = 0;    asm    {		mov		edx, n				// get the count    	mov		ebx, s1				// get str1    	mov		ecx, s2				// and str2    			test	edx, edx			// if count is zero		je		done				// they are equal				    lab:    	mov		al, [ebx]			// get a byte from str1    	cmp		al, [ecx]			// compare it to str2    	jne		out					// if not equal we are done    			test	al, al				// and check for end of string		je		out					// looping if not    	inc		ebx					// bump the pointers    	inc		ecx    	    	    	sub		edx,1				// decrement count    	jne		lab					// and loop if not done    	jmp		done    	    out:    	movzx	ecx, byte ptr [ecx]		movzx	eax, al    	sub		eax, ecx    	mov		result, eax	done:    }        return result;}// Search for a char in a stringchar * strchr(const char *s, int c){	char *loc = 0;    asm    {    	mov		esi, s				// get source    	mov		ecx, c				// get char	    lab:		lodsb						// load a byte		cmp		al, cl				// check it		je		out					// if equal we found it				test	al, al				// check for zero terminator		jne		lab		jmp		done				// not found, return 0    					align	out:		lea		loc, -1[esi]		// found, return address    done:    }        return loc;}#ifdef __cplusplus          /* hh 971206 */	}#endif#endif/* * Change Record * hh 971206  Added include guards * hh 971206  Added namespace support * hh 980122  Added <cstring> for prototypes * bk 980806  Fixes bug in strcmp and strncmp in which string compares *            did not work properly  with bytes in the range of 128...255 *            (-128...-1 signed) * blc 990309 Changed to use non-declspec(naked) implementation * blc 990310 Fixed code in strncmp and strlen (left in naked's pops) */