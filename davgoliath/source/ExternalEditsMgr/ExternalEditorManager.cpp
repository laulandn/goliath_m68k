/* ================================================================================================== * ExternalEditorManager.cpp											    *    Goliath - a Finder like application that implements WebDAV *    Copyright (C) 1999-2002  Thomas Bednarz * *    This program is free software; you can redistribute it and/or modify *    it under the terms of the GNU General Public License as published by *    the Free Software Foundation; either version 2 of the License, or *    (at your option) any later version. * *    This program is distributed in the hope that it will be useful, *    but WITHOUT ANY WARRANTY; without even the implied warranty of *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the *    GNU General Public License for more details. * *    You should have received a copy of the GNU General Public License *    along with this program; if not, write to the Free Software Foundation, *    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. * *  For questions, suggestions, bug-reports, enhancement-requests etc. *  I may be contacted at: * *  tombednarz@hotmail.com * =========================================================================== */#ifndef __ExternalEditorManager_h__#include "ExternalEditorManager.h"#endif#ifndef __ExternalEditContext_h__#include "ExternalEditContext.h"#endif#ifndef __AppLauncher_h__#include "AppLauncher.h"#endif#include "PropListParser.h"#include <CDAVTranscodeUtils.h>#include <CDAVContext.h>#include "CDAVItemUtils.h"#include "ParseConnectionDocument.h"#include "CDAVLibUtils.h"#include "CDAVTableApp.h"#include "CDAVTableWindow.h"#include <memory>#include <cassert>#include <vector>#include <string.h>#include <stdlib.h>const char* kPropListAppName = "app.name";const char* kPropListAppCode = "app.code";const char* kPropListEditConnection = "cdat";const char* kPropListEditAlias = "alias";const char* kPropListEditEncodeRes = "encres";const char* kPropListEditLastMod = "lastmod";std::auto_ptr<ExternalEditorManager> gExtEditMgr;const int kNumFixedMenuItems = 4;// ---------------------------------------------------------------------------------//		¥ GetExternalEditsMgr()// ---------------------------------------------------------------------------------//ExternalEditorManager* ExternalEditorManager::GetExternalEditsMgr() {	assert(NULL != gExtEditMgr.get());	return gExtEditMgr.get();}// ---------------------------------------------------------------------------------//		¥ ExternalEditsMgrInitialized()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::ExternalEditsMgrInitialized() {	if (NULL == gExtEditMgr.get())		return false;	return gExtEditMgr->mInit;}// ---------------------------------------------------------------------------------//		¥ GetExternalEditsMgr()// ---------------------------------------------------------------------------------//void ExternalEditorManager::InitializeExternalEditMgr(const FSSpec& inAppListStore, 	CommandT inStartEditCommand, SInt16	inEditCommandRange,CommandT subMenuCMD,	const LStr255& inEditRootDirName, const FSSpec& inEditFileStorage) {	assert(NULL == gExtEditMgr.get());	if (NULL != gExtEditMgr.get()) 		return;	gExtEditMgr = std::auto_ptr<ExternalEditorManager>(new ExternalEditorManager(inAppListStore,	 	inStartEditCommand, inEditCommandRange, subMenuCMD, inEditRootDirName, inEditFileStorage));}// ---------------------------------------------------------------------------------//		¥ ExternalEditorManager()// ---------------------------------------------------------------------------------//ExternalEditorManager::ExternalEditorManager(const FSSpec& inAppListStore, 												CommandT inStartEditCommand,												SInt16	inEditCommandRange,												CommandT subMenuCMD,												const LStr255& inEditRootDirName,												const FSSpec& inEditFileStorage):	mAppListStore(inAppListStore),	mEditFileStore(inEditFileStorage),	mFirstEditCmd(inStartEditCommand),	mCommandRnge(inEditCommandRange),	mInit(false){	ResIDT			menuID;	MenuRef			menuHandle;	SInt16			itemNum;	SInt16	hierID = 0;	LMenu* origMenu = NULL;		LMenuBar::GetCurrentMenuBar()->FindMenuItem(subMenuCMD, menuID, menuHandle, itemNum);	if (NULL == menuHandle)		throw;		if (((::GetMenuItemHierarchicalID(menuHandle, itemNum, &hierID) == noErr && hierID != 0)) &&	 	(origMenu = LMenuBar::GetCurrentMenuBar()->FetchMenu( hierID ))!=NULL) {	 	mAppEditMenu = origMenu;	} else {		throw;	}		assert(::CountMenuItems(mAppEditMenu->GetMacMenuH()) == kNumFixedMenuItems);	::FSpCreate(&mAppListStore, '????', 'pref', smSystemScript );	OSErr err = ResError();	if ( err == dupFNErr || err == noErr) {		mInit = true;	} else {		throw;	}   		::FSpCreate(&mEditFileStore, '????', 'pref', smSystemScript );	err = ResError();	if ( err == dupFNErr || err == noErr ) {		mInit = true;	} else {		throw;	}   		SInt16	theVRef;	SInt32	theDirID;	err = ::FindFolder(kOnSystemDisk, kDocumentsFolderType,					kCreateFolder, &theVRef, &theDirID);#if PP_Target_Carbon	ThrowIfOSErr_(err);#else	if (err != noErr) {		theVRef = -1;		theDirID = fsRtDirID;	}#endif		err =::FSMakeFSSpec( theVRef, theDirID, inEditRootDirName, &mEditSpaceRoot);	if (err == fnfErr) {		long createdDirId;		err = ::FSpDirCreate(&mEditSpaceRoot, smSystemScript, &createdDirId);		if ( err == dupFNErr ) {			mInit = true;		} else {			mInit = true;		}   	} else if (noErr != err) {		mInit = false;	}		LoadAppList();	RebuildMenu();	LoadEditedFilesList();}// ---------------------------------------------------------------------------------//		¥ ~ExternalEditorManager()// ---------------------------------------------------------------------------------//ExternalEditorManager::~ExternalEditorManager() {	for (std::list<ExternalEditContext*>::iterator iter = mEditingItems.begin(); iter != mEditingItems.end(); ++iter) {		delete *iter;	}}// ---------------------------------------------------------------------------------//		¥ GetEditorList()// ---------------------------------------------------------------------------------//void ExternalEditorManager::GetEditorList(ExternalEditorDefList& outList) {	for (ExternalEditorDefList::iterator iter  = mExternalEditors.begin(); iter != mExternalEditors.end(); ++iter)		outList.push_back(*iter);}// ---------------------------------------------------------------------------------//		¥ SetEditorList()// ---------------------------------------------------------------------------------//void ExternalEditorManager::SetEditorList(const ExternalEditorDefList& inList) {	mExternalEditors.clear();	for (ExternalEditorDefList::const_iterator iter  = inList.begin(); iter != inList.end(); ++iter)		mExternalEditors.push_back(*iter);	SaveAppList();	RebuildMenu();}// ---------------------------------------------------------------------------------//		¥ EditItems()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::EditItems(CommandT inEditCmd, const CDAVContext* inDAVContext, 						const std::list<std::pair<std::string, FSSpec> >& inURLToFSpecMap, CDAVTableWindow *inOriginatingWnd) {	assert(mCmdToAppMap.find(inEditCmd) != mCmdToAppMap.end());	if (mCmdToAppMap.find(inEditCmd) == mCmdToAppMap.end())		return false;			std::list<FSSpec> files;	std::list<ExternalEditContext*> tmpCtxList;	std::string srvrname(inDAVContext->GetServerName());		for (std::list<std::pair<std::string, FSSpec> >::const_iterator iter = inURLToFSpecMap.begin(); iter != inURLToFSpecMap.end(); ++iter) {		files.push_back(iter->second);		tmpCtxList.push_back(new ExternalEditContext(inDAVContext, iter->first, iter->second, inOriginatingWnd, !inOriginatingWnd->EncodeResources()));	}	OSStatus launchStat = AppLauncher::OpenFilesForEdit(files, mCmdToAppMap[inEditCmd]);		if (launchStat != noErr) {		for (std::list<ExternalEditContext*>::iterator iter = tmpCtxList.begin(); iter != tmpCtxList.end(); ++iter) 			delete *iter;		return false;	}		for (std::list<ExternalEditContext*>::iterator iter = tmpCtxList.begin(); iter != tmpCtxList.end(); ++iter) {		if (!URLIsBeingEdited(srvrname, (*iter)->GetURL()))			mEditingItems.push_back(*iter);		else			delete *iter;	}		SaveEditedFilesList();	return true;}// ---------------------------------------------------------------------------------//		¥ StopEditingItem()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::StopEditingItem(const std::string& inServer, const std::string& inURI) {	for (std::list<ExternalEditContext*>::iterator iter = mEditingItems.begin(); iter != mEditingItems.end(); ++iter) { 		if ((*iter)->IsSameResource(inServer, inURI)) {			ExternalEditContext* ctxPtr = *iter;			mEditingItems.erase(iter);			delete ctxPtr;			SaveEditedFilesList();			return true;		}	}	return false;}// ---------------------------------------------------------------------------------//		¥ UpdateItemEditTime()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::UpdateItemEditTime(const std::string& inServer, const std::string& inURI) {	for (std::list<ExternalEditContext*>::iterator iter = mEditingItems.begin(); iter != mEditingItems.end(); ++iter) { 		if ((*iter)->IsSameResource(inServer, inURI)) {			ExternalEditContext* ctxPtr = *iter;			ctxPtr->ResetFileEditTime();			SaveEditedFilesList();			return true;		}	}	return false;}// ---------------------------------------------------------------------------------//		¥ GetModifiedItems()// ---------------------------------------------------------------------------------//void ExternalEditorManager::GetModifiedItems(std::list<ExternalEditContext*>& outItems) {	for (std::list<ExternalEditContext*>::iterator iter = mEditingItems.begin(); iter != mEditingItems.end(); ++iter) {		if ((*iter)->FileHasChanged()) 			outItems.push_back(*iter);	}}// ---------------------------------------------------------------------------------//		¥ GetAllEditedItems()// ---------------------------------------------------------------------------------//void ExternalEditorManager::GetAllEditedItems(std::list<ExternalEditContext*>& outItems) {	for (std::list<ExternalEditContext*>::iterator iter = mEditingItems.begin(); iter != mEditingItems.end(); ++iter) {		outItems.push_back(*iter);	}}// ---------------------------------------------------------------------------------//		¥ URLIsBeingEdited()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::URLIsBeingEdited(const std::string& inServer, const std::string& inURI) {	for (std::list<ExternalEditContext*>::iterator iter = mEditingItems.begin(); iter != mEditingItems.end(); ++iter) { 		if ((*iter)->IsSameResource(inServer, inURI))			return true;	}	return false;}// ---------------------------------------------------------------------------------//		¥ GetFSSpecForEditedItem()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::GetFSSpecForEditedItem(const std::string& inServer, const std::string& inURI, FSSpec& outSpec) {	for (std::list<ExternalEditContext*>::iterator iter = mEditingItems.begin(); iter != mEditingItems.end(); ++iter) { 		if ((*iter)->IsSameResource(inServer, inURI)) {			outSpec = *((*iter)->GetFSSpec());			return true;		}	}	return false;}// ---------------------------------------------------------------------------------//		¥ GetEditSpecRoot()// ---------------------------------------------------------------------------------//const FSSpec& ExternalEditorManager::GetEditSpecRoot() const {	return mEditSpaceRoot;}// ---------------------------------------------------------------------------------//		¥ GetEditSpecRoot()// ---------------------------------------------------------------------------------//		bool ExternalEditorManager::GetFSSpecForLocalEdit(const std::string& inHostName, const std::string& inURIToEdit, FSSpec& outSpec) {	std::list<std::string> folderStack;	folderStack.push_back(inHostName);	std::vector<char> tmpbuf(inURIToEdit.size()+1);	strncpy(&tmpbuf[0], inURIToEdit.c_str(), inURIToEdit.size());		char* p = strtok(&tmpbuf[0], "/");	while (p) {		std::string itemName(p);		#ifdef __POWERPC__		itemName = CDAVTranscodeUtils::TranscodeUTF8ToSystemScript(itemName);		#endif    	folderStack.push_back(itemName);		p = strtok(NULL, "/");	}	std::string fileName = *(folderStack.rbegin());	folderStack.pop_back();		FSSpec pntSpec = mEditSpaceRoot;	OSErr err = noErr;	long dirId;	if (!CDAVItemUtils::GetDirID(&pntSpec, dirId))		return false;		for (std::list<std::string>::iterator iter = folderStack.begin(); iter != folderStack.end(); ++iter) {		FSSpec newChildSpec;		LStr255 name((*iter).c_str());		StringPtr ptr = name;		if (ptr[0] > 63)			ptr[0] = 63;		err =::FSMakeFSSpec( pntSpec.vRefNum, dirId, ptr, &newChildSpec);		if (err == fnfErr) {		   err = ::FSpDirCreate(&newChildSpec, smSystemScript, &dirId);			if (err != noErr)				return false;		} else {			if (!CDAVItemUtils::GetDirID(&newChildSpec, dirId))				return false;		}	}	LStr255 name(fileName.c_str());	StringPtr ptr = name;	if (ptr[0] > 63)		ptr[0] = 63;		outSpec.vRefNum = pntSpec.vRefNum;	outSpec.parID = dirId;	LString::CopyPStr(ptr, outSpec.name, 63);	return true;}// ---------------------------------------------------------------------------------//		¥ LoadAppList()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::LoadAppList() {	mExternalEditors.clear();	PropListParser::PropValMapList PVMList;	if (!PropListParser::LoadPropList(mAppListStore, PVMList))		return false;		for (PropListParser::PropValMapList::iterator iter = PVMList.begin(); iter != PVMList.end(); ++iter) {		ExternalEditorDef eDef;	   		PropListParser::PropValMap pvMap = *iter;		eDef.first = pvMap[kPropListAppName];		std::string appcodestr = pvMap[kPropListAppCode];	    OSType applType;	    		for (int j=0; j<4; j++)			((Byte*)&applType)[j]=appcodestr[j];		eDef.second = applType;				mExternalEditors.push_back(eDef);	}		return true;}// ---------------------------------------------------------------------------------//		¥ SaveAppList()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::SaveAppList() {	PropListParser::PropValMapList PVMList;	for (ExternalEditorDefList::iterator iter = mExternalEditors.begin(); iter != mExternalEditors.end(); ++iter) {		PropListParser::PropValMap pvMap;	    		std::string appcode;		appcode += ((Byte*)&(*iter).second)[0];		appcode += ((Byte*)&(*iter).second)[1];		appcode += ((Byte*)&(*iter).second)[2];		appcode += ((Byte*)&(*iter).second)[3];		pvMap[kPropListAppName] = (*iter).first;		pvMap[kPropListAppCode] = appcode;		PVMList.push_back(pvMap);	}	return PropListParser::SavePropList(mAppListStore, PVMList);}// ---------------------------------------------------------------------------------//		¥ LoadEditedFilesList()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::LoadEditedFilesList() {	PropListParser::PropValMapList PVMList;	if (!PropListParser::LoadPropList(mEditFileStore, PVMList))		return false;		for (PropListParser::PropValMapList::iterator iter = PVMList.begin(); iter != PVMList.end(); ++iter) {	   		PropListParser::PropValMap pvMap = *iter;		std::string b64conndat = pvMap[kPropListEditConnection];		std::string b64alisdat = pvMap[kPropListEditAlias];		std::string encodeResStr = pvMap[kPropListEditEncodeRes];		std::string conndat;		std::string aliasdat;				bool encodeRes = false;		if (encodeResStr.size() ==1 && encodeResStr[0] == 'T')			encodeRes = true;					CBase64StringUtils::Decode(b64alisdat, aliasdat);		AliasPtr aptr = (AliasPtr)aliasdat.c_str();		FSSpec target;		Boolean wasChanged;		OSErr err = ResolveAlias(NULL, &aptr, &target, &wasChanged);				CBase64StringUtils::Decode(b64conndat, conndat);		ConnectionDocumentData connectionData;		InitConnectionDocumentData(connectionData);				XML_Error xmlerr = ParseConnectionData(conndat, &connectionData); 		std::string lastModTimeStr = pvMap[kPropListEditLastMod];		const char* startChar = lastModTimeStr.c_str(), *endChar = lastModTimeStr.c_str() + lastModTimeStr.size();		UInt32 lastModTime = strtoul(startChar, (char**)&endChar, 10);				if (XML_ERROR_NONE == xmlerr && err == noErr) {#if 1				CDAVContext *ctx = new CDAVContext (connectionData.mHost.c_str(), connectionData.mPort, connectionData.mForceSecure);		ctx->SetCookieList (&(GetApplicationInstance()->GetCookieList()));   		if (connectionData.mHasProxy) {			ctx->SetProxyServer(std::string (connectionData.mProxyHost.TextPtr(), connectionData.mProxyHost.Length()), connectionData.mProxyPort);		} 		if (connectionData.mHasUserCredentials) {			ctx->SetUserCredentials(connectionData.mUser, connectionData.mPassword);		}		if (connectionData.mHasProxyCredentials) {			std::string plogin, ppassword;			plogin.assign ((const char*) connectionData.mProxyUser.ConstTextPtr(), connectionData.mProxyUser.Length());			ppassword.assign ((const char*) connectionData.mProxyPassword.ConstTextPtr(), connectionData.mProxyPassword.Length());			ctx->SetProxyCredentials(plogin.c_str(), ppassword.c_str());		}		mEditingItems.push_back(new ExternalEditContext(ctx, connectionData.mResource, target, encodeRes, lastModTime));#endif	}	}		return true;}#include <stdio.h>// ---------------------------------------------------------------------------------//		¥ SaveEditedFilesList()// ---------------------------------------------------------------------------------//bool ExternalEditorManager::SaveEditedFilesList() {	PropListParser::PropValMapList PVMList;	for (std::list<ExternalEditContext*>::iterator iter = mEditingItems.begin(); iter != mEditingItems.end(); ++iter) {		PropListParser::PropValMap pvMap;		std::string conndata;		SDimension16 dum;		dum.width = dum.height = 0;		Point dum2;		dum2.v = dum2.h = 0;		std::string url = (*iter)->GetURL();		BuildConnectionData(conndata, url, (*iter)->GetContext(), 							dum, dum2, NULL, true);				std::string b64conndata;		CBase64StringUtils::Encode(conndata, b64conndata);		FSSpec theSpec = *(*iter)->GetFSSpec();		AliasHandle aliasHandle;		NewAlias(NULL, &theSpec, &aliasHandle);				std::string aliasData, b64aliasData;		Size hsz = GetHandleSize((Handle)aliasHandle);		{			StHandleLocker locked((Handle)aliasHandle);			aliasData.append((const char*)*aliasHandle, hsz);		}		DisposeHandle((Handle) aliasHandle);		CBase64StringUtils::Encode(aliasData, b64aliasData);		pvMap[kPropListEditConnection] = b64conndata;		pvMap[kPropListEditAlias] = b64aliasData;		if ((*iter)->GetEncodeResources())			pvMap[kPropListEditEncodeRes] = "T";		else			pvMap[kPropListEditEncodeRes] = "F";				UInt32 lastModTime = ExternalEditContext::GetFSSpecModDate(theSpec);		char buf[32];		sprintf(&buf[0], "%u", lastModTime);				pvMap[kPropListEditLastMod] = buf;				PVMList.push_back(pvMap);	}	return PropListParser::SavePropList(mEditFileStore, PVMList);}		// ---------------------------------------------------------------------------------//		¥ RebuildMenu()// ---------------------------------------------------------------------------------//void ExternalEditorManager::RebuildMenu() {	if (!mAppEditMenu)		return;			while (::CountMenuItems(mAppEditMenu->GetMacMenuH()) > kNumFixedMenuItems) {		mAppEditMenu->RemoveItem(1);	}		mCmdToAppMap.clear();	CommandT cmd = mFirstEditCmd;	int numApps = 0;	for (ExternalEditorDefList::reverse_iterator iter = mExternalEditors.rbegin(); iter != mExternalEditors.rend(); ++iter) {		numApps++;		ExternalEditorDef *eDef = &(*iter);		LStr255 itemText(eDef->first.c_str(), eDef->first.size());		mAppEditMenu->InsertCommand(itemText, cmd, 0);		mCmdToAppMap[cmd] = eDef->second;		cmd++;	}	if (numApps > 10)		numApps = 10;	for (int i=0; i<numApps; i++) {		SetItemCmd(mAppEditMenu->GetMacMenuH(), i+1, '0'+i);		SetMenuItemModifiers( mAppEditMenu->GetMacMenuH(), i+1, kMenuShiftModifier);		}}