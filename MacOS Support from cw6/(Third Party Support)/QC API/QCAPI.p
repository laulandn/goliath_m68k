{________________________________________________________________________________	QCAPI.p	Pascal Application Programmer Interface (API) to QC(tm) development tool.	Copyright 1993-1996 Onyx Technology. All rights reserved worldwide.	Special thanks to Rich Siegel at Bare Bones Software		for getting this file started for us.	revis:	10/20/95	dth - derived from QCAPI.h________________________________________________________________________________}unit QCAPI;interface{$IFC UNDEFINED THINK_PASCAL}uses	Types, Memory, OSUtils;{$ENDC}type	QCErr = LongInt;					{ QC error code type }	QCType = OSType;					{ QC type codes }	QCStateHandle = Handle;				{ QC save/restore state data }		{ Parameter block for custom error handler }	QCPBRec = record		testID : QCType;				{ the selector id of the test }		error : QCErr;					{ error detected (see below) }		data : LongInt;					{ data/address from QCInstallHandler() }		errString : Ptr;				{ error string being reported }		lastTestedTrapPC : LongInt;		{ PC of last trap QC detected error at }		lastTrapPC : LongInt;			{ PC of last trap executed from user code }	end;	QCPBPtr = ^QCPBRec;	{ Test list handle returned by QCGetTestList().		Delete with DisposeHandle(). }	QCTestRec = record		testID : QCType;		testName : Str32;	end;	QCTestPtr = ^QCTestRec;	QCTestHandle = ^QCTestPtr;	{ Specific test option structs for use 		in QCGetTestOptions()/QCSetTestOptions}	QCAutoLaunchRec = record		which : Integer;				{ 1 = _InitGraf; 2 = _Get1Resource; }		id : Integer;					{ id for useGet1Resource }		rType : OSType;					{ type for useGet1Resource }	end;	QCReasonAllocRec = record		which : Integer;				{ 1 = use app heap; 2 = use specified }		size : LongInt;					{ alloc size to break on >= }	end;	QCBlockBoundsRec = record			tagSize : Integer;				{ block bounds size to tag blocks with }	end;	QCDebugOptionsRec = record		which : Integer;				{ 1 = _DebugStr; 2 = _SysBreakStr }	end;	QCValidateHPOptionsRec = record		nilHandleWarnings : Integer;	{ true if you want NIL handle warnings }		nilPointerWarnings : Integer;	{ true if you want NIL pointer warnings }	end;	QCOptionData = record		case integer of			0 : ( autoLaunch : QCAutoLaunchRec );				{ AutoLaunch information }			1 : ( reasonableAlloc : QCReasonAllocRec );			{ Reasonable Allocation information }			2 : ( blockBounds : QCBlockBoundsRec );				{ BlockBounds information }			3 : ( debugOptions : QCDebugOptionsRec );			{ Debugger Break option information }			4 : ( validateHPOptions : QCValidateHPOptionsRec );	{ Validate Handle/Pointer information }	end;	QCTestOptions = record		testID : QCType;				{ the test this data belongs to }		optionData : QCOptionData;		{ union specific data belongs here }	end;	QCTestOptionsPtr = ^QCTestOptions;	const	{ QCAPI result codes }	kQCNoErr = 0;	kQCInternalErr = 9;	kQCNotInstalled = kQCInternalErr + 1;			{ QC extension not installed }	kQCNotActive = kQCNotInstalled + 1;				{ QC is not testing; must be to complete }	kQCInvalidParam = kQCNotActive + 1;				{ invalid parameter passed to routine }	kQCInvalidType = kQCInvalidParam + 1;			{ invalid QCType given to a routine }	kQCPBRecMismatch = kQCInvalidType + 1;			{ QCPBRec size mismatch.  QCAPI library in use }													{ does not match API loaded extension needs. }	kQCAPIMismatch = kQCPBRecMismatch + 1;			{ The QCAPI and loaded extension API's don't match! }	kQCErrHandlerNotFound = kQCAPIMismatch + 1;		{ QCRemoveHandler result when given proc was not }													{	installed. }	{ API error detection result codes (given to handler routine (if installed) }	kErrorBase = 300;	kBadBlockLenErr = kErrorBase + 1;				{ invalid physical block length }	kBadRelHandErr = kBadBlockLenErr + 1;			{ Offset from zone start to masterPtr invalid }	kLostMasterPtrErr = kBadRelHandErr + 1;			{ master pointer is not in the heap }	kBadMasterPtrErr = kLostMasterPtrErr + 1;		{ MasterPtr does not point to data }	kBadNonRelocErr = kBadMasterPtrErr + 1;			{ Bad Non-reloc block: heap addr must follow physSize. }	kBadBlockTypeErr = kBadNonRelocErr + 1;			{ invalid block type (not reloc, non-reloc, or free) }	kBadLastBlockErr = kBadBlockTypeErr + 1;		{ invalid physical block length (last block) }	kWriteToZeroErr = kBadLastBlockErr + 1;			{ write to location zero detected }	kNilHandleErr = kWriteToZeroErr + 1;			{ nil handle error }	{ 10 }	kHandleInFreeErr = kNilHandleErr + 1;			{ handle is in a free block }	kBadHandleErr = kHandleInFreeErr + 1;			{ handle is bad - not at start of relocatable block }	kBadPtrErr = kBadHandleErr + 1;					{ Ptr does not point to non-relocatable block }	kNilPointerErr = kBadPtrErr + 1;				{ nil pointer detected }	kUnused = kNilPointerErr + 1;	kHeapStartEndErr = kUnused + 1;					{ bkLim of heap has heap end before it starts }	kFreeByteHeapErr = kHeapStartEndErr + 1;		{ no. of free bytes exceeds heap size }	kGrowZoneMismatchErr = kFreeByteHeapErr + 1;	{ grow zone function mistmatch! }	kUnreasonableNewHandleErr = kGrowZoneMismatchErr + 1;		{ new handle size is questionable }	kUnreasonableNewPtrErr = kUnreasonableNewHandleErr + 1;	{ 20 }	kUnreasonableSetHandleSizeErr = kUnreasonableNewPtrErr + 1;	kUnreasonableReallocHandleErr = kUnreasonableSetHandleSizeErr + 1;	kUnreasonableSetPtrSizeErr = kUnreasonableReallocHandleErr + 1;	kReleaseHandleErr = kUnreasonableSetPtrSizeErr + 1;			{ called release resource on a handle }	kDisposResourceErr = kReleaseHandleErr + 1;					{ Trying to perform a DisposHandle on a resource }	kBlockMoveDestFree = kDisposResourceErr + 1;				{ Destination ptr for BlockMove is in a free block }	kBlockMoveDestMultiple = kBlockMoveDestFree + 1;			{ Destination ptr for BlockMove spans multiple blocks }	kBlockMoveHeadOverwrite = kBlockMoveDestMultiple + 1;		{ Blockmove will overwrite a block header }	kBlockMovePadOverwrite = kBlockMoveHeadOverwrite + 1;		{ Blockmove will overwrite padding in a block }	{ 30 }	kUnreasonableBlockMoveSize = kBlockMovePadOverwrite + 1;	{ Blockmove attempting to move an unreasonable size }	kMemErrDetected = kUnreasonableBlockMoveSize + 1;			{ a MemErr value has been detected after a call }	kEmptyHandleErr = kMemErrDetected + 1;		{ Empty handle used by routine that needs data }	kPtrBoundsErr = kEmptyHandleErr + 1;		{ Write past end of non-relocatable block detected }	kHandleBoundsErr = kPtrBoundsErr + 1;		{ Write past end of relocatable block detected }	kFreeMemOverwrite = kHandleBoundsErr + 1;	{ Write has been made to a free block }	kGrowLock = kFreeMemOverwrite + 1;			{ App is growing a locked block }	kGrowPtr = kGrowLock + 1;					{ App is growing a non-relocatable block }	kBlockMoveNilSrc = kGrowPtr + 1;			{ source pointer is NIL! }	kBlockMoveNilDest = kBlockMoveNilSrc + 1;	{ destination pointer is NIL! }	kErrorLimit = kBlockMoveNilDest + 1;		{ max error id place holder }	qcAutoLaunch				= 'auto'; {  auto launch this app/file }	qcCheckSystemHeap			= 'cksh'; {  check system heap }	qcValidateMasterPointers	= 'vlmp'; {  validate master pointers }	qcValidateHandlePointers	= 'vlhp'; {  validate handles/pointers }	qcDetectWriteToZero			= 'dtwz'; {  detect write to zero }	qcDerefZeroCheck			= 'drzc'; {  detect deref zero }	qcReasonableAllocation		= 'rall'; {  reasonable allocation checks }	qcCheckDisposeRelease		= 'dprl'; {  check DisposeHandle/ReleaseResource }	qcScrambleHeap				= 'schp'; {  scramble heap }	qcPurgeHeap					= 'pghp'; {  purge heap }	qcCheckHeap					= 'ckhp'; {  check heap }	qcInvalidateFreeMemory		= 'infm'; {  trample (invalidate) free memory }	qcCheckSystemCode			= 'csys'; {  check system code }	qcErrorReporting			= 'erpt'; {  error reporting }	qcDebugBreaks				= 'dbrk'; {  debugger breaks }	qcBeepNotify				= 'beep'; {  beep on activate/deactivate }	qcIconNotify				= 'sicn'; {  rotate small icon when active }	qcBlockMoveChecking			= 'bkmv'; { check BlockMove calls }	qcBlockBoundsChecking		= 'bbck'; { block bounds checking }	qcMemErrDetection			= 'merr'; {  obsolete - here for compatibility }	qcMemErrWarnings			= 'merr'; {	 MemErr value checking }	qcGrowLockChecking			= 'grlk'; {  grow locked block checking }	qcGrowNonRelocChecking		= 'gron'; {  grow non-reloc block checking }	qcAllTestsMask				= 'mask'; {  all tests mask (activate/deactivate all) }	{ Missing PowerPC UPP stuff here for callbacks }function QCInstalled : QCErr;							{  is QC extension loaded and usable? }function QCIsActive : Boolean;							{  is QC currently testing an application? }function QCActivate(zone : THz) : QCErr;				{  activate QC on a specific heap zone }														{ 	or current heap if 0L is specified }function QCDeactivate : QCErr;							{  deactivate QC testing }function QCTestingHeap : THz;							{  get the heap being tested }function QCGetState : QCStateHandle;					{  get the current testing state }function QCSetState(state : QCStateHandle) : QCErr;		{  restore the current testing state }function QCDisposeState(state : QCStateHandle) : QCErr;	{  dispose of state handle }function QCGetTestState(qc_type : QCType; var l : LongInt) : QCErr;	{  get state of a particular test }function QCSetTestState(QCType, l : LongInt) : QCErr;				{  set state of a particular test }function QCGetTestOptions(options : QCTestOptionsPtr) : QCErr;		{  get specific test options }function QCSetTestOptions(options : QCTestOptionsPtr) : QCErr;		{  set specific test options }function QCInstallPascalHandler(proc : ProcPtr; l : LongInt) : QCErr;	{  install a PASCAL error handler routine }function QCRemoveHandler(proc : ProcPtr) : QCErr;						{  remove an error handler routine }function QCGetErrorText(err : QCErr; s: univ StringPtr) : QCErr;		{  get error text for a particular error }function QCHeapCheckNow : QCErr;						{  check the active heap now }function QCScrambleHeapNow : QCErr;						{  scramble the active heap now }function QCBlockBoundsCheckNow : QCErr;					{  perform a block bounds check now }function QCVerifyHandle(h : univ Handle) : QCErr;		{  verify the given handle }function QCVerifyPtr(p : univ Ptr) : QCErr;				{  verify the given pointer }function QCGetTestList(var l : LongInt) : QCTestHandle;	{  Get a list of install/available tests }														{ 	return # of tests in "l" }implementationend.